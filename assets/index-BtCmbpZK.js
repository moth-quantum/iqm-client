(function(){const l=document.createElement("link").relList;if(l&&l.supports&&l.supports("modulepreload"))return;for(const _ of document.querySelectorAll('link[rel="modulepreload"]'))b(_);new MutationObserver(_=>{for(const v of _)if(v.type==="childList")for(const q of v.addedNodes)q.tagName==="LINK"&&q.rel==="modulepreload"&&b(q)}).observe(document,{childList:!0,subtree:!0});function r(_){const v={};return _.integrity&&(v.integrity=_.integrity),_.referrerPolicy&&(v.referrerPolicy=_.referrerPolicy),_.crossOrigin==="use-credentials"?v.credentials="include":_.crossOrigin==="anonymous"?v.credentials="omit":v.credentials="same-origin",v}function b(_){if(_.ep)return;_.ep=!0;const v=r(_);fetch(_.href,v)}})();var Bs={exports:{}},kn={},Ds={exports:{}},Z={};/**
 * @license React
 * react.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Wu;function mp(){if(Wu)return Z;Wu=1;var c=Symbol.for("react.element"),l=Symbol.for("react.portal"),r=Symbol.for("react.fragment"),b=Symbol.for("react.strict_mode"),_=Symbol.for("react.profiler"),v=Symbol.for("react.provider"),q=Symbol.for("react.context"),k=Symbol.for("react.forward_ref"),I=Symbol.for("react.suspense"),M=Symbol.for("react.memo"),P=Symbol.for("react.lazy"),T=Symbol.iterator;function O(m){return m===null||typeof m!="object"?null:(m=T&&m[T]||m["@@iterator"],typeof m=="function"?m:null)}var W={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},Y=Object.assign,H={};function V(m,C,X){this.props=m,this.context=C,this.refs=H,this.updater=X||W}V.prototype.isReactComponent={},V.prototype.setState=function(m,C){if(typeof m!="object"&&typeof m!="function"&&m!=null)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,m,C,"setState")},V.prototype.forceUpdate=function(m){this.updater.enqueueForceUpdate(this,m,"forceUpdate")};function Ie(){}Ie.prototype=V.prototype;function ve(m,C,X){this.props=m,this.context=C,this.refs=H,this.updater=X||W}var Se=ve.prototype=new Ie;Se.constructor=ve,Y(Se,V.prototype),Se.isPureReactComponent=!0;var ue=Array.isArray,$e=Object.prototype.hasOwnProperty,we={current:null},ae={key:!0,ref:!0,__self:!0,__source:!0};function _e(m,C,X){var $,K={},ee=null,oe=null;if(C!=null)for($ in C.ref!==void 0&&(oe=C.ref),C.key!==void 0&&(ee=""+C.key),C)$e.call(C,$)&&!ae.hasOwnProperty($)&&(K[$]=C[$]);var ie=arguments.length-2;if(ie===1)K.children=X;else if(1<ie){for(var ce=Array(ie),Ye=0;Ye<ie;Ye++)ce[Ye]=arguments[Ye+2];K.children=ce}if(m&&m.defaultProps)for($ in ie=m.defaultProps,ie)K[$]===void 0&&(K[$]=ie[$]);return{$$typeof:c,type:m,key:ee,ref:oe,props:K,_owner:we.current}}function Te(m,C){return{$$typeof:c,type:m.type,key:C,ref:m.ref,props:m.props,_owner:m._owner}}function nt(m){return typeof m=="object"&&m!==null&&m.$$typeof===c}function ct(m){var C={"=":"=0",":":"=2"};return"$"+m.replace(/[=:]/g,function(X){return C[X]})}var Ae=/\/+/g;function Ge(m,C){return typeof m=="object"&&m!==null&&m.key!=null?ct(""+m.key):C.toString(36)}function pe(m,C,X,$,K){var ee=typeof m;(ee==="undefined"||ee==="boolean")&&(m=null);var oe=!1;if(m===null)oe=!0;else switch(ee){case"string":case"number":oe=!0;break;case"object":switch(m.$$typeof){case c:case l:oe=!0}}if(oe)return oe=m,K=K(oe),m=$===""?"."+Ge(oe,0):$,ue(K)?(X="",m!=null&&(X=m.replace(Ae,"$&/")+"/"),pe(K,C,X,"",function(Ye){return Ye})):K!=null&&(nt(K)&&(K=Te(K,X+(!K.key||oe&&oe.key===K.key?"":(""+K.key).replace(Ae,"$&/")+"/")+m)),C.push(K)),1;if(oe=0,$=$===""?".":$+":",ue(m))for(var ie=0;ie<m.length;ie++){ee=m[ie];var ce=$+Ge(ee,ie);oe+=pe(ee,C,X,ce,K)}else if(ce=O(m),typeof ce=="function")for(m=ce.call(m),ie=0;!(ee=m.next()).done;)ee=ee.value,ce=$+Ge(ee,ie++),oe+=pe(ee,C,X,ce,K);else if(ee==="object")throw C=String(m),Error("Objects are not valid as a React child (found: "+(C==="[object Object]"?"object with keys {"+Object.keys(m).join(", ")+"}":C)+"). If you meant to render a collection of children, use an array instead.");return oe}function Le(m,C,X){if(m==null)return m;var $=[],K=0;return pe(m,$,"","",function(ee){return C.call(X,ee,K++)}),$}function Pe(m){if(m._status===-1){var C=m._result;C=C(),C.then(function(X){(m._status===0||m._status===-1)&&(m._status=1,m._result=X)},function(X){(m._status===0||m._status===-1)&&(m._status=2,m._result=X)}),m._status===-1&&(m._status=0,m._result=C)}if(m._status===1)return m._result.default;throw m._result}var fe={current:null},A={transition:null},U={ReactCurrentDispatcher:fe,ReactCurrentBatchConfig:A,ReactCurrentOwner:we};function B(){throw Error("act(...) is not supported in production builds of React.")}return Z.Children={map:Le,forEach:function(m,C,X){Le(m,function(){C.apply(this,arguments)},X)},count:function(m){var C=0;return Le(m,function(){C++}),C},toArray:function(m){return Le(m,function(C){return C})||[]},only:function(m){if(!nt(m))throw Error("React.Children.only expected to receive a single React element child.");return m}},Z.Component=V,Z.Fragment=r,Z.Profiler=_,Z.PureComponent=ve,Z.StrictMode=b,Z.Suspense=I,Z.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=U,Z.act=B,Z.cloneElement=function(m,C,X){if(m==null)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+m+".");var $=Y({},m.props),K=m.key,ee=m.ref,oe=m._owner;if(C!=null){if(C.ref!==void 0&&(ee=C.ref,oe=we.current),C.key!==void 0&&(K=""+C.key),m.type&&m.type.defaultProps)var ie=m.type.defaultProps;for(ce in C)$e.call(C,ce)&&!ae.hasOwnProperty(ce)&&($[ce]=C[ce]===void 0&&ie!==void 0?ie[ce]:C[ce])}var ce=arguments.length-2;if(ce===1)$.children=X;else if(1<ce){ie=Array(ce);for(var Ye=0;Ye<ce;Ye++)ie[Ye]=arguments[Ye+2];$.children=ie}return{$$typeof:c,type:m.type,key:K,ref:ee,props:$,_owner:oe}},Z.createContext=function(m){return m={$$typeof:q,_currentValue:m,_currentValue2:m,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null},m.Provider={$$typeof:v,_context:m},m.Consumer=m},Z.createElement=_e,Z.createFactory=function(m){var C=_e.bind(null,m);return C.type=m,C},Z.createRef=function(){return{current:null}},Z.forwardRef=function(m){return{$$typeof:k,render:m}},Z.isValidElement=nt,Z.lazy=function(m){return{$$typeof:P,_payload:{_status:-1,_result:m},_init:Pe}},Z.memo=function(m,C){return{$$typeof:M,type:m,compare:C===void 0?null:C}},Z.startTransition=function(m){var C=A.transition;A.transition={};try{m()}finally{A.transition=C}},Z.unstable_act=B,Z.useCallback=function(m,C){return fe.current.useCallback(m,C)},Z.useContext=function(m){return fe.current.useContext(m)},Z.useDebugValue=function(){},Z.useDeferredValue=function(m){return fe.current.useDeferredValue(m)},Z.useEffect=function(m,C){return fe.current.useEffect(m,C)},Z.useId=function(){return fe.current.useId()},Z.useImperativeHandle=function(m,C,X){return fe.current.useImperativeHandle(m,C,X)},Z.useInsertionEffect=function(m,C){return fe.current.useInsertionEffect(m,C)},Z.useLayoutEffect=function(m,C){return fe.current.useLayoutEffect(m,C)},Z.useMemo=function(m,C){return fe.current.useMemo(m,C)},Z.useReducer=function(m,C,X){return fe.current.useReducer(m,C,X)},Z.useRef=function(m){return fe.current.useRef(m)},Z.useState=function(m){return fe.current.useState(m)},Z.useSyncExternalStore=function(m,C,X){return fe.current.useSyncExternalStore(m,C,X)},Z.useTransition=function(){return fe.current.useTransition()},Z.version="18.3.1",Z}var Vu;function Zs(){return Vu||(Vu=1,Ds.exports=mp()),Ds.exports}/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Xu;function hp(){if(Xu)return kn;Xu=1;var c=Zs(),l=Symbol.for("react.element"),r=Symbol.for("react.fragment"),b=Object.prototype.hasOwnProperty,_=c.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,v={key:!0,ref:!0,__self:!0,__source:!0};function q(k,I,M){var P,T={},O=null,W=null;M!==void 0&&(O=""+M),I.key!==void 0&&(O=""+I.key),I.ref!==void 0&&(W=I.ref);for(P in I)b.call(I,P)&&!v.hasOwnProperty(P)&&(T[P]=I[P]);if(k&&k.defaultProps)for(P in I=k.defaultProps,I)T[P]===void 0&&(T[P]=I[P]);return{$$typeof:l,type:k,key:O,ref:W,props:T,_owner:_.current}}return kn.Fragment=r,kn.jsx=q,kn.jsxs=q,kn}var Hu;function fp(){return Hu||(Hu=1,Bs.exports=hp()),Bs.exports}var y=fp(),Ue=Zs(),Ea={},Es={exports:{}},Ze={},Ls={exports:{}},Ns={};/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Zu;function gp(){return Zu||(Zu=1,function(c){function l(A,U){var B=A.length;A.push(U);e:for(;0<B;){var m=B-1>>>1,C=A[m];if(0<_(C,U))A[m]=U,A[B]=C,B=m;else break e}}function r(A){return A.length===0?null:A[0]}function b(A){if(A.length===0)return null;var U=A[0],B=A.pop();if(B!==U){A[0]=B;e:for(var m=0,C=A.length,X=C>>>1;m<X;){var $=2*(m+1)-1,K=A[$],ee=$+1,oe=A[ee];if(0>_(K,B))ee<C&&0>_(oe,K)?(A[m]=oe,A[ee]=B,m=ee):(A[m]=K,A[$]=B,m=$);else if(ee<C&&0>_(oe,B))A[m]=oe,A[ee]=B,m=ee;else break e}}return U}function _(A,U){var B=A.sortIndex-U.sortIndex;return B!==0?B:A.id-U.id}if(typeof performance=="object"&&typeof performance.now=="function"){var v=performance;c.unstable_now=function(){return v.now()}}else{var q=Date,k=q.now();c.unstable_now=function(){return q.now()-k}}var I=[],M=[],P=1,T=null,O=3,W=!1,Y=!1,H=!1,V=typeof setTimeout=="function"?setTimeout:null,Ie=typeof clearTimeout=="function"?clearTimeout:null,ve=typeof setImmediate<"u"?setImmediate:null;typeof navigator<"u"&&navigator.scheduling!==void 0&&navigator.scheduling.isInputPending!==void 0&&navigator.scheduling.isInputPending.bind(navigator.scheduling);function Se(A){for(var U=r(M);U!==null;){if(U.callback===null)b(M);else if(U.startTime<=A)b(M),U.sortIndex=U.expirationTime,l(I,U);else break;U=r(M)}}function ue(A){if(H=!1,Se(A),!Y)if(r(I)!==null)Y=!0,Pe($e);else{var U=r(M);U!==null&&fe(ue,U.startTime-A)}}function $e(A,U){Y=!1,H&&(H=!1,Ie(_e),_e=-1),W=!0;var B=O;try{for(Se(U),T=r(I);T!==null&&(!(T.expirationTime>U)||A&&!ct());){var m=T.callback;if(typeof m=="function"){T.callback=null,O=T.priorityLevel;var C=m(T.expirationTime<=U);U=c.unstable_now(),typeof C=="function"?T.callback=C:T===r(I)&&b(I),Se(U)}else b(I);T=r(I)}if(T!==null)var X=!0;else{var $=r(M);$!==null&&fe(ue,$.startTime-U),X=!1}return X}finally{T=null,O=B,W=!1}}var we=!1,ae=null,_e=-1,Te=5,nt=-1;function ct(){return!(c.unstable_now()-nt<Te)}function Ae(){if(ae!==null){var A=c.unstable_now();nt=A;var U=!0;try{U=ae(!0,A)}finally{U?Ge():(we=!1,ae=null)}}else we=!1}var Ge;if(typeof ve=="function")Ge=function(){ve(Ae)};else if(typeof MessageChannel<"u"){var pe=new MessageChannel,Le=pe.port2;pe.port1.onmessage=Ae,Ge=function(){Le.postMessage(null)}}else Ge=function(){V(Ae,0)};function Pe(A){ae=A,we||(we=!0,Ge())}function fe(A,U){_e=V(function(){A(c.unstable_now())},U)}c.unstable_IdlePriority=5,c.unstable_ImmediatePriority=1,c.unstable_LowPriority=4,c.unstable_NormalPriority=3,c.unstable_Profiling=null,c.unstable_UserBlockingPriority=2,c.unstable_cancelCallback=function(A){A.callback=null},c.unstable_continueExecution=function(){Y||W||(Y=!0,Pe($e))},c.unstable_forceFrameRate=function(A){0>A||125<A?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):Te=0<A?Math.floor(1e3/A):5},c.unstable_getCurrentPriorityLevel=function(){return O},c.unstable_getFirstCallbackNode=function(){return r(I)},c.unstable_next=function(A){switch(O){case 1:case 2:case 3:var U=3;break;default:U=O}var B=O;O=U;try{return A()}finally{O=B}},c.unstable_pauseExecution=function(){},c.unstable_requestPaint=function(){},c.unstable_runWithPriority=function(A,U){switch(A){case 1:case 2:case 3:case 4:case 5:break;default:A=3}var B=O;O=A;try{return U()}finally{O=B}},c.unstable_scheduleCallback=function(A,U,B){var m=c.unstable_now();switch(typeof B=="object"&&B!==null?(B=B.delay,B=typeof B=="number"&&0<B?m+B:m):B=m,A){case 1:var C=-1;break;case 2:C=250;break;case 5:C=1073741823;break;case 4:C=1e4;break;default:C=5e3}return C=B+C,A={id:P++,callback:U,priorityLevel:A,startTime:B,expirationTime:C,sortIndex:-1},B>m?(A.sortIndex=B,l(M,A),r(I)===null&&A===r(M)&&(H?(Ie(_e),_e=-1):H=!0,fe(ue,B-m))):(A.sortIndex=C,l(I,A),Y||W||(Y=!0,Pe($e))),A},c.unstable_shouldYield=ct,c.unstable_wrapCallback=function(A){var U=O;return function(){var B=O;O=U;try{return A.apply(this,arguments)}finally{O=B}}}}(Ns)),Ns}var $u;function _p(){return $u||($u=1,Ls.exports=gp()),Ls.exports}/**
 * @license React
 * react-dom.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */var Yu;function yp(){if(Yu)return Ze;Yu=1;var c=Zs(),l=_p();function r(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,i=1;i<arguments.length;i++)t+="&args[]="+encodeURIComponent(arguments[i]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var b=new Set,_={};function v(e,t){q(e,t),q(e+"Capture",t)}function q(e,t){for(_[e]=t,e=0;e<t.length;e++)b.add(t[e])}var k=!(typeof window>"u"||typeof window.document>"u"||typeof window.document.createElement>"u"),I=Object.prototype.hasOwnProperty,M=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,P={},T={};function O(e){return I.call(T,e)?!0:I.call(P,e)?!1:M.test(e)?T[e]=!0:(P[e]=!0,!1)}function W(e,t,i,n){if(i!==null&&i.type===0)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return n?!1:i!==null?!i.acceptsBooleans:(e=e.toLowerCase().slice(0,5),e!=="data-"&&e!=="aria-");default:return!1}}function Y(e,t,i,n){if(t===null||typeof t>"u"||W(e,t,i,n))return!0;if(n)return!1;if(i!==null)switch(i.type){case 3:return!t;case 4:return t===!1;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}function H(e,t,i,n,a,o,s){this.acceptsBooleans=t===2||t===3||t===4,this.attributeName=n,this.attributeNamespace=a,this.mustUseProperty=i,this.propertyName=e,this.type=t,this.sanitizeURL=o,this.removeEmptyString=s}var V={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach(function(e){V[e]=new H(e,0,!1,e,null,!1,!1)}),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach(function(e){var t=e[0];V[t]=new H(t,1,!1,e[1],null,!1,!1)}),["contentEditable","draggable","spellCheck","value"].forEach(function(e){V[e]=new H(e,2,!1,e.toLowerCase(),null,!1,!1)}),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach(function(e){V[e]=new H(e,2,!1,e,null,!1,!1)}),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach(function(e){V[e]=new H(e,3,!1,e.toLowerCase(),null,!1,!1)}),["checked","multiple","muted","selected"].forEach(function(e){V[e]=new H(e,3,!0,e,null,!1,!1)}),["capture","download"].forEach(function(e){V[e]=new H(e,4,!1,e,null,!1,!1)}),["cols","rows","size","span"].forEach(function(e){V[e]=new H(e,6,!1,e,null,!1,!1)}),["rowSpan","start"].forEach(function(e){V[e]=new H(e,5,!1,e.toLowerCase(),null,!1,!1)});var Ie=/[\-:]([a-z])/g;function ve(e){return e[1].toUpperCase()}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach(function(e){var t=e.replace(Ie,ve);V[t]=new H(t,1,!1,e,null,!1,!1)}),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach(function(e){var t=e.replace(Ie,ve);V[t]=new H(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)}),["xml:base","xml:lang","xml:space"].forEach(function(e){var t=e.replace(Ie,ve);V[t]=new H(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)}),["tabIndex","crossOrigin"].forEach(function(e){V[e]=new H(e,1,!1,e.toLowerCase(),null,!1,!1)}),V.xlinkHref=new H("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach(function(e){V[e]=new H(e,1,!1,e.toLowerCase(),null,!0,!0)});function Se(e,t,i,n){var a=V.hasOwnProperty(t)?V[t]:null;(a!==null?a.type!==0:n||!(2<t.length)||t[0]!=="o"&&t[0]!=="O"||t[1]!=="n"&&t[1]!=="N")&&(Y(t,i,a,n)&&(i=null),n||a===null?O(t)&&(i===null?e.removeAttribute(t):e.setAttribute(t,""+i)):a.mustUseProperty?e[a.propertyName]=i===null?a.type===3?!1:"":i:(t=a.attributeName,n=a.attributeNamespace,i===null?e.removeAttribute(t):(a=a.type,i=a===3||a===4&&i===!0?"":""+i,n?e.setAttributeNS(n,t,i):e.setAttribute(t,i))))}var ue=c.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,$e=Symbol.for("react.element"),we=Symbol.for("react.portal"),ae=Symbol.for("react.fragment"),_e=Symbol.for("react.strict_mode"),Te=Symbol.for("react.profiler"),nt=Symbol.for("react.provider"),ct=Symbol.for("react.context"),Ae=Symbol.for("react.forward_ref"),Ge=Symbol.for("react.suspense"),pe=Symbol.for("react.suspense_list"),Le=Symbol.for("react.memo"),Pe=Symbol.for("react.lazy"),fe=Symbol.for("react.offscreen"),A=Symbol.iterator;function U(e){return e===null||typeof e!="object"?null:(e=A&&e[A]||e["@@iterator"],typeof e=="function"?e:null)}var B=Object.assign,m;function C(e){if(m===void 0)try{throw Error()}catch(i){var t=i.stack.trim().match(/\n( *(at )?)/);m=t&&t[1]||""}return`
`+m+e}var X=!1;function $(e,t){if(!e||X)return"";X=!0;var i=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),typeof Reflect=="object"&&Reflect.construct){try{Reflect.construct(t,[])}catch(g){var n=g}Reflect.construct(e,[],t)}else{try{t.call()}catch(g){n=g}e.call(t.prototype)}else{try{throw Error()}catch(g){n=g}e()}}catch(g){if(g&&n&&typeof g.stack=="string"){for(var a=g.stack.split(`
`),o=n.stack.split(`
`),s=a.length-1,u=o.length-1;1<=s&&0<=u&&a[s]!==o[u];)u--;for(;1<=s&&0<=u;s--,u--)if(a[s]!==o[u]){if(s!==1||u!==1)do if(s--,u--,0>u||a[s]!==o[u]){var d=`
`+a[s].replace(" at new "," at ");return e.displayName&&d.includes("<anonymous>")&&(d=d.replace("<anonymous>",e.displayName)),d}while(1<=s&&0<=u);break}}}finally{X=!1,Error.prepareStackTrace=i}return(e=e?e.displayName||e.name:"")?C(e):""}function K(e){switch(e.tag){case 5:return C(e.type);case 16:return C("Lazy");case 13:return C("Suspense");case 19:return C("SuspenseList");case 0:case 2:case 15:return e=$(e.type,!1),e;case 11:return e=$(e.type.render,!1),e;case 1:return e=$(e.type,!0),e;default:return""}}function ee(e){if(e==null)return null;if(typeof e=="function")return e.displayName||e.name||null;if(typeof e=="string")return e;switch(e){case ae:return"Fragment";case we:return"Portal";case Te:return"Profiler";case _e:return"StrictMode";case Ge:return"Suspense";case pe:return"SuspenseList"}if(typeof e=="object")switch(e.$$typeof){case ct:return(e.displayName||"Context")+".Consumer";case nt:return(e._context.displayName||"Context")+".Provider";case Ae:var t=e.render;return e=e.displayName,e||(e=t.displayName||t.name||"",e=e!==""?"ForwardRef("+e+")":"ForwardRef"),e;case Le:return t=e.displayName||null,t!==null?t:ee(e.type)||"Memo";case Pe:t=e._payload,e=e._init;try{return ee(e(t))}catch{}}return null}function oe(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=t.render,e=e.displayName||e.name||"",t.displayName||(e!==""?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return ee(t);case 8:return t===_e?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if(typeof t=="function")return t.displayName||t.name||null;if(typeof t=="string")return t}return null}function ie(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":return e;case"object":return e;default:return""}}function ce(e){var t=e.type;return(e=e.nodeName)&&e.toLowerCase()==="input"&&(t==="checkbox"||t==="radio")}function Ye(e){var t=ce(e)?"checked":"value",i=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),n=""+e[t];if(!e.hasOwnProperty(t)&&typeof i<"u"&&typeof i.get=="function"&&typeof i.set=="function"){var a=i.get,o=i.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return a.call(this)},set:function(s){n=""+s,o.call(this,s)}}),Object.defineProperty(e,t,{enumerable:i.enumerable}),{getValue:function(){return n},setValue:function(s){n=""+s},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}function Rn(e){e._valueTracker||(e._valueTracker=Ye(e))}function Ys(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var i=t.getValue(),n="";return e&&(n=ce(e)?e.checked?"true":"false":e.value),e=n,e!==i?(t.setValue(e),!0):!1}function Mn(e){if(e=e||(typeof document<"u"?document:void 0),typeof e>"u")return null;try{return e.activeElement||e.body}catch{return e.body}}function Ua(e,t){var i=t.checked;return B({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:i??e._wrapperState.initialChecked})}function Js(e,t){var i=t.defaultValue==null?"":t.defaultValue,n=t.checked!=null?t.checked:t.defaultChecked;i=ie(t.value!=null?t.value:i),e._wrapperState={initialChecked:n,initialValue:i,controlled:t.type==="checkbox"||t.type==="radio"?t.checked!=null:t.value!=null}}function Ks(e,t){t=t.checked,t!=null&&Se(e,"checked",t,!1)}function Ga(e,t){Ks(e,t);var i=ie(t.value),n=t.type;if(i!=null)n==="number"?(i===0&&e.value===""||e.value!=i)&&(e.value=""+i):e.value!==""+i&&(e.value=""+i);else if(n==="submit"||n==="reset"){e.removeAttribute("value");return}t.hasOwnProperty("value")?ja(e,t.type,i):t.hasOwnProperty("defaultValue")&&ja(e,t.type,ie(t.defaultValue)),t.checked==null&&t.defaultChecked!=null&&(e.defaultChecked=!!t.defaultChecked)}function er(e,t,i){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var n=t.type;if(!(n!=="submit"&&n!=="reset"||t.value!==void 0&&t.value!==null))return;t=""+e._wrapperState.initialValue,i||t===e.value||(e.value=t),e.defaultValue=t}i=e.name,i!==""&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,i!==""&&(e.name=i)}function ja(e,t,i){(t!=="number"||Mn(e.ownerDocument)!==e)&&(i==null?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+i&&(e.defaultValue=""+i))}var zi=Array.isArray;function hi(e,t,i,n){if(e=e.options,t){t={};for(var a=0;a<i.length;a++)t["$"+i[a]]=!0;for(i=0;i<e.length;i++)a=t.hasOwnProperty("$"+e[i].value),e[i].selected!==a&&(e[i].selected=a),a&&n&&(e[i].defaultSelected=!0)}else{for(i=""+ie(i),t=null,a=0;a<e.length;a++){if(e[a].value===i){e[a].selected=!0,n&&(e[a].defaultSelected=!0);return}t!==null||e[a].disabled||(t=e[a])}t!==null&&(t.selected=!0)}}function Wa(e,t){if(t.dangerouslySetInnerHTML!=null)throw Error(r(91));return B({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function tr(e,t){var i=t.value;if(i==null){if(i=t.children,t=t.defaultValue,i!=null){if(t!=null)throw Error(r(92));if(zi(i)){if(1<i.length)throw Error(r(93));i=i[0]}t=i}t==null&&(t=""),i=t}e._wrapperState={initialValue:ie(i)}}function ir(e,t){var i=ie(t.value),n=ie(t.defaultValue);i!=null&&(i=""+i,i!==e.value&&(e.value=i),t.defaultValue==null&&e.defaultValue!==i&&(e.defaultValue=i)),n!=null&&(e.defaultValue=""+n)}function nr(e){var t=e.textContent;t===e._wrapperState.initialValue&&t!==""&&t!==null&&(e.value=t)}function ar(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function Va(e,t){return e==null||e==="http://www.w3.org/1999/xhtml"?ar(t):e==="http://www.w3.org/2000/svg"&&t==="foreignObject"?"http://www.w3.org/1999/xhtml":e}var Tn,or=function(e){return typeof MSApp<"u"&&MSApp.execUnsafeLocalFunction?function(t,i,n,a){MSApp.execUnsafeLocalFunction(function(){return e(t,i,n,a)})}:e}(function(e,t){if(e.namespaceURI!=="http://www.w3.org/2000/svg"||"innerHTML"in e)e.innerHTML=t;else{for(Tn=Tn||document.createElement("div"),Tn.innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=Tn.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}});function Ui(e,t){if(t){var i=e.firstChild;if(i&&i===e.lastChild&&i.nodeType===3){i.nodeValue=t;return}}e.textContent=t}var Gi={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},_c=["Webkit","ms","Moz","O"];Object.keys(Gi).forEach(function(e){_c.forEach(function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),Gi[t]=Gi[e]})});function sr(e,t,i){return t==null||typeof t=="boolean"||t===""?"":i||typeof t!="number"||t===0||Gi.hasOwnProperty(e)&&Gi[e]?(""+t).trim():t+"px"}function rr(e,t){e=e.style;for(var i in t)if(t.hasOwnProperty(i)){var n=i.indexOf("--")===0,a=sr(i,t[i],n);i==="float"&&(i="cssFloat"),n?e.setProperty(i,a):e[i]=a}}var yc=B({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function Xa(e,t){if(t){if(yc[e]&&(t.children!=null||t.dangerouslySetInnerHTML!=null))throw Error(r(137,e));if(t.dangerouslySetInnerHTML!=null){if(t.children!=null)throw Error(r(60));if(typeof t.dangerouslySetInnerHTML!="object"||!("__html"in t.dangerouslySetInnerHTML))throw Error(r(61))}if(t.style!=null&&typeof t.style!="object")throw Error(r(62))}}function Ha(e,t){if(e.indexOf("-")===-1)return typeof t.is=="string";switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var Za=null;function $a(e){return e=e.target||e.srcElement||window,e.correspondingUseElement&&(e=e.correspondingUseElement),e.nodeType===3?e.parentNode:e}var Ya=null,fi=null,gi=null;function lr(e){if(e=pn(e)){if(typeof Ya!="function")throw Error(r(280));var t=e.stateNode;t&&(t=Kn(t),Ya(e.stateNode,e.type,t))}}function ur(e){fi?gi?gi.push(e):gi=[e]:fi=e}function cr(){if(fi){var e=fi,t=gi;if(gi=fi=null,lr(e),t)for(e=0;e<t.length;e++)lr(t[e])}}function dr(e,t){return e(t)}function pr(){}var Ja=!1;function mr(e,t,i){if(Ja)return e(t,i);Ja=!0;try{return dr(e,t,i)}finally{Ja=!1,(fi!==null||gi!==null)&&(pr(),cr())}}function ji(e,t){var i=e.stateNode;if(i===null)return null;var n=Kn(i);if(n===null)return null;i=n[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(n=!n.disabled)||(e=e.type,n=!(e==="button"||e==="input"||e==="select"||e==="textarea")),e=!n;break e;default:e=!1}if(e)return null;if(i&&typeof i!="function")throw Error(r(231,t,typeof i));return i}var Ka=!1;if(k)try{var Wi={};Object.defineProperty(Wi,"passive",{get:function(){Ka=!0}}),window.addEventListener("test",Wi,Wi),window.removeEventListener("test",Wi,Wi)}catch{Ka=!1}function bc(e,t,i,n,a,o,s,u,d){var g=Array.prototype.slice.call(arguments,3);try{t.apply(i,g)}catch(x){this.onError(x)}}var Vi=!1,An=null,Pn=!1,eo=null,vc={onError:function(e){Vi=!0,An=e}};function qc(e,t,i,n,a,o,s,u,d){Vi=!1,An=null,bc.apply(vc,arguments)}function wc(e,t,i,n,a,o,s,u,d){if(qc.apply(this,arguments),Vi){if(Vi){var g=An;Vi=!1,An=null}else throw Error(r(198));Pn||(Pn=!0,eo=g)}}function Kt(e){var t=e,i=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do t=e,(t.flags&4098)!==0&&(i=t.return),e=t.return;while(e)}return t.tag===3?i:null}function hr(e){if(e.tag===13){var t=e.memoizedState;if(t===null&&(e=e.alternate,e!==null&&(t=e.memoizedState)),t!==null)return t.dehydrated}return null}function fr(e){if(Kt(e)!==e)throw Error(r(188))}function Cc(e){var t=e.alternate;if(!t){if(t=Kt(e),t===null)throw Error(r(188));return t!==e?null:e}for(var i=e,n=t;;){var a=i.return;if(a===null)break;var o=a.alternate;if(o===null){if(n=a.return,n!==null){i=n;continue}break}if(a.child===o.child){for(o=a.child;o;){if(o===i)return fr(a),e;if(o===n)return fr(a),t;o=o.sibling}throw Error(r(188))}if(i.return!==n.return)i=a,n=o;else{for(var s=!1,u=a.child;u;){if(u===i){s=!0,i=a,n=o;break}if(u===n){s=!0,n=a,i=o;break}u=u.sibling}if(!s){for(u=o.child;u;){if(u===i){s=!0,i=o,n=a;break}if(u===n){s=!0,n=o,i=a;break}u=u.sibling}if(!s)throw Error(r(189))}}if(i.alternate!==n)throw Error(r(190))}if(i.tag!==3)throw Error(r(188));return i.stateNode.current===i?e:t}function gr(e){return e=Cc(e),e!==null?_r(e):null}function _r(e){if(e.tag===5||e.tag===6)return e;for(e=e.child;e!==null;){var t=_r(e);if(t!==null)return t;e=e.sibling}return null}var yr=l.unstable_scheduleCallback,br=l.unstable_cancelCallback,xc=l.unstable_shouldYield,Ic=l.unstable_requestPaint,ye=l.unstable_now,Sc=l.unstable_getCurrentPriorityLevel,to=l.unstable_ImmediatePriority,vr=l.unstable_UserBlockingPriority,On=l.unstable_NormalPriority,kc=l.unstable_LowPriority,qr=l.unstable_IdlePriority,Qn=null,yt=null;function Rc(e){if(yt&&typeof yt.onCommitFiberRoot=="function")try{yt.onCommitFiberRoot(Qn,e,void 0,(e.current.flags&128)===128)}catch{}}var dt=Math.clz32?Math.clz32:Ac,Mc=Math.log,Tc=Math.LN2;function Ac(e){return e>>>=0,e===0?32:31-(Mc(e)/Tc|0)|0}var Fn=64,Bn=4194304;function Xi(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return e&4194240;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return e&130023424;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function Dn(e,t){var i=e.pendingLanes;if(i===0)return 0;var n=0,a=e.suspendedLanes,o=e.pingedLanes,s=i&268435455;if(s!==0){var u=s&~a;u!==0?n=Xi(u):(o&=s,o!==0&&(n=Xi(o)))}else s=i&~a,s!==0?n=Xi(s):o!==0&&(n=Xi(o));if(n===0)return 0;if(t!==0&&t!==n&&(t&a)===0&&(a=n&-n,o=t&-t,a>=o||a===16&&(o&4194240)!==0))return t;if((n&4)!==0&&(n|=i&16),t=e.entangledLanes,t!==0)for(e=e.entanglements,t&=n;0<t;)i=31-dt(t),a=1<<i,n|=e[i],t&=~a;return n}function Pc(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return-1;case 134217728:case 268435456:case 536870912:case 1073741824:return-1;default:return-1}}function Oc(e,t){for(var i=e.suspendedLanes,n=e.pingedLanes,a=e.expirationTimes,o=e.pendingLanes;0<o;){var s=31-dt(o),u=1<<s,d=a[s];d===-1?((u&i)===0||(u&n)!==0)&&(a[s]=Pc(u,t)):d<=t&&(e.expiredLanes|=u),o&=~u}}function io(e){return e=e.pendingLanes&-1073741825,e!==0?e:e&1073741824?1073741824:0}function wr(){var e=Fn;return Fn<<=1,(Fn&4194240)===0&&(Fn=64),e}function no(e){for(var t=[],i=0;31>i;i++)t.push(e);return t}function Hi(e,t,i){e.pendingLanes|=t,t!==536870912&&(e.suspendedLanes=0,e.pingedLanes=0),e=e.eventTimes,t=31-dt(t),e[t]=i}function Qc(e,t){var i=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var n=e.eventTimes;for(e=e.expirationTimes;0<i;){var a=31-dt(i),o=1<<a;t[a]=0,n[a]=-1,e[a]=-1,i&=~o}}function ao(e,t){var i=e.entangledLanes|=t;for(e=e.entanglements;i;){var n=31-dt(i),a=1<<n;a&t|e[n]&t&&(e[n]|=t),i&=~a}}var ne=0;function Cr(e){return e&=-e,1<e?4<e?(e&268435455)!==0?16:536870912:4:1}var xr,oo,Ir,Sr,kr,so=!1,En=[],Ot=null,Qt=null,Ft=null,Zi=new Map,$i=new Map,Bt=[],Fc="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Rr(e,t){switch(e){case"focusin":case"focusout":Ot=null;break;case"dragenter":case"dragleave":Qt=null;break;case"mouseover":case"mouseout":Ft=null;break;case"pointerover":case"pointerout":Zi.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":$i.delete(t.pointerId)}}function Yi(e,t,i,n,a,o){return e===null||e.nativeEvent!==o?(e={blockedOn:t,domEventName:i,eventSystemFlags:n,nativeEvent:o,targetContainers:[a]},t!==null&&(t=pn(t),t!==null&&oo(t)),e):(e.eventSystemFlags|=n,t=e.targetContainers,a!==null&&t.indexOf(a)===-1&&t.push(a),e)}function Bc(e,t,i,n,a){switch(t){case"focusin":return Ot=Yi(Ot,e,t,i,n,a),!0;case"dragenter":return Qt=Yi(Qt,e,t,i,n,a),!0;case"mouseover":return Ft=Yi(Ft,e,t,i,n,a),!0;case"pointerover":var o=a.pointerId;return Zi.set(o,Yi(Zi.get(o)||null,e,t,i,n,a)),!0;case"gotpointercapture":return o=a.pointerId,$i.set(o,Yi($i.get(o)||null,e,t,i,n,a)),!0}return!1}function Mr(e){var t=ei(e.target);if(t!==null){var i=Kt(t);if(i!==null){if(t=i.tag,t===13){if(t=hr(i),t!==null){e.blockedOn=t,kr(e.priority,function(){Ir(i)});return}}else if(t===3&&i.stateNode.current.memoizedState.isDehydrated){e.blockedOn=i.tag===3?i.stateNode.containerInfo:null;return}}}e.blockedOn=null}function Ln(e){if(e.blockedOn!==null)return!1;for(var t=e.targetContainers;0<t.length;){var i=lo(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(i===null){i=e.nativeEvent;var n=new i.constructor(i.type,i);Za=n,i.target.dispatchEvent(n),Za=null}else return t=pn(i),t!==null&&oo(t),e.blockedOn=i,!1;t.shift()}return!0}function Tr(e,t,i){Ln(e)&&i.delete(t)}function Dc(){so=!1,Ot!==null&&Ln(Ot)&&(Ot=null),Qt!==null&&Ln(Qt)&&(Qt=null),Ft!==null&&Ln(Ft)&&(Ft=null),Zi.forEach(Tr),$i.forEach(Tr)}function Ji(e,t){e.blockedOn===t&&(e.blockedOn=null,so||(so=!0,l.unstable_scheduleCallback(l.unstable_NormalPriority,Dc)))}function Ki(e){function t(a){return Ji(a,e)}if(0<En.length){Ji(En[0],e);for(var i=1;i<En.length;i++){var n=En[i];n.blockedOn===e&&(n.blockedOn=null)}}for(Ot!==null&&Ji(Ot,e),Qt!==null&&Ji(Qt,e),Ft!==null&&Ji(Ft,e),Zi.forEach(t),$i.forEach(t),i=0;i<Bt.length;i++)n=Bt[i],n.blockedOn===e&&(n.blockedOn=null);for(;0<Bt.length&&(i=Bt[0],i.blockedOn===null);)Mr(i),i.blockedOn===null&&Bt.shift()}var _i=ue.ReactCurrentBatchConfig,Nn=!0;function Ec(e,t,i,n){var a=ne,o=_i.transition;_i.transition=null;try{ne=1,ro(e,t,i,n)}finally{ne=a,_i.transition=o}}function Lc(e,t,i,n){var a=ne,o=_i.transition;_i.transition=null;try{ne=4,ro(e,t,i,n)}finally{ne=a,_i.transition=o}}function ro(e,t,i,n){if(Nn){var a=lo(e,t,i,n);if(a===null)So(e,t,n,zn,i),Rr(e,n);else if(Bc(a,e,t,i,n))n.stopPropagation();else if(Rr(e,n),t&4&&-1<Fc.indexOf(e)){for(;a!==null;){var o=pn(a);if(o!==null&&xr(o),o=lo(e,t,i,n),o===null&&So(e,t,n,zn,i),o===a)break;a=o}a!==null&&n.stopPropagation()}else So(e,t,n,null,i)}}var zn=null;function lo(e,t,i,n){if(zn=null,e=$a(n),e=ei(e),e!==null)if(t=Kt(e),t===null)e=null;else if(i=t.tag,i===13){if(e=hr(t),e!==null)return e;e=null}else if(i===3){if(t.stateNode.current.memoizedState.isDehydrated)return t.tag===3?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return zn=e,null}function Ar(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Sc()){case to:return 1;case vr:return 4;case On:case kc:return 16;case qr:return 536870912;default:return 16}default:return 16}}var Dt=null,uo=null,Un=null;function Pr(){if(Un)return Un;var e,t=uo,i=t.length,n,a="value"in Dt?Dt.value:Dt.textContent,o=a.length;for(e=0;e<i&&t[e]===a[e];e++);var s=i-e;for(n=1;n<=s&&t[i-n]===a[o-n];n++);return Un=a.slice(e,1<n?1-n:void 0)}function Gn(e){var t=e.keyCode;return"charCode"in e?(e=e.charCode,e===0&&t===13&&(e=13)):e=t,e===10&&(e=13),32<=e||e===13?e:0}function jn(){return!0}function Or(){return!1}function Je(e){function t(i,n,a,o,s){this._reactName=i,this._targetInst=a,this.type=n,this.nativeEvent=o,this.target=s,this.currentTarget=null;for(var u in e)e.hasOwnProperty(u)&&(i=e[u],this[u]=i?i(o):o[u]);return this.isDefaultPrevented=(o.defaultPrevented!=null?o.defaultPrevented:o.returnValue===!1)?jn:Or,this.isPropagationStopped=Or,this}return B(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var i=this.nativeEvent;i&&(i.preventDefault?i.preventDefault():typeof i.returnValue!="unknown"&&(i.returnValue=!1),this.isDefaultPrevented=jn)},stopPropagation:function(){var i=this.nativeEvent;i&&(i.stopPropagation?i.stopPropagation():typeof i.cancelBubble!="unknown"&&(i.cancelBubble=!0),this.isPropagationStopped=jn)},persist:function(){},isPersistent:jn}),t}var yi={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},co=Je(yi),en=B({},yi,{view:0,detail:0}),Nc=Je(en),po,mo,tn,Wn=B({},en,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:fo,button:0,buttons:0,relatedTarget:function(e){return e.relatedTarget===void 0?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==tn&&(tn&&e.type==="mousemove"?(po=e.screenX-tn.screenX,mo=e.screenY-tn.screenY):mo=po=0,tn=e),po)},movementY:function(e){return"movementY"in e?e.movementY:mo}}),Qr=Je(Wn),zc=B({},Wn,{dataTransfer:0}),Uc=Je(zc),Gc=B({},en,{relatedTarget:0}),ho=Je(Gc),jc=B({},yi,{animationName:0,elapsedTime:0,pseudoElement:0}),Wc=Je(jc),Vc=B({},yi,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),Xc=Je(Vc),Hc=B({},yi,{data:0}),Fr=Je(Hc),Zc={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},$c={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Yc={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function Jc(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):(e=Yc[e])?!!t[e]:!1}function fo(){return Jc}var Kc=B({},en,{key:function(e){if(e.key){var t=Zc[e.key]||e.key;if(t!=="Unidentified")return t}return e.type==="keypress"?(e=Gn(e),e===13?"Enter":String.fromCharCode(e)):e.type==="keydown"||e.type==="keyup"?$c[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:fo,charCode:function(e){return e.type==="keypress"?Gn(e):0},keyCode:function(e){return e.type==="keydown"||e.type==="keyup"?e.keyCode:0},which:function(e){return e.type==="keypress"?Gn(e):e.type==="keydown"||e.type==="keyup"?e.keyCode:0}}),ed=Je(Kc),td=B({},Wn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0}),Br=Je(td),id=B({},en,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:fo}),nd=Je(id),ad=B({},yi,{propertyName:0,elapsedTime:0,pseudoElement:0}),od=Je(ad),sd=B({},Wn,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),rd=Je(sd),ld=[9,13,27,32],go=k&&"CompositionEvent"in window,nn=null;k&&"documentMode"in document&&(nn=document.documentMode);var ud=k&&"TextEvent"in window&&!nn,Dr=k&&(!go||nn&&8<nn&&11>=nn),Er=" ",Lr=!1;function Nr(e,t){switch(e){case"keyup":return ld.indexOf(t.keyCode)!==-1;case"keydown":return t.keyCode!==229;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function zr(e){return e=e.detail,typeof e=="object"&&"data"in e?e.data:null}var bi=!1;function cd(e,t){switch(e){case"compositionend":return zr(t);case"keypress":return t.which!==32?null:(Lr=!0,Er);case"textInput":return e=t.data,e===Er&&Lr?null:e;default:return null}}function dd(e,t){if(bi)return e==="compositionend"||!go&&Nr(e,t)?(e=Pr(),Un=uo=Dt=null,bi=!1,e):null;switch(e){case"paste":return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return Dr&&t.locale!=="ko"?null:t.data;default:return null}}var pd={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Ur(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t==="input"?!!pd[e.type]:t==="textarea"}function Gr(e,t,i,n){ur(n),t=$n(t,"onChange"),0<t.length&&(i=new co("onChange","change",null,i,n),e.push({event:i,listeners:t}))}var an=null,on=null;function md(e){rl(e,0)}function Vn(e){var t=xi(e);if(Ys(t))return e}function hd(e,t){if(e==="change")return t}var jr=!1;if(k){var _o;if(k){var yo="oninput"in document;if(!yo){var Wr=document.createElement("div");Wr.setAttribute("oninput","return;"),yo=typeof Wr.oninput=="function"}_o=yo}else _o=!1;jr=_o&&(!document.documentMode||9<document.documentMode)}function Vr(){an&&(an.detachEvent("onpropertychange",Xr),on=an=null)}function Xr(e){if(e.propertyName==="value"&&Vn(on)){var t=[];Gr(t,on,e,$a(e)),mr(md,t)}}function fd(e,t,i){e==="focusin"?(Vr(),an=t,on=i,an.attachEvent("onpropertychange",Xr)):e==="focusout"&&Vr()}function gd(e){if(e==="selectionchange"||e==="keyup"||e==="keydown")return Vn(on)}function _d(e,t){if(e==="click")return Vn(t)}function yd(e,t){if(e==="input"||e==="change")return Vn(t)}function bd(e,t){return e===t&&(e!==0||1/e===1/t)||e!==e&&t!==t}var pt=typeof Object.is=="function"?Object.is:bd;function sn(e,t){if(pt(e,t))return!0;if(typeof e!="object"||e===null||typeof t!="object"||t===null)return!1;var i=Object.keys(e),n=Object.keys(t);if(i.length!==n.length)return!1;for(n=0;n<i.length;n++){var a=i[n];if(!I.call(t,a)||!pt(e[a],t[a]))return!1}return!0}function Hr(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function Zr(e,t){var i=Hr(e);e=0;for(var n;i;){if(i.nodeType===3){if(n=e+i.textContent.length,e<=t&&n>=t)return{node:i,offset:t-e};e=n}e:{for(;i;){if(i.nextSibling){i=i.nextSibling;break e}i=i.parentNode}i=void 0}i=Hr(i)}}function $r(e,t){return e&&t?e===t?!0:e&&e.nodeType===3?!1:t&&t.nodeType===3?$r(e,t.parentNode):"contains"in e?e.contains(t):e.compareDocumentPosition?!!(e.compareDocumentPosition(t)&16):!1:!1}function Yr(){for(var e=window,t=Mn();t instanceof e.HTMLIFrameElement;){try{var i=typeof t.contentWindow.location.href=="string"}catch{i=!1}if(i)e=t.contentWindow;else break;t=Mn(e.document)}return t}function bo(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&(t==="input"&&(e.type==="text"||e.type==="search"||e.type==="tel"||e.type==="url"||e.type==="password")||t==="textarea"||e.contentEditable==="true")}function vd(e){var t=Yr(),i=e.focusedElem,n=e.selectionRange;if(t!==i&&i&&i.ownerDocument&&$r(i.ownerDocument.documentElement,i)){if(n!==null&&bo(i)){if(t=n.start,e=n.end,e===void 0&&(e=t),"selectionStart"in i)i.selectionStart=t,i.selectionEnd=Math.min(e,i.value.length);else if(e=(t=i.ownerDocument||document)&&t.defaultView||window,e.getSelection){e=e.getSelection();var a=i.textContent.length,o=Math.min(n.start,a);n=n.end===void 0?o:Math.min(n.end,a),!e.extend&&o>n&&(a=n,n=o,o=a),a=Zr(i,o);var s=Zr(i,n);a&&s&&(e.rangeCount!==1||e.anchorNode!==a.node||e.anchorOffset!==a.offset||e.focusNode!==s.node||e.focusOffset!==s.offset)&&(t=t.createRange(),t.setStart(a.node,a.offset),e.removeAllRanges(),o>n?(e.addRange(t),e.extend(s.node,s.offset)):(t.setEnd(s.node,s.offset),e.addRange(t)))}}for(t=[],e=i;e=e.parentNode;)e.nodeType===1&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for(typeof i.focus=="function"&&i.focus(),i=0;i<t.length;i++)e=t[i],e.element.scrollLeft=e.left,e.element.scrollTop=e.top}}var qd=k&&"documentMode"in document&&11>=document.documentMode,vi=null,vo=null,rn=null,qo=!1;function Jr(e,t,i){var n=i.window===i?i.document:i.nodeType===9?i:i.ownerDocument;qo||vi==null||vi!==Mn(n)||(n=vi,"selectionStart"in n&&bo(n)?n={start:n.selectionStart,end:n.selectionEnd}:(n=(n.ownerDocument&&n.ownerDocument.defaultView||window).getSelection(),n={anchorNode:n.anchorNode,anchorOffset:n.anchorOffset,focusNode:n.focusNode,focusOffset:n.focusOffset}),rn&&sn(rn,n)||(rn=n,n=$n(vo,"onSelect"),0<n.length&&(t=new co("onSelect","select",null,t,i),e.push({event:t,listeners:n}),t.target=vi)))}function Xn(e,t){var i={};return i[e.toLowerCase()]=t.toLowerCase(),i["Webkit"+e]="webkit"+t,i["Moz"+e]="moz"+t,i}var qi={animationend:Xn("Animation","AnimationEnd"),animationiteration:Xn("Animation","AnimationIteration"),animationstart:Xn("Animation","AnimationStart"),transitionend:Xn("Transition","TransitionEnd")},wo={},Kr={};k&&(Kr=document.createElement("div").style,"AnimationEvent"in window||(delete qi.animationend.animation,delete qi.animationiteration.animation,delete qi.animationstart.animation),"TransitionEvent"in window||delete qi.transitionend.transition);function Hn(e){if(wo[e])return wo[e];if(!qi[e])return e;var t=qi[e],i;for(i in t)if(t.hasOwnProperty(i)&&i in Kr)return wo[e]=t[i];return e}var el=Hn("animationend"),tl=Hn("animationiteration"),il=Hn("animationstart"),nl=Hn("transitionend"),al=new Map,ol="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Et(e,t){al.set(e,t),v(t,[e])}for(var Co=0;Co<ol.length;Co++){var xo=ol[Co],wd=xo.toLowerCase(),Cd=xo[0].toUpperCase()+xo.slice(1);Et(wd,"on"+Cd)}Et(el,"onAnimationEnd"),Et(tl,"onAnimationIteration"),Et(il,"onAnimationStart"),Et("dblclick","onDoubleClick"),Et("focusin","onFocus"),Et("focusout","onBlur"),Et(nl,"onTransitionEnd"),q("onMouseEnter",["mouseout","mouseover"]),q("onMouseLeave",["mouseout","mouseover"]),q("onPointerEnter",["pointerout","pointerover"]),q("onPointerLeave",["pointerout","pointerover"]),v("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),v("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),v("onBeforeInput",["compositionend","keypress","textInput","paste"]),v("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),v("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),v("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var ln="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),xd=new Set("cancel close invalid load scroll toggle".split(" ").concat(ln));function sl(e,t,i){var n=e.type||"unknown-event";e.currentTarget=i,wc(n,t,void 0,e),e.currentTarget=null}function rl(e,t){t=(t&4)!==0;for(var i=0;i<e.length;i++){var n=e[i],a=n.event;n=n.listeners;e:{var o=void 0;if(t)for(var s=n.length-1;0<=s;s--){var u=n[s],d=u.instance,g=u.currentTarget;if(u=u.listener,d!==o&&a.isPropagationStopped())break e;sl(a,u,g),o=d}else for(s=0;s<n.length;s++){if(u=n[s],d=u.instance,g=u.currentTarget,u=u.listener,d!==o&&a.isPropagationStopped())break e;sl(a,u,g),o=d}}}if(Pn)throw e=eo,Pn=!1,eo=null,e}function re(e,t){var i=t[Po];i===void 0&&(i=t[Po]=new Set);var n=e+"__bubble";i.has(n)||(ll(t,e,2,!1),i.add(n))}function Io(e,t,i){var n=0;t&&(n|=4),ll(i,e,n,t)}var Zn="_reactListening"+Math.random().toString(36).slice(2);function un(e){if(!e[Zn]){e[Zn]=!0,b.forEach(function(i){i!=="selectionchange"&&(xd.has(i)||Io(i,!1,e),Io(i,!0,e))});var t=e.nodeType===9?e:e.ownerDocument;t===null||t[Zn]||(t[Zn]=!0,Io("selectionchange",!1,t))}}function ll(e,t,i,n){switch(Ar(t)){case 1:var a=Ec;break;case 4:a=Lc;break;default:a=ro}i=a.bind(null,t,i,e),a=void 0,!Ka||t!=="touchstart"&&t!=="touchmove"&&t!=="wheel"||(a=!0),n?a!==void 0?e.addEventListener(t,i,{capture:!0,passive:a}):e.addEventListener(t,i,!0):a!==void 0?e.addEventListener(t,i,{passive:a}):e.addEventListener(t,i,!1)}function So(e,t,i,n,a){var o=n;if((t&1)===0&&(t&2)===0&&n!==null)e:for(;;){if(n===null)return;var s=n.tag;if(s===3||s===4){var u=n.stateNode.containerInfo;if(u===a||u.nodeType===8&&u.parentNode===a)break;if(s===4)for(s=n.return;s!==null;){var d=s.tag;if((d===3||d===4)&&(d=s.stateNode.containerInfo,d===a||d.nodeType===8&&d.parentNode===a))return;s=s.return}for(;u!==null;){if(s=ei(u),s===null)return;if(d=s.tag,d===5||d===6){n=o=s;continue e}u=u.parentNode}}n=n.return}mr(function(){var g=o,x=$a(i),S=[];e:{var w=al.get(e);if(w!==void 0){var Q=co,D=e;switch(e){case"keypress":if(Gn(i)===0)break e;case"keydown":case"keyup":Q=ed;break;case"focusin":D="focus",Q=ho;break;case"focusout":D="blur",Q=ho;break;case"beforeblur":case"afterblur":Q=ho;break;case"click":if(i.button===2)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":Q=Qr;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":Q=Uc;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":Q=nd;break;case el:case tl:case il:Q=Wc;break;case nl:Q=od;break;case"scroll":Q=Nc;break;case"wheel":Q=rd;break;case"copy":case"cut":case"paste":Q=Xc;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":Q=Br}var E=(t&4)!==0,be=!E&&e==="scroll",h=E?w!==null?w+"Capture":null:w;E=[];for(var p=g,f;p!==null;){f=p;var R=f.stateNode;if(f.tag===5&&R!==null&&(f=R,h!==null&&(R=ji(p,h),R!=null&&E.push(cn(p,R,f)))),be)break;p=p.return}0<E.length&&(w=new Q(w,D,null,i,x),S.push({event:w,listeners:E}))}}if((t&7)===0){e:{if(w=e==="mouseover"||e==="pointerover",Q=e==="mouseout"||e==="pointerout",w&&i!==Za&&(D=i.relatedTarget||i.fromElement)&&(ei(D)||D[xt]))break e;if((Q||w)&&(w=x.window===x?x:(w=x.ownerDocument)?w.defaultView||w.parentWindow:window,Q?(D=i.relatedTarget||i.toElement,Q=g,D=D?ei(D):null,D!==null&&(be=Kt(D),D!==be||D.tag!==5&&D.tag!==6)&&(D=null)):(Q=null,D=g),Q!==D)){if(E=Qr,R="onMouseLeave",h="onMouseEnter",p="mouse",(e==="pointerout"||e==="pointerover")&&(E=Br,R="onPointerLeave",h="onPointerEnter",p="pointer"),be=Q==null?w:xi(Q),f=D==null?w:xi(D),w=new E(R,p+"leave",Q,i,x),w.target=be,w.relatedTarget=f,R=null,ei(x)===g&&(E=new E(h,p+"enter",D,i,x),E.target=f,E.relatedTarget=be,R=E),be=R,Q&&D)t:{for(E=Q,h=D,p=0,f=E;f;f=wi(f))p++;for(f=0,R=h;R;R=wi(R))f++;for(;0<p-f;)E=wi(E),p--;for(;0<f-p;)h=wi(h),f--;for(;p--;){if(E===h||h!==null&&E===h.alternate)break t;E=wi(E),h=wi(h)}E=null}else E=null;Q!==null&&ul(S,w,Q,E,!1),D!==null&&be!==null&&ul(S,be,D,E,!0)}}e:{if(w=g?xi(g):window,Q=w.nodeName&&w.nodeName.toLowerCase(),Q==="select"||Q==="input"&&w.type==="file")var L=hd;else if(Ur(w))if(jr)L=yd;else{L=gd;var N=fd}else(Q=w.nodeName)&&Q.toLowerCase()==="input"&&(w.type==="checkbox"||w.type==="radio")&&(L=_d);if(L&&(L=L(e,g))){Gr(S,L,i,x);break e}N&&N(e,w,g),e==="focusout"&&(N=w._wrapperState)&&N.controlled&&w.type==="number"&&ja(w,"number",w.value)}switch(N=g?xi(g):window,e){case"focusin":(Ur(N)||N.contentEditable==="true")&&(vi=N,vo=g,rn=null);break;case"focusout":rn=vo=vi=null;break;case"mousedown":qo=!0;break;case"contextmenu":case"mouseup":case"dragend":qo=!1,Jr(S,i,x);break;case"selectionchange":if(qd)break;case"keydown":case"keyup":Jr(S,i,x)}var z;if(go)e:{switch(e){case"compositionstart":var j="onCompositionStart";break e;case"compositionend":j="onCompositionEnd";break e;case"compositionupdate":j="onCompositionUpdate";break e}j=void 0}else bi?Nr(e,i)&&(j="onCompositionEnd"):e==="keydown"&&i.keyCode===229&&(j="onCompositionStart");j&&(Dr&&i.locale!=="ko"&&(bi||j!=="onCompositionStart"?j==="onCompositionEnd"&&bi&&(z=Pr()):(Dt=x,uo="value"in Dt?Dt.value:Dt.textContent,bi=!0)),N=$n(g,j),0<N.length&&(j=new Fr(j,e,null,i,x),S.push({event:j,listeners:N}),z?j.data=z:(z=zr(i),z!==null&&(j.data=z)))),(z=ud?cd(e,i):dd(e,i))&&(g=$n(g,"onBeforeInput"),0<g.length&&(x=new Fr("onBeforeInput","beforeinput",null,i,x),S.push({event:x,listeners:g}),x.data=z))}rl(S,t)})}function cn(e,t,i){return{instance:e,listener:t,currentTarget:i}}function $n(e,t){for(var i=t+"Capture",n=[];e!==null;){var a=e,o=a.stateNode;a.tag===5&&o!==null&&(a=o,o=ji(e,i),o!=null&&n.unshift(cn(e,o,a)),o=ji(e,t),o!=null&&n.push(cn(e,o,a))),e=e.return}return n}function wi(e){if(e===null)return null;do e=e.return;while(e&&e.tag!==5);return e||null}function ul(e,t,i,n,a){for(var o=t._reactName,s=[];i!==null&&i!==n;){var u=i,d=u.alternate,g=u.stateNode;if(d!==null&&d===n)break;u.tag===5&&g!==null&&(u=g,a?(d=ji(i,o),d!=null&&s.unshift(cn(i,d,u))):a||(d=ji(i,o),d!=null&&s.push(cn(i,d,u)))),i=i.return}s.length!==0&&e.push({event:t,listeners:s})}var Id=/\r\n?/g,Sd=/\u0000|\uFFFD/g;function cl(e){return(typeof e=="string"?e:""+e).replace(Id,`
`).replace(Sd,"")}function Yn(e,t,i){if(t=cl(t),cl(e)!==t&&i)throw Error(r(425))}function Jn(){}var ko=null,Ro=null;function Mo(e,t){return e==="textarea"||e==="noscript"||typeof t.children=="string"||typeof t.children=="number"||typeof t.dangerouslySetInnerHTML=="object"&&t.dangerouslySetInnerHTML!==null&&t.dangerouslySetInnerHTML.__html!=null}var To=typeof setTimeout=="function"?setTimeout:void 0,kd=typeof clearTimeout=="function"?clearTimeout:void 0,dl=typeof Promise=="function"?Promise:void 0,Rd=typeof queueMicrotask=="function"?queueMicrotask:typeof dl<"u"?function(e){return dl.resolve(null).then(e).catch(Md)}:To;function Md(e){setTimeout(function(){throw e})}function Ao(e,t){var i=t,n=0;do{var a=i.nextSibling;if(e.removeChild(i),a&&a.nodeType===8)if(i=a.data,i==="/$"){if(n===0){e.removeChild(a),Ki(t);return}n--}else i!=="$"&&i!=="$?"&&i!=="$!"||n++;i=a}while(i);Ki(t)}function Lt(e){for(;e!=null;e=e.nextSibling){var t=e.nodeType;if(t===1||t===3)break;if(t===8){if(t=e.data,t==="$"||t==="$!"||t==="$?")break;if(t==="/$")return null}}return e}function pl(e){e=e.previousSibling;for(var t=0;e;){if(e.nodeType===8){var i=e.data;if(i==="$"||i==="$!"||i==="$?"){if(t===0)return e;t--}else i==="/$"&&t++}e=e.previousSibling}return null}var Ci=Math.random().toString(36).slice(2),bt="__reactFiber$"+Ci,dn="__reactProps$"+Ci,xt="__reactContainer$"+Ci,Po="__reactEvents$"+Ci,Td="__reactListeners$"+Ci,Ad="__reactHandles$"+Ci;function ei(e){var t=e[bt];if(t)return t;for(var i=e.parentNode;i;){if(t=i[xt]||i[bt]){if(i=t.alternate,t.child!==null||i!==null&&i.child!==null)for(e=pl(e);e!==null;){if(i=e[bt])return i;e=pl(e)}return t}e=i,i=e.parentNode}return null}function pn(e){return e=e[bt]||e[xt],!e||e.tag!==5&&e.tag!==6&&e.tag!==13&&e.tag!==3?null:e}function xi(e){if(e.tag===5||e.tag===6)return e.stateNode;throw Error(r(33))}function Kn(e){return e[dn]||null}var Oo=[],Ii=-1;function Nt(e){return{current:e}}function le(e){0>Ii||(e.current=Oo[Ii],Oo[Ii]=null,Ii--)}function se(e,t){Ii++,Oo[Ii]=e.current,e.current=t}var zt={},Fe=Nt(zt),je=Nt(!1),ti=zt;function Si(e,t){var i=e.type.contextTypes;if(!i)return zt;var n=e.stateNode;if(n&&n.__reactInternalMemoizedUnmaskedChildContext===t)return n.__reactInternalMemoizedMaskedChildContext;var a={},o;for(o in i)a[o]=t[o];return n&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=a),a}function We(e){return e=e.childContextTypes,e!=null}function ea(){le(je),le(Fe)}function ml(e,t,i){if(Fe.current!==zt)throw Error(r(168));se(Fe,t),se(je,i)}function hl(e,t,i){var n=e.stateNode;if(t=t.childContextTypes,typeof n.getChildContext!="function")return i;n=n.getChildContext();for(var a in n)if(!(a in t))throw Error(r(108,oe(e)||"Unknown",a));return B({},i,n)}function ta(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||zt,ti=Fe.current,se(Fe,e),se(je,je.current),!0}function fl(e,t,i){var n=e.stateNode;if(!n)throw Error(r(169));i?(e=hl(e,t,ti),n.__reactInternalMemoizedMergedChildContext=e,le(je),le(Fe),se(Fe,e)):le(je),se(je,i)}var It=null,ia=!1,Qo=!1;function gl(e){It===null?It=[e]:It.push(e)}function Pd(e){ia=!0,gl(e)}function Ut(){if(!Qo&&It!==null){Qo=!0;var e=0,t=ne;try{var i=It;for(ne=1;e<i.length;e++){var n=i[e];do n=n(!0);while(n!==null)}It=null,ia=!1}catch(a){throw It!==null&&(It=It.slice(e+1)),yr(to,Ut),a}finally{ne=t,Qo=!1}}return null}var ki=[],Ri=0,na=null,aa=0,at=[],ot=0,ii=null,St=1,kt="";function ni(e,t){ki[Ri++]=aa,ki[Ri++]=na,na=e,aa=t}function _l(e,t,i){at[ot++]=St,at[ot++]=kt,at[ot++]=ii,ii=e;var n=St;e=kt;var a=32-dt(n)-1;n&=~(1<<a),i+=1;var o=32-dt(t)+a;if(30<o){var s=a-a%5;o=(n&(1<<s)-1).toString(32),n>>=s,a-=s,St=1<<32-dt(t)+a|i<<a|n,kt=o+e}else St=1<<o|i<<a|n,kt=e}function Fo(e){e.return!==null&&(ni(e,1),_l(e,1,0))}function Bo(e){for(;e===na;)na=ki[--Ri],ki[Ri]=null,aa=ki[--Ri],ki[Ri]=null;for(;e===ii;)ii=at[--ot],at[ot]=null,kt=at[--ot],at[ot]=null,St=at[--ot],at[ot]=null}var Ke=null,et=null,de=!1,mt=null;function yl(e,t){var i=ut(5,null,null,0);i.elementType="DELETED",i.stateNode=t,i.return=e,t=e.deletions,t===null?(e.deletions=[i],e.flags|=16):t.push(i)}function bl(e,t){switch(e.tag){case 5:var i=e.type;return t=t.nodeType!==1||i.toLowerCase()!==t.nodeName.toLowerCase()?null:t,t!==null?(e.stateNode=t,Ke=e,et=Lt(t.firstChild),!0):!1;case 6:return t=e.pendingProps===""||t.nodeType!==3?null:t,t!==null?(e.stateNode=t,Ke=e,et=null,!0):!1;case 13:return t=t.nodeType!==8?null:t,t!==null?(i=ii!==null?{id:St,overflow:kt}:null,e.memoizedState={dehydrated:t,treeContext:i,retryLane:1073741824},i=ut(18,null,null,0),i.stateNode=t,i.return=e,e.child=i,Ke=e,et=null,!0):!1;default:return!1}}function Do(e){return(e.mode&1)!==0&&(e.flags&128)===0}function Eo(e){if(de){var t=et;if(t){var i=t;if(!bl(e,t)){if(Do(e))throw Error(r(418));t=Lt(i.nextSibling);var n=Ke;t&&bl(e,t)?yl(n,i):(e.flags=e.flags&-4097|2,de=!1,Ke=e)}}else{if(Do(e))throw Error(r(418));e.flags=e.flags&-4097|2,de=!1,Ke=e}}}function vl(e){for(e=e.return;e!==null&&e.tag!==5&&e.tag!==3&&e.tag!==13;)e=e.return;Ke=e}function oa(e){if(e!==Ke)return!1;if(!de)return vl(e),de=!0,!1;var t;if((t=e.tag!==3)&&!(t=e.tag!==5)&&(t=e.type,t=t!=="head"&&t!=="body"&&!Mo(e.type,e.memoizedProps)),t&&(t=et)){if(Do(e))throw ql(),Error(r(418));for(;t;)yl(e,t),t=Lt(t.nextSibling)}if(vl(e),e.tag===13){if(e=e.memoizedState,e=e!==null?e.dehydrated:null,!e)throw Error(r(317));e:{for(e=e.nextSibling,t=0;e;){if(e.nodeType===8){var i=e.data;if(i==="/$"){if(t===0){et=Lt(e.nextSibling);break e}t--}else i!=="$"&&i!=="$!"&&i!=="$?"||t++}e=e.nextSibling}et=null}}else et=Ke?Lt(e.stateNode.nextSibling):null;return!0}function ql(){for(var e=et;e;)e=Lt(e.nextSibling)}function Mi(){et=Ke=null,de=!1}function Lo(e){mt===null?mt=[e]:mt.push(e)}var Od=ue.ReactCurrentBatchConfig;function mn(e,t,i){if(e=i.ref,e!==null&&typeof e!="function"&&typeof e!="object"){if(i._owner){if(i=i._owner,i){if(i.tag!==1)throw Error(r(309));var n=i.stateNode}if(!n)throw Error(r(147,e));var a=n,o=""+e;return t!==null&&t.ref!==null&&typeof t.ref=="function"&&t.ref._stringRef===o?t.ref:(t=function(s){var u=a.refs;s===null?delete u[o]:u[o]=s},t._stringRef=o,t)}if(typeof e!="string")throw Error(r(284));if(!i._owner)throw Error(r(290,e))}return e}function sa(e,t){throw e=Object.prototype.toString.call(t),Error(r(31,e==="[object Object]"?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function wl(e){var t=e._init;return t(e._payload)}function Cl(e){function t(h,p){if(e){var f=h.deletions;f===null?(h.deletions=[p],h.flags|=16):f.push(p)}}function i(h,p){if(!e)return null;for(;p!==null;)t(h,p),p=p.sibling;return null}function n(h,p){for(h=new Map;p!==null;)p.key!==null?h.set(p.key,p):h.set(p.index,p),p=p.sibling;return h}function a(h,p){return h=$t(h,p),h.index=0,h.sibling=null,h}function o(h,p,f){return h.index=f,e?(f=h.alternate,f!==null?(f=f.index,f<p?(h.flags|=2,p):f):(h.flags|=2,p)):(h.flags|=1048576,p)}function s(h){return e&&h.alternate===null&&(h.flags|=2),h}function u(h,p,f,R){return p===null||p.tag!==6?(p=Ts(f,h.mode,R),p.return=h,p):(p=a(p,f),p.return=h,p)}function d(h,p,f,R){var L=f.type;return L===ae?x(h,p,f.props.children,R,f.key):p!==null&&(p.elementType===L||typeof L=="object"&&L!==null&&L.$$typeof===Pe&&wl(L)===p.type)?(R=a(p,f.props),R.ref=mn(h,p,f),R.return=h,R):(R=Ta(f.type,f.key,f.props,null,h.mode,R),R.ref=mn(h,p,f),R.return=h,R)}function g(h,p,f,R){return p===null||p.tag!==4||p.stateNode.containerInfo!==f.containerInfo||p.stateNode.implementation!==f.implementation?(p=As(f,h.mode,R),p.return=h,p):(p=a(p,f.children||[]),p.return=h,p)}function x(h,p,f,R,L){return p===null||p.tag!==7?(p=di(f,h.mode,R,L),p.return=h,p):(p=a(p,f),p.return=h,p)}function S(h,p,f){if(typeof p=="string"&&p!==""||typeof p=="number")return p=Ts(""+p,h.mode,f),p.return=h,p;if(typeof p=="object"&&p!==null){switch(p.$$typeof){case $e:return f=Ta(p.type,p.key,p.props,null,h.mode,f),f.ref=mn(h,null,p),f.return=h,f;case we:return p=As(p,h.mode,f),p.return=h,p;case Pe:var R=p._init;return S(h,R(p._payload),f)}if(zi(p)||U(p))return p=di(p,h.mode,f,null),p.return=h,p;sa(h,p)}return null}function w(h,p,f,R){var L=p!==null?p.key:null;if(typeof f=="string"&&f!==""||typeof f=="number")return L!==null?null:u(h,p,""+f,R);if(typeof f=="object"&&f!==null){switch(f.$$typeof){case $e:return f.key===L?d(h,p,f,R):null;case we:return f.key===L?g(h,p,f,R):null;case Pe:return L=f._init,w(h,p,L(f._payload),R)}if(zi(f)||U(f))return L!==null?null:x(h,p,f,R,null);sa(h,f)}return null}function Q(h,p,f,R,L){if(typeof R=="string"&&R!==""||typeof R=="number")return h=h.get(f)||null,u(p,h,""+R,L);if(typeof R=="object"&&R!==null){switch(R.$$typeof){case $e:return h=h.get(R.key===null?f:R.key)||null,d(p,h,R,L);case we:return h=h.get(R.key===null?f:R.key)||null,g(p,h,R,L);case Pe:var N=R._init;return Q(h,p,f,N(R._payload),L)}if(zi(R)||U(R))return h=h.get(f)||null,x(p,h,R,L,null);sa(p,R)}return null}function D(h,p,f,R){for(var L=null,N=null,z=p,j=p=0,Me=null;z!==null&&j<f.length;j++){z.index>j?(Me=z,z=null):Me=z.sibling;var te=w(h,z,f[j],R);if(te===null){z===null&&(z=Me);break}e&&z&&te.alternate===null&&t(h,z),p=o(te,p,j),N===null?L=te:N.sibling=te,N=te,z=Me}if(j===f.length)return i(h,z),de&&ni(h,j),L;if(z===null){for(;j<f.length;j++)z=S(h,f[j],R),z!==null&&(p=o(z,p,j),N===null?L=z:N.sibling=z,N=z);return de&&ni(h,j),L}for(z=n(h,z);j<f.length;j++)Me=Q(z,h,j,f[j],R),Me!==null&&(e&&Me.alternate!==null&&z.delete(Me.key===null?j:Me.key),p=o(Me,p,j),N===null?L=Me:N.sibling=Me,N=Me);return e&&z.forEach(function(Yt){return t(h,Yt)}),de&&ni(h,j),L}function E(h,p,f,R){var L=U(f);if(typeof L!="function")throw Error(r(150));if(f=L.call(f),f==null)throw Error(r(151));for(var N=L=null,z=p,j=p=0,Me=null,te=f.next();z!==null&&!te.done;j++,te=f.next()){z.index>j?(Me=z,z=null):Me=z.sibling;var Yt=w(h,z,te.value,R);if(Yt===null){z===null&&(z=Me);break}e&&z&&Yt.alternate===null&&t(h,z),p=o(Yt,p,j),N===null?L=Yt:N.sibling=Yt,N=Yt,z=Me}if(te.done)return i(h,z),de&&ni(h,j),L;if(z===null){for(;!te.done;j++,te=f.next())te=S(h,te.value,R),te!==null&&(p=o(te,p,j),N===null?L=te:N.sibling=te,N=te);return de&&ni(h,j),L}for(z=n(h,z);!te.done;j++,te=f.next())te=Q(z,h,j,te.value,R),te!==null&&(e&&te.alternate!==null&&z.delete(te.key===null?j:te.key),p=o(te,p,j),N===null?L=te:N.sibling=te,N=te);return e&&z.forEach(function(pp){return t(h,pp)}),de&&ni(h,j),L}function be(h,p,f,R){if(typeof f=="object"&&f!==null&&f.type===ae&&f.key===null&&(f=f.props.children),typeof f=="object"&&f!==null){switch(f.$$typeof){case $e:e:{for(var L=f.key,N=p;N!==null;){if(N.key===L){if(L=f.type,L===ae){if(N.tag===7){i(h,N.sibling),p=a(N,f.props.children),p.return=h,h=p;break e}}else if(N.elementType===L||typeof L=="object"&&L!==null&&L.$$typeof===Pe&&wl(L)===N.type){i(h,N.sibling),p=a(N,f.props),p.ref=mn(h,N,f),p.return=h,h=p;break e}i(h,N);break}else t(h,N);N=N.sibling}f.type===ae?(p=di(f.props.children,h.mode,R,f.key),p.return=h,h=p):(R=Ta(f.type,f.key,f.props,null,h.mode,R),R.ref=mn(h,p,f),R.return=h,h=R)}return s(h);case we:e:{for(N=f.key;p!==null;){if(p.key===N)if(p.tag===4&&p.stateNode.containerInfo===f.containerInfo&&p.stateNode.implementation===f.implementation){i(h,p.sibling),p=a(p,f.children||[]),p.return=h,h=p;break e}else{i(h,p);break}else t(h,p);p=p.sibling}p=As(f,h.mode,R),p.return=h,h=p}return s(h);case Pe:return N=f._init,be(h,p,N(f._payload),R)}if(zi(f))return D(h,p,f,R);if(U(f))return E(h,p,f,R);sa(h,f)}return typeof f=="string"&&f!==""||typeof f=="number"?(f=""+f,p!==null&&p.tag===6?(i(h,p.sibling),p=a(p,f),p.return=h,h=p):(i(h,p),p=Ts(f,h.mode,R),p.return=h,h=p),s(h)):i(h,p)}return be}var Ti=Cl(!0),xl=Cl(!1),ra=Nt(null),la=null,Ai=null,No=null;function zo(){No=Ai=la=null}function Uo(e){var t=ra.current;le(ra),e._currentValue=t}function Go(e,t,i){for(;e!==null;){var n=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,n!==null&&(n.childLanes|=t)):n!==null&&(n.childLanes&t)!==t&&(n.childLanes|=t),e===i)break;e=e.return}}function Pi(e,t){la=e,No=Ai=null,e=e.dependencies,e!==null&&e.firstContext!==null&&((e.lanes&t)!==0&&(Ve=!0),e.firstContext=null)}function st(e){var t=e._currentValue;if(No!==e)if(e={context:e,memoizedValue:t,next:null},Ai===null){if(la===null)throw Error(r(308));Ai=e,la.dependencies={lanes:0,firstContext:e}}else Ai=Ai.next=e;return t}var ai=null;function jo(e){ai===null?ai=[e]:ai.push(e)}function Il(e,t,i,n){var a=t.interleaved;return a===null?(i.next=i,jo(t)):(i.next=a.next,a.next=i),t.interleaved=i,Rt(e,n)}function Rt(e,t){e.lanes|=t;var i=e.alternate;for(i!==null&&(i.lanes|=t),i=e,e=e.return;e!==null;)e.childLanes|=t,i=e.alternate,i!==null&&(i.childLanes|=t),i=e,e=e.return;return i.tag===3?i.stateNode:null}var Gt=!1;function Wo(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function Sl(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function Mt(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function jt(e,t,i){var n=e.updateQueue;if(n===null)return null;if(n=n.shared,(J&2)!==0){var a=n.pending;return a===null?t.next=t:(t.next=a.next,a.next=t),n.pending=t,Rt(e,i)}return a=n.interleaved,a===null?(t.next=t,jo(n)):(t.next=a.next,a.next=t),n.interleaved=t,Rt(e,i)}function ua(e,t,i){if(t=t.updateQueue,t!==null&&(t=t.shared,(i&4194240)!==0)){var n=t.lanes;n&=e.pendingLanes,i|=n,t.lanes=i,ao(e,i)}}function kl(e,t){var i=e.updateQueue,n=e.alternate;if(n!==null&&(n=n.updateQueue,i===n)){var a=null,o=null;if(i=i.firstBaseUpdate,i!==null){do{var s={eventTime:i.eventTime,lane:i.lane,tag:i.tag,payload:i.payload,callback:i.callback,next:null};o===null?a=o=s:o=o.next=s,i=i.next}while(i!==null);o===null?a=o=t:o=o.next=t}else a=o=t;i={baseState:n.baseState,firstBaseUpdate:a,lastBaseUpdate:o,shared:n.shared,effects:n.effects},e.updateQueue=i;return}e=i.lastBaseUpdate,e===null?i.firstBaseUpdate=t:e.next=t,i.lastBaseUpdate=t}function ca(e,t,i,n){var a=e.updateQueue;Gt=!1;var o=a.firstBaseUpdate,s=a.lastBaseUpdate,u=a.shared.pending;if(u!==null){a.shared.pending=null;var d=u,g=d.next;d.next=null,s===null?o=g:s.next=g,s=d;var x=e.alternate;x!==null&&(x=x.updateQueue,u=x.lastBaseUpdate,u!==s&&(u===null?x.firstBaseUpdate=g:u.next=g,x.lastBaseUpdate=d))}if(o!==null){var S=a.baseState;s=0,x=g=d=null,u=o;do{var w=u.lane,Q=u.eventTime;if((n&w)===w){x!==null&&(x=x.next={eventTime:Q,lane:0,tag:u.tag,payload:u.payload,callback:u.callback,next:null});e:{var D=e,E=u;switch(w=t,Q=i,E.tag){case 1:if(D=E.payload,typeof D=="function"){S=D.call(Q,S,w);break e}S=D;break e;case 3:D.flags=D.flags&-65537|128;case 0:if(D=E.payload,w=typeof D=="function"?D.call(Q,S,w):D,w==null)break e;S=B({},S,w);break e;case 2:Gt=!0}}u.callback!==null&&u.lane!==0&&(e.flags|=64,w=a.effects,w===null?a.effects=[u]:w.push(u))}else Q={eventTime:Q,lane:w,tag:u.tag,payload:u.payload,callback:u.callback,next:null},x===null?(g=x=Q,d=S):x=x.next=Q,s|=w;if(u=u.next,u===null){if(u=a.shared.pending,u===null)break;w=u,u=w.next,w.next=null,a.lastBaseUpdate=w,a.shared.pending=null}}while(!0);if(x===null&&(d=S),a.baseState=d,a.firstBaseUpdate=g,a.lastBaseUpdate=x,t=a.shared.interleaved,t!==null){a=t;do s|=a.lane,a=a.next;while(a!==t)}else o===null&&(a.shared.lanes=0);ri|=s,e.lanes=s,e.memoizedState=S}}function Rl(e,t,i){if(e=t.effects,t.effects=null,e!==null)for(t=0;t<e.length;t++){var n=e[t],a=n.callback;if(a!==null){if(n.callback=null,n=i,typeof a!="function")throw Error(r(191,a));a.call(n)}}}var hn={},vt=Nt(hn),fn=Nt(hn),gn=Nt(hn);function oi(e){if(e===hn)throw Error(r(174));return e}function Vo(e,t){switch(se(gn,t),se(fn,e),se(vt,hn),e=t.nodeType,e){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:Va(null,"");break;default:e=e===8?t.parentNode:t,t=e.namespaceURI||null,e=e.tagName,t=Va(t,e)}le(vt),se(vt,t)}function Oi(){le(vt),le(fn),le(gn)}function Ml(e){oi(gn.current);var t=oi(vt.current),i=Va(t,e.type);t!==i&&(se(fn,e),se(vt,i))}function Xo(e){fn.current===e&&(le(vt),le(fn))}var me=Nt(0);function da(e){for(var t=e;t!==null;){if(t.tag===13){var i=t.memoizedState;if(i!==null&&(i=i.dehydrated,i===null||i.data==="$?"||i.data==="$!"))return t}else if(t.tag===19&&t.memoizedProps.revealOrder!==void 0){if((t.flags&128)!==0)return t}else if(t.child!==null){t.child.return=t,t=t.child;continue}if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var Ho=[];function Zo(){for(var e=0;e<Ho.length;e++)Ho[e]._workInProgressVersionPrimary=null;Ho.length=0}var pa=ue.ReactCurrentDispatcher,$o=ue.ReactCurrentBatchConfig,si=0,he=null,Ce=null,ke=null,ma=!1,_n=!1,yn=0,Qd=0;function Be(){throw Error(r(321))}function Yo(e,t){if(t===null)return!1;for(var i=0;i<t.length&&i<e.length;i++)if(!pt(e[i],t[i]))return!1;return!0}function Jo(e,t,i,n,a,o){if(si=o,he=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,pa.current=e===null||e.memoizedState===null?Ed:Ld,e=i(n,a),_n){o=0;do{if(_n=!1,yn=0,25<=o)throw Error(r(301));o+=1,ke=Ce=null,t.updateQueue=null,pa.current=Nd,e=i(n,a)}while(_n)}if(pa.current=ga,t=Ce!==null&&Ce.next!==null,si=0,ke=Ce=he=null,ma=!1,t)throw Error(r(300));return e}function Ko(){var e=yn!==0;return yn=0,e}function qt(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return ke===null?he.memoizedState=ke=e:ke=ke.next=e,ke}function rt(){if(Ce===null){var e=he.alternate;e=e!==null?e.memoizedState:null}else e=Ce.next;var t=ke===null?he.memoizedState:ke.next;if(t!==null)ke=t,Ce=e;else{if(e===null)throw Error(r(310));Ce=e,e={memoizedState:Ce.memoizedState,baseState:Ce.baseState,baseQueue:Ce.baseQueue,queue:Ce.queue,next:null},ke===null?he.memoizedState=ke=e:ke=ke.next=e}return ke}function bn(e,t){return typeof t=="function"?t(e):t}function es(e){var t=rt(),i=t.queue;if(i===null)throw Error(r(311));i.lastRenderedReducer=e;var n=Ce,a=n.baseQueue,o=i.pending;if(o!==null){if(a!==null){var s=a.next;a.next=o.next,o.next=s}n.baseQueue=a=o,i.pending=null}if(a!==null){o=a.next,n=n.baseState;var u=s=null,d=null,g=o;do{var x=g.lane;if((si&x)===x)d!==null&&(d=d.next={lane:0,action:g.action,hasEagerState:g.hasEagerState,eagerState:g.eagerState,next:null}),n=g.hasEagerState?g.eagerState:e(n,g.action);else{var S={lane:x,action:g.action,hasEagerState:g.hasEagerState,eagerState:g.eagerState,next:null};d===null?(u=d=S,s=n):d=d.next=S,he.lanes|=x,ri|=x}g=g.next}while(g!==null&&g!==o);d===null?s=n:d.next=u,pt(n,t.memoizedState)||(Ve=!0),t.memoizedState=n,t.baseState=s,t.baseQueue=d,i.lastRenderedState=n}if(e=i.interleaved,e!==null){a=e;do o=a.lane,he.lanes|=o,ri|=o,a=a.next;while(a!==e)}else a===null&&(i.lanes=0);return[t.memoizedState,i.dispatch]}function ts(e){var t=rt(),i=t.queue;if(i===null)throw Error(r(311));i.lastRenderedReducer=e;var n=i.dispatch,a=i.pending,o=t.memoizedState;if(a!==null){i.pending=null;var s=a=a.next;do o=e(o,s.action),s=s.next;while(s!==a);pt(o,t.memoizedState)||(Ve=!0),t.memoizedState=o,t.baseQueue===null&&(t.baseState=o),i.lastRenderedState=o}return[o,n]}function Tl(){}function Al(e,t){var i=he,n=rt(),a=t(),o=!pt(n.memoizedState,a);if(o&&(n.memoizedState=a,Ve=!0),n=n.queue,is(Ql.bind(null,i,n,e),[e]),n.getSnapshot!==t||o||ke!==null&&ke.memoizedState.tag&1){if(i.flags|=2048,vn(9,Ol.bind(null,i,n,a,t),void 0,null),Re===null)throw Error(r(349));(si&30)!==0||Pl(i,t,a)}return a}function Pl(e,t,i){e.flags|=16384,e={getSnapshot:t,value:i},t=he.updateQueue,t===null?(t={lastEffect:null,stores:null},he.updateQueue=t,t.stores=[e]):(i=t.stores,i===null?t.stores=[e]:i.push(e))}function Ol(e,t,i,n){t.value=i,t.getSnapshot=n,Fl(t)&&Bl(e)}function Ql(e,t,i){return i(function(){Fl(t)&&Bl(e)})}function Fl(e){var t=e.getSnapshot;e=e.value;try{var i=t();return!pt(e,i)}catch{return!0}}function Bl(e){var t=Rt(e,1);t!==null&&_t(t,e,1,-1)}function Dl(e){var t=qt();return typeof e=="function"&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:bn,lastRenderedState:e},t.queue=e,e=e.dispatch=Dd.bind(null,he,e),[t.memoizedState,e]}function vn(e,t,i,n){return e={tag:e,create:t,destroy:i,deps:n,next:null},t=he.updateQueue,t===null?(t={lastEffect:null,stores:null},he.updateQueue=t,t.lastEffect=e.next=e):(i=t.lastEffect,i===null?t.lastEffect=e.next=e:(n=i.next,i.next=e,e.next=n,t.lastEffect=e)),e}function El(){return rt().memoizedState}function ha(e,t,i,n){var a=qt();he.flags|=e,a.memoizedState=vn(1|t,i,void 0,n===void 0?null:n)}function fa(e,t,i,n){var a=rt();n=n===void 0?null:n;var o=void 0;if(Ce!==null){var s=Ce.memoizedState;if(o=s.destroy,n!==null&&Yo(n,s.deps)){a.memoizedState=vn(t,i,o,n);return}}he.flags|=e,a.memoizedState=vn(1|t,i,o,n)}function Ll(e,t){return ha(8390656,8,e,t)}function is(e,t){return fa(2048,8,e,t)}function Nl(e,t){return fa(4,2,e,t)}function zl(e,t){return fa(4,4,e,t)}function Ul(e,t){if(typeof t=="function")return e=e(),t(e),function(){t(null)};if(t!=null)return e=e(),t.current=e,function(){t.current=null}}function Gl(e,t,i){return i=i!=null?i.concat([e]):null,fa(4,4,Ul.bind(null,t,e),i)}function ns(){}function jl(e,t){var i=rt();t=t===void 0?null:t;var n=i.memoizedState;return n!==null&&t!==null&&Yo(t,n[1])?n[0]:(i.memoizedState=[e,t],e)}function Wl(e,t){var i=rt();t=t===void 0?null:t;var n=i.memoizedState;return n!==null&&t!==null&&Yo(t,n[1])?n[0]:(e=e(),i.memoizedState=[e,t],e)}function Vl(e,t,i){return(si&21)===0?(e.baseState&&(e.baseState=!1,Ve=!0),e.memoizedState=i):(pt(i,t)||(i=wr(),he.lanes|=i,ri|=i,e.baseState=!0),t)}function Fd(e,t){var i=ne;ne=i!==0&&4>i?i:4,e(!0);var n=$o.transition;$o.transition={};try{e(!1),t()}finally{ne=i,$o.transition=n}}function Xl(){return rt().memoizedState}function Bd(e,t,i){var n=Ht(e);if(i={lane:n,action:i,hasEagerState:!1,eagerState:null,next:null},Hl(e))Zl(t,i);else if(i=Il(e,t,i,n),i!==null){var a=ze();_t(i,e,n,a),$l(i,t,n)}}function Dd(e,t,i){var n=Ht(e),a={lane:n,action:i,hasEagerState:!1,eagerState:null,next:null};if(Hl(e))Zl(t,a);else{var o=e.alternate;if(e.lanes===0&&(o===null||o.lanes===0)&&(o=t.lastRenderedReducer,o!==null))try{var s=t.lastRenderedState,u=o(s,i);if(a.hasEagerState=!0,a.eagerState=u,pt(u,s)){var d=t.interleaved;d===null?(a.next=a,jo(t)):(a.next=d.next,d.next=a),t.interleaved=a;return}}catch{}finally{}i=Il(e,t,a,n),i!==null&&(a=ze(),_t(i,e,n,a),$l(i,t,n))}}function Hl(e){var t=e.alternate;return e===he||t!==null&&t===he}function Zl(e,t){_n=ma=!0;var i=e.pending;i===null?t.next=t:(t.next=i.next,i.next=t),e.pending=t}function $l(e,t,i){if((i&4194240)!==0){var n=t.lanes;n&=e.pendingLanes,i|=n,t.lanes=i,ao(e,i)}}var ga={readContext:st,useCallback:Be,useContext:Be,useEffect:Be,useImperativeHandle:Be,useInsertionEffect:Be,useLayoutEffect:Be,useMemo:Be,useReducer:Be,useRef:Be,useState:Be,useDebugValue:Be,useDeferredValue:Be,useTransition:Be,useMutableSource:Be,useSyncExternalStore:Be,useId:Be,unstable_isNewReconciler:!1},Ed={readContext:st,useCallback:function(e,t){return qt().memoizedState=[e,t===void 0?null:t],e},useContext:st,useEffect:Ll,useImperativeHandle:function(e,t,i){return i=i!=null?i.concat([e]):null,ha(4194308,4,Ul.bind(null,t,e),i)},useLayoutEffect:function(e,t){return ha(4194308,4,e,t)},useInsertionEffect:function(e,t){return ha(4,2,e,t)},useMemo:function(e,t){var i=qt();return t=t===void 0?null:t,e=e(),i.memoizedState=[e,t],e},useReducer:function(e,t,i){var n=qt();return t=i!==void 0?i(t):t,n.memoizedState=n.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},n.queue=e,e=e.dispatch=Bd.bind(null,he,e),[n.memoizedState,e]},useRef:function(e){var t=qt();return e={current:e},t.memoizedState=e},useState:Dl,useDebugValue:ns,useDeferredValue:function(e){return qt().memoizedState=e},useTransition:function(){var e=Dl(!1),t=e[0];return e=Fd.bind(null,e[1]),qt().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,i){var n=he,a=qt();if(de){if(i===void 0)throw Error(r(407));i=i()}else{if(i=t(),Re===null)throw Error(r(349));(si&30)!==0||Pl(n,t,i)}a.memoizedState=i;var o={value:i,getSnapshot:t};return a.queue=o,Ll(Ql.bind(null,n,o,e),[e]),n.flags|=2048,vn(9,Ol.bind(null,n,o,i,t),void 0,null),i},useId:function(){var e=qt(),t=Re.identifierPrefix;if(de){var i=kt,n=St;i=(n&~(1<<32-dt(n)-1)).toString(32)+i,t=":"+t+"R"+i,i=yn++,0<i&&(t+="H"+i.toString(32)),t+=":"}else i=Qd++,t=":"+t+"r"+i.toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},Ld={readContext:st,useCallback:jl,useContext:st,useEffect:is,useImperativeHandle:Gl,useInsertionEffect:Nl,useLayoutEffect:zl,useMemo:Wl,useReducer:es,useRef:El,useState:function(){return es(bn)},useDebugValue:ns,useDeferredValue:function(e){var t=rt();return Vl(t,Ce.memoizedState,e)},useTransition:function(){var e=es(bn)[0],t=rt().memoizedState;return[e,t]},useMutableSource:Tl,useSyncExternalStore:Al,useId:Xl,unstable_isNewReconciler:!1},Nd={readContext:st,useCallback:jl,useContext:st,useEffect:is,useImperativeHandle:Gl,useInsertionEffect:Nl,useLayoutEffect:zl,useMemo:Wl,useReducer:ts,useRef:El,useState:function(){return ts(bn)},useDebugValue:ns,useDeferredValue:function(e){var t=rt();return Ce===null?t.memoizedState=e:Vl(t,Ce.memoizedState,e)},useTransition:function(){var e=ts(bn)[0],t=rt().memoizedState;return[e,t]},useMutableSource:Tl,useSyncExternalStore:Al,useId:Xl,unstable_isNewReconciler:!1};function ht(e,t){if(e&&e.defaultProps){t=B({},t),e=e.defaultProps;for(var i in e)t[i]===void 0&&(t[i]=e[i]);return t}return t}function as(e,t,i,n){t=e.memoizedState,i=i(n,t),i=i==null?t:B({},t,i),e.memoizedState=i,e.lanes===0&&(e.updateQueue.baseState=i)}var _a={isMounted:function(e){return(e=e._reactInternals)?Kt(e)===e:!1},enqueueSetState:function(e,t,i){e=e._reactInternals;var n=ze(),a=Ht(e),o=Mt(n,a);o.payload=t,i!=null&&(o.callback=i),t=jt(e,o,a),t!==null&&(_t(t,e,a,n),ua(t,e,a))},enqueueReplaceState:function(e,t,i){e=e._reactInternals;var n=ze(),a=Ht(e),o=Mt(n,a);o.tag=1,o.payload=t,i!=null&&(o.callback=i),t=jt(e,o,a),t!==null&&(_t(t,e,a,n),ua(t,e,a))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var i=ze(),n=Ht(e),a=Mt(i,n);a.tag=2,t!=null&&(a.callback=t),t=jt(e,a,n),t!==null&&(_t(t,e,n,i),ua(t,e,n))}};function Yl(e,t,i,n,a,o,s){return e=e.stateNode,typeof e.shouldComponentUpdate=="function"?e.shouldComponentUpdate(n,o,s):t.prototype&&t.prototype.isPureReactComponent?!sn(i,n)||!sn(a,o):!0}function Jl(e,t,i){var n=!1,a=zt,o=t.contextType;return typeof o=="object"&&o!==null?o=st(o):(a=We(t)?ti:Fe.current,n=t.contextTypes,o=(n=n!=null)?Si(e,a):zt),t=new t(i,o),e.memoizedState=t.state!==null&&t.state!==void 0?t.state:null,t.updater=_a,e.stateNode=t,t._reactInternals=e,n&&(e=e.stateNode,e.__reactInternalMemoizedUnmaskedChildContext=a,e.__reactInternalMemoizedMaskedChildContext=o),t}function Kl(e,t,i,n){e=t.state,typeof t.componentWillReceiveProps=="function"&&t.componentWillReceiveProps(i,n),typeof t.UNSAFE_componentWillReceiveProps=="function"&&t.UNSAFE_componentWillReceiveProps(i,n),t.state!==e&&_a.enqueueReplaceState(t,t.state,null)}function os(e,t,i,n){var a=e.stateNode;a.props=i,a.state=e.memoizedState,a.refs={},Wo(e);var o=t.contextType;typeof o=="object"&&o!==null?a.context=st(o):(o=We(t)?ti:Fe.current,a.context=Si(e,o)),a.state=e.memoizedState,o=t.getDerivedStateFromProps,typeof o=="function"&&(as(e,t,o,i),a.state=e.memoizedState),typeof t.getDerivedStateFromProps=="function"||typeof a.getSnapshotBeforeUpdate=="function"||typeof a.UNSAFE_componentWillMount!="function"&&typeof a.componentWillMount!="function"||(t=a.state,typeof a.componentWillMount=="function"&&a.componentWillMount(),typeof a.UNSAFE_componentWillMount=="function"&&a.UNSAFE_componentWillMount(),t!==a.state&&_a.enqueueReplaceState(a,a.state,null),ca(e,i,a,n),a.state=e.memoizedState),typeof a.componentDidMount=="function"&&(e.flags|=4194308)}function Qi(e,t){try{var i="",n=t;do i+=K(n),n=n.return;while(n);var a=i}catch(o){a=`
Error generating stack: `+o.message+`
`+o.stack}return{value:e,source:t,stack:a,digest:null}}function ss(e,t,i){return{value:e,source:null,stack:i??null,digest:t??null}}function rs(e,t){try{console.error(t.value)}catch(i){setTimeout(function(){throw i})}}var zd=typeof WeakMap=="function"?WeakMap:Map;function eu(e,t,i){i=Mt(-1,i),i.tag=3,i.payload={element:null};var n=t.value;return i.callback=function(){xa||(xa=!0,ws=n),rs(e,t)},i}function tu(e,t,i){i=Mt(-1,i),i.tag=3;var n=e.type.getDerivedStateFromError;if(typeof n=="function"){var a=t.value;i.payload=function(){return n(a)},i.callback=function(){rs(e,t)}}var o=e.stateNode;return o!==null&&typeof o.componentDidCatch=="function"&&(i.callback=function(){rs(e,t),typeof n!="function"&&(Vt===null?Vt=new Set([this]):Vt.add(this));var s=t.stack;this.componentDidCatch(t.value,{componentStack:s!==null?s:""})}),i}function iu(e,t,i){var n=e.pingCache;if(n===null){n=e.pingCache=new zd;var a=new Set;n.set(t,a)}else a=n.get(t),a===void 0&&(a=new Set,n.set(t,a));a.has(i)||(a.add(i),e=tp.bind(null,e,t,i),t.then(e,e))}function nu(e){do{var t;if((t=e.tag===13)&&(t=e.memoizedState,t=t!==null?t.dehydrated!==null:!0),t)return e;e=e.return}while(e!==null);return null}function au(e,t,i,n,a){return(e.mode&1)===0?(e===t?e.flags|=65536:(e.flags|=128,i.flags|=131072,i.flags&=-52805,i.tag===1&&(i.alternate===null?i.tag=17:(t=Mt(-1,1),t.tag=2,jt(i,t,1))),i.lanes|=1),e):(e.flags|=65536,e.lanes=a,e)}var Ud=ue.ReactCurrentOwner,Ve=!1;function Ne(e,t,i,n){t.child=e===null?xl(t,null,i,n):Ti(t,e.child,i,n)}function ou(e,t,i,n,a){i=i.render;var o=t.ref;return Pi(t,a),n=Jo(e,t,i,n,o,a),i=Ko(),e!==null&&!Ve?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~a,Tt(e,t,a)):(de&&i&&Fo(t),t.flags|=1,Ne(e,t,n,a),t.child)}function su(e,t,i,n,a){if(e===null){var o=i.type;return typeof o=="function"&&!Ms(o)&&o.defaultProps===void 0&&i.compare===null&&i.defaultProps===void 0?(t.tag=15,t.type=o,ru(e,t,o,n,a)):(e=Ta(i.type,null,n,t,t.mode,a),e.ref=t.ref,e.return=t,t.child=e)}if(o=e.child,(e.lanes&a)===0){var s=o.memoizedProps;if(i=i.compare,i=i!==null?i:sn,i(s,n)&&e.ref===t.ref)return Tt(e,t,a)}return t.flags|=1,e=$t(o,n),e.ref=t.ref,e.return=t,t.child=e}function ru(e,t,i,n,a){if(e!==null){var o=e.memoizedProps;if(sn(o,n)&&e.ref===t.ref)if(Ve=!1,t.pendingProps=n=o,(e.lanes&a)!==0)(e.flags&131072)!==0&&(Ve=!0);else return t.lanes=e.lanes,Tt(e,t,a)}return ls(e,t,i,n,a)}function lu(e,t,i){var n=t.pendingProps,a=n.children,o=e!==null?e.memoizedState:null;if(n.mode==="hidden")if((t.mode&1)===0)t.memoizedState={baseLanes:0,cachePool:null,transitions:null},se(Bi,tt),tt|=i;else{if((i&1073741824)===0)return e=o!==null?o.baseLanes|i:i,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,se(Bi,tt),tt|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},n=o!==null?o.baseLanes:i,se(Bi,tt),tt|=n}else o!==null?(n=o.baseLanes|i,t.memoizedState=null):n=i,se(Bi,tt),tt|=n;return Ne(e,t,a,i),t.child}function uu(e,t){var i=t.ref;(e===null&&i!==null||e!==null&&e.ref!==i)&&(t.flags|=512,t.flags|=2097152)}function ls(e,t,i,n,a){var o=We(i)?ti:Fe.current;return o=Si(t,o),Pi(t,a),i=Jo(e,t,i,n,o,a),n=Ko(),e!==null&&!Ve?(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~a,Tt(e,t,a)):(de&&n&&Fo(t),t.flags|=1,Ne(e,t,i,a),t.child)}function cu(e,t,i,n,a){if(We(i)){var o=!0;ta(t)}else o=!1;if(Pi(t,a),t.stateNode===null)ba(e,t),Jl(t,i,n),os(t,i,n,a),n=!0;else if(e===null){var s=t.stateNode,u=t.memoizedProps;s.props=u;var d=s.context,g=i.contextType;typeof g=="object"&&g!==null?g=st(g):(g=We(i)?ti:Fe.current,g=Si(t,g));var x=i.getDerivedStateFromProps,S=typeof x=="function"||typeof s.getSnapshotBeforeUpdate=="function";S||typeof s.UNSAFE_componentWillReceiveProps!="function"&&typeof s.componentWillReceiveProps!="function"||(u!==n||d!==g)&&Kl(t,s,n,g),Gt=!1;var w=t.memoizedState;s.state=w,ca(t,n,s,a),d=t.memoizedState,u!==n||w!==d||je.current||Gt?(typeof x=="function"&&(as(t,i,x,n),d=t.memoizedState),(u=Gt||Yl(t,i,u,n,w,d,g))?(S||typeof s.UNSAFE_componentWillMount!="function"&&typeof s.componentWillMount!="function"||(typeof s.componentWillMount=="function"&&s.componentWillMount(),typeof s.UNSAFE_componentWillMount=="function"&&s.UNSAFE_componentWillMount()),typeof s.componentDidMount=="function"&&(t.flags|=4194308)):(typeof s.componentDidMount=="function"&&(t.flags|=4194308),t.memoizedProps=n,t.memoizedState=d),s.props=n,s.state=d,s.context=g,n=u):(typeof s.componentDidMount=="function"&&(t.flags|=4194308),n=!1)}else{s=t.stateNode,Sl(e,t),u=t.memoizedProps,g=t.type===t.elementType?u:ht(t.type,u),s.props=g,S=t.pendingProps,w=s.context,d=i.contextType,typeof d=="object"&&d!==null?d=st(d):(d=We(i)?ti:Fe.current,d=Si(t,d));var Q=i.getDerivedStateFromProps;(x=typeof Q=="function"||typeof s.getSnapshotBeforeUpdate=="function")||typeof s.UNSAFE_componentWillReceiveProps!="function"&&typeof s.componentWillReceiveProps!="function"||(u!==S||w!==d)&&Kl(t,s,n,d),Gt=!1,w=t.memoizedState,s.state=w,ca(t,n,s,a);var D=t.memoizedState;u!==S||w!==D||je.current||Gt?(typeof Q=="function"&&(as(t,i,Q,n),D=t.memoizedState),(g=Gt||Yl(t,i,g,n,w,D,d)||!1)?(x||typeof s.UNSAFE_componentWillUpdate!="function"&&typeof s.componentWillUpdate!="function"||(typeof s.componentWillUpdate=="function"&&s.componentWillUpdate(n,D,d),typeof s.UNSAFE_componentWillUpdate=="function"&&s.UNSAFE_componentWillUpdate(n,D,d)),typeof s.componentDidUpdate=="function"&&(t.flags|=4),typeof s.getSnapshotBeforeUpdate=="function"&&(t.flags|=1024)):(typeof s.componentDidUpdate!="function"||u===e.memoizedProps&&w===e.memoizedState||(t.flags|=4),typeof s.getSnapshotBeforeUpdate!="function"||u===e.memoizedProps&&w===e.memoizedState||(t.flags|=1024),t.memoizedProps=n,t.memoizedState=D),s.props=n,s.state=D,s.context=d,n=g):(typeof s.componentDidUpdate!="function"||u===e.memoizedProps&&w===e.memoizedState||(t.flags|=4),typeof s.getSnapshotBeforeUpdate!="function"||u===e.memoizedProps&&w===e.memoizedState||(t.flags|=1024),n=!1)}return us(e,t,i,n,o,a)}function us(e,t,i,n,a,o){uu(e,t);var s=(t.flags&128)!==0;if(!n&&!s)return a&&fl(t,i,!1),Tt(e,t,o);n=t.stateNode,Ud.current=t;var u=s&&typeof i.getDerivedStateFromError!="function"?null:n.render();return t.flags|=1,e!==null&&s?(t.child=Ti(t,e.child,null,o),t.child=Ti(t,null,u,o)):Ne(e,t,u,o),t.memoizedState=n.state,a&&fl(t,i,!0),t.child}function du(e){var t=e.stateNode;t.pendingContext?ml(e,t.pendingContext,t.pendingContext!==t.context):t.context&&ml(e,t.context,!1),Vo(e,t.containerInfo)}function pu(e,t,i,n,a){return Mi(),Lo(a),t.flags|=256,Ne(e,t,i,n),t.child}var cs={dehydrated:null,treeContext:null,retryLane:0};function ds(e){return{baseLanes:e,cachePool:null,transitions:null}}function mu(e,t,i){var n=t.pendingProps,a=me.current,o=!1,s=(t.flags&128)!==0,u;if((u=s)||(u=e!==null&&e.memoizedState===null?!1:(a&2)!==0),u?(o=!0,t.flags&=-129):(e===null||e.memoizedState!==null)&&(a|=1),se(me,a&1),e===null)return Eo(t),e=t.memoizedState,e!==null&&(e=e.dehydrated,e!==null)?((t.mode&1)===0?t.lanes=1:e.data==="$!"?t.lanes=8:t.lanes=1073741824,null):(s=n.children,e=n.fallback,o?(n=t.mode,o=t.child,s={mode:"hidden",children:s},(n&1)===0&&o!==null?(o.childLanes=0,o.pendingProps=s):o=Aa(s,n,0,null),e=di(e,n,i,null),o.return=t,e.return=t,o.sibling=e,t.child=o,t.child.memoizedState=ds(i),t.memoizedState=cs,e):ps(t,s));if(a=e.memoizedState,a!==null&&(u=a.dehydrated,u!==null))return Gd(e,t,s,n,u,a,i);if(o){o=n.fallback,s=t.mode,a=e.child,u=a.sibling;var d={mode:"hidden",children:n.children};return(s&1)===0&&t.child!==a?(n=t.child,n.childLanes=0,n.pendingProps=d,t.deletions=null):(n=$t(a,d),n.subtreeFlags=a.subtreeFlags&14680064),u!==null?o=$t(u,o):(o=di(o,s,i,null),o.flags|=2),o.return=t,n.return=t,n.sibling=o,t.child=n,n=o,o=t.child,s=e.child.memoizedState,s=s===null?ds(i):{baseLanes:s.baseLanes|i,cachePool:null,transitions:s.transitions},o.memoizedState=s,o.childLanes=e.childLanes&~i,t.memoizedState=cs,n}return o=e.child,e=o.sibling,n=$t(o,{mode:"visible",children:n.children}),(t.mode&1)===0&&(n.lanes=i),n.return=t,n.sibling=null,e!==null&&(i=t.deletions,i===null?(t.deletions=[e],t.flags|=16):i.push(e)),t.child=n,t.memoizedState=null,n}function ps(e,t){return t=Aa({mode:"visible",children:t},e.mode,0,null),t.return=e,e.child=t}function ya(e,t,i,n){return n!==null&&Lo(n),Ti(t,e.child,null,i),e=ps(t,t.pendingProps.children),e.flags|=2,t.memoizedState=null,e}function Gd(e,t,i,n,a,o,s){if(i)return t.flags&256?(t.flags&=-257,n=ss(Error(r(422))),ya(e,t,s,n)):t.memoizedState!==null?(t.child=e.child,t.flags|=128,null):(o=n.fallback,a=t.mode,n=Aa({mode:"visible",children:n.children},a,0,null),o=di(o,a,s,null),o.flags|=2,n.return=t,o.return=t,n.sibling=o,t.child=n,(t.mode&1)!==0&&Ti(t,e.child,null,s),t.child.memoizedState=ds(s),t.memoizedState=cs,o);if((t.mode&1)===0)return ya(e,t,s,null);if(a.data==="$!"){if(n=a.nextSibling&&a.nextSibling.dataset,n)var u=n.dgst;return n=u,o=Error(r(419)),n=ss(o,n,void 0),ya(e,t,s,n)}if(u=(s&e.childLanes)!==0,Ve||u){if(n=Re,n!==null){switch(s&-s){case 4:a=2;break;case 16:a=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:a=32;break;case 536870912:a=268435456;break;default:a=0}a=(a&(n.suspendedLanes|s))!==0?0:a,a!==0&&a!==o.retryLane&&(o.retryLane=a,Rt(e,a),_t(n,e,a,-1))}return Rs(),n=ss(Error(r(421))),ya(e,t,s,n)}return a.data==="$?"?(t.flags|=128,t.child=e.child,t=ip.bind(null,e),a._reactRetry=t,null):(e=o.treeContext,et=Lt(a.nextSibling),Ke=t,de=!0,mt=null,e!==null&&(at[ot++]=St,at[ot++]=kt,at[ot++]=ii,St=e.id,kt=e.overflow,ii=t),t=ps(t,n.children),t.flags|=4096,t)}function hu(e,t,i){e.lanes|=t;var n=e.alternate;n!==null&&(n.lanes|=t),Go(e.return,t,i)}function ms(e,t,i,n,a){var o=e.memoizedState;o===null?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:n,tail:i,tailMode:a}:(o.isBackwards=t,o.rendering=null,o.renderingStartTime=0,o.last=n,o.tail=i,o.tailMode=a)}function fu(e,t,i){var n=t.pendingProps,a=n.revealOrder,o=n.tail;if(Ne(e,t,n.children,i),n=me.current,(n&2)!==0)n=n&1|2,t.flags|=128;else{if(e!==null&&(e.flags&128)!==0)e:for(e=t.child;e!==null;){if(e.tag===13)e.memoizedState!==null&&hu(e,i,t);else if(e.tag===19)hu(e,i,t);else if(e.child!==null){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;e.sibling===null;){if(e.return===null||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}n&=1}if(se(me,n),(t.mode&1)===0)t.memoizedState=null;else switch(a){case"forwards":for(i=t.child,a=null;i!==null;)e=i.alternate,e!==null&&da(e)===null&&(a=i),i=i.sibling;i=a,i===null?(a=t.child,t.child=null):(a=i.sibling,i.sibling=null),ms(t,!1,a,i,o);break;case"backwards":for(i=null,a=t.child,t.child=null;a!==null;){if(e=a.alternate,e!==null&&da(e)===null){t.child=a;break}e=a.sibling,a.sibling=i,i=a,a=e}ms(t,!0,i,null,o);break;case"together":ms(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function ba(e,t){(t.mode&1)===0&&e!==null&&(e.alternate=null,t.alternate=null,t.flags|=2)}function Tt(e,t,i){if(e!==null&&(t.dependencies=e.dependencies),ri|=t.lanes,(i&t.childLanes)===0)return null;if(e!==null&&t.child!==e.child)throw Error(r(153));if(t.child!==null){for(e=t.child,i=$t(e,e.pendingProps),t.child=i,i.return=t;e.sibling!==null;)e=e.sibling,i=i.sibling=$t(e,e.pendingProps),i.return=t;i.sibling=null}return t.child}function jd(e,t,i){switch(t.tag){case 3:du(t),Mi();break;case 5:Ml(t);break;case 1:We(t.type)&&ta(t);break;case 4:Vo(t,t.stateNode.containerInfo);break;case 10:var n=t.type._context,a=t.memoizedProps.value;se(ra,n._currentValue),n._currentValue=a;break;case 13:if(n=t.memoizedState,n!==null)return n.dehydrated!==null?(se(me,me.current&1),t.flags|=128,null):(i&t.child.childLanes)!==0?mu(e,t,i):(se(me,me.current&1),e=Tt(e,t,i),e!==null?e.sibling:null);se(me,me.current&1);break;case 19:if(n=(i&t.childLanes)!==0,(e.flags&128)!==0){if(n)return fu(e,t,i);t.flags|=128}if(a=t.memoizedState,a!==null&&(a.rendering=null,a.tail=null,a.lastEffect=null),se(me,me.current),n)break;return null;case 22:case 23:return t.lanes=0,lu(e,t,i)}return Tt(e,t,i)}var gu,hs,_u,yu;gu=function(e,t){for(var i=t.child;i!==null;){if(i.tag===5||i.tag===6)e.appendChild(i.stateNode);else if(i.tag!==4&&i.child!==null){i.child.return=i,i=i.child;continue}if(i===t)break;for(;i.sibling===null;){if(i.return===null||i.return===t)return;i=i.return}i.sibling.return=i.return,i=i.sibling}},hs=function(){},_u=function(e,t,i,n){var a=e.memoizedProps;if(a!==n){e=t.stateNode,oi(vt.current);var o=null;switch(i){case"input":a=Ua(e,a),n=Ua(e,n),o=[];break;case"select":a=B({},a,{value:void 0}),n=B({},n,{value:void 0}),o=[];break;case"textarea":a=Wa(e,a),n=Wa(e,n),o=[];break;default:typeof a.onClick!="function"&&typeof n.onClick=="function"&&(e.onclick=Jn)}Xa(i,n);var s;i=null;for(g in a)if(!n.hasOwnProperty(g)&&a.hasOwnProperty(g)&&a[g]!=null)if(g==="style"){var u=a[g];for(s in u)u.hasOwnProperty(s)&&(i||(i={}),i[s]="")}else g!=="dangerouslySetInnerHTML"&&g!=="children"&&g!=="suppressContentEditableWarning"&&g!=="suppressHydrationWarning"&&g!=="autoFocus"&&(_.hasOwnProperty(g)?o||(o=[]):(o=o||[]).push(g,null));for(g in n){var d=n[g];if(u=a!=null?a[g]:void 0,n.hasOwnProperty(g)&&d!==u&&(d!=null||u!=null))if(g==="style")if(u){for(s in u)!u.hasOwnProperty(s)||d&&d.hasOwnProperty(s)||(i||(i={}),i[s]="");for(s in d)d.hasOwnProperty(s)&&u[s]!==d[s]&&(i||(i={}),i[s]=d[s])}else i||(o||(o=[]),o.push(g,i)),i=d;else g==="dangerouslySetInnerHTML"?(d=d?d.__html:void 0,u=u?u.__html:void 0,d!=null&&u!==d&&(o=o||[]).push(g,d)):g==="children"?typeof d!="string"&&typeof d!="number"||(o=o||[]).push(g,""+d):g!=="suppressContentEditableWarning"&&g!=="suppressHydrationWarning"&&(_.hasOwnProperty(g)?(d!=null&&g==="onScroll"&&re("scroll",e),o||u===d||(o=[])):(o=o||[]).push(g,d))}i&&(o=o||[]).push("style",i);var g=o;(t.updateQueue=g)&&(t.flags|=4)}},yu=function(e,t,i,n){i!==n&&(t.flags|=4)};function qn(e,t){if(!de)switch(e.tailMode){case"hidden":t=e.tail;for(var i=null;t!==null;)t.alternate!==null&&(i=t),t=t.sibling;i===null?e.tail=null:i.sibling=null;break;case"collapsed":i=e.tail;for(var n=null;i!==null;)i.alternate!==null&&(n=i),i=i.sibling;n===null?t||e.tail===null?e.tail=null:e.tail.sibling=null:n.sibling=null}}function De(e){var t=e.alternate!==null&&e.alternate.child===e.child,i=0,n=0;if(t)for(var a=e.child;a!==null;)i|=a.lanes|a.childLanes,n|=a.subtreeFlags&14680064,n|=a.flags&14680064,a.return=e,a=a.sibling;else for(a=e.child;a!==null;)i|=a.lanes|a.childLanes,n|=a.subtreeFlags,n|=a.flags,a.return=e,a=a.sibling;return e.subtreeFlags|=n,e.childLanes=i,t}function Wd(e,t,i){var n=t.pendingProps;switch(Bo(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return De(t),null;case 1:return We(t.type)&&ea(),De(t),null;case 3:return n=t.stateNode,Oi(),le(je),le(Fe),Zo(),n.pendingContext&&(n.context=n.pendingContext,n.pendingContext=null),(e===null||e.child===null)&&(oa(t)?t.flags|=4:e===null||e.memoizedState.isDehydrated&&(t.flags&256)===0||(t.flags|=1024,mt!==null&&(Is(mt),mt=null))),hs(e,t),De(t),null;case 5:Xo(t);var a=oi(gn.current);if(i=t.type,e!==null&&t.stateNode!=null)_u(e,t,i,n,a),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!n){if(t.stateNode===null)throw Error(r(166));return De(t),null}if(e=oi(vt.current),oa(t)){n=t.stateNode,i=t.type;var o=t.memoizedProps;switch(n[bt]=t,n[dn]=o,e=(t.mode&1)!==0,i){case"dialog":re("cancel",n),re("close",n);break;case"iframe":case"object":case"embed":re("load",n);break;case"video":case"audio":for(a=0;a<ln.length;a++)re(ln[a],n);break;case"source":re("error",n);break;case"img":case"image":case"link":re("error",n),re("load",n);break;case"details":re("toggle",n);break;case"input":Js(n,o),re("invalid",n);break;case"select":n._wrapperState={wasMultiple:!!o.multiple},re("invalid",n);break;case"textarea":tr(n,o),re("invalid",n)}Xa(i,o),a=null;for(var s in o)if(o.hasOwnProperty(s)){var u=o[s];s==="children"?typeof u=="string"?n.textContent!==u&&(o.suppressHydrationWarning!==!0&&Yn(n.textContent,u,e),a=["children",u]):typeof u=="number"&&n.textContent!==""+u&&(o.suppressHydrationWarning!==!0&&Yn(n.textContent,u,e),a=["children",""+u]):_.hasOwnProperty(s)&&u!=null&&s==="onScroll"&&re("scroll",n)}switch(i){case"input":Rn(n),er(n,o,!0);break;case"textarea":Rn(n),nr(n);break;case"select":case"option":break;default:typeof o.onClick=="function"&&(n.onclick=Jn)}n=a,t.updateQueue=n,n!==null&&(t.flags|=4)}else{s=a.nodeType===9?a:a.ownerDocument,e==="http://www.w3.org/1999/xhtml"&&(e=ar(i)),e==="http://www.w3.org/1999/xhtml"?i==="script"?(e=s.createElement("div"),e.innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):typeof n.is=="string"?e=s.createElement(i,{is:n.is}):(e=s.createElement(i),i==="select"&&(s=e,n.multiple?s.multiple=!0:n.size&&(s.size=n.size))):e=s.createElementNS(e,i),e[bt]=t,e[dn]=n,gu(e,t,!1,!1),t.stateNode=e;e:{switch(s=Ha(i,n),i){case"dialog":re("cancel",e),re("close",e),a=n;break;case"iframe":case"object":case"embed":re("load",e),a=n;break;case"video":case"audio":for(a=0;a<ln.length;a++)re(ln[a],e);a=n;break;case"source":re("error",e),a=n;break;case"img":case"image":case"link":re("error",e),re("load",e),a=n;break;case"details":re("toggle",e),a=n;break;case"input":Js(e,n),a=Ua(e,n),re("invalid",e);break;case"option":a=n;break;case"select":e._wrapperState={wasMultiple:!!n.multiple},a=B({},n,{value:void 0}),re("invalid",e);break;case"textarea":tr(e,n),a=Wa(e,n),re("invalid",e);break;default:a=n}Xa(i,a),u=a;for(o in u)if(u.hasOwnProperty(o)){var d=u[o];o==="style"?rr(e,d):o==="dangerouslySetInnerHTML"?(d=d?d.__html:void 0,d!=null&&or(e,d)):o==="children"?typeof d=="string"?(i!=="textarea"||d!=="")&&Ui(e,d):typeof d=="number"&&Ui(e,""+d):o!=="suppressContentEditableWarning"&&o!=="suppressHydrationWarning"&&o!=="autoFocus"&&(_.hasOwnProperty(o)?d!=null&&o==="onScroll"&&re("scroll",e):d!=null&&Se(e,o,d,s))}switch(i){case"input":Rn(e),er(e,n,!1);break;case"textarea":Rn(e),nr(e);break;case"option":n.value!=null&&e.setAttribute("value",""+ie(n.value));break;case"select":e.multiple=!!n.multiple,o=n.value,o!=null?hi(e,!!n.multiple,o,!1):n.defaultValue!=null&&hi(e,!!n.multiple,n.defaultValue,!0);break;default:typeof a.onClick=="function"&&(e.onclick=Jn)}switch(i){case"button":case"input":case"select":case"textarea":n=!!n.autoFocus;break e;case"img":n=!0;break e;default:n=!1}}n&&(t.flags|=4)}t.ref!==null&&(t.flags|=512,t.flags|=2097152)}return De(t),null;case 6:if(e&&t.stateNode!=null)yu(e,t,e.memoizedProps,n);else{if(typeof n!="string"&&t.stateNode===null)throw Error(r(166));if(i=oi(gn.current),oi(vt.current),oa(t)){if(n=t.stateNode,i=t.memoizedProps,n[bt]=t,(o=n.nodeValue!==i)&&(e=Ke,e!==null))switch(e.tag){case 3:Yn(n.nodeValue,i,(e.mode&1)!==0);break;case 5:e.memoizedProps.suppressHydrationWarning!==!0&&Yn(n.nodeValue,i,(e.mode&1)!==0)}o&&(t.flags|=4)}else n=(i.nodeType===9?i:i.ownerDocument).createTextNode(n),n[bt]=t,t.stateNode=n}return De(t),null;case 13:if(le(me),n=t.memoizedState,e===null||e.memoizedState!==null&&e.memoizedState.dehydrated!==null){if(de&&et!==null&&(t.mode&1)!==0&&(t.flags&128)===0)ql(),Mi(),t.flags|=98560,o=!1;else if(o=oa(t),n!==null&&n.dehydrated!==null){if(e===null){if(!o)throw Error(r(318));if(o=t.memoizedState,o=o!==null?o.dehydrated:null,!o)throw Error(r(317));o[bt]=t}else Mi(),(t.flags&128)===0&&(t.memoizedState=null),t.flags|=4;De(t),o=!1}else mt!==null&&(Is(mt),mt=null),o=!0;if(!o)return t.flags&65536?t:null}return(t.flags&128)!==0?(t.lanes=i,t):(n=n!==null,n!==(e!==null&&e.memoizedState!==null)&&n&&(t.child.flags|=8192,(t.mode&1)!==0&&(e===null||(me.current&1)!==0?xe===0&&(xe=3):Rs())),t.updateQueue!==null&&(t.flags|=4),De(t),null);case 4:return Oi(),hs(e,t),e===null&&un(t.stateNode.containerInfo),De(t),null;case 10:return Uo(t.type._context),De(t),null;case 17:return We(t.type)&&ea(),De(t),null;case 19:if(le(me),o=t.memoizedState,o===null)return De(t),null;if(n=(t.flags&128)!==0,s=o.rendering,s===null)if(n)qn(o,!1);else{if(xe!==0||e!==null&&(e.flags&128)!==0)for(e=t.child;e!==null;){if(s=da(e),s!==null){for(t.flags|=128,qn(o,!1),n=s.updateQueue,n!==null&&(t.updateQueue=n,t.flags|=4),t.subtreeFlags=0,n=i,i=t.child;i!==null;)o=i,e=n,o.flags&=14680066,s=o.alternate,s===null?(o.childLanes=0,o.lanes=e,o.child=null,o.subtreeFlags=0,o.memoizedProps=null,o.memoizedState=null,o.updateQueue=null,o.dependencies=null,o.stateNode=null):(o.childLanes=s.childLanes,o.lanes=s.lanes,o.child=s.child,o.subtreeFlags=0,o.deletions=null,o.memoizedProps=s.memoizedProps,o.memoizedState=s.memoizedState,o.updateQueue=s.updateQueue,o.type=s.type,e=s.dependencies,o.dependencies=e===null?null:{lanes:e.lanes,firstContext:e.firstContext}),i=i.sibling;return se(me,me.current&1|2),t.child}e=e.sibling}o.tail!==null&&ye()>Di&&(t.flags|=128,n=!0,qn(o,!1),t.lanes=4194304)}else{if(!n)if(e=da(s),e!==null){if(t.flags|=128,n=!0,i=e.updateQueue,i!==null&&(t.updateQueue=i,t.flags|=4),qn(o,!0),o.tail===null&&o.tailMode==="hidden"&&!s.alternate&&!de)return De(t),null}else 2*ye()-o.renderingStartTime>Di&&i!==1073741824&&(t.flags|=128,n=!0,qn(o,!1),t.lanes=4194304);o.isBackwards?(s.sibling=t.child,t.child=s):(i=o.last,i!==null?i.sibling=s:t.child=s,o.last=s)}return o.tail!==null?(t=o.tail,o.rendering=t,o.tail=t.sibling,o.renderingStartTime=ye(),t.sibling=null,i=me.current,se(me,n?i&1|2:i&1),t):(De(t),null);case 22:case 23:return ks(),n=t.memoizedState!==null,e!==null&&e.memoizedState!==null!==n&&(t.flags|=8192),n&&(t.mode&1)!==0?(tt&1073741824)!==0&&(De(t),t.subtreeFlags&6&&(t.flags|=8192)):De(t),null;case 24:return null;case 25:return null}throw Error(r(156,t.tag))}function Vd(e,t){switch(Bo(t),t.tag){case 1:return We(t.type)&&ea(),e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 3:return Oi(),le(je),le(Fe),Zo(),e=t.flags,(e&65536)!==0&&(e&128)===0?(t.flags=e&-65537|128,t):null;case 5:return Xo(t),null;case 13:if(le(me),e=t.memoizedState,e!==null&&e.dehydrated!==null){if(t.alternate===null)throw Error(r(340));Mi()}return e=t.flags,e&65536?(t.flags=e&-65537|128,t):null;case 19:return le(me),null;case 4:return Oi(),null;case 10:return Uo(t.type._context),null;case 22:case 23:return ks(),null;case 24:return null;default:return null}}var va=!1,Ee=!1,Xd=typeof WeakSet=="function"?WeakSet:Set,F=null;function Fi(e,t){var i=e.ref;if(i!==null)if(typeof i=="function")try{i(null)}catch(n){ge(e,t,n)}else i.current=null}function fs(e,t,i){try{i()}catch(n){ge(e,t,n)}}var bu=!1;function Hd(e,t){if(ko=Nn,e=Yr(),bo(e)){if("selectionStart"in e)var i={start:e.selectionStart,end:e.selectionEnd};else e:{i=(i=e.ownerDocument)&&i.defaultView||window;var n=i.getSelection&&i.getSelection();if(n&&n.rangeCount!==0){i=n.anchorNode;var a=n.anchorOffset,o=n.focusNode;n=n.focusOffset;try{i.nodeType,o.nodeType}catch{i=null;break e}var s=0,u=-1,d=-1,g=0,x=0,S=e,w=null;t:for(;;){for(var Q;S!==i||a!==0&&S.nodeType!==3||(u=s+a),S!==o||n!==0&&S.nodeType!==3||(d=s+n),S.nodeType===3&&(s+=S.nodeValue.length),(Q=S.firstChild)!==null;)w=S,S=Q;for(;;){if(S===e)break t;if(w===i&&++g===a&&(u=s),w===o&&++x===n&&(d=s),(Q=S.nextSibling)!==null)break;S=w,w=S.parentNode}S=Q}i=u===-1||d===-1?null:{start:u,end:d}}else i=null}i=i||{start:0,end:0}}else i=null;for(Ro={focusedElem:e,selectionRange:i},Nn=!1,F=t;F!==null;)if(t=F,e=t.child,(t.subtreeFlags&1028)!==0&&e!==null)e.return=t,F=e;else for(;F!==null;){t=F;try{var D=t.alternate;if((t.flags&1024)!==0)switch(t.tag){case 0:case 11:case 15:break;case 1:if(D!==null){var E=D.memoizedProps,be=D.memoizedState,h=t.stateNode,p=h.getSnapshotBeforeUpdate(t.elementType===t.type?E:ht(t.type,E),be);h.__reactInternalSnapshotBeforeUpdate=p}break;case 3:var f=t.stateNode.containerInfo;f.nodeType===1?f.textContent="":f.nodeType===9&&f.documentElement&&f.removeChild(f.documentElement);break;case 5:case 6:case 4:case 17:break;default:throw Error(r(163))}}catch(R){ge(t,t.return,R)}if(e=t.sibling,e!==null){e.return=t.return,F=e;break}F=t.return}return D=bu,bu=!1,D}function wn(e,t,i){var n=t.updateQueue;if(n=n!==null?n.lastEffect:null,n!==null){var a=n=n.next;do{if((a.tag&e)===e){var o=a.destroy;a.destroy=void 0,o!==void 0&&fs(t,i,o)}a=a.next}while(a!==n)}}function qa(e,t){if(t=t.updateQueue,t=t!==null?t.lastEffect:null,t!==null){var i=t=t.next;do{if((i.tag&e)===e){var n=i.create;i.destroy=n()}i=i.next}while(i!==t)}}function gs(e){var t=e.ref;if(t!==null){var i=e.stateNode;switch(e.tag){case 5:e=i;break;default:e=i}typeof t=="function"?t(e):t.current=e}}function vu(e){var t=e.alternate;t!==null&&(e.alternate=null,vu(t)),e.child=null,e.deletions=null,e.sibling=null,e.tag===5&&(t=e.stateNode,t!==null&&(delete t[bt],delete t[dn],delete t[Po],delete t[Td],delete t[Ad])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function qu(e){return e.tag===5||e.tag===3||e.tag===4}function wu(e){e:for(;;){for(;e.sibling===null;){if(e.return===null||qu(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;e.tag!==5&&e.tag!==6&&e.tag!==18;){if(e.flags&2||e.child===null||e.tag===4)continue e;e.child.return=e,e=e.child}if(!(e.flags&2))return e.stateNode}}function _s(e,t,i){var n=e.tag;if(n===5||n===6)e=e.stateNode,t?i.nodeType===8?i.parentNode.insertBefore(e,t):i.insertBefore(e,t):(i.nodeType===8?(t=i.parentNode,t.insertBefore(e,i)):(t=i,t.appendChild(e)),i=i._reactRootContainer,i!=null||t.onclick!==null||(t.onclick=Jn));else if(n!==4&&(e=e.child,e!==null))for(_s(e,t,i),e=e.sibling;e!==null;)_s(e,t,i),e=e.sibling}function ys(e,t,i){var n=e.tag;if(n===5||n===6)e=e.stateNode,t?i.insertBefore(e,t):i.appendChild(e);else if(n!==4&&(e=e.child,e!==null))for(ys(e,t,i),e=e.sibling;e!==null;)ys(e,t,i),e=e.sibling}var Oe=null,ft=!1;function Wt(e,t,i){for(i=i.child;i!==null;)Cu(e,t,i),i=i.sibling}function Cu(e,t,i){if(yt&&typeof yt.onCommitFiberUnmount=="function")try{yt.onCommitFiberUnmount(Qn,i)}catch{}switch(i.tag){case 5:Ee||Fi(i,t);case 6:var n=Oe,a=ft;Oe=null,Wt(e,t,i),Oe=n,ft=a,Oe!==null&&(ft?(e=Oe,i=i.stateNode,e.nodeType===8?e.parentNode.removeChild(i):e.removeChild(i)):Oe.removeChild(i.stateNode));break;case 18:Oe!==null&&(ft?(e=Oe,i=i.stateNode,e.nodeType===8?Ao(e.parentNode,i):e.nodeType===1&&Ao(e,i),Ki(e)):Ao(Oe,i.stateNode));break;case 4:n=Oe,a=ft,Oe=i.stateNode.containerInfo,ft=!0,Wt(e,t,i),Oe=n,ft=a;break;case 0:case 11:case 14:case 15:if(!Ee&&(n=i.updateQueue,n!==null&&(n=n.lastEffect,n!==null))){a=n=n.next;do{var o=a,s=o.destroy;o=o.tag,s!==void 0&&((o&2)!==0||(o&4)!==0)&&fs(i,t,s),a=a.next}while(a!==n)}Wt(e,t,i);break;case 1:if(!Ee&&(Fi(i,t),n=i.stateNode,typeof n.componentWillUnmount=="function"))try{n.props=i.memoizedProps,n.state=i.memoizedState,n.componentWillUnmount()}catch(u){ge(i,t,u)}Wt(e,t,i);break;case 21:Wt(e,t,i);break;case 22:i.mode&1?(Ee=(n=Ee)||i.memoizedState!==null,Wt(e,t,i),Ee=n):Wt(e,t,i);break;default:Wt(e,t,i)}}function xu(e){var t=e.updateQueue;if(t!==null){e.updateQueue=null;var i=e.stateNode;i===null&&(i=e.stateNode=new Xd),t.forEach(function(n){var a=np.bind(null,e,n);i.has(n)||(i.add(n),n.then(a,a))})}}function gt(e,t){var i=t.deletions;if(i!==null)for(var n=0;n<i.length;n++){var a=i[n];try{var o=e,s=t,u=s;e:for(;u!==null;){switch(u.tag){case 5:Oe=u.stateNode,ft=!1;break e;case 3:Oe=u.stateNode.containerInfo,ft=!0;break e;case 4:Oe=u.stateNode.containerInfo,ft=!0;break e}u=u.return}if(Oe===null)throw Error(r(160));Cu(o,s,a),Oe=null,ft=!1;var d=a.alternate;d!==null&&(d.return=null),a.return=null}catch(g){ge(a,t,g)}}if(t.subtreeFlags&12854)for(t=t.child;t!==null;)Iu(t,e),t=t.sibling}function Iu(e,t){var i=e.alternate,n=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(gt(t,e),wt(e),n&4){try{wn(3,e,e.return),qa(3,e)}catch(E){ge(e,e.return,E)}try{wn(5,e,e.return)}catch(E){ge(e,e.return,E)}}break;case 1:gt(t,e),wt(e),n&512&&i!==null&&Fi(i,i.return);break;case 5:if(gt(t,e),wt(e),n&512&&i!==null&&Fi(i,i.return),e.flags&32){var a=e.stateNode;try{Ui(a,"")}catch(E){ge(e,e.return,E)}}if(n&4&&(a=e.stateNode,a!=null)){var o=e.memoizedProps,s=i!==null?i.memoizedProps:o,u=e.type,d=e.updateQueue;if(e.updateQueue=null,d!==null)try{u==="input"&&o.type==="radio"&&o.name!=null&&Ks(a,o),Ha(u,s);var g=Ha(u,o);for(s=0;s<d.length;s+=2){var x=d[s],S=d[s+1];x==="style"?rr(a,S):x==="dangerouslySetInnerHTML"?or(a,S):x==="children"?Ui(a,S):Se(a,x,S,g)}switch(u){case"input":Ga(a,o);break;case"textarea":ir(a,o);break;case"select":var w=a._wrapperState.wasMultiple;a._wrapperState.wasMultiple=!!o.multiple;var Q=o.value;Q!=null?hi(a,!!o.multiple,Q,!1):w!==!!o.multiple&&(o.defaultValue!=null?hi(a,!!o.multiple,o.defaultValue,!0):hi(a,!!o.multiple,o.multiple?[]:"",!1))}a[dn]=o}catch(E){ge(e,e.return,E)}}break;case 6:if(gt(t,e),wt(e),n&4){if(e.stateNode===null)throw Error(r(162));a=e.stateNode,o=e.memoizedProps;try{a.nodeValue=o}catch(E){ge(e,e.return,E)}}break;case 3:if(gt(t,e),wt(e),n&4&&i!==null&&i.memoizedState.isDehydrated)try{Ki(t.containerInfo)}catch(E){ge(e,e.return,E)}break;case 4:gt(t,e),wt(e);break;case 13:gt(t,e),wt(e),a=e.child,a.flags&8192&&(o=a.memoizedState!==null,a.stateNode.isHidden=o,!o||a.alternate!==null&&a.alternate.memoizedState!==null||(qs=ye())),n&4&&xu(e);break;case 22:if(x=i!==null&&i.memoizedState!==null,e.mode&1?(Ee=(g=Ee)||x,gt(t,e),Ee=g):gt(t,e),wt(e),n&8192){if(g=e.memoizedState!==null,(e.stateNode.isHidden=g)&&!x&&(e.mode&1)!==0)for(F=e,x=e.child;x!==null;){for(S=F=x;F!==null;){switch(w=F,Q=w.child,w.tag){case 0:case 11:case 14:case 15:wn(4,w,w.return);break;case 1:Fi(w,w.return);var D=w.stateNode;if(typeof D.componentWillUnmount=="function"){n=w,i=w.return;try{t=n,D.props=t.memoizedProps,D.state=t.memoizedState,D.componentWillUnmount()}catch(E){ge(n,i,E)}}break;case 5:Fi(w,w.return);break;case 22:if(w.memoizedState!==null){Ru(S);continue}}Q!==null?(Q.return=w,F=Q):Ru(S)}x=x.sibling}e:for(x=null,S=e;;){if(S.tag===5){if(x===null){x=S;try{a=S.stateNode,g?(o=a.style,typeof o.setProperty=="function"?o.setProperty("display","none","important"):o.display="none"):(u=S.stateNode,d=S.memoizedProps.style,s=d!=null&&d.hasOwnProperty("display")?d.display:null,u.style.display=sr("display",s))}catch(E){ge(e,e.return,E)}}}else if(S.tag===6){if(x===null)try{S.stateNode.nodeValue=g?"":S.memoizedProps}catch(E){ge(e,e.return,E)}}else if((S.tag!==22&&S.tag!==23||S.memoizedState===null||S===e)&&S.child!==null){S.child.return=S,S=S.child;continue}if(S===e)break e;for(;S.sibling===null;){if(S.return===null||S.return===e)break e;x===S&&(x=null),S=S.return}x===S&&(x=null),S.sibling.return=S.return,S=S.sibling}}break;case 19:gt(t,e),wt(e),n&4&&xu(e);break;case 21:break;default:gt(t,e),wt(e)}}function wt(e){var t=e.flags;if(t&2){try{e:{for(var i=e.return;i!==null;){if(qu(i)){var n=i;break e}i=i.return}throw Error(r(160))}switch(n.tag){case 5:var a=n.stateNode;n.flags&32&&(Ui(a,""),n.flags&=-33);var o=wu(e);ys(e,o,a);break;case 3:case 4:var s=n.stateNode.containerInfo,u=wu(e);_s(e,u,s);break;default:throw Error(r(161))}}catch(d){ge(e,e.return,d)}e.flags&=-3}t&4096&&(e.flags&=-4097)}function Zd(e,t,i){F=e,Su(e)}function Su(e,t,i){for(var n=(e.mode&1)!==0;F!==null;){var a=F,o=a.child;if(a.tag===22&&n){var s=a.memoizedState!==null||va;if(!s){var u=a.alternate,d=u!==null&&u.memoizedState!==null||Ee;u=va;var g=Ee;if(va=s,(Ee=d)&&!g)for(F=a;F!==null;)s=F,d=s.child,s.tag===22&&s.memoizedState!==null?Mu(a):d!==null?(d.return=s,F=d):Mu(a);for(;o!==null;)F=o,Su(o),o=o.sibling;F=a,va=u,Ee=g}ku(e)}else(a.subtreeFlags&8772)!==0&&o!==null?(o.return=a,F=o):ku(e)}}function ku(e){for(;F!==null;){var t=F;if((t.flags&8772)!==0){var i=t.alternate;try{if((t.flags&8772)!==0)switch(t.tag){case 0:case 11:case 15:Ee||qa(5,t);break;case 1:var n=t.stateNode;if(t.flags&4&&!Ee)if(i===null)n.componentDidMount();else{var a=t.elementType===t.type?i.memoizedProps:ht(t.type,i.memoizedProps);n.componentDidUpdate(a,i.memoizedState,n.__reactInternalSnapshotBeforeUpdate)}var o=t.updateQueue;o!==null&&Rl(t,o,n);break;case 3:var s=t.updateQueue;if(s!==null){if(i=null,t.child!==null)switch(t.child.tag){case 5:i=t.child.stateNode;break;case 1:i=t.child.stateNode}Rl(t,s,i)}break;case 5:var u=t.stateNode;if(i===null&&t.flags&4){i=u;var d=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":d.autoFocus&&i.focus();break;case"img":d.src&&(i.src=d.src)}}break;case 6:break;case 4:break;case 12:break;case 13:if(t.memoizedState===null){var g=t.alternate;if(g!==null){var x=g.memoizedState;if(x!==null){var S=x.dehydrated;S!==null&&Ki(S)}}}break;case 19:case 17:case 21:case 22:case 23:case 25:break;default:throw Error(r(163))}Ee||t.flags&512&&gs(t)}catch(w){ge(t,t.return,w)}}if(t===e){F=null;break}if(i=t.sibling,i!==null){i.return=t.return,F=i;break}F=t.return}}function Ru(e){for(;F!==null;){var t=F;if(t===e){F=null;break}var i=t.sibling;if(i!==null){i.return=t.return,F=i;break}F=t.return}}function Mu(e){for(;F!==null;){var t=F;try{switch(t.tag){case 0:case 11:case 15:var i=t.return;try{qa(4,t)}catch(d){ge(t,i,d)}break;case 1:var n=t.stateNode;if(typeof n.componentDidMount=="function"){var a=t.return;try{n.componentDidMount()}catch(d){ge(t,a,d)}}var o=t.return;try{gs(t)}catch(d){ge(t,o,d)}break;case 5:var s=t.return;try{gs(t)}catch(d){ge(t,s,d)}}}catch(d){ge(t,t.return,d)}if(t===e){F=null;break}var u=t.sibling;if(u!==null){u.return=t.return,F=u;break}F=t.return}}var $d=Math.ceil,wa=ue.ReactCurrentDispatcher,bs=ue.ReactCurrentOwner,lt=ue.ReactCurrentBatchConfig,J=0,Re=null,qe=null,Qe=0,tt=0,Bi=Nt(0),xe=0,Cn=null,ri=0,Ca=0,vs=0,xn=null,Xe=null,qs=0,Di=1/0,At=null,xa=!1,ws=null,Vt=null,Ia=!1,Xt=null,Sa=0,In=0,Cs=null,ka=-1,Ra=0;function ze(){return(J&6)!==0?ye():ka!==-1?ka:ka=ye()}function Ht(e){return(e.mode&1)===0?1:(J&2)!==0&&Qe!==0?Qe&-Qe:Od.transition!==null?(Ra===0&&(Ra=wr()),Ra):(e=ne,e!==0||(e=window.event,e=e===void 0?16:Ar(e.type)),e)}function _t(e,t,i,n){if(50<In)throw In=0,Cs=null,Error(r(185));Hi(e,i,n),((J&2)===0||e!==Re)&&(e===Re&&((J&2)===0&&(Ca|=i),xe===4&&Zt(e,Qe)),He(e,n),i===1&&J===0&&(t.mode&1)===0&&(Di=ye()+500,ia&&Ut()))}function He(e,t){var i=e.callbackNode;Oc(e,t);var n=Dn(e,e===Re?Qe:0);if(n===0)i!==null&&br(i),e.callbackNode=null,e.callbackPriority=0;else if(t=n&-n,e.callbackPriority!==t){if(i!=null&&br(i),t===1)e.tag===0?Pd(Au.bind(null,e)):gl(Au.bind(null,e)),Rd(function(){(J&6)===0&&Ut()}),i=null;else{switch(Cr(n)){case 1:i=to;break;case 4:i=vr;break;case 16:i=On;break;case 536870912:i=qr;break;default:i=On}i=Lu(i,Tu.bind(null,e))}e.callbackPriority=t,e.callbackNode=i}}function Tu(e,t){if(ka=-1,Ra=0,(J&6)!==0)throw Error(r(327));var i=e.callbackNode;if(Ei()&&e.callbackNode!==i)return null;var n=Dn(e,e===Re?Qe:0);if(n===0)return null;if((n&30)!==0||(n&e.expiredLanes)!==0||t)t=Ma(e,n);else{t=n;var a=J;J|=2;var o=Ou();(Re!==e||Qe!==t)&&(At=null,Di=ye()+500,ui(e,t));do try{Kd();break}catch(u){Pu(e,u)}while(!0);zo(),wa.current=o,J=a,qe!==null?t=0:(Re=null,Qe=0,t=xe)}if(t!==0){if(t===2&&(a=io(e),a!==0&&(n=a,t=xs(e,a))),t===1)throw i=Cn,ui(e,0),Zt(e,n),He(e,ye()),i;if(t===6)Zt(e,n);else{if(a=e.current.alternate,(n&30)===0&&!Yd(a)&&(t=Ma(e,n),t===2&&(o=io(e),o!==0&&(n=o,t=xs(e,o))),t===1))throw i=Cn,ui(e,0),Zt(e,n),He(e,ye()),i;switch(e.finishedWork=a,e.finishedLanes=n,t){case 0:case 1:throw Error(r(345));case 2:ci(e,Xe,At);break;case 3:if(Zt(e,n),(n&130023424)===n&&(t=qs+500-ye(),10<t)){if(Dn(e,0)!==0)break;if(a=e.suspendedLanes,(a&n)!==n){ze(),e.pingedLanes|=e.suspendedLanes&a;break}e.timeoutHandle=To(ci.bind(null,e,Xe,At),t);break}ci(e,Xe,At);break;case 4:if(Zt(e,n),(n&4194240)===n)break;for(t=e.eventTimes,a=-1;0<n;){var s=31-dt(n);o=1<<s,s=t[s],s>a&&(a=s),n&=~o}if(n=a,n=ye()-n,n=(120>n?120:480>n?480:1080>n?1080:1920>n?1920:3e3>n?3e3:4320>n?4320:1960*$d(n/1960))-n,10<n){e.timeoutHandle=To(ci.bind(null,e,Xe,At),n);break}ci(e,Xe,At);break;case 5:ci(e,Xe,At);break;default:throw Error(r(329))}}}return He(e,ye()),e.callbackNode===i?Tu.bind(null,e):null}function xs(e,t){var i=xn;return e.current.memoizedState.isDehydrated&&(ui(e,t).flags|=256),e=Ma(e,t),e!==2&&(t=Xe,Xe=i,t!==null&&Is(t)),e}function Is(e){Xe===null?Xe=e:Xe.push.apply(Xe,e)}function Yd(e){for(var t=e;;){if(t.flags&16384){var i=t.updateQueue;if(i!==null&&(i=i.stores,i!==null))for(var n=0;n<i.length;n++){var a=i[n],o=a.getSnapshot;a=a.value;try{if(!pt(o(),a))return!1}catch{return!1}}}if(i=t.child,t.subtreeFlags&16384&&i!==null)i.return=t,t=i;else{if(t===e)break;for(;t.sibling===null;){if(t.return===null||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}function Zt(e,t){for(t&=~vs,t&=~Ca,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var i=31-dt(t),n=1<<i;e[i]=-1,t&=~n}}function Au(e){if((J&6)!==0)throw Error(r(327));Ei();var t=Dn(e,0);if((t&1)===0)return He(e,ye()),null;var i=Ma(e,t);if(e.tag!==0&&i===2){var n=io(e);n!==0&&(t=n,i=xs(e,n))}if(i===1)throw i=Cn,ui(e,0),Zt(e,t),He(e,ye()),i;if(i===6)throw Error(r(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,ci(e,Xe,At),He(e,ye()),null}function Ss(e,t){var i=J;J|=1;try{return e(t)}finally{J=i,J===0&&(Di=ye()+500,ia&&Ut())}}function li(e){Xt!==null&&Xt.tag===0&&(J&6)===0&&Ei();var t=J;J|=1;var i=lt.transition,n=ne;try{if(lt.transition=null,ne=1,e)return e()}finally{ne=n,lt.transition=i,J=t,(J&6)===0&&Ut()}}function ks(){tt=Bi.current,le(Bi)}function ui(e,t){e.finishedWork=null,e.finishedLanes=0;var i=e.timeoutHandle;if(i!==-1&&(e.timeoutHandle=-1,kd(i)),qe!==null)for(i=qe.return;i!==null;){var n=i;switch(Bo(n),n.tag){case 1:n=n.type.childContextTypes,n!=null&&ea();break;case 3:Oi(),le(je),le(Fe),Zo();break;case 5:Xo(n);break;case 4:Oi();break;case 13:le(me);break;case 19:le(me);break;case 10:Uo(n.type._context);break;case 22:case 23:ks()}i=i.return}if(Re=e,qe=e=$t(e.current,null),Qe=tt=t,xe=0,Cn=null,vs=Ca=ri=0,Xe=xn=null,ai!==null){for(t=0;t<ai.length;t++)if(i=ai[t],n=i.interleaved,n!==null){i.interleaved=null;var a=n.next,o=i.pending;if(o!==null){var s=o.next;o.next=a,n.next=s}i.pending=n}ai=null}return e}function Pu(e,t){do{var i=qe;try{if(zo(),pa.current=ga,ma){for(var n=he.memoizedState;n!==null;){var a=n.queue;a!==null&&(a.pending=null),n=n.next}ma=!1}if(si=0,ke=Ce=he=null,_n=!1,yn=0,bs.current=null,i===null||i.return===null){xe=1,Cn=t,qe=null;break}e:{var o=e,s=i.return,u=i,d=t;if(t=Qe,u.flags|=32768,d!==null&&typeof d=="object"&&typeof d.then=="function"){var g=d,x=u,S=x.tag;if((x.mode&1)===0&&(S===0||S===11||S===15)){var w=x.alternate;w?(x.updateQueue=w.updateQueue,x.memoizedState=w.memoizedState,x.lanes=w.lanes):(x.updateQueue=null,x.memoizedState=null)}var Q=nu(s);if(Q!==null){Q.flags&=-257,au(Q,s,u,o,t),Q.mode&1&&iu(o,g,t),t=Q,d=g;var D=t.updateQueue;if(D===null){var E=new Set;E.add(d),t.updateQueue=E}else D.add(d);break e}else{if((t&1)===0){iu(o,g,t),Rs();break e}d=Error(r(426))}}else if(de&&u.mode&1){var be=nu(s);if(be!==null){(be.flags&65536)===0&&(be.flags|=256),au(be,s,u,o,t),Lo(Qi(d,u));break e}}o=d=Qi(d,u),xe!==4&&(xe=2),xn===null?xn=[o]:xn.push(o),o=s;do{switch(o.tag){case 3:o.flags|=65536,t&=-t,o.lanes|=t;var h=eu(o,d,t);kl(o,h);break e;case 1:u=d;var p=o.type,f=o.stateNode;if((o.flags&128)===0&&(typeof p.getDerivedStateFromError=="function"||f!==null&&typeof f.componentDidCatch=="function"&&(Vt===null||!Vt.has(f)))){o.flags|=65536,t&=-t,o.lanes|=t;var R=tu(o,u,t);kl(o,R);break e}}o=o.return}while(o!==null)}Fu(i)}catch(L){t=L,qe===i&&i!==null&&(qe=i=i.return);continue}break}while(!0)}function Ou(){var e=wa.current;return wa.current=ga,e===null?ga:e}function Rs(){(xe===0||xe===3||xe===2)&&(xe=4),Re===null||(ri&268435455)===0&&(Ca&268435455)===0||Zt(Re,Qe)}function Ma(e,t){var i=J;J|=2;var n=Ou();(Re!==e||Qe!==t)&&(At=null,ui(e,t));do try{Jd();break}catch(a){Pu(e,a)}while(!0);if(zo(),J=i,wa.current=n,qe!==null)throw Error(r(261));return Re=null,Qe=0,xe}function Jd(){for(;qe!==null;)Qu(qe)}function Kd(){for(;qe!==null&&!xc();)Qu(qe)}function Qu(e){var t=Eu(e.alternate,e,tt);e.memoizedProps=e.pendingProps,t===null?Fu(e):qe=t,bs.current=null}function Fu(e){var t=e;do{var i=t.alternate;if(e=t.return,(t.flags&32768)===0){if(i=Wd(i,t,tt),i!==null){qe=i;return}}else{if(i=Vd(i,t),i!==null){i.flags&=32767,qe=i;return}if(e!==null)e.flags|=32768,e.subtreeFlags=0,e.deletions=null;else{xe=6,qe=null;return}}if(t=t.sibling,t!==null){qe=t;return}qe=t=e}while(t!==null);xe===0&&(xe=5)}function ci(e,t,i){var n=ne,a=lt.transition;try{lt.transition=null,ne=1,ep(e,t,i,n)}finally{lt.transition=a,ne=n}return null}function ep(e,t,i,n){do Ei();while(Xt!==null);if((J&6)!==0)throw Error(r(327));i=e.finishedWork;var a=e.finishedLanes;if(i===null)return null;if(e.finishedWork=null,e.finishedLanes=0,i===e.current)throw Error(r(177));e.callbackNode=null,e.callbackPriority=0;var o=i.lanes|i.childLanes;if(Qc(e,o),e===Re&&(qe=Re=null,Qe=0),(i.subtreeFlags&2064)===0&&(i.flags&2064)===0||Ia||(Ia=!0,Lu(On,function(){return Ei(),null})),o=(i.flags&15990)!==0,(i.subtreeFlags&15990)!==0||o){o=lt.transition,lt.transition=null;var s=ne;ne=1;var u=J;J|=4,bs.current=null,Hd(e,i),Iu(i,e),vd(Ro),Nn=!!ko,Ro=ko=null,e.current=i,Zd(i),Ic(),J=u,ne=s,lt.transition=o}else e.current=i;if(Ia&&(Ia=!1,Xt=e,Sa=a),o=e.pendingLanes,o===0&&(Vt=null),Rc(i.stateNode),He(e,ye()),t!==null)for(n=e.onRecoverableError,i=0;i<t.length;i++)a=t[i],n(a.value,{componentStack:a.stack,digest:a.digest});if(xa)throw xa=!1,e=ws,ws=null,e;return(Sa&1)!==0&&e.tag!==0&&Ei(),o=e.pendingLanes,(o&1)!==0?e===Cs?In++:(In=0,Cs=e):In=0,Ut(),null}function Ei(){if(Xt!==null){var e=Cr(Sa),t=lt.transition,i=ne;try{if(lt.transition=null,ne=16>e?16:e,Xt===null)var n=!1;else{if(e=Xt,Xt=null,Sa=0,(J&6)!==0)throw Error(r(331));var a=J;for(J|=4,F=e.current;F!==null;){var o=F,s=o.child;if((F.flags&16)!==0){var u=o.deletions;if(u!==null){for(var d=0;d<u.length;d++){var g=u[d];for(F=g;F!==null;){var x=F;switch(x.tag){case 0:case 11:case 15:wn(8,x,o)}var S=x.child;if(S!==null)S.return=x,F=S;else for(;F!==null;){x=F;var w=x.sibling,Q=x.return;if(vu(x),x===g){F=null;break}if(w!==null){w.return=Q,F=w;break}F=Q}}}var D=o.alternate;if(D!==null){var E=D.child;if(E!==null){D.child=null;do{var be=E.sibling;E.sibling=null,E=be}while(E!==null)}}F=o}}if((o.subtreeFlags&2064)!==0&&s!==null)s.return=o,F=s;else e:for(;F!==null;){if(o=F,(o.flags&2048)!==0)switch(o.tag){case 0:case 11:case 15:wn(9,o,o.return)}var h=o.sibling;if(h!==null){h.return=o.return,F=h;break e}F=o.return}}var p=e.current;for(F=p;F!==null;){s=F;var f=s.child;if((s.subtreeFlags&2064)!==0&&f!==null)f.return=s,F=f;else e:for(s=p;F!==null;){if(u=F,(u.flags&2048)!==0)try{switch(u.tag){case 0:case 11:case 15:qa(9,u)}}catch(L){ge(u,u.return,L)}if(u===s){F=null;break e}var R=u.sibling;if(R!==null){R.return=u.return,F=R;break e}F=u.return}}if(J=a,Ut(),yt&&typeof yt.onPostCommitFiberRoot=="function")try{yt.onPostCommitFiberRoot(Qn,e)}catch{}n=!0}return n}finally{ne=i,lt.transition=t}}return!1}function Bu(e,t,i){t=Qi(i,t),t=eu(e,t,1),e=jt(e,t,1),t=ze(),e!==null&&(Hi(e,1,t),He(e,t))}function ge(e,t,i){if(e.tag===3)Bu(e,e,i);else for(;t!==null;){if(t.tag===3){Bu(t,e,i);break}else if(t.tag===1){var n=t.stateNode;if(typeof t.type.getDerivedStateFromError=="function"||typeof n.componentDidCatch=="function"&&(Vt===null||!Vt.has(n))){e=Qi(i,e),e=tu(t,e,1),t=jt(t,e,1),e=ze(),t!==null&&(Hi(t,1,e),He(t,e));break}}t=t.return}}function tp(e,t,i){var n=e.pingCache;n!==null&&n.delete(t),t=ze(),e.pingedLanes|=e.suspendedLanes&i,Re===e&&(Qe&i)===i&&(xe===4||xe===3&&(Qe&130023424)===Qe&&500>ye()-qs?ui(e,0):vs|=i),He(e,t)}function Du(e,t){t===0&&((e.mode&1)===0?t=1:(t=Bn,Bn<<=1,(Bn&130023424)===0&&(Bn=4194304)));var i=ze();e=Rt(e,t),e!==null&&(Hi(e,t,i),He(e,i))}function ip(e){var t=e.memoizedState,i=0;t!==null&&(i=t.retryLane),Du(e,i)}function np(e,t){var i=0;switch(e.tag){case 13:var n=e.stateNode,a=e.memoizedState;a!==null&&(i=a.retryLane);break;case 19:n=e.stateNode;break;default:throw Error(r(314))}n!==null&&n.delete(t),Du(e,i)}var Eu;Eu=function(e,t,i){if(e!==null)if(e.memoizedProps!==t.pendingProps||je.current)Ve=!0;else{if((e.lanes&i)===0&&(t.flags&128)===0)return Ve=!1,jd(e,t,i);Ve=(e.flags&131072)!==0}else Ve=!1,de&&(t.flags&1048576)!==0&&_l(t,aa,t.index);switch(t.lanes=0,t.tag){case 2:var n=t.type;ba(e,t),e=t.pendingProps;var a=Si(t,Fe.current);Pi(t,i),a=Jo(null,t,n,e,a,i);var o=Ko();return t.flags|=1,typeof a=="object"&&a!==null&&typeof a.render=="function"&&a.$$typeof===void 0?(t.tag=1,t.memoizedState=null,t.updateQueue=null,We(n)?(o=!0,ta(t)):o=!1,t.memoizedState=a.state!==null&&a.state!==void 0?a.state:null,Wo(t),a.updater=_a,t.stateNode=a,a._reactInternals=t,os(t,n,e,i),t=us(null,t,n,!0,o,i)):(t.tag=0,de&&o&&Fo(t),Ne(null,t,a,i),t=t.child),t;case 16:n=t.elementType;e:{switch(ba(e,t),e=t.pendingProps,a=n._init,n=a(n._payload),t.type=n,a=t.tag=op(n),e=ht(n,e),a){case 0:t=ls(null,t,n,e,i);break e;case 1:t=cu(null,t,n,e,i);break e;case 11:t=ou(null,t,n,e,i);break e;case 14:t=su(null,t,n,ht(n.type,e),i);break e}throw Error(r(306,n,""))}return t;case 0:return n=t.type,a=t.pendingProps,a=t.elementType===n?a:ht(n,a),ls(e,t,n,a,i);case 1:return n=t.type,a=t.pendingProps,a=t.elementType===n?a:ht(n,a),cu(e,t,n,a,i);case 3:e:{if(du(t),e===null)throw Error(r(387));n=t.pendingProps,o=t.memoizedState,a=o.element,Sl(e,t),ca(t,n,null,i);var s=t.memoizedState;if(n=s.element,o.isDehydrated)if(o={element:n,isDehydrated:!1,cache:s.cache,pendingSuspenseBoundaries:s.pendingSuspenseBoundaries,transitions:s.transitions},t.updateQueue.baseState=o,t.memoizedState=o,t.flags&256){a=Qi(Error(r(423)),t),t=pu(e,t,n,i,a);break e}else if(n!==a){a=Qi(Error(r(424)),t),t=pu(e,t,n,i,a);break e}else for(et=Lt(t.stateNode.containerInfo.firstChild),Ke=t,de=!0,mt=null,i=xl(t,null,n,i),t.child=i;i;)i.flags=i.flags&-3|4096,i=i.sibling;else{if(Mi(),n===a){t=Tt(e,t,i);break e}Ne(e,t,n,i)}t=t.child}return t;case 5:return Ml(t),e===null&&Eo(t),n=t.type,a=t.pendingProps,o=e!==null?e.memoizedProps:null,s=a.children,Mo(n,a)?s=null:o!==null&&Mo(n,o)&&(t.flags|=32),uu(e,t),Ne(e,t,s,i),t.child;case 6:return e===null&&Eo(t),null;case 13:return mu(e,t,i);case 4:return Vo(t,t.stateNode.containerInfo),n=t.pendingProps,e===null?t.child=Ti(t,null,n,i):Ne(e,t,n,i),t.child;case 11:return n=t.type,a=t.pendingProps,a=t.elementType===n?a:ht(n,a),ou(e,t,n,a,i);case 7:return Ne(e,t,t.pendingProps,i),t.child;case 8:return Ne(e,t,t.pendingProps.children,i),t.child;case 12:return Ne(e,t,t.pendingProps.children,i),t.child;case 10:e:{if(n=t.type._context,a=t.pendingProps,o=t.memoizedProps,s=a.value,se(ra,n._currentValue),n._currentValue=s,o!==null)if(pt(o.value,s)){if(o.children===a.children&&!je.current){t=Tt(e,t,i);break e}}else for(o=t.child,o!==null&&(o.return=t);o!==null;){var u=o.dependencies;if(u!==null){s=o.child;for(var d=u.firstContext;d!==null;){if(d.context===n){if(o.tag===1){d=Mt(-1,i&-i),d.tag=2;var g=o.updateQueue;if(g!==null){g=g.shared;var x=g.pending;x===null?d.next=d:(d.next=x.next,x.next=d),g.pending=d}}o.lanes|=i,d=o.alternate,d!==null&&(d.lanes|=i),Go(o.return,i,t),u.lanes|=i;break}d=d.next}}else if(o.tag===10)s=o.type===t.type?null:o.child;else if(o.tag===18){if(s=o.return,s===null)throw Error(r(341));s.lanes|=i,u=s.alternate,u!==null&&(u.lanes|=i),Go(s,i,t),s=o.sibling}else s=o.child;if(s!==null)s.return=o;else for(s=o;s!==null;){if(s===t){s=null;break}if(o=s.sibling,o!==null){o.return=s.return,s=o;break}s=s.return}o=s}Ne(e,t,a.children,i),t=t.child}return t;case 9:return a=t.type,n=t.pendingProps.children,Pi(t,i),a=st(a),n=n(a),t.flags|=1,Ne(e,t,n,i),t.child;case 14:return n=t.type,a=ht(n,t.pendingProps),a=ht(n.type,a),su(e,t,n,a,i);case 15:return ru(e,t,t.type,t.pendingProps,i);case 17:return n=t.type,a=t.pendingProps,a=t.elementType===n?a:ht(n,a),ba(e,t),t.tag=1,We(n)?(e=!0,ta(t)):e=!1,Pi(t,i),Jl(t,n,a),os(t,n,a,i),us(null,t,n,!0,e,i);case 19:return fu(e,t,i);case 22:return lu(e,t,i)}throw Error(r(156,t.tag))};function Lu(e,t){return yr(e,t)}function ap(e,t,i,n){this.tag=e,this.key=i,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=n,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function ut(e,t,i,n){return new ap(e,t,i,n)}function Ms(e){return e=e.prototype,!(!e||!e.isReactComponent)}function op(e){if(typeof e=="function")return Ms(e)?1:0;if(e!=null){if(e=e.$$typeof,e===Ae)return 11;if(e===Le)return 14}return 2}function $t(e,t){var i=e.alternate;return i===null?(i=ut(e.tag,t,e.key,e.mode),i.elementType=e.elementType,i.type=e.type,i.stateNode=e.stateNode,i.alternate=e,e.alternate=i):(i.pendingProps=t,i.type=e.type,i.flags=0,i.subtreeFlags=0,i.deletions=null),i.flags=e.flags&14680064,i.childLanes=e.childLanes,i.lanes=e.lanes,i.child=e.child,i.memoizedProps=e.memoizedProps,i.memoizedState=e.memoizedState,i.updateQueue=e.updateQueue,t=e.dependencies,i.dependencies=t===null?null:{lanes:t.lanes,firstContext:t.firstContext},i.sibling=e.sibling,i.index=e.index,i.ref=e.ref,i}function Ta(e,t,i,n,a,o){var s=2;if(n=e,typeof e=="function")Ms(e)&&(s=1);else if(typeof e=="string")s=5;else e:switch(e){case ae:return di(i.children,a,o,t);case _e:s=8,a|=8;break;case Te:return e=ut(12,i,t,a|2),e.elementType=Te,e.lanes=o,e;case Ge:return e=ut(13,i,t,a),e.elementType=Ge,e.lanes=o,e;case pe:return e=ut(19,i,t,a),e.elementType=pe,e.lanes=o,e;case fe:return Aa(i,a,o,t);default:if(typeof e=="object"&&e!==null)switch(e.$$typeof){case nt:s=10;break e;case ct:s=9;break e;case Ae:s=11;break e;case Le:s=14;break e;case Pe:s=16,n=null;break e}throw Error(r(130,e==null?e:typeof e,""))}return t=ut(s,i,t,a),t.elementType=e,t.type=n,t.lanes=o,t}function di(e,t,i,n){return e=ut(7,e,n,t),e.lanes=i,e}function Aa(e,t,i,n){return e=ut(22,e,n,t),e.elementType=fe,e.lanes=i,e.stateNode={isHidden:!1},e}function Ts(e,t,i){return e=ut(6,e,null,t),e.lanes=i,e}function As(e,t,i){return t=ut(4,e.children!==null?e.children:[],e.key,t),t.lanes=i,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function sp(e,t,i,n,a){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=no(0),this.expirationTimes=no(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=no(0),this.identifierPrefix=n,this.onRecoverableError=a,this.mutableSourceEagerHydrationData=null}function Ps(e,t,i,n,a,o,s,u,d){return e=new sp(e,t,i,u,d),t===1?(t=1,o===!0&&(t|=8)):t=0,o=ut(3,null,null,t),e.current=o,o.stateNode=e,o.memoizedState={element:n,isDehydrated:i,cache:null,transitions:null,pendingSuspenseBoundaries:null},Wo(o),e}function rp(e,t,i){var n=3<arguments.length&&arguments[3]!==void 0?arguments[3]:null;return{$$typeof:we,key:n==null?null:""+n,children:e,containerInfo:t,implementation:i}}function Nu(e){if(!e)return zt;e=e._reactInternals;e:{if(Kt(e)!==e||e.tag!==1)throw Error(r(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(We(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(t!==null);throw Error(r(171))}if(e.tag===1){var i=e.type;if(We(i))return hl(e,i,t)}return t}function zu(e,t,i,n,a,o,s,u,d){return e=Ps(i,n,!0,e,a,o,s,u,d),e.context=Nu(null),i=e.current,n=ze(),a=Ht(i),o=Mt(n,a),o.callback=t??null,jt(i,o,a),e.current.lanes=a,Hi(e,a,n),He(e,n),e}function Pa(e,t,i,n){var a=t.current,o=ze(),s=Ht(a);return i=Nu(i),t.context===null?t.context=i:t.pendingContext=i,t=Mt(o,s),t.payload={element:e},n=n===void 0?null:n,n!==null&&(t.callback=n),e=jt(a,t,s),e!==null&&(_t(e,a,s,o),ua(e,a,s)),s}function Oa(e){if(e=e.current,!e.child)return null;switch(e.child.tag){case 5:return e.child.stateNode;default:return e.child.stateNode}}function Uu(e,t){if(e=e.memoizedState,e!==null&&e.dehydrated!==null){var i=e.retryLane;e.retryLane=i!==0&&i<t?i:t}}function Os(e,t){Uu(e,t),(e=e.alternate)&&Uu(e,t)}function lp(){return null}var Gu=typeof reportError=="function"?reportError:function(e){console.error(e)};function Qs(e){this._internalRoot=e}Qa.prototype.render=Qs.prototype.render=function(e){var t=this._internalRoot;if(t===null)throw Error(r(409));Pa(e,t,null,null)},Qa.prototype.unmount=Qs.prototype.unmount=function(){var e=this._internalRoot;if(e!==null){this._internalRoot=null;var t=e.containerInfo;li(function(){Pa(null,e,null,null)}),t[xt]=null}};function Qa(e){this._internalRoot=e}Qa.prototype.unstable_scheduleHydration=function(e){if(e){var t=Sr();e={blockedOn:null,target:e,priority:t};for(var i=0;i<Bt.length&&t!==0&&t<Bt[i].priority;i++);Bt.splice(i,0,e),i===0&&Mr(e)}};function Fs(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11)}function Fa(e){return!(!e||e.nodeType!==1&&e.nodeType!==9&&e.nodeType!==11&&(e.nodeType!==8||e.nodeValue!==" react-mount-point-unstable "))}function ju(){}function up(e,t,i,n,a){if(a){if(typeof n=="function"){var o=n;n=function(){var g=Oa(s);o.call(g)}}var s=zu(t,n,e,0,null,!1,!1,"",ju);return e._reactRootContainer=s,e[xt]=s.current,un(e.nodeType===8?e.parentNode:e),li(),s}for(;a=e.lastChild;)e.removeChild(a);if(typeof n=="function"){var u=n;n=function(){var g=Oa(d);u.call(g)}}var d=Ps(e,0,!1,null,null,!1,!1,"",ju);return e._reactRootContainer=d,e[xt]=d.current,un(e.nodeType===8?e.parentNode:e),li(function(){Pa(t,d,i,n)}),d}function Ba(e,t,i,n,a){var o=i._reactRootContainer;if(o){var s=o;if(typeof a=="function"){var u=a;a=function(){var d=Oa(s);u.call(d)}}Pa(t,s,e,a)}else s=up(i,t,e,a,n);return Oa(s)}xr=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var i=Xi(t.pendingLanes);i!==0&&(ao(t,i|1),He(t,ye()),(J&6)===0&&(Di=ye()+500,Ut()))}break;case 13:li(function(){var n=Rt(e,1);if(n!==null){var a=ze();_t(n,e,1,a)}}),Os(e,1)}},oo=function(e){if(e.tag===13){var t=Rt(e,134217728);if(t!==null){var i=ze();_t(t,e,134217728,i)}Os(e,134217728)}},Ir=function(e){if(e.tag===13){var t=Ht(e),i=Rt(e,t);if(i!==null){var n=ze();_t(i,e,t,n)}Os(e,t)}},Sr=function(){return ne},kr=function(e,t){var i=ne;try{return ne=e,t()}finally{ne=i}},Ya=function(e,t,i){switch(t){case"input":if(Ga(e,i),t=i.name,i.type==="radio"&&t!=null){for(i=e;i.parentNode;)i=i.parentNode;for(i=i.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<i.length;t++){var n=i[t];if(n!==e&&n.form===e.form){var a=Kn(n);if(!a)throw Error(r(90));Ys(n),Ga(n,a)}}}break;case"textarea":ir(e,i);break;case"select":t=i.value,t!=null&&hi(e,!!i.multiple,t,!1)}},dr=Ss,pr=li;var cp={usingClientEntryPoint:!1,Events:[pn,xi,Kn,ur,cr,Ss]},Sn={findFiberByHostInstance:ei,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},dp={bundleType:Sn.bundleType,version:Sn.version,rendererPackageName:Sn.rendererPackageName,rendererConfig:Sn.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:ue.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return e=gr(e),e===null?null:e.stateNode},findFiberByHostInstance:Sn.findFiberByHostInstance||lp,findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__<"u"){var Da=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!Da.isDisabled&&Da.supportsFiber)try{Qn=Da.inject(dp),yt=Da}catch{}}return Ze.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=cp,Ze.createPortal=function(e,t){var i=2<arguments.length&&arguments[2]!==void 0?arguments[2]:null;if(!Fs(t))throw Error(r(200));return rp(e,t,null,i)},Ze.createRoot=function(e,t){if(!Fs(e))throw Error(r(299));var i=!1,n="",a=Gu;return t!=null&&(t.unstable_strictMode===!0&&(i=!0),t.identifierPrefix!==void 0&&(n=t.identifierPrefix),t.onRecoverableError!==void 0&&(a=t.onRecoverableError)),t=Ps(e,1,!1,null,null,i,!1,n,a),e[xt]=t.current,un(e.nodeType===8?e.parentNode:e),new Qs(t)},Ze.findDOMNode=function(e){if(e==null)return null;if(e.nodeType===1)return e;var t=e._reactInternals;if(t===void 0)throw typeof e.render=="function"?Error(r(188)):(e=Object.keys(e).join(","),Error(r(268,e)));return e=gr(t),e=e===null?null:e.stateNode,e},Ze.flushSync=function(e){return li(e)},Ze.hydrate=function(e,t,i){if(!Fa(t))throw Error(r(200));return Ba(null,e,t,!0,i)},Ze.hydrateRoot=function(e,t,i){if(!Fs(e))throw Error(r(405));var n=i!=null&&i.hydratedSources||null,a=!1,o="",s=Gu;if(i!=null&&(i.unstable_strictMode===!0&&(a=!0),i.identifierPrefix!==void 0&&(o=i.identifierPrefix),i.onRecoverableError!==void 0&&(s=i.onRecoverableError)),t=zu(t,null,e,1,i??null,a,!1,o,s),e[xt]=t.current,un(e),n)for(e=0;e<n.length;e++)i=n[e],a=i._getVersion,a=a(i._source),t.mutableSourceEagerHydrationData==null?t.mutableSourceEagerHydrationData=[i,a]:t.mutableSourceEagerHydrationData.push(i,a);return new Qa(t)},Ze.render=function(e,t,i){if(!Fa(t))throw Error(r(200));return Ba(null,e,t,!1,i)},Ze.unmountComponentAtNode=function(e){if(!Fa(e))throw Error(r(40));return e._reactRootContainer?(li(function(){Ba(null,null,e,!1,function(){e._reactRootContainer=null,e[xt]=null})}),!0):!1},Ze.unstable_batchedUpdates=Ss,Ze.unstable_renderSubtreeIntoContainer=function(e,t,i,n){if(!Fa(i))throw Error(r(200));if(e==null||e._reactInternals===void 0)throw Error(r(38));return Ba(e,t,i,!1,n)},Ze.version="18.3.1-next-f1338f8080-20240426",Ze}var Ju;function sc(){if(Ju)return Es.exports;Ju=1;function c(){if(!(typeof __REACT_DEVTOOLS_GLOBAL_HOOK__>"u"||typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE!="function"))try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(c)}catch(l){console.error(l)}}return c(),Es.exports=yp(),Es.exports}var Ku;function bp(){if(Ku)return Ea;Ku=1;var c=sc();return Ea.createRoot=c.createRoot,Ea.hydrateRoot=c.hydrateRoot,Ea}var vp=bp();function Pt(c){return Array.isArray?Array.isArray(c):uc(c)==="[object Array]"}function qp(c){if(typeof c=="string")return c;let l=c+"";return l=="0"&&1/c==-1/0?"-0":l}function wp(c){return c==null?"":qp(c)}function Ct(c){return typeof c=="string"}function rc(c){return typeof c=="number"}function Cp(c){return c===!0||c===!1||xp(c)&&uc(c)=="[object Boolean]"}function lc(c){return typeof c=="object"}function xp(c){return lc(c)&&c!==null}function it(c){return c!=null}function zs(c){return!c.trim().length}function uc(c){return c==null?c===void 0?"[object Undefined]":"[object Null]":Object.prototype.toString.call(c)}const Ip="Incorrect 'index' type",Sp=c=>`Invalid value for key ${c}`,kp=c=>`Pattern length exceeds max of ${c}.`,Rp=c=>`Missing ${c} property in key`,Mp=c=>`Property 'weight' in key '${c}' must be a positive integer`,ec=Object.prototype.hasOwnProperty;class Tp{constructor(l){this._keys=[],this._keyMap={};let r=0;l.forEach(b=>{let _=cc(b);this._keys.push(_),this._keyMap[_.id]=_,r+=_.weight}),this._keys.forEach(b=>{b.weight/=r})}get(l){return this._keyMap[l]}keys(){return this._keys}toJSON(){return JSON.stringify(this._keys)}}function cc(c){let l=null,r=null,b=null,_=1,v=null;if(Ct(c)||Pt(c))b=c,l=tc(c),r=Gs(c);else{if(!ec.call(c,"name"))throw new Error(Rp("name"));const q=c.name;if(b=q,ec.call(c,"weight")&&(_=c.weight,_<=0))throw new Error(Mp(q));l=tc(q),r=Gs(q),v=c.getFn}return{path:l,id:r,weight:_,src:b,getFn:v}}function tc(c){return Pt(c)?c:c.split(".")}function Gs(c){return Pt(c)?c.join("."):c}function Ap(c,l){let r=[],b=!1;const _=(v,q,k)=>{if(it(v))if(!q[k])r.push(v);else{let I=q[k];const M=v[I];if(!it(M))return;if(k===q.length-1&&(Ct(M)||rc(M)||Cp(M)))r.push(wp(M));else if(Pt(M)){b=!0;for(let P=0,T=M.length;P<T;P+=1)_(M[P],q,k+1)}else q.length&&_(M,q,k+1)}};return _(c,Ct(l)?l.split("."):l,0),b?r:r[0]}const Pp={includeMatches:!1,findAllMatches:!1,minMatchCharLength:1},Op={isCaseSensitive:!1,ignoreDiacritics:!1,includeScore:!1,keys:[],shouldSort:!0,sortFn:(c,l)=>c.score===l.score?c.idx<l.idx?-1:1:c.score<l.score?-1:1},Qp={location:0,threshold:.6,distance:100},Fp={useExtendedSearch:!1,getFn:Ap,ignoreLocation:!1,ignoreFieldNorm:!1,fieldNormWeight:1};var G={...Op,...Pp,...Qp,...Fp};const Bp=/[^ ]+/g;function Dp(c=1,l=3){const r=new Map,b=Math.pow(10,l);return{get(_){const v=_.match(Bp).length;if(r.has(v))return r.get(v);const q=1/Math.pow(v,.5*c),k=parseFloat(Math.round(q*b)/b);return r.set(v,k),k},clear(){r.clear()}}}class $s{constructor({getFn:l=G.getFn,fieldNormWeight:r=G.fieldNormWeight}={}){this.norm=Dp(r,3),this.getFn=l,this.isCreated=!1,this.setIndexRecords()}setSources(l=[]){this.docs=l}setIndexRecords(l=[]){this.records=l}setKeys(l=[]){this.keys=l,this._keysMap={},l.forEach((r,b)=>{this._keysMap[r.id]=b})}create(){this.isCreated||!this.docs.length||(this.isCreated=!0,Ct(this.docs[0])?this.docs.forEach((l,r)=>{this._addString(l,r)}):this.docs.forEach((l,r)=>{this._addObject(l,r)}),this.norm.clear())}add(l){const r=this.size();Ct(l)?this._addString(l,r):this._addObject(l,r)}removeAt(l){this.records.splice(l,1);for(let r=l,b=this.size();r<b;r+=1)this.records[r].i-=1}getValueForItemAtKeyId(l,r){return l[this._keysMap[r]]}size(){return this.records.length}_addString(l,r){if(!it(l)||zs(l))return;let b={v:l,i:r,n:this.norm.get(l)};this.records.push(b)}_addObject(l,r){let b={i:r,$:{}};this.keys.forEach((_,v)=>{let q=_.getFn?_.getFn(l):this.getFn(l,_.path);if(it(q)){if(Pt(q)){let k=[];const I=[{nestedArrIndex:-1,value:q}];for(;I.length;){const{nestedArrIndex:M,value:P}=I.pop();if(it(P))if(Ct(P)&&!zs(P)){let T={v:P,i:M,n:this.norm.get(P)};k.push(T)}else Pt(P)&&P.forEach((T,O)=>{I.push({nestedArrIndex:O,value:T})})}b.$[v]=k}else if(Ct(q)&&!zs(q)){let k={v:q,n:this.norm.get(q)};b.$[v]=k}}}),this.records.push(b)}toJSON(){return{keys:this.keys,records:this.records}}}function dc(c,l,{getFn:r=G.getFn,fieldNormWeight:b=G.fieldNormWeight}={}){const _=new $s({getFn:r,fieldNormWeight:b});return _.setKeys(c.map(cc)),_.setSources(l),_.create(),_}function Ep(c,{getFn:l=G.getFn,fieldNormWeight:r=G.fieldNormWeight}={}){const{keys:b,records:_}=c,v=new $s({getFn:l,fieldNormWeight:r});return v.setKeys(b),v.setIndexRecords(_),v}function La(c,{errors:l=0,currentLocation:r=0,expectedLocation:b=0,distance:_=G.distance,ignoreLocation:v=G.ignoreLocation}={}){const q=l/c.length;if(v)return q;const k=Math.abs(b-r);return _?q+k/_:k?1:q}function Lp(c=[],l=G.minMatchCharLength){let r=[],b=-1,_=-1,v=0;for(let q=c.length;v<q;v+=1){let k=c[v];k&&b===-1?b=v:!k&&b!==-1&&(_=v-1,_-b+1>=l&&r.push([b,_]),b=-1)}return c[v-1]&&v-b>=l&&r.push([b,v-1]),r}const pi=32;function Np(c,l,r,{location:b=G.location,distance:_=G.distance,threshold:v=G.threshold,findAllMatches:q=G.findAllMatches,minMatchCharLength:k=G.minMatchCharLength,includeMatches:I=G.includeMatches,ignoreLocation:M=G.ignoreLocation}={}){if(l.length>pi)throw new Error(kp(pi));const P=l.length,T=c.length,O=Math.max(0,Math.min(b,T));let W=v,Y=O;const H=k>1||I,V=H?Array(T):[];let Ie;for(;(Ie=c.indexOf(l,Y))>-1;){let ae=La(l,{currentLocation:Ie,expectedLocation:O,distance:_,ignoreLocation:M});if(W=Math.min(ae,W),Y=Ie+P,H){let _e=0;for(;_e<P;)V[Ie+_e]=1,_e+=1}}Y=-1;let ve=[],Se=1,ue=P+T;const $e=1<<P-1;for(let ae=0;ae<P;ae+=1){let _e=0,Te=ue;for(;_e<Te;)La(l,{errors:ae,currentLocation:O+Te,expectedLocation:O,distance:_,ignoreLocation:M})<=W?_e=Te:ue=Te,Te=Math.floor((ue-_e)/2+_e);ue=Te;let nt=Math.max(1,O-Te+1),ct=q?T:Math.min(O+Te,T)+P,Ae=Array(ct+2);Ae[ct+1]=(1<<ae)-1;for(let pe=ct;pe>=nt;pe-=1){let Le=pe-1,Pe=r[c.charAt(Le)];if(H&&(V[Le]=+!!Pe),Ae[pe]=(Ae[pe+1]<<1|1)&Pe,ae&&(Ae[pe]|=(ve[pe+1]|ve[pe])<<1|1|ve[pe+1]),Ae[pe]&$e&&(Se=La(l,{errors:ae,currentLocation:Le,expectedLocation:O,distance:_,ignoreLocation:M}),Se<=W)){if(W=Se,Y=Le,Y<=O)break;nt=Math.max(1,2*O-Y)}}if(La(l,{errors:ae+1,currentLocation:O,expectedLocation:O,distance:_,ignoreLocation:M})>W)break;ve=Ae}const we={isMatch:Y>=0,score:Math.max(.001,Se)};if(H){const ae=Lp(V,k);ae.length?I&&(we.indices=ae):we.isMatch=!1}return we}function zp(c){let l={};for(let r=0,b=c.length;r<b;r+=1){const _=c.charAt(r);l[_]=(l[_]||0)|1<<b-r-1}return l}const Na=String.prototype.normalize?c=>c.normalize("NFD").replace(/[\u0300-\u036F\u0483-\u0489\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u0610-\u061A\u064B-\u065F\u0670\u06D6-\u06DC\u06DF-\u06E4\u06E7\u06E8\u06EA-\u06ED\u0711\u0730-\u074A\u07A6-\u07B0\u07EB-\u07F3\u07FD\u0816-\u0819\u081B-\u0823\u0825-\u0827\u0829-\u082D\u0859-\u085B\u08D3-\u08E1\u08E3-\u0903\u093A-\u093C\u093E-\u094F\u0951-\u0957\u0962\u0963\u0981-\u0983\u09BC\u09BE-\u09C4\u09C7\u09C8\u09CB-\u09CD\u09D7\u09E2\u09E3\u09FE\u0A01-\u0A03\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A70\u0A71\u0A75\u0A81-\u0A83\u0ABC\u0ABE-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AE2\u0AE3\u0AFA-\u0AFF\u0B01-\u0B03\u0B3C\u0B3E-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B62\u0B63\u0B82\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD7\u0C00-\u0C04\u0C3E-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C62\u0C63\u0C81-\u0C83\u0CBC\u0CBE-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CE2\u0CE3\u0D00-\u0D03\u0D3B\u0D3C\u0D3E-\u0D44\u0D46-\u0D48\u0D4A-\u0D4D\u0D57\u0D62\u0D63\u0D82\u0D83\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DF2\u0DF3\u0E31\u0E34-\u0E3A\u0E47-\u0E4E\u0EB1\u0EB4-\u0EB9\u0EBB\u0EBC\u0EC8-\u0ECD\u0F18\u0F19\u0F35\u0F37\u0F39\u0F3E\u0F3F\u0F71-\u0F84\u0F86\u0F87\u0F8D-\u0F97\u0F99-\u0FBC\u0FC6\u102B-\u103E\u1056-\u1059\u105E-\u1060\u1062-\u1064\u1067-\u106D\u1071-\u1074\u1082-\u108D\u108F\u109A-\u109D\u135D-\u135F\u1712-\u1714\u1732-\u1734\u1752\u1753\u1772\u1773\u17B4-\u17D3\u17DD\u180B-\u180D\u1885\u1886\u18A9\u1920-\u192B\u1930-\u193B\u1A17-\u1A1B\u1A55-\u1A5E\u1A60-\u1A7C\u1A7F\u1AB0-\u1ABE\u1B00-\u1B04\u1B34-\u1B44\u1B6B-\u1B73\u1B80-\u1B82\u1BA1-\u1BAD\u1BE6-\u1BF3\u1C24-\u1C37\u1CD0-\u1CD2\u1CD4-\u1CE8\u1CED\u1CF2-\u1CF4\u1CF7-\u1CF9\u1DC0-\u1DF9\u1DFB-\u1DFF\u20D0-\u20F0\u2CEF-\u2CF1\u2D7F\u2DE0-\u2DFF\u302A-\u302F\u3099\u309A\uA66F-\uA672\uA674-\uA67D\uA69E\uA69F\uA6F0\uA6F1\uA802\uA806\uA80B\uA823-\uA827\uA880\uA881\uA8B4-\uA8C5\uA8E0-\uA8F1\uA8FF\uA926-\uA92D\uA947-\uA953\uA980-\uA983\uA9B3-\uA9C0\uA9E5\uAA29-\uAA36\uAA43\uAA4C\uAA4D\uAA7B-\uAA7D\uAAB0\uAAB2-\uAAB4\uAAB7\uAAB8\uAABE\uAABF\uAAC1\uAAEB-\uAAEF\uAAF5\uAAF6\uABE3-\uABEA\uABEC\uABED\uFB1E\uFE00-\uFE0F\uFE20-\uFE2F]/g,""):c=>c;class pc{constructor(l,{location:r=G.location,threshold:b=G.threshold,distance:_=G.distance,includeMatches:v=G.includeMatches,findAllMatches:q=G.findAllMatches,minMatchCharLength:k=G.minMatchCharLength,isCaseSensitive:I=G.isCaseSensitive,ignoreDiacritics:M=G.ignoreDiacritics,ignoreLocation:P=G.ignoreLocation}={}){if(this.options={location:r,threshold:b,distance:_,includeMatches:v,findAllMatches:q,minMatchCharLength:k,isCaseSensitive:I,ignoreDiacritics:M,ignoreLocation:P},l=I?l:l.toLowerCase(),l=M?Na(l):l,this.pattern=l,this.chunks=[],!this.pattern.length)return;const T=(W,Y)=>{this.chunks.push({pattern:W,alphabet:zp(W),startIndex:Y})},O=this.pattern.length;if(O>pi){let W=0;const Y=O%pi,H=O-Y;for(;W<H;)T(this.pattern.substr(W,pi),W),W+=pi;if(Y){const V=O-pi;T(this.pattern.substr(V),V)}}else T(this.pattern,0)}searchIn(l){const{isCaseSensitive:r,ignoreDiacritics:b,includeMatches:_}=this.options;if(l=r?l:l.toLowerCase(),l=b?Na(l):l,this.pattern===l){let H={isMatch:!0,score:0};return _&&(H.indices=[[0,l.length-1]]),H}const{location:v,distance:q,threshold:k,findAllMatches:I,minMatchCharLength:M,ignoreLocation:P}=this.options;let T=[],O=0,W=!1;this.chunks.forEach(({pattern:H,alphabet:V,startIndex:Ie})=>{const{isMatch:ve,score:Se,indices:ue}=Np(l,H,V,{location:v+Ie,distance:q,threshold:k,findAllMatches:I,minMatchCharLength:M,includeMatches:_,ignoreLocation:P});ve&&(W=!0),O+=Se,ve&&ue&&(T=[...T,...ue])});let Y={isMatch:W,score:W?O/this.chunks.length:1};return W&&_&&(Y.indices=T),Y}}class Jt{constructor(l){this.pattern=l}static isMultiMatch(l){return ic(l,this.multiRegex)}static isSingleMatch(l){return ic(l,this.singleRegex)}search(){}}function ic(c,l){const r=c.match(l);return r?r[1]:null}class Up extends Jt{constructor(l){super(l)}static get type(){return"exact"}static get multiRegex(){return/^="(.*)"$/}static get singleRegex(){return/^=(.*)$/}search(l){const r=l===this.pattern;return{isMatch:r,score:r?0:1,indices:[0,this.pattern.length-1]}}}class Gp extends Jt{constructor(l){super(l)}static get type(){return"inverse-exact"}static get multiRegex(){return/^!"(.*)"$/}static get singleRegex(){return/^!(.*)$/}search(l){const b=l.indexOf(this.pattern)===-1;return{isMatch:b,score:b?0:1,indices:[0,l.length-1]}}}class jp extends Jt{constructor(l){super(l)}static get type(){return"prefix-exact"}static get multiRegex(){return/^\^"(.*)"$/}static get singleRegex(){return/^\^(.*)$/}search(l){const r=l.startsWith(this.pattern);return{isMatch:r,score:r?0:1,indices:[0,this.pattern.length-1]}}}class Wp extends Jt{constructor(l){super(l)}static get type(){return"inverse-prefix-exact"}static get multiRegex(){return/^!\^"(.*)"$/}static get singleRegex(){return/^!\^(.*)$/}search(l){const r=!l.startsWith(this.pattern);return{isMatch:r,score:r?0:1,indices:[0,l.length-1]}}}class Vp extends Jt{constructor(l){super(l)}static get type(){return"suffix-exact"}static get multiRegex(){return/^"(.*)"\$$/}static get singleRegex(){return/^(.*)\$$/}search(l){const r=l.endsWith(this.pattern);return{isMatch:r,score:r?0:1,indices:[l.length-this.pattern.length,l.length-1]}}}class Xp extends Jt{constructor(l){super(l)}static get type(){return"inverse-suffix-exact"}static get multiRegex(){return/^!"(.*)"\$$/}static get singleRegex(){return/^!(.*)\$$/}search(l){const r=!l.endsWith(this.pattern);return{isMatch:r,score:r?0:1,indices:[0,l.length-1]}}}class mc extends Jt{constructor(l,{location:r=G.location,threshold:b=G.threshold,distance:_=G.distance,includeMatches:v=G.includeMatches,findAllMatches:q=G.findAllMatches,minMatchCharLength:k=G.minMatchCharLength,isCaseSensitive:I=G.isCaseSensitive,ignoreDiacritics:M=G.ignoreDiacritics,ignoreLocation:P=G.ignoreLocation}={}){super(l),this._bitapSearch=new pc(l,{location:r,threshold:b,distance:_,includeMatches:v,findAllMatches:q,minMatchCharLength:k,isCaseSensitive:I,ignoreDiacritics:M,ignoreLocation:P})}static get type(){return"fuzzy"}static get multiRegex(){return/^"(.*)"$/}static get singleRegex(){return/^(.*)$/}search(l){return this._bitapSearch.searchIn(l)}}class hc extends Jt{constructor(l){super(l)}static get type(){return"include"}static get multiRegex(){return/^'"(.*)"$/}static get singleRegex(){return/^'(.*)$/}search(l){let r=0,b;const _=[],v=this.pattern.length;for(;(b=l.indexOf(this.pattern,r))>-1;)r=b+v,_.push([b,r-1]);const q=!!_.length;return{isMatch:q,score:q?0:1,indices:_}}}const js=[Up,hc,jp,Wp,Xp,Vp,Gp,mc],nc=js.length,Hp=/ +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/,Zp="|";function $p(c,l={}){return c.split(Zp).map(r=>{let b=r.trim().split(Hp).filter(v=>v&&!!v.trim()),_=[];for(let v=0,q=b.length;v<q;v+=1){const k=b[v];let I=!1,M=-1;for(;!I&&++M<nc;){const P=js[M];let T=P.isMultiMatch(k);T&&(_.push(new P(T,l)),I=!0)}if(!I)for(M=-1;++M<nc;){const P=js[M];let T=P.isSingleMatch(k);if(T){_.push(new P(T,l));break}}}return _})}const Yp=new Set([mc.type,hc.type]);class Jp{constructor(l,{isCaseSensitive:r=G.isCaseSensitive,ignoreDiacritics:b=G.ignoreDiacritics,includeMatches:_=G.includeMatches,minMatchCharLength:v=G.minMatchCharLength,ignoreLocation:q=G.ignoreLocation,findAllMatches:k=G.findAllMatches,location:I=G.location,threshold:M=G.threshold,distance:P=G.distance}={}){this.query=null,this.options={isCaseSensitive:r,ignoreDiacritics:b,includeMatches:_,minMatchCharLength:v,findAllMatches:k,ignoreLocation:q,location:I,threshold:M,distance:P},l=r?l:l.toLowerCase(),l=b?Na(l):l,this.pattern=l,this.query=$p(this.pattern,this.options)}static condition(l,r){return r.useExtendedSearch}searchIn(l){const r=this.query;if(!r)return{isMatch:!1,score:1};const{includeMatches:b,isCaseSensitive:_,ignoreDiacritics:v}=this.options;l=_?l:l.toLowerCase(),l=v?Na(l):l;let q=0,k=[],I=0;for(let M=0,P=r.length;M<P;M+=1){const T=r[M];k.length=0,q=0;for(let O=0,W=T.length;O<W;O+=1){const Y=T[O],{isMatch:H,indices:V,score:Ie}=Y.search(l);if(H){if(q+=1,I+=Ie,b){const ve=Y.constructor.type;Yp.has(ve)?k=[...k,...V]:k.push(V)}}else{I=0,q=0,k.length=0;break}}if(q){let O={isMatch:!0,score:I/q};return b&&(O.indices=k),O}}return{isMatch:!1,score:1}}}const Ws=[];function Kp(...c){Ws.push(...c)}function Vs(c,l){for(let r=0,b=Ws.length;r<b;r+=1){let _=Ws[r];if(_.condition(c,l))return new _(c,l)}return new pc(c,l)}const za={AND:"$and",OR:"$or"},Xs={PATH:"$path",PATTERN:"$val"},Hs=c=>!!(c[za.AND]||c[za.OR]),em=c=>!!c[Xs.PATH],tm=c=>!Pt(c)&&lc(c)&&!Hs(c),ac=c=>({[za.AND]:Object.keys(c).map(l=>({[l]:c[l]}))});function fc(c,l,{auto:r=!0}={}){const b=_=>{let v=Object.keys(_);const q=em(_);if(!q&&v.length>1&&!Hs(_))return b(ac(_));if(tm(_)){const I=q?_[Xs.PATH]:v[0],M=q?_[Xs.PATTERN]:_[I];if(!Ct(M))throw new Error(Sp(I));const P={keyId:Gs(I),pattern:M};return r&&(P.searcher=Vs(M,l)),P}let k={children:[],operator:v[0]};return v.forEach(I=>{const M=_[I];Pt(M)&&M.forEach(P=>{k.children.push(b(P))})}),k};return Hs(c)||(c=ac(c)),b(c)}function im(c,{ignoreFieldNorm:l=G.ignoreFieldNorm}){c.forEach(r=>{let b=1;r.matches.forEach(({key:_,norm:v,score:q})=>{const k=_?_.weight:null;b*=Math.pow(q===0&&k?Number.EPSILON:q,(k||1)*(l?1:v))}),r.score=b})}function nm(c,l){const r=c.matches;l.matches=[],it(r)&&r.forEach(b=>{if(!it(b.indices)||!b.indices.length)return;const{indices:_,value:v}=b;let q={indices:_,value:v};b.key&&(q.key=b.key.src),b.idx>-1&&(q.refIndex=b.idx),l.matches.push(q)})}function am(c,l){l.score=c.score}function om(c,l,{includeMatches:r=G.includeMatches,includeScore:b=G.includeScore}={}){const _=[];return r&&_.push(nm),b&&_.push(am),c.map(v=>{const{idx:q}=v,k={item:l[q],refIndex:q};return _.length&&_.forEach(I=>{I(v,k)}),k})}class Ni{constructor(l,r={},b){this.options={...G,...r},this.options.useExtendedSearch,this._keyStore=new Tp(this.options.keys),this.setCollection(l,b)}setCollection(l,r){if(this._docs=l,r&&!(r instanceof $s))throw new Error(Ip);this._myIndex=r||dc(this.options.keys,this._docs,{getFn:this.options.getFn,fieldNormWeight:this.options.fieldNormWeight})}add(l){it(l)&&(this._docs.push(l),this._myIndex.add(l))}remove(l=()=>!1){const r=[];for(let b=0,_=this._docs.length;b<_;b+=1){const v=this._docs[b];l(v,b)&&(this.removeAt(b),b-=1,_-=1,r.push(v))}return r}removeAt(l){this._docs.splice(l,1),this._myIndex.removeAt(l)}getIndex(){return this._myIndex}search(l,{limit:r=-1}={}){const{includeMatches:b,includeScore:_,shouldSort:v,sortFn:q,ignoreFieldNorm:k}=this.options;let I=Ct(l)?Ct(this._docs[0])?this._searchStringList(l):this._searchObjectList(l):this._searchLogical(l);return im(I,{ignoreFieldNorm:k}),v&&I.sort(q),rc(r)&&r>-1&&(I=I.slice(0,r)),om(I,this._docs,{includeMatches:b,includeScore:_})}_searchStringList(l){const r=Vs(l,this.options),{records:b}=this._myIndex,_=[];return b.forEach(({v,i:q,n:k})=>{if(!it(v))return;const{isMatch:I,score:M,indices:P}=r.searchIn(v);I&&_.push({item:v,idx:q,matches:[{score:M,value:v,norm:k,indices:P}]})}),_}_searchLogical(l){const r=fc(l,this.options),b=(k,I,M)=>{if(!k.children){const{keyId:T,searcher:O}=k,W=this._findMatches({key:this._keyStore.get(T),value:this._myIndex.getValueForItemAtKeyId(I,T),searcher:O});return W&&W.length?[{idx:M,item:I,matches:W}]:[]}const P=[];for(let T=0,O=k.children.length;T<O;T+=1){const W=k.children[T],Y=b(W,I,M);if(Y.length)P.push(...Y);else if(k.operator===za.AND)return[]}return P},_=this._myIndex.records,v={},q=[];return _.forEach(({$:k,i:I})=>{if(it(k)){let M=b(r,k,I);M.length&&(v[I]||(v[I]={idx:I,item:k,matches:[]},q.push(v[I])),M.forEach(({matches:P})=>{v[I].matches.push(...P)}))}}),q}_searchObjectList(l){const r=Vs(l,this.options),{keys:b,records:_}=this._myIndex,v=[];return _.forEach(({$:q,i:k})=>{if(!it(q))return;let I=[];b.forEach((M,P)=>{I.push(...this._findMatches({key:M,value:q[P],searcher:r}))}),I.length&&v.push({idx:k,item:q,matches:I})}),v}_findMatches({key:l,value:r,searcher:b}){if(!it(r))return[];let _=[];if(Pt(r))r.forEach(({v,i:q,n:k})=>{if(!it(v))return;const{isMatch:I,score:M,indices:P}=b.searchIn(v);I&&_.push({score:M,key:l,value:v,idx:q,norm:k,indices:P})});else{const{v,n:q}=r,{isMatch:k,score:I,indices:M}=b.searchIn(v);k&&_.push({score:I,key:l,value:v,norm:q,indices:M})}return _}}Ni.version="7.1.0";Ni.createIndex=dc;Ni.parseIndex=Ep;Ni.config=G;Ni.parseQuery=fc;Kp(Jp);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */var sm={xmlns:"http://www.w3.org/2000/svg",width:24,height:24,viewBox:"0 0 24 24",fill:"none",stroke:"currentColor",strokeWidth:2,strokeLinecap:"round",strokeLinejoin:"round"};/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const rm=c=>c.replace(/([a-z0-9])([A-Z])/g,"$1-$2").toLowerCase().trim(),gc=(c,l)=>{const r=Ue.forwardRef(({color:b="currentColor",size:_=24,strokeWidth:v=2,absoluteStrokeWidth:q,className:k="",children:I,...M},P)=>Ue.createElement("svg",{ref:P,...sm,width:_,height:_,stroke:b,strokeWidth:q?Number(v)*24/Number(_):v,className:["lucide",`lucide-${rm(c)}`,k].join(" "),...M},[...l.map(([T,O])=>Ue.createElement(T,O)),...Array.isArray(I)?I:[I]]));return r.displayName=`${c}`,r};/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const oc=gc("Search",[["circle",{cx:"11",cy:"11",r:"8",key:"4ej97u"}],["path",{d:"m21 21-4.3-4.3",key:"1qie3q"}]]);/**
 * @license lucide-react v0.344.0 - ISC
 *
 * This source code is licensed under the ISC license.
 * See the LICENSE file in the root directory of this source tree.
 */const lm=gc("X",[["path",{d:"M18 6 6 18",key:"1bl5f8"}],["path",{d:"m6 6 12 12",key:"d8bk6v"}]]),um=""+new URL("switcher-CaaC6x9B.svg",import.meta.url).href,cm=""+new URL("docs-BGLm6Xpv.svg",import.meta.url).href,dm=""+new URL("academy-DLOT8zSY.svg",import.meta.url).href,pm=""+new URL("resonance-Du6ePxdd.svg",import.meta.url).href,mm=""+new URL("support-rYw0KIxl.svg",import.meta.url).href,hm=()=>{const[c,l]=Ue.useState(!1),r=()=>{l(!c)};return y.jsxs("div",{className:"flex items-center pt-2 w-56 p-0",children:[y.jsx("button",{className:"cursor-pointer p-0 border-none bg-transparent",onClick:r,children:y.jsx("img",{className:"title-image cursor-pointer",alt:"IQM Docs Application Switcher",src:um,height:42,width:222,style:{height:"42px",width:"222px"}})}),c&&y.jsxs("div",{className:"absolute mt-[14em] ml-[0.5em] bg-white w-[208px] rounded-lg p-1 pt-1 z-50 border border-gray-300",children:[y.jsx("div",{children:y.jsx("a",{href:"/","aria-label":"IQM Docs",target:"_blank",children:y.jsx("img",{className:"switcher-title-image hover:filter hover:contrast-[.90]",alt:"IQM Academy",src:cm,height:40,width:200})})}),y.jsx("div",{children:y.jsx("a",{href:"https://academy.meetiqm.com",target:"_blank","aria-label":"IQM Academy",children:y.jsx("img",{className:"switcher-title-image hover:filter hover:contrast-[.90]",alt:"IQM Academy",src:dm,height:40,width:200})})}),y.jsx("div",{children:y.jsx("a",{href:"https://resonance.meetiqm.com",target:"_blank",rel:"noreferrer","aria-label":"IQM Resonance",children:y.jsx("img",{className:"switcher-title-image hover:filter hover:contrast-[.90]",alt:"IQM Resonance",src:pm,height:40,width:200})})}),y.jsx("div",{children:y.jsx("a",{href:"https://support.meetiqm.com",target:"_blank",rel:"noreferrer","aria-label":"IQM Support",children:y.jsx("img",{className:"switcher-title-image hover:filter hover:contrast-[.90]",alt:"IQM Support",src:mm,height:40,width:200})})})]})]})},Us=JSON.parse(`[{"package":"iqm-exa-common","title":"API documentation: exa-common","url":"/iqm-exa-common/index.html","description":"26.14 2025-04-26 This documentation describes the common library of the Experiment Automation ( EXA ) project. exa-common contains classes and functions that are shared by EXA , Cortex and Station Con...","content":"26.14 2025-04-26 This documentation describes the common library of the Experiment Automation ( EXA ) project. exa-common contains classes and functions that are shared by EXA , Cortex and Station Control . Index Module Index Search Page next API Reference © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"API Reference","url":"/iqm-exa-common/API.html","description":"exa.common Shared errors, helpers, control structures, settings, API models etc. previous API documentation: exa-common next common © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated o...","content":"exa.common Shared errors, helpers, control structures, settings, API models etc. previous API documentation: exa-common next common © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"data","url":"/iqm-exa-common/api/exa.common.data.html","description":"Classes for representing physical quantities and instrument settings. Full path: exa.common.data Subpackages and modules base_model  parameter Physical quantities and instrument settings. setting_node...","content":"Classes for representing physical quantities and instrument settings. Full path: exa.common.data Subpackages and modules base_model  parameter Physical quantities and instrument settings. setting_node A tree-structured container for Settings . value  previous exa.common.control.sweep.sweep_values.validate_sweep_values next base_model © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.control.sweep.option.constants.DEFAULT_BASE","url":"/iqm-exa-common/api/exa.common.control.sweep.option.constants.DEFAULT_BASE.html","description":"Default value for base value in options. previous exa.common.control.sweep.option.constants.DEFAULT_COUNT next exa.common.control.sweep.option.constants.OPTIONS_TYPE © Copyright 2019-2025, IQM Finland...","content":"Default value for base value in options. previous exa.common.control.sweep.option.constants.DEFAULT_COUNT next exa.common.control.sweep.option.constants.OPTIONS_TYPE © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.errors.exa_error.EmptyComponentListError","url":"/iqm-exa-common/api/exa.common.errors.exa_error.EmptyComponentListError.html","description":"Error raised when an empty list is given as components for running an experiment. message ( str ) – previous exa_error next exa.common.errors.exa_error.ExaError © Copyright 2019-2025, IQM Finland Oy, ...","content":"Error raised when an empty list is given as components for running an experiment. message ( str ) – previous exa_error next exa.common.errors.exa_error.ExaError © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"common","url":"/iqm-exa-common/api/exa.common.html","description":"Shared errors, helpers, control structures, settings, API models etc. Full path: exa.common Subpackages and modules api API helpers. control Common data structures of abstract instrument control. data...","content":"Shared errors, helpers, control structures, settings, API models etc. Full path: exa.common Subpackages and modules api API helpers. control Common data structures of abstract instrument control. data Classes for representing physical quantities and instrument settings. errors Common error messages. helpers Miscellaneous helper functionality. logger Helper to initialize loggers to the specified logging level. qcm_data  sweep Sweep utilities. previous API Reference next api © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.control.sweep.option.option_converter.convert_to_options","url":"/iqm-exa-common/api/exa.common.control.sweep.option.option_converter.convert_to_options.html","description":"Creates one of the options object based on configuration dictionary. If configuration has keys start and stop , StartStopOptions is created. If configuration has keys start_exp and stop_exp , StartSto...","content":"Creates one of the options object based on configuration dictionary. If configuration has keys start and stop , StartStopOptions is created. If configuration has keys start_exp and stop_exp , StartStopBaseOptions is created. If configuration has keys center and span , CenterSpanOptions is created. If configuration has keys center_exp and span_exp , CenterSpanBaseOptions is created If configuration has keys fixed , FixedOptions is created. config ( dict [ str , Any ] ) – Configuration dictionary. ValueError – Error is raised if config has unsupported structure SweepOptions previous option_converter next start_stop_base_options © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"immutable_base_model","url":"/iqm-exa-common/api/exa.common.qcm_data.immutable_base_model.html","description":"Full path: exa.common.qcm_data.immutable_base_model Classes ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Inheritance previous FileAdapter next Imm...","content":"Full path: exa.common.qcm_data.immutable_base_model Classes ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Inheritance previous FileAdapter next ImmutableBaseModel © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"InfoFilter","url":"/iqm-exa-common/api/exa.common.logger.logger.InfoFilter.html","description":"Bases: Filter Helper class to filter log messages above INFO level. Initialize a filter. Initialize with the name of the logger which, together with its\\nchildren, will have its events allowed through ...","content":"Bases: Filter Helper class to filter log messages above INFO level. Initialize a filter. Initialize with the name of the logger which, together with its\\nchildren, will have its events allowed through the filter. If no\\nname is specified, allow every event. Module: exa.common.logger.logger Methods filter Determine if the specified record is to be logged. Determine if the specified record is to be logged. Returns True if the record should be logged, or False otherwise.\\nIf deemed appropriate, the record may be modified in-place. record ( LogRecord ) – bool previous ExtraFormatter next qcm_data © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"yaml_helper","url":"/iqm-exa-common/api/exa.common.helpers.yaml_helper.html","description":"YAML utilities. Full path: exa.common.helpers.yaml_helper Functions dump_yaml (data, path) Dump a YAML data to the given path. load_yaml (path) Load a YAML file from the given path and raise error if ...","content":"YAML utilities. Full path: exa.common.helpers.yaml_helper Functions dump_yaml (data, path) Dump a YAML data to the given path. load_yaml (path) Load a YAML file from the given path and raise error if the file can't be loaded. previous exa.common.helpers.software_version_helper.get_vcs_description next exa.common.helpers.yaml_helper.dump_yaml © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"Parameter","url":"/iqm-exa-common/api/exa.common.data.parameter.Parameter.html","description":"Bases: BaseModel A basic data structure that represents a single variable. The variable can be a high-level or low-level control knob of an instrument such as the amplitude of a pulse\\nor a control vol...","content":"Bases: BaseModel A basic data structure that represents a single variable. The variable can be a high-level or low-level control knob of an instrument such as the amplitude of a pulse\\nor a control voltage; a physical quantity such as resonance frequency; or an abstract concept\\nlike the number of averages in a measurement. Setting combines Parameter with a numerical, boolean, or string value to represent a quantity. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.data.parameter Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. parent_label Returns the parent label. parent_name Returns the parent name. name Parameter name used as identifier label name unit SI unit of the quantity, if applicable. data_type Data type or a tuple of datatypes that this parameter accepts and validates. collection_type Data format that this parameter accepts and validates. element_indices For parameters representing a single value in a collection-valued parent parameter, this field gives the indices of that value. Methods build_data_array Attach Parameter information to a numerical array. build_data_set Build an xarray Dataset, where the only DataArray is given by results and coordinates are given by variables . create_element_parameter_for Utility for creating an element-wise parameter for a single value in a collection valued parameter. model_post_init This function is meant to behave like a BaseModel method to initialise private attributes. set Create a Setting object with given value . validate Validate that given value matches the data_type and collection_type . name ( str ) – label ( str ) – unit ( str ) – data_type ( DataType | tuple [ DataType , ... ] ) – collection_type ( CollectionType ) – element_indices ( int | list [ int ] | None ) – Parameter name used as identifier name Parameter label used as pretty identifier for display purposes. Default SI unit of the quantity, if applicable. Data type or a tuple of datatypes that this parameter accepts and validates. One of DataType .\\nDefault: FLOAT. Data format that this parameter accepts and validates. One of CollectionType .\\nDefault: SCALAR. For parameters representing a single value in a collection-valued parent parameter, this field gives the indices\\nof that value. If populated, the self.name and self.label will be updated in post init to include\\nthe indices (becoming \\"<parent name>__<index0>__<index1>__...__<indexN>\\" and \\"<parent label> <indices>\\" , respectively). The parent name can then be retrieved with self.parent_name and the parent label with self.parent_label . Returns the parent name. This None except in element-wise parameters where gives the name of the parent parameter. Returns the parent label. This None except in element-wise parameters where gives the label of the parent parameter. Create a Setting object with given value . value ( Any ) – Setting Build an xarray Dataset, where the only DataArray is given by results and coordinates are given by variables . The data is reshaped to correspond to the sizes of the variables. For example, variables = [(par_x, [1,2,3]), (par_y: [-1, -2])] will shape the data to 3-by-2 array. If there are not\\nenough variables to reshape the data, remaining dimensions can be given by extra_variables . For example, variables = [(par_x: [1,2,3])], extra_variables=[('y', 2)] yields the same 3-by-2 data. 'y' will then be\\na “dimension without coordinate” in xarray terms. variables ( list [ tuple [ Parameter , list [ Any ] ] ] ) – Coordinates of the set. data ( tuple [ Parameter , list [ Any ] | ndarray [ Any ] ] ) – Data Parameter and associated data as a possible nested list. attributes ( dict [ str , Any ] ) – metadata to attach to the whole Dataset. extra_variables ( list [ tuple [ str , int ] ] | None ) – Valueless dimensions and their sizes. Validate that given value matches the data_type and collection_type . value ( Any ) – bool Attach Parameter information to a numerical array. Given an array of numerical values, returns a corresponding xr.DataArray instance\\nthat gets its name, units, and dimension names (unless explicitly given) from the Parameter instance. data ( ndarray ) – numerical values dimensions ( list [ Hashable ] ) – names of the dimensions of data coords ( dict [ Hashable , Any ] ) – coordinates labeling the dimensions of data metadata ( dict [ str , Any ] ) – additional xr.DataArray.attrs corresponding DataArray DataArray Utility for creating an element-wise parameter for a single value in a collection valued parameter. indices ( int | list [ int ] ) – The indices in the collection for which to create the element-wise parameter. The element-wise parameter. UnprocessableEntityError – If self is not collection-valued. Parameter Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. This function is meant to behave like a BaseModel method to initialise private attributes. It takes context as an argument since that’s what pydantic-core passes when calling it. self ( BaseModel ) – The BaseModel instance. context ( Any ) – The context. None previous DataType next Setting © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"sweep","url":"/iqm-exa-common/api/exa.common.sweep.html","description":"Sweep utilities. Full path: exa.common.sweep Subpackages and modules database_serialization Functions that encode and decode all sweep arguments(different types of sweeps, return parameters, settings,...","content":"Sweep utilities. Full path: exa.common.sweep Subpackages and modules database_serialization Functions that encode and decode all sweep arguments(different types of sweeps, return parameters, settings, etc.). util Generic utilities for converting sweep definitions from user-friendly format to canonic ones. previous QCMDataClient next database_serialization © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa_error","url":"/iqm-exa-common/api/exa.common.errors.exa_error.html","description":"Full path: exa.common.errors.exa_error Exceptions EmptyComponentListError (message, *args) Error raised when an empty list is given as components for running an experiment. ExaError (message, *args) B...","content":"Full path: exa.common.errors.exa_error Exceptions EmptyComponentListError (message, *args) Error raised when an empty list is given as components for running an experiment. ExaError (message, *args) Base class for exa errors. InvalidSweepOptionsTypeError (**kwargs) The type of sweep options is invalid. UnknownSettingError (message, *args) This SettingNode does not have a given key. previous errors next exa.common.errors.exa_error.EmptyComponentListError © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"StartStopBaseOptions","url":"/iqm-exa-common/api/exa.common.control.sweep.option.start_stop_base_options.StartStopBaseOptions.html","description":"Bases: SweepOptions Range generation options. Values are generated over the interval from base power start to base power stop .\\nThe number of values = count . These options are used only for exponenti...","content":"Bases: SweepOptions Range generation options. Values are generated over the interval from base power start to base power stop .\\nThe number of values = count . These options are used only for exponential sweep range. Module: exa.common.control.sweep.option.start_stop_base_options Attributes base Number, that is raised to the power start or stop . count Number of values to generate. data List of values for parameter start The power for the start of the interval. stop The power for the end of the interval. Methods start ( int | float | complex ) – stop ( int | float | complex ) – count ( int | None ) – base ( int | float | None ) – The power for the start of the interval. The power for the end of the interval. Number of values to generate. Default to exa.common.control.sweep.option.constants.DEFAULT_COUNT . Number, that is raised to the power start or stop . Default to exa.common.control.sweep.option.constants.DEFAULT_BASE . List of values for parameter previous start_stop_base_options next start_stop_options © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.errors.server_errors.ValidationError","url":"/iqm-exa-common/api/exa.common.errors.server_errors.ValidationError.html","description":"Error raised when something is unprocessable in general, for example if the input value is not acceptable. message ( str ) – previous exa.common.errors.server_errors.UnauthorizedError next helpers © C...","content":"Error raised when something is unprocessable in general, for example if the input value is not acceptable. message ( str ) – previous exa.common.errors.server_errors.UnauthorizedError next helpers © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"CHAD","url":"/iqm-exa-common/api/exa.common.qcm_data.chad_model.CHAD.html","description":"Bases: ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidate...","content":"Bases: ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes computational_resonator_names Names of all the computational resonators declared in CHAD data. coupler_names Names of all the couplers declared in CHAD data. model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. probe_line_names Names of all the probe lines declared in CHAD data. qubit_names Names of all the qubits declared in CHAD data. mask_set_name  variant  components  Methods filter_qubit_components Filter qubit components from the input components. get_common_coupler_for Convenience method for getting the name of a coupler connecting a pair of components. get_component Get component by component name. get_coupler_mapping_for Get the coupler-component mapping for the couplers that connects to at least two components get_probe_line_mapping_for Get the probe line-component mapping. get_probe_line_names_for Get probe lines for given qubits in CHAD data. group_components_per_default_operations Groups given qubits/couplers based on their defined default operations. mask_set_name ( str ) – variant ( str ) – components ( Components ) – Get component by component name. component_name ( str ) – Component Names of all the qubits declared in CHAD data. Names of all the couplers declared in CHAD data. Names of all the probe lines declared in CHAD data. Names of all the computational resonators declared in CHAD data. Filter qubit components from the input components. component_names ( Collection [ str ] ) – list [ str ] Get probe lines for given qubits in CHAD data. component_names ( Collection [ str ] ) – list [ str ] Groups given qubits/couplers based on their defined default operations. The default operations that can be deducted from a CHAD are readout , drive , and flux . component_names ( Collection [ str ] ) – The component names to which to do the grouping.\\nOther components present in the CHAD will not be included in the returned data. Tuple of qubits and couplers mapped to their connected default operations. The data is in the form of a dict with the keys being readout , drive , and flux ,\\nand the values the list of component names having that particular operation. The data is in the form of a dict with the keys being readout , drive , and flux ,\\nand the values the list of component names having that particular operation. tuple [ dict [ str , list [ str ]], dict [ str , list [ str ]]] in the given qubits. component_names ( Collection [ str ] ) – The qubit names. May contain any number of qubits. Coupler names mapped to the components they connect. - ValueError – If the provided qubit name list contains duplicates. dict [ str , list [ str ]] Get the probe line-component mapping. component_names ( Collection [ str ] ) – The qubit names. May contain any number of qubits. dict [ str , list [ str ]] Convenience method for getting the name of a coupler connecting a pair of components. first_component ( str ) – The name of the first component. second_component ( str ) – The name of the second component.\\nThe order of qubits does not matter, i.e. the first_qubit and second_qubit arguments are interchangeable. The name of the coupler that connects the inputted components. The name of the coupler that connects the inputted components. - ValueError – If there were no couplers or more than one coupler connecting the component pair (the latter\\n    should not be possible in a realistic chip). str Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous chad_model next Component © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.sweep.database_serialization.encode_nd_sweeps","url":"/iqm-exa-common/api/exa.common.sweep.database_serialization.encode_nd_sweeps.html","description":"Encode sweeps to a JSON string. sweeps ( list [ tuple [ Sweep , ... ] ] ) – sweeps to be serialized. kwargs – keyword arguments passed to json.dumps json as a string str previous exa.common.sweep.data...","content":"Encode sweeps to a JSON string. sweeps ( list [ tuple [ Sweep , ... ] ] ) – sweeps to be serialized. kwargs – keyword arguments passed to json.dumps json as a string str previous exa.common.sweep.database_serialization.decode_settings next exa.common.sweep.database_serialization.encode_return_parameters © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"file_adapter","url":"/iqm-exa-common/api/exa.common.qcm_data.file_adapter.html","description":"Full path: exa.common.qcm_data.file_adapter Classes FileAdapter  Inheritance previous ChipTopology next FileAdapter © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26....","content":"Full path: exa.common.qcm_data.file_adapter Classes FileAdapter  Inheritance previous ChipTopology next FileAdapter © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.helpers.yaml_helper.load_yaml","url":"/iqm-exa-common/api/exa.common.helpers.yaml_helper.load_yaml.html","description":"Load a YAML file from the given path and raise error if the file can’t be loaded. path ( Path | str ) – dict [ str , Any ] previous exa.common.helpers.yaml_helper.dump_yaml next logger © Copyright 201...","content":"Load a YAML file from the given path and raise error if the file can’t be loaded. path ( Path | str ) – dict [ str , Any ] previous exa.common.helpers.yaml_helper.dump_yaml next logger © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"fixed_options","url":"/iqm-exa-common/api/exa.common.control.sweep.option.fixed_options.html","description":"Range specification for arbitrary set of values. Full path: exa.common.control.sweep.option.fixed_options Classes FixedOptions Range fixed options. Inheritance previous exa.common.control.sweep.option...","content":"Range specification for arbitrary set of values. Full path: exa.common.control.sweep.option.fixed_options Classes FixedOptions Range fixed options. Inheritance previous exa.common.control.sweep.option.constants.OPTIONS_TYPE next FixedOptions © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"LinearSweep","url":"/iqm-exa-common/api/exa.common.control.sweep.linear_sweep.LinearSweep.html","description":"Bases: Sweep Generates evenly spaced parameter values based on options . If options is instance of StartStopOptions , then start and stop options are used for interval If options is instance of Center...","content":"Bases: Sweep Generates evenly spaced parameter values based on options . If options is instance of StartStopOptions , then start and stop options are used for interval If options is instance of CenterSpanOptions ,\\nthen the start and stop of the interval are calculated from center and span values ValueError – Error is raised if options is inconsistent. parameter ( Parameter ) – options ( StartStopOptions | CenterSpanOptions | None ) – data ( list [ Any ] | ndarray [ Any ] ) – Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.control.sweep.linear_sweep Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. parameter The Sweep represents changing the values of this Parameter. data List of values for parameter Methods Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous linear_sweep next option © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"logger","url":"/iqm-exa-common/api/exa.common.logger.html","description":"Helper to initialize loggers to the specified logging level. Full path: exa.common.logger Subpackages and modules logger  previous exa.common.helpers.yaml_helper.load_yaml next logger © Copyright 2019...","content":"Helper to initialize loggers to the specified logging level. Full path: exa.common.logger Subpackages and modules logger  previous exa.common.helpers.yaml_helper.load_yaml next logger © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.data.value.validate_value","url":"/iqm-exa-common/api/exa.common.data.value.validate_value.html","description":"Validate (i.e. deserialize) JSON serializable value to Python type, to support complex and ndarray types. value ( Any ) – Any previous exa.common.data.value.serialize_value next errors © Copyright 201...","content":"Validate (i.e. deserialize) JSON serializable value to Python type, to support complex and ndarray types. value ( Any ) – Any previous exa.common.data.value.serialize_value next errors © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"util","url":"/iqm-exa-common/api/exa.common.sweep.util.html","description":"Generic utilities for converting sweep definitions from\\nuser-friendly format to canonic ones. Full path: exa.common.sweep.util Functions convert_sweeps_to_list_of_tuples (sweeps) Validate sweeps and c...","content":"Generic utilities for converting sweep definitions from\\nuser-friendly format to canonic ones. Full path: exa.common.sweep.util Functions convert_sweeps_to_list_of_tuples (sweeps) Validate sweeps and convert it to format accepted by the station control. linear_index_sweep (parameter, length) Produce an NdSweep over a dummy index. previous exa.common.sweep.database_serialization.encode_return_parameters next exa.common.sweep.util.convert_sweeps_to_list_of_tuples © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"linear_sweep","url":"/iqm-exa-common/api/exa.common.control.sweep.linear_sweep.html","description":"Sweep specification with linearly spaced values. Full path: exa.common.control.sweep.linear_sweep Classes LinearSweep Generates evenly spaced parameter values based on options . Inheritance previous F...","content":"Sweep specification with linearly spaced values. Full path: exa.common.control.sweep.linear_sweep Classes LinearSweep Generates evenly spaced parameter values based on options . Inheritance previous FixedSweep next LinearSweep © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"Component","url":"/iqm-exa-common/api/exa.common.qcm_data.chad_model.Component.html","description":"Bases: ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidate...","content":"Bases: ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name  connections  Methods sort  name ( str ) – connections ( tuple [ str , ... ] ) – Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous CHAD next Components © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.control.sweep.sweep_values.serialize_sweep_values","url":"/iqm-exa-common/api/exa.common.control.sweep.sweep_values.serialize_sweep_values.html","description":"Serialize sweep values type to JSON serializable type, to support complex types. sweep_values ( Any ) – Any previous sweep_values next exa.common.control.sweep.sweep_values.validate_sweep_values © Cop...","content":"Serialize sweep values type to JSON serializable type, to support complex types. sweep_values ( Any ) – Any previous sweep_values next exa.common.control.sweep.sweep_values.validate_sweep_values © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"CollectionType","url":"/iqm-exa-common/api/exa.common.data.parameter.CollectionType.html","description":"Bases: IntEnum Parameter collection type. Module: exa.common.data.parameter Attributes SCALAR Scalar, not a list of any kind. LIST Python list. NDARRAY Numpy ndarray. Methods cast Cast the given value...","content":"Bases: IntEnum Parameter collection type. Module: exa.common.data.parameter Attributes SCALAR Scalar, not a list of any kind. LIST Python list. NDARRAY Numpy ndarray. Methods cast Cast the given value to this collection type. Scalar, not a list of any kind. Python list. Numpy ndarray. Cast the given value to this collection type. value ( Any ) – Any previous parameter next DataType © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.helpers.numpy_helper.coerce_numpy_type_to_native","url":"/iqm-exa-common/api/exa.common.helpers.numpy_helper.coerce_numpy_type_to_native.html","description":"Convert numpy types to underlying native types, and Windows-specific int32 arrays to int64s. value ( Any ) – Any previous numpy_helper next software_version_helper © Copyright 2019-2025, IQM Finland O...","content":"Convert numpy types to underlying native types, and Windows-specific int32 arrays to int64s. value ( Any ) – Any previous numpy_helper next software_version_helper © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"ProbeLine","url":"/iqm-exa-common/api/exa.common.qcm_data.chad_model.ProbeLine.html","description":"Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form...","content":"Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name  connections  Methods name ( str ) – connections ( tuple [ str , ... ] ) – Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous Launcher next Qubit © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"ChipTopology","url":"/iqm-exa-common/api/exa.common.qcm_data.chip_topology.ChipTopology.html","description":"Bases: object Topology information for a chip (typically a QPU). Can represent the information found in a CHAD, as well as locus mappings for gates. qubits ( Iterable [ str ] ) – names of the qubits. ...","content":"Bases: object Topology information for a chip (typically a QPU). Can represent the information found in a CHAD, as well as locus mappings for gates. qubits ( Iterable [ str ] ) – names of the qubits. computational_resonators ( Iterable [ str ] ) – names of the computational resonators. couplers ( dict [ str , Iterable [ str ] ] ) – mapping from coupler name to names of chip components it connects to. probe_lines ( dict [ str , Iterable [ str ] ] ) – mapping from probe line name to names of chip components it connects to. variant ( str ) – identifier of the QPU design variant. Module: exa.common.qcm_data.chip_topology Attributes computational_resonators Computational resonators on the chip, in any order. computational_resonators_sorted Computational resonators on the chip, sorted. couplers Tunable couplers on the chip, in any order. couplers_sorted Tunable couplers on the chip, sorted by numerical IDs. probe_lines Probe lines on the chip, in any order. probe_lines_sorted Probe lines on the chip, sorted. all_components All components on the chip. coupler_to_components Map from each coupler to all other components it connects to. component_to_couplers Map from each component to all couplers connected to it. probe_line_to_components Map from each probe line to all components it connects to. component_to_probe_line Map from each component to the probeline connected to it. Methods from_chad Construct a ChipTopology instance from a CHAD. from_chip_design_record Construct a ChipTopology instance from a raw Chip design record. get_all_common_resonators Computational resonators connected to all the given qubits via a coupler. get_common_computational_resonator Convenience method for getting the name of a computational resonator which is connected to both specified qubit components via tunable couplers. get_connected_probe_lines Get probelines that are connected to any of the given components. get_connecting_couplers Couplers that only connect to the given chip components, and connect at least two of them. get_coupler_for Common coupler for the given chip components (e.g. qubit or computational resonator). get_loci Gives all the loci of a given gate. get_neighbor_couplers Couplers that connect to at least one of the given chip components. get_neighbor_locus_components Chip components that are connected to the given components by a coupler, but not included in them. is_computational_resonator True iff the given component is a computational resonator. is_coupler True iff the given component is a coupler. is_probe_line True iff the given component is a probe line. is_qubit True iff the given component is a qubit. limit_values Prunes the given dictionary (e.g. a coupler-to-qubits map) to a subset of values. map_locus Returns the mapped components for the given locus and the given gate. map_to_locus Returns the locus that is mapped to the given components. set_locus_mapping Add a custom mapping from a gate locus to a set of components required for the gate operation. Computational resonators on the chip, in any order. Computational resonators on the chip, sorted. Tunable couplers on the chip, in any order. Tunable couplers on the chip, sorted by numerical IDs. Probe lines on the chip, in any order. Probe lines on the chip, sorted. All components on the chip. Map from each coupler to all other components it connects to. The values are sorted. Map from each component to all couplers connected to it. Map from each probe line to all components it connects to. Map from each component to the probeline connected to it.\\nMax 1 connection per component is assumed.\\nComponents without connection to a probe line don’t appear. Construct a ChipTopology instance from a raw Chip design record. record ( dict ) – Record as returned by Station control. Corresponding chip topology ChipTopology Construct a ChipTopology instance from a CHAD. Use from_chip_design_record() if possible. chad ( CHAD ) – parsed CHAD model corresponding chip topology ChipTopology Couplers that connect to at least one of the given chip components. components ( Iterable [ str ] ) – some chip components, typically qubits and computational resonators couplers that connect to at least one of components set [ str ] Couplers that only connect to the given chip components, and connect at least two of them. Equivalent to returning the edges in the components -induced\\nsubgraph of the coupling topology. components ( Collection [ str ] ) – some chip components, typically qubits and computational resonators couplers that connect to only members of components , and to at least two of them set [ str ] Common coupler for the given chip components (e.g. qubit or computational resonator). component_1 ( str ) – first component component_2 ( str ) – second component the common coupler ValueError – the given components have zero or more than one connecting coupler str Chip components that are connected to the given components by a coupler, but not included in them. components ( Collection [ str ] ) – some chip components, typically qubits and computational resonators components that are connected to components by a coupler, but not included in them set [ str ] Get probelines that are connected to any of the given components. components ( Collection [ str ] ) – set [ str ] Prunes the given dictionary (e.g. a coupler-to-qubits map) to a subset of values. Used to prune e.g. coupler_to_components to a subset of relevant elements. dct ( ComponentMap ) – Dictionary of collections of values. limit_to ( Collection [ str ] ) – Components to limit the output to. The input dictionary, but only with key-value pairs where the value intersects with limit_to . ComponentMap True iff the given component is a qubit. component ( str ) – bool True iff the given component is a coupler. component ( str ) – bool True iff the given component is a probe line. component ( str ) – bool True iff the given component is a computational resonator. component ( str ) – bool Add a custom mapping from a gate locus to a set of components required for the gate operation. The mapping is of the form {<locus>: <components mapped to locus>}, where a locus can be mapped to one or more\\ncomponents. The locus itself can be a frozenset (denoting a symmetric gate) or a tuple (non-symmetric gate). Some examples:\\n- DEFAULT_2QB_MAPPING (added in __init__() ) maps pairs of qubits to their common coupler symmetrically.\\n- Fast flux CZ-gate maps pairs of qubits to their couplers non-symmetrically (first locus qubit can perform flux pulses).\\n- A two-qubit gate implementation that includes playing pulses on neighboring components in addition to the connecting coupler. name ( str ) – The name for the gate & implementation this locus mapping represents (typically in the format \\"<gate name>.<implementation name>\\" ). mapping ( dict [ tuple [ str , ... ] | frozenset [ str ] , tuple [ str , ... ] ] ) – The locus mapping to be added. None Validate that the components given in mapping are found in self and the mapping is correctly formed. mapping ( dict [ str | tuple [ str ] , tuple [ str , ... ] | frozenset [ str ] ] | None ) – None Returns the mapped components for the given locus and the given gate. If the locus or the gate is not found from the locus mappings of self, returns None. locus ( tuple [ str , ... ] | frozenset [ str ] ) – The locus to map. name ( str | None ) – The name for the gate & implementation with which to map the locus (typically in the format \\"<gate name>.<implementation name>\\" ). The components mapped to the given locus or None if locus is not found in the given mapping. str | tuple [ str ] | None Returns the locus that is mapped to the given components. mapped ( str | tuple [ str ] ) – The mapped components. name ( str ) – The name for the gate & implementation with which to map the locus (typically in the format \\"<gate name>.<implementation name>\\" ). The locus mapped to the given components or None if the components are not mapped to any locus. tuple [ str , …] | frozenset [ str ] | None Gives all the loci of a given gate. If no mapping with the given the name nor a default mapping with the given dimensionality is found,\\nreturns an empty list. name ( str ) – The name for the gate & implementation with which to map the locus (typically in the format \\"<gate name>.<implementation name>\\" ). default_mapping_dimension ( int | None ) – If provided, will return the loci of the default mapping of the given\\ndimensionality in case no mapping for name can be found. The loci associated with the given gate. list [ tuple [ str , …] | frozenset [ str ]] Convenience method for getting the name of a computational resonator which is connected to both specified\\nqubit components via tunable couplers. first_qubit ( str ) – The name of the first qubit. second_qubit ( str ) – The name of the second qubit. The order of qubits does not matter, i.e. the first_qubit and second_qubit arguments are interchangeable. The name of the second qubit. The order of qubits does not matter, i.e. the first_qubit and second_qubit arguments are interchangeable. The name of the computational resonator that is connected to both inputted qubits via tunable couplers. The name of the computational resonator that is connected to both inputted qubits via tunable couplers. - ValueError – If no computational resonator was found that is connected to both qubits via tunable couplers. – str Computational resonators connected to all the given qubits via a coupler. qubits ( list [ str ] ) – Qubit names. Names of the computational resonators neighboring all of qubits (can be an empty set). set [ str ] previous exa.common.qcm_data.chip_topology.sort_couplers next file_adapter © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"errors","url":"/iqm-exa-common/api/exa.common.errors.html","description":"Common error messages. Full path: exa.common.errors Subpackages and modules exa_error  server_errors Errors used in the client-server communication. previous exa.common.data.value.validate_value next ...","content":"Common error messages. Full path: exa.common.errors Subpackages and modules exa_error  server_errors Errors used in the client-server communication. previous exa.common.data.value.validate_value next exa_error © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.errors.exa_error.InvalidSweepOptionsTypeError","url":"/iqm-exa-common/api/exa.common.errors.exa_error.InvalidSweepOptionsTypeError.html","description":"The type of sweep options is invalid. previous exa.common.errors.exa_error.ExaError next exa.common.errors.exa_error.UnknownSettingError © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last upda...","content":"The type of sweep options is invalid. previous exa.common.errors.exa_error.ExaError next exa.common.errors.exa_error.UnknownSettingError © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.control.sweep.sweep_values.validate_sweep_values","url":"/iqm-exa-common/api/exa.common.control.sweep.sweep_values.validate_sweep_values.html","description":"Validate (i.e. deserialize) JSON serializable sweep values to Python type, to support complex types. sweep_values ( Any ) – Any previous exa.common.control.sweep.sweep_values.serialize_sweep_values ne...","content":"Validate (i.e. deserialize) JSON serializable sweep values to Python type, to support complex types. sweep_values ( Any ) – Any previous exa.common.control.sweep.sweep_values.serialize_sweep_values next data © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.errors.server_errors.StationControlError","url":"/iqm-exa-common/api/exa.common.errors.server_errors.StationControlError.html","description":"Base class for station control errors used in client-server communication. message ( str ) – previous exa.common.errors.server_errors.ServiceUnavailableError next exa.common.errors.server_errors.Unaut...","content":"Base class for station control errors used in client-server communication. message ( str ) – previous exa.common.errors.server_errors.ServiceUnavailableError next exa.common.errors.server_errors.UnauthorizedError © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.data.value.serialize_value","url":"/iqm-exa-common/api/exa.common.data.value.serialize_value.html","description":"Serialize value type to JSON serializable type, to support complex and ndarray types. value ( Any ) – Any previous value next exa.common.data.value.validate_value © Copyright 2019-2025, IQM Finland Oy...","content":"Serialize value type to JSON serializable type, to support complex and ndarray types. value ( Any ) – Any previous value next exa.common.data.value.validate_value © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"sweep_options","url":"/iqm-exa-common/api/exa.common.control.sweep.option.sweep_options.html","description":"Base class for sweep options. Full path: exa.common.control.sweep.option.sweep_options Classes SweepOptions Base immutable class for sweep options. Inheritance previous StartStopOptions next SweepOpti...","content":"Base class for sweep options. Full path: exa.common.control.sweep.option.sweep_options Classes SweepOptions Base immutable class for sweep options. Inheritance previous StartStopOptions next SweepOptions © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"value","url":"/iqm-exa-common/api/exa.common.data.value.html","description":"Full path: exa.common.data.value Functions serialize_value (value) Serialize value type to JSON serializable type, to support complex and ndarray types. validate_value (value) Validate (i.e. deseriali...","content":"Full path: exa.common.data.value Functions serialize_value (value) Serialize value type to JSON serializable type, to support complex and ndarray types. validate_value (value) Validate (i.e. deserialize) JSON serializable value to Python type, to support complex and ndarray types. previous SettingNode next exa.common.data.value.serialize_value © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"ExtraFormatter","url":"/iqm-exa-common/api/exa.common.logger.logger.ExtraFormatter.html","description":"Bases: Formatter Helper formatter class to pass in arbitrary extra information to log messages. Initialize the formatter with specified format strings. Initialize the formatter either with the specifi...","content":"Bases: Formatter Helper formatter class to pass in arbitrary extra information to log messages. Initialize the formatter with specified format strings. Initialize the formatter either with the specified format string, or a\\ndefault as described above. Allow for specialized date formatting with\\nthe optional datefmt argument. If datefmt is omitted, you get an\\nISO8601-like (or RFC 3339-like) format. Use a style parameter of ‘%’, ‘{’ or ‘$’ to specify that you want to\\nuse one of %-formatting, str.format() ( {} ) formatting or string.Template formatting in your format string. Changed in version 3.2: Added the style parameter. Module: exa.common.logger.logger Attributes Methods format Format the specified record as text. extra_info_getter ( Callable [ [ ] , str ] | None ) – Format the specified record as text. The record’s attribute dictionary is used as the operand to a\\nstring formatting operation which yields the returned string.\\nBefore formatting the dictionary, a couple of preparatory steps\\nare carried out. The message attribute of the record is computed\\nusing LogRecord.getMessage(). If the formatting string uses the\\ntime (as determined by a call to usesTime(), formatTime() is\\ncalled to format the event time. If there is exception information,\\nit is formatted using formatException() and appended to the message. previous exa.common.logger.logger.init_loggers next InfoFilter © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"json_helper","url":"/iqm-exa-common/api/exa.common.helpers.json_helper.html","description":"Full path: exa.common.helpers.json_helper Functions decode_json (obj) Custom json decoder for object, in case it is represented as complex number, ndarray or tuple. get_json_encoder () Custom JSON enc...","content":"Full path: exa.common.helpers.json_helper Functions decode_json (obj) Custom json decoder for object, in case it is represented as complex number, ndarray or tuple. get_json_encoder () Custom JSON encoder for complex number, ndarray or tuple previous exa.common.helpers.deprecation.format_deprecated next exa.common.helpers.json_helper.decode_json © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"FixedOptions","url":"/iqm-exa-common/api/exa.common.control.sweep.option.fixed_options.FixedOptions.html","description":"Bases: SweepOptions Range fixed options. Module: exa.common.control.sweep.option.fixed_options Attributes data List of values for parameter fixed List of values. Methods fixed ( list [ Any ] | ndarray...","content":"Bases: SweepOptions Range fixed options. Module: exa.common.control.sweep.option.fixed_options Attributes data List of values for parameter fixed List of values. Methods fixed ( list [ Any ] | ndarray [ Any ] ) – List of values. List of values for parameter previous fixed_options next option_converter © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"parameter","url":"/iqm-exa-common/api/exa.common.data.parameter.html","description":"Physical quantities and instrument settings. A basic data structure in EXA is the Parameter , which represents\\na single variable. The variable can be a high-level or low-level control knob of an instr...","content":"Physical quantities and instrument settings. A basic data structure in EXA is the Parameter , which represents\\na single variable. The variable can be a high-level or low-level control knob of an instrument such as\\nthe amplitude of a pulse or a control voltage; a physical quantity such as resonance frequency; or an abstract concept\\nlike the number of averages in a measurement. The Parameter is a simple structure with a name, label, unit and a datatype without much functionality.\\nThe Setting combines a Parameter and a value of the corresponding type.\\nLike Parameters, Settings are lightweight objects that contain information but don’t do anything by themselves. The Settings are immutable, which means that the value can’t be changed, we can only make a copy with another value.\\nWhen assigning a new value to a Setting, the datatype of the value is validated against the expected datatype of the\\nparameter. Full path: exa.common.data.parameter Classes CollectionType Parameter collection type. DataType Parameter data type. Parameter A basic data structure that represents a single variable. Setting Physical quantity represented as a Parameter attached to a numerical value. Inheritance previous BaseModel next CollectionType © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"sweep","url":"/iqm-exa-common/api/exa.common.control.sweep.sweep.html","description":"Base immutable class for sweeps specifications. Full path: exa.common.control.sweep.sweep Classes Sweep Base immutable class for sweeps. Inheritance previous SweepOptions next Sweep © Copyright 2019-2...","content":"Base immutable class for sweeps specifications. Full path: exa.common.control.sweep.sweep Classes Sweep Base immutable class for sweeps. Inheritance previous SweepOptions next Sweep © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"server_errors","url":"/iqm-exa-common/api/exa.common.errors.server_errors.html","description":"Errors used in the client-server communication. Full path: exa.common.errors.server_errors Exceptions BadRequestError (message, *args) Error raised when the request syntax is invalid or the method is ...","content":"Errors used in the client-server communication. Full path: exa.common.errors.server_errors Exceptions BadRequestError (message, *args) Error raised when the request syntax is invalid or the method is unsupported in general. ConflictError (message, *args) This error happens when there is a conflict with the current state of the resource. ForbiddenError (message, *args) Error raised when the operation is forbidden for the user. InternalServerError (message, *args) Error raised when an unexpected error happened on the server side. NotFoundError (message, *args) Error raised when nothing was found with the given parameters. ServiceUnavailableError (message, *args) Error raised when the service is unavailable. StationControlError (message, *args) Base class for station control errors used in client-server communication. UnauthorizedError (message, *args) Error raised when the user is not authorized. ValidationError (message, *args) Error raised when something is unprocessable in general, for example if the input value is not acceptable. previous exa.common.errors.exa_error.UnknownSettingError next exa.common.errors.server_errors.BadRequestError © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.sweep.database_serialization.decode_settings","url":"/iqm-exa-common/api/exa.common.sweep.database_serialization.decode_settings.html","description":"Deserialize settings from json string json_str ( str ) – JSON representation of settings loaded\\nfrom e.g. persistence deserialized settings SettingNode previous exa.common.sweep.database_serialization...","content":"Deserialize settings from json string json_str ( str ) – JSON representation of settings loaded\\nfrom e.g. persistence deserialized settings SettingNode previous exa.common.sweep.database_serialization.decode_return_parameters next exa.common.sweep.database_serialization.encode_nd_sweeps © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.helpers.json_helper.get_json_encoder","url":"/iqm-exa-common/api/exa.common.helpers.json_helper.get_json_encoder.html","description":"Custom JSON encoder for complex number, ndarray or tuple Can be used in situation when serialization of JSON can be customised\\n(json_encoders config in pydantic models, custom_encoder in jsonable_enco...","content":"Custom JSON encoder for complex number, ndarray or tuple Can be used in situation when serialization of JSON can be customised\\n(json_encoders config in pydantic models, custom_encoder in jsonable_encoder\\nof fastapi, etc.) dict [ Any , Callable [[…], dict [ str , Any ]]] previous exa.common.helpers.json_helper.decode_json next numpy_helper © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"FileAdapter","url":"/iqm-exa-common/api/exa.common.qcm_data.file_adapter.FileAdapter.html","description":"Bases: BaseAdapter Module: exa.common.qcm_data.file_adapter Methods close Cleans up adapter specific items. send Sends PreparedRequest object. Sends PreparedRequest object. Returns Response object. Cl...","content":"Bases: BaseAdapter Module: exa.common.qcm_data.file_adapter Methods close Cleans up adapter specific items. send Sends PreparedRequest object. Sends PreparedRequest object. Returns Response object. Cleans up adapter specific items. previous file_adapter next immutable_base_model © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"StartStopOptions","url":"/iqm-exa-common/api/exa.common.control.sweep.option.start_stop_options.StartStopOptions.html","description":"Bases: SweepOptions Range generation options. Values are generated over the interval from start to stop . For linear sweep range the\\nnumber of generated values can be based either on count or step . I...","content":"Bases: SweepOptions Range generation options. Values are generated over the interval from start to stop . For linear sweep range the\\nnumber of generated values can be based either on count or step . In case count is empty\\nand step is not, step is used for calculating count . For exponential sweep range only count is used. Module: exa.common.control.sweep.option.start_stop_options Attributes count Number of values to generate. data List of values for parameter step Size of spacing between values. start Starting value of interval. stop Stopping value of interval. Methods start ( int | float | complex ) – stop ( int | float | complex ) – count ( int | None ) – step ( int | float | complex | None ) – Starting value of interval. Stopping value of interval. Number of values to generate. Must be non-negative.\\nIf count and step are empty, the default value of count is exa.common.control.sweep.option.constants.DEFAULT_COUNT . Size of spacing between values. Must be non-zero.\\nIf both count and step are not empty, only count is used List of values for parameter previous start_stop_options next sweep_options © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"DataType","url":"/iqm-exa-common/api/exa.common.data.parameter.DataType.html","description":"Bases: IntEnum Parameter data type. Module: exa.common.data.parameter Attributes ANYTHING  FLOAT  COMPLEX  STRING  BOOLEAN  INT  NUMBER  Methods cast  validate  previous CollectionType next Parameter ...","content":"Bases: IntEnum Parameter data type. Module: exa.common.data.parameter Attributes ANYTHING  FLOAT  COMPLEX  STRING  BOOLEAN  INT  NUMBER  Methods cast  validate  previous CollectionType next Parameter © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"Setting","url":"/iqm-exa-common/api/exa.common.data.parameter.Setting.html","description":"Bases: BaseModel Physical quantity represented as a Parameter attached to a numerical value. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][...","content":"Bases: BaseModel Physical quantity represented as a Parameter attached to a numerical value. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.data.parameter Attributes element_indices Element-wise indices of the parameter in self . label Label used as pretty identifier for display purposes, same as label of parameter . model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name Name used as identifier, same as name of parameter . parent_label Parent label of the parameter of self . parent_name Parent name of the parameter of self . unit SI unit of the value , if applicable, same as unit of parameter . parameter The parameter this Setting represents. value Data value attached to the parameter. read_only Indicates if the attribute is read-only. path Path in the settings tree (starting from the root SettingNode ) for this setting. Methods create_element_parameter_for Utility for creating an element-wise parameter for a single value in a collection valued parameter. diff_sets Return a one-sided difference between two sets of Settings, prioritising values in first . get_by_name  merge  remove_by_name  replace  update Create a new setting object with updated value . validate_parameter_value_after  with_path_name Copy of self with the parameter name replaced by the path name. parameter ( Parameter | None ) – value ( ObservationValue | None ) – read_only ( bool ) – path ( str ) – The parameter this Setting represents. Data value attached to the parameter. Indicates if the attribute is read-only. Path in the settings tree (starting from the root SettingNode ) for this setting. Create a new setting object with updated value . value ( bool | str | int | float | complex | ndarray ) – Setting Name used as identifier, same as name of parameter . Parent name of the parameter of self . Label used as pretty identifier for display purposes, same as label of parameter . Parent label of the parameter of self . Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. SI unit of the value , if applicable, same as unit of parameter . Element-wise indices of the parameter in self . Return a one-sided difference between two sets of Settings, prioritising values in first . first ( set [ Setting ] ) – Set whose values will be in the resulting diff. second ( set [ Setting ] ) – Set that is compared to first . A new set of Settings whose parameters are only found in first , and Settings in first whose\\nvalues differ from their counterparts in second . set [ Setting ] Utility for creating an element-wise parameter for a single value in a collection valued parameter. indices ( int | list [ int ] ) – The indices in the collection for which to create the element-wise parameter. The element-wise parameter. ValueError – If self is not collection-valued. Parameter Copy of self with the parameter name replaced by the path name. Setting previous Parameter next setting_node © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.helpers.data_helper.add_data_array","url":"/iqm-exa-common/api/exa.common.helpers.data_helper.add_data_array.html","description":"Add data array da to dataset ds . Unlike the default xarray command, preserves metadata of the dataset. ds ( Dataset ) – Dataset to add to. da ( DataArray ) – DataArray to add name ( str | None ) – na...","content":"Add data array da to dataset ds . Unlike the default xarray command, preserves metadata of the dataset. ds ( Dataset ) – Dataset to add to. da ( DataArray ) – DataArray to add name ( str | None ) – name under which da can be accessed inside ds .\\nBy default, uses the name property of da . The updated dataset. Dataset previous data_helper next deprecation © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"ComputationalResonator","url":"/iqm-exa-common/api/exa.common.qcm_data.chad_model.ComputationalResonator.html","description":"Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form...","content":"Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name  connections  Methods name ( str ) – connections ( tuple [ str , ... ] ) – Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous Components next Coupler © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.qcm_data.chip_topology.sort_couplers","url":"/iqm-exa-common/api/exa.common.qcm_data.chip_topology.sort_couplers.html","description":"Sort the given couplers in a human-readable way. couplers ( Iterable [ str ] ) – list [ str ] previous exa.common.qcm_data.chip_topology.sort_components next ChipTopology © Copyright 2019-2025, IQM Fi...","content":"Sort the given couplers in a human-readable way. couplers ( Iterable [ str ] ) – list [ str ] previous exa.common.qcm_data.chip_topology.sort_components next ChipTopology © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"FixedSweep","url":"/iqm-exa-common/api/exa.common.control.sweep.fixed_sweep.FixedSweep.html","description":"Bases: Sweep A sweep over arbitrary set of values, given by options . Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.Validatio...","content":"Bases: Sweep A sweep over arbitrary set of values, given by options . Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.control.sweep.fixed_sweep Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. parameter The Sweep represents changing the values of this Parameter. data List of values for parameter Methods parameter ( Parameter ) – options ( FixedOptions | None ) – data ( list [ Any ] | ndarray [ Any ] ) – Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous fixed_sweep next linear_sweep © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.sweep.util.convert_sweeps_to_list_of_tuples","url":"/iqm-exa-common/api/exa.common.sweep.util.convert_sweeps_to_list_of_tuples.html","description":"Validate sweeps and convert it to format accepted by the station control. Converts a more convenient sweep definition list to a strict list of tuples of sweeps.\\nThe sweep instances themselves are the ...","content":"Validate sweeps and convert it to format accepted by the station control. Converts a more convenient sweep definition list to a strict list of tuples of sweeps.\\nThe sweep instances themselves are the same, except single sweep instances are turned\\ninto a tuple containing a single sweep. Verify that:\\n* sweeps list element is either Sweep or ParallelSweep\\n* tuple_of_sweep element is a Sweep\\n* tuple of sweeps contains at least one element\\n* length of a data is identical in all tuples of sweeps sweeps ( list [ Sweep | tuple [ Sweep , ... ] ] ) – More user-friendly definition of a list of sweeps. List of tuples of sweeps. ValueError if sweeps parameter does not follow the contract. – list [ tuple [ Sweep , …]] previous util next exa.common.sweep.util.linear_index_sweep © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"option_converter","url":"/iqm-exa-common/api/exa.common.control.sweep.option.option_converter.html","description":"Helper to create a SweepOptions instance from a dict. Full path: exa.common.control.sweep.option.option_converter Functions convert_to_options (config) Creates one of the options object based on confi...","content":"Helper to create a SweepOptions instance from a dict. Full path: exa.common.control.sweep.option.option_converter Functions convert_to_options (config) Creates one of the options object based on configuration dictionary. previous FixedOptions next exa.common.control.sweep.option.option_converter.convert_to_options © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.helpers.json_helper.decode_json","url":"/iqm-exa-common/api/exa.common.helpers.json_helper.decode_json.html","description":"Custom json decoder for object, in case it is represented as\\ncomplex number, ndarray or tuple.\\nOtherwise decoder won’t be applied Here is an example of encoded/decoded json with complex number and nda...","content":"Custom json decoder for object, in case it is represented as\\ncomplex number, ndarray or tuple.\\nOtherwise decoder won’t be applied Here is an example of encoded/decoded json with complex number and ndarray: obj ( Any ) – Any previous json_helper next exa.common.helpers.json_helper.get_json_encoder © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.helpers.software_version_helper.get_all_software_versions","url":"/iqm-exa-common/api/exa.common.helpers.software_version_helper.get_all_software_versions.html","description":"Get all available software version information. Currently, this function collects all Python package versions and Python interpreter version. reload_module ( bool ) – Whether to reload the pkg_resourc...","content":"Get all available software version information. Currently, this function collects all Python package versions and Python interpreter version. reload_module ( bool ) – Whether to reload the pkg_resources module or not. By default,\\nit is disabled because reloading the module is not thread safe!\\nThis function should be called with reload_module=True when IPython autoreload is in use. dict [ str , str ] Example You have numpy==1.21.0 installed, and in the notebook you have executed the following IPython magic: You install numpy==1.21.1 You call this function with reload_module=False . This will result in some warning printouts and\\nthe function will succeed by returning 1.21.0 for numpy, which is wrong because in reality IPython\\nautoreload has reloaded the newly installed numpy 1.21.1.\\nWith reload_module=True the correct version 1.21.1 is returned and no warnings are printed. information. A package’s version information contains the base version, and the string\\n“(local editable)” in the case the package is a local editable installation. previous software_version_helper next exa.common.helpers.software_version_helper.get_vcs_description © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.helpers.software_version_helper.get_vcs_description","url":"/iqm-exa-common/api/exa.common.helpers.software_version_helper.get_vcs_description.html","description":"Get Version Control System (VCS) description for the caller’s current working directory. The description is used to verify if a directory is installed under VCS and whether changes to the files have\\nb...","content":"Get Version Control System (VCS) description for the caller’s current working directory. The description is used to verify if a directory is installed under VCS and whether changes to the files have\\nbeen made. First, the existence of .git directory will be checked from root_directory .\\nOnly if it exists, a git command is executed in a subprocess with a timeout\\nof 1 seconds as the best effort only. The path to the directory where the command will be executed. For instance when called from\\nexa-experiment, it can be the exa-experiment root directory or any directory under it. If root_directory is not installed under git, None will be returned. Otherwise, the output of git describe --dirty --tags --long is returned. In case of errors in executing the command, the caught subprocess.CalledProcessError will be converted to string and returned. If the command fails or timeouts , an exception will be raised directly from subprocess.check_output. – root_directory ( str ) – str | None previous exa.common.helpers.software_version_helper.get_all_software_versions next yaml_helper © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"sweep","url":"/iqm-exa-common/api/exa.common.control.sweep.html","description":"Classes for sweep specification. Full path: exa.common.control.sweep Subpackages and modules exponential_sweep Sweep specification with exponentially spaced values. fixed_sweep Sweep specification wit...","content":"Classes for sweep specification. Full path: exa.common.control.sweep Subpackages and modules exponential_sweep Sweep specification with exponentially spaced values. fixed_sweep Sweep specification with arbitrary values. linear_sweep Sweep specification with linearly spaced values. option Range specifications for Sweeps. sweep Base immutable class for sweeps specifications. sweep_values Pydantic compatible annotated class for sweep values. previous control next exponential_sweep © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.sweep.database_serialization.encode_return_parameters","url":"/iqm-exa-common/api/exa.common.sweep.database_serialization.encode_return_parameters.html","description":"Encode sweeps to a JSON string. return_parameters ( dict [ Parameter , list [ tuple [ Sweep , ... ] ] | None ] ) – Return parameters as specified by sweep() . kwargs – keyword arguments passed to json...","content":"Encode sweeps to a JSON string. return_parameters ( dict [ Parameter , list [ tuple [ Sweep , ... ] ] | None ] ) – Return parameters as specified by sweep() . kwargs – keyword arguments passed to json.dumps json as a string str previous exa.common.sweep.database_serialization.encode_nd_sweeps next util © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"Qubit","url":"/iqm-exa-common/api/exa.common.qcm_data.chad_model.Qubit.html","description":"Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form...","content":"Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name  connections  Methods name ( str ) – connections ( tuple [ str , ... ] ) – Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous ProbeLine next chip_topology © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"control","url":"/iqm-exa-common/api/exa.common.control.html","description":"Common data structures of abstract instrument control. Full path: exa.common.control Subpackages and modules sweep Classes for sweep specification. previous api next sweep © Copyright 2019-2025, IQM F...","content":"Common data structures of abstract instrument control. Full path: exa.common.control Subpackages and modules sweep Classes for sweep specification. previous api next sweep © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"base_model","url":"/iqm-exa-common/api/exa.common.data.base_model.html","description":"Full path: exa.common.data.base_model Classes BaseModel Pydantic base model to change the behaviour of pydantic globally. Inheritance previous data next BaseModel © Copyright 2019-2025, IQM Finland Oy...","content":"Full path: exa.common.data.base_model Classes BaseModel Pydantic base model to change the behaviour of pydantic globally. Inheritance previous data next BaseModel © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.errors.server_errors.ForbiddenError","url":"/iqm-exa-common/api/exa.common.errors.server_errors.ForbiddenError.html","description":"Error raised when the operation is forbidden for the user. message ( str ) – previous exa.common.errors.server_errors.ConflictError next exa.common.errors.server_errors.InternalServerError © Copyright...","content":"Error raised when the operation is forbidden for the user. message ( str ) – previous exa.common.errors.server_errors.ConflictError next exa.common.errors.server_errors.InternalServerError © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"sweep_values","url":"/iqm-exa-common/api/exa.common.control.sweep.sweep_values.html","description":"Pydantic compatible annotated class for sweep values. Full path: exa.common.control.sweep.sweep_values Functions serialize_sweep_values (sweep_values) Serialize sweep values type to JSON serializable ...","content":"Pydantic compatible annotated class for sweep values. Full path: exa.common.control.sweep.sweep_values Functions serialize_sweep_values (sweep_values) Serialize sweep values type to JSON serializable type, to support complex types. validate_sweep_values (sweep_values) Validate (i.e. deserialize) JSON serializable sweep values to Python type, to support complex types. previous Sweep next exa.common.control.sweep.sweep_values.serialize_sweep_values © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.control.sweep.option.constants.DEFAULT_COUNT","url":"/iqm-exa-common/api/exa.common.control.sweep.option.constants.DEFAULT_COUNT.html","description":"Default value for count value in options. previous constants next exa.common.control.sweep.option.constants.DEFAULT_BASE © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-2...","content":"Default value for count value in options. previous constants next exa.common.control.sweep.option.constants.DEFAULT_BASE © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.errors.server_errors.BadRequestError","url":"/iqm-exa-common/api/exa.common.errors.server_errors.BadRequestError.html","description":"Error raised when the request syntax is invalid or the method is unsupported in general. message ( str ) – previous server_errors next exa.common.errors.server_errors.ConflictError © Copyright 2019-20...","content":"Error raised when the request syntax is invalid or the method is unsupported in general. message ( str ) – previous server_errors next exa.common.errors.server_errors.ConflictError © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.errors.server_errors.UnauthorizedError","url":"/iqm-exa-common/api/exa.common.errors.server_errors.UnauthorizedError.html","description":"Error raised when the user is not authorized. message ( str ) – previous exa.common.errors.server_errors.StationControlError next exa.common.errors.server_errors.ValidationError © Copyright 2019-2025,...","content":"Error raised when the user is not authorized. message ( str ) – previous exa.common.errors.server_errors.StationControlError next exa.common.errors.server_errors.ValidationError © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"option","url":"/iqm-exa-common/api/exa.common.control.sweep.option.html","description":"Range specifications for Sweeps. Full path: exa.common.control.sweep.option Subpackages and modules center_span_base_options Range specification used with exponential sweeps. center_span_options Range...","content":"Range specifications for Sweeps. Full path: exa.common.control.sweep.option Subpackages and modules center_span_base_options Range specification used with exponential sweeps. center_span_options Range specification to define a range around a center value. constants Helper constants for SweepOptions classes. fixed_options Range specification for arbitrary set of values. option_converter Helper to create a SweepOptions instance from a dict. start_stop_base_options Range specification used with exponential sweeps. start_stop_options Range specification to define a linearly spaced interval. sweep_options Base class for sweep options. previous LinearSweep next center_span_base_options © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"Launcher","url":"/iqm-exa-common/api/exa.common.qcm_data.chad_model.Launcher.html","description":"Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form...","content":"Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. pin  function  name  connections  Methods name ( str ) – connections ( tuple [ str , ... ] ) – pin ( str ) – function ( str ) – Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous Coupler next ProbeLine © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.sweep.util.linear_index_sweep","url":"/iqm-exa-common/api/exa.common.sweep.util.linear_index_sweep.html","description":"Produce an NdSweep over a dummy index. Can be used in places where a “hardware sweep” is needed but not really meaningful. parameter ( Parameter ) – Data parameter this index is for. length ( int ) – ...","content":"Produce an NdSweep over a dummy index. Can be used in places where a “hardware sweep” is needed but not really meaningful. parameter ( Parameter ) – Data parameter this index is for. length ( int ) – Number of integers in the dummy sweep. A linear sweep over a parameter whose name is parameter.name + _index and whose data ranges from 0 to length with steps of 1. list [ tuple [ Sweep ]] previous exa.common.sweep.util.convert_sweeps_to_list_of_tuples next Changelog © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exponential_sweep","url":"/iqm-exa-common/api/exa.common.control.sweep.exponential_sweep.html","description":"Sweep specification with exponentially spaced values. Full path: exa.common.control.sweep.exponential_sweep Classes ExponentialSweep Generates parameter values spaced evenly on a geometric progression...","content":"Sweep specification with exponentially spaced values. Full path: exa.common.control.sweep.exponential_sweep Classes ExponentialSweep Generates parameter values spaced evenly on a geometric progression based on options . Inheritance previous sweep next ExponentialSweep © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"ExponentialSweep","url":"/iqm-exa-common/api/exa.common.control.sweep.exponential_sweep.ExponentialSweep.html","description":"Bases: Sweep Generates parameter values spaced evenly on a geometric progression based on options . If options is instance of StartStopBaseOptions ,\\nthe start and stop of the interval are calculated f...","content":"Bases: Sweep Generates parameter values spaced evenly on a geometric progression based on options . If options is instance of StartStopBaseOptions ,\\nthe start and stop of the interval are calculated from powers of start and stop. If options is instance of CenterSpanBaseOptions ,\\nthe start and stop of the interval are calculated from powers of start and stop,\\nwhich are derived from center and span. ValueError – Error is raised if options is inconsistent. parameter ( Parameter ) – options ( StartStopBaseOptions | CenterSpanBaseOptions | None ) – data ( list [ Any ] | ndarray [ Any ] ) – Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.control.sweep.exponential_sweep Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. parameter The Sweep represents changing the values of this Parameter. data List of values for parameter Methods Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous exponential_sweep next fixed_sweep © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.helpers.yaml_helper.dump_yaml","url":"/iqm-exa-common/api/exa.common.helpers.yaml_helper.dump_yaml.html","description":"Dump a YAML data to the given path. Create missing directories if necessary. data ( dict [ str , Any ] ) – path ( Path | str ) – None previous yaml_helper next exa.common.helpers.yaml_helper.load_yaml...","content":"Dump a YAML data to the given path. Create missing directories if necessary. data ( dict [ str , Any ] ) – path ( Path | str ) – None previous yaml_helper next exa.common.helpers.yaml_helper.load_yaml © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"start_stop_options","url":"/iqm-exa-common/api/exa.common.control.sweep.option.start_stop_options.html","description":"Range specification to define a linearly spaced interval. Full path: exa.common.control.sweep.option.start_stop_options Classes StartStopOptions Range generation options. Inheritance previous StartSto...","content":"Range specification to define a linearly spaced interval. Full path: exa.common.control.sweep.option.start_stop_options Classes StartStopOptions Range generation options. Inheritance previous StartStopBaseOptions next StartStopOptions © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"ImmutableBaseModel","url":"/iqm-exa-common/api/exa.common.qcm_data.immutable_base_model.ImmutableBaseModel.html","description":"Bases: BaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form...","content":"Bases: BaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.immutable_base_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Methods Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous immutable_base_model next qcm_data_client © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.sweep.database_serialization.decode_and_validate_sweeps","url":"/iqm-exa-common/api/exa.common.sweep.database_serialization.decode_and_validate_sweeps.html","description":"Decodes and validates json string of list of Sweeps and tuples of Sweeps. sweeps_json ( str ) – json string of nested structure of Sweep objects list of sweeps and tuples of sweeps ValueError if decod...","content":"Decodes and validates json string of list of Sweeps and tuples of Sweeps. sweeps_json ( str ) – json string of nested structure of Sweep objects list of sweeps and tuples of sweeps ValueError if decoded result is not expected return type – list [ Sweep | tuple [ Sweep , …]] previous database_serialization next exa.common.sweep.database_serialization.decode_return_parameters © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"Coupler","url":"/iqm-exa-common/api/exa.common.qcm_data.chad_model.Coupler.html","description":"Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form...","content":"Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name  connections  Methods name ( str ) – connections ( tuple [ str , ... ] ) – Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous ComputationalResonator next Launcher © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"fixed_sweep","url":"/iqm-exa-common/api/exa.common.control.sweep.fixed_sweep.html","description":"Sweep specification with arbitrary values. Full path: exa.common.control.sweep.fixed_sweep Classes FixedSweep A sweep over arbitrary set of values, given by options . Inheritance previous ExponentialS...","content":"Sweep specification with arbitrary values. Full path: exa.common.control.sweep.fixed_sweep Classes FixedSweep A sweep over arbitrary set of values, given by options . Inheritance previous ExponentialSweep next FixedSweep © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"center_span_base_options","url":"/iqm-exa-common/api/exa.common.control.sweep.option.center_span_base_options.html","description":"Range specification used with exponential sweeps. Full path: exa.common.control.sweep.option.center_span_base_options Classes CenterSpanBaseOptions Range generation options. Inheritance previous optio...","content":"Range specification used with exponential sweeps. Full path: exa.common.control.sweep.option.center_span_base_options Classes CenterSpanBaseOptions Range generation options. Inheritance previous option next CenterSpanBaseOptions © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"QCMDataClient","url":"/iqm-exa-common/api/exa.common.qcm_data.qcm_data_client.QCMDataClient.html","description":"Bases: object Python client for QCM (Quantum Computer Management) Data API. root_url ( str ) – URL pointing to QCM Data service.\\nThis URL can point to a local file storage as well.\\nIn that case, the U...","content":"Bases: object Python client for QCM (Quantum Computer Management) Data API. root_url ( str ) – URL pointing to QCM Data service.\\nThis URL can point to a local file storage as well.\\nIn that case, the URL should point to a directory which\\nhas a directory structure identical to QCM Data service (for example /chip-data-records/),\\nand files containing data in identical format returned by QCM Data service.\\nFor example, CHAD files should be named {chip_label}.json, like M156_W531_A09_L09.json, and contain\\na list instead of a single object. fallback_root_url ( str ) – Same as root_url , used if a query via root_url returns nothing. Module: exa.common.qcm_data.qcm_data_client Attributes root_url Returns the remote QCM Data service URL. Methods get_chip_design_record Get a raw chip design record matching the given chip label. Returns the remote QCM Data service URL. Get a raw chip design record matching the given chip label. chip_label ( str ) – Chip label. Data record matching the given chip label. dict previous qcm_data_client next sweep © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.errors.exa_error.UnknownSettingError","url":"/iqm-exa-common/api/exa.common.errors.exa_error.UnknownSettingError.html","description":"This SettingNode does not have a given key. message ( str ) – previous exa.common.errors.exa_error.InvalidSweepOptionsTypeError next server_errors © Copyright 2019-2025, IQM Finland Oy, Release 26.14....","content":"This SettingNode does not have a given key. message ( str ) – previous exa.common.errors.exa_error.InvalidSweepOptionsTypeError next server_errors © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"start_stop_base_options","url":"/iqm-exa-common/api/exa.common.control.sweep.option.start_stop_base_options.html","description":"Range specification used with exponential sweeps. Full path: exa.common.control.sweep.option.start_stop_base_options Classes StartStopBaseOptions Range generation options. Inheritance previous exa.com...","content":"Range specification used with exponential sweeps. Full path: exa.common.control.sweep.option.start_stop_base_options Classes StartStopBaseOptions Range generation options. Inheritance previous exa.common.control.sweep.option.option_converter.convert_to_options next StartStopBaseOptions © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.errors.server_errors.ServiceUnavailableError","url":"/iqm-exa-common/api/exa.common.errors.server_errors.ServiceUnavailableError.html","description":"Error raised when the service is unavailable. message ( str ) – previous exa.common.errors.server_errors.NotFoundError next exa.common.errors.server_errors.StationControlError © Copyright 2019-2025, I...","content":"Error raised when the service is unavailable. message ( str ) – previous exa.common.errors.server_errors.NotFoundError next exa.common.errors.server_errors.StationControlError © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.errors.server_errors.ConflictError","url":"/iqm-exa-common/api/exa.common.errors.server_errors.ConflictError.html","description":"This error happens when there is a conflict with the current state of the resource. For example, when doing duplicate submissions for the same unique data. message ( str ) – previous exa.common.errors...","content":"This error happens when there is a conflict with the current state of the resource. For example, when doing duplicate submissions for the same unique data. message ( str ) – previous exa.common.errors.server_errors.BadRequestError next exa.common.errors.server_errors.ForbiddenError © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"BaseModel","url":"/iqm-exa-common/api/exa.common.data.base_model.BaseModel.html","description":"Bases: BaseModel Pydantic base model to change the behaviour of pydantic globally.\\nNote that setting model_config in child classes will merge the configs rather than override this one. https://docs.py...","content":"Bases: BaseModel Pydantic base model to change the behaviour of pydantic globally.\\nNote that setting model_config in child classes will merge the configs rather than override this one. https://docs.pydantic.dev/latest/concepts/config/#change-behaviour-globally Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.data.base_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Methods copy Returns a copy of the model. model_copy Returns a copy of the model. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Returns a copy of the model. Overrides the Pydantic default ‘model_copy’ to set ‘deep=True’ by default. update ( dict [ str , Any ] | None ) – deep ( bool ) – Self Returns a copy of the model. Self previous base_model next parameter © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"chip_topology","url":"/iqm-exa-common/api/exa.common.qcm_data.chip_topology.html","description":"Chip topology class for parsing CHAD and other QPU related data into human-usable form. Full path: exa.common.qcm_data.chip_topology Functions sort_components (components) Sort the given components in...","content":"Chip topology class for parsing CHAD and other QPU related data into human-usable form. Full path: exa.common.qcm_data.chip_topology Functions sort_components (components) Sort the given components in a human-readable way. sort_couplers (couplers) Sort the given couplers in a human-readable way. Classes ChipTopology Topology information for a chip (typically a QPU). Inheritance previous Qubit next exa.common.qcm_data.chip_topology.sort_components © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"logger","url":"/iqm-exa-common/api/exa.common.logger.logger.html","description":"Full path: exa.common.logger.logger Functions init_loggers ([loggers, default_level, ...]) Set the log level of given logger names. Classes ExtraFormatter Helper formatter class to pass in arbitrary e...","content":"Full path: exa.common.logger.logger Functions init_loggers ([loggers, default_level, ...]) Set the log level of given logger names. Classes ExtraFormatter Helper formatter class to pass in arbitrary extra information to log messages. InfoFilter Helper class to filter log messages above INFO level. Inheritance previous logger next exa.common.logger.logger.init_loggers © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.errors.server_errors.NotFoundError","url":"/iqm-exa-common/api/exa.common.errors.server_errors.NotFoundError.html","description":"Error raised when nothing was found with the given parameters. This should be used when it’s expected that something is found, for example when trying to find with an exact ID. message ( str ) – previ...","content":"Error raised when nothing was found with the given parameters. This should be used when it’s expected that something is found, for example when trying to find with an exact ID. message ( str ) – previous exa.common.errors.server_errors.InternalServerError next exa.common.errors.server_errors.ServiceUnavailableError © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"qcm_data_client","url":"/iqm-exa-common/api/exa.common.qcm_data.qcm_data_client.html","description":"QCM (Quantum Computer Management) Data API client implementation. Full path: exa.common.qcm_data.qcm_data_client Classes QCMDataClient Python client for QCM (Quantum Computer Management) Data API. Inh...","content":"QCM (Quantum Computer Management) Data API client implementation. Full path: exa.common.qcm_data.qcm_data_client Classes QCMDataClient Python client for QCM (Quantum Computer Management) Data API. Inheritance previous ImmutableBaseModel next QCMDataClient © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"SweepOptions","url":"/iqm-exa-common/api/exa.common.control.sweep.option.sweep_options.SweepOptions.html","description":"Bases: object Base immutable class for sweep options. Module: exa.common.control.sweep.option.sweep_options Attributes data List of values for parameter Methods List of values for parameter previous s...","content":"Bases: object Base immutable class for sweep options. Module: exa.common.control.sweep.option.sweep_options Attributes data List of values for parameter Methods List of values for parameter previous sweep_options next sweep © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"CenterSpanBaseOptions","url":"/iqm-exa-common/api/exa.common.control.sweep.option.center_span_base_options.CenterSpanBaseOptions.html","description":"Bases: SweepOptions Range generation options. Values are generated over the interval from base power start of the range\\nwith the center center and the size of span to base power end of the range\\nwith ...","content":"Bases: SweepOptions Range generation options. Values are generated over the interval from base power start of the range\\nwith the center center and the size of span to base power end of the range\\nwith the center center and the size of span . The number of values = count .\\nThese options are used only for exponential sweep range. Module: exa.common.control.sweep.option.center_span_base_options Attributes asc Order of generated values. base  count Number of values to generate. data List of values for parameter center Value of interval center for the power. span Size of the interval for the power Methods center ( int | float ) – span ( int | float ) – count ( int | None ) – base ( int | float | None ) – asc ( bool | None ) – Value of interval center for the power. Size of the interval for the power Number of values to generate. Default to exa.common.control.sweep.option.constants.DEFAULT_COUNT . Order of generated values. Default to ascending List of values for parameter previous center_span_base_options next center_span_options © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.control.sweep.option.constants.OPTIONS_TYPE","url":"/iqm-exa-common/api/exa.common.control.sweep.option.constants.OPTIONS_TYPE.html","description":"Dictionary with all possible types of options previous exa.common.control.sweep.option.constants.DEFAULT_BASE next fixed_options © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2...","content":"Dictionary with all possible types of options previous exa.common.control.sweep.option.constants.DEFAULT_BASE next fixed_options © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"Components","url":"/iqm-exa-common/api/exa.common.qcm_data.chad_model.Components.html","description":"Bases: ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidate...","content":"Bases: ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes all  model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. qubits  couplers  probe_lines  launchers  computational_resonators  Methods sort_components  qubit ( tuple [ Qubit , ... ] ) – tunable_coupler ( tuple [ Coupler , ... ] ) – probe_line ( tuple [ ProbeLine , ... ] ) – launcher ( tuple [ Launcher , ... ] ) – computational_resonator ( tuple [ ComputationalResonator , ... ] ) – Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous Component next ComputationalResonator © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"constants","url":"/iqm-exa-common/api/exa.common.control.sweep.option.constants.html","description":"Helper constants for SweepOptions classes. Full path: exa.common.control.sweep.option.constants Module Attributes DEFAULT_COUNT Default value for count value in options. DEFAULT_BASE Default value for...","content":"Helper constants for SweepOptions classes. Full path: exa.common.control.sweep.option.constants Module Attributes DEFAULT_COUNT Default value for count value in options. DEFAULT_BASE Default value for base value in options. OPTIONS_TYPE Dictionary with all possible types of options previous CenterSpanOptions next exa.common.control.sweep.option.constants.DEFAULT_COUNT © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"deprecation","url":"/iqm-exa-common/api/exa.common.helpers.deprecation.html","description":"Full path: exa.common.helpers.deprecation Functions format_deprecated (old, new, since)  previous exa.common.helpers.data_helper.add_data_array next exa.common.helpers.deprecation.format_deprecated © ...","content":"Full path: exa.common.helpers.deprecation Functions format_deprecated (old, new, since)  previous exa.common.helpers.data_helper.add_data_array next exa.common.helpers.deprecation.format_deprecated © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.qcm_data.chip_topology.sort_components","url":"/iqm-exa-common/api/exa.common.qcm_data.chip_topology.sort_components.html","description":"Sort the given components in a human-readable way. components ( Iterable [ str ] ) – list [ str ] previous chip_topology next exa.common.qcm_data.chip_topology.sort_couplers © Copyright 2019-2025, IQM...","content":"Sort the given components in a human-readable way. components ( Iterable [ str ] ) – list [ str ] previous chip_topology next exa.common.qcm_data.chip_topology.sort_couplers © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"Sweep","url":"/iqm-exa-common/api/exa.common.control.sweep.sweep.Sweep.html","description":"Bases: BaseModel Base immutable class for sweeps. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input...","content":"Bases: BaseModel Base immutable class for sweeps. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.control.sweep.sweep Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. parameter The Sweep represents changing the values of this Parameter. data List of values for parameter Methods model_post_init Override this method to perform additional initialization after __init__ and model_construct . parameter ( Parameter ) – options ( SweepOptions | None ) – data ( list [ Any ] | ndarray [ Any ] ) – The Sweep represents changing the values of this Parameter. List of values for parameter Override this method to perform additional initialization after __init__ and model_construct .\\nThis is useful if you want to do some validation that requires the entire model to be initialized. _Sweep__context ( Any ) – None Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous sweep next sweep_values © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.errors.exa_error.ExaError","url":"/iqm-exa-common/api/exa.common.errors.exa_error.ExaError.html","description":"Base class for exa errors. message ( str ) – Error message. previous exa.common.errors.exa_error.EmptyComponentListError next exa.common.errors.exa_error.InvalidSweepOptionsTypeError © Copyright 2019-...","content":"Base class for exa errors. message ( str ) – Error message. previous exa.common.errors.exa_error.EmptyComponentListError next exa.common.errors.exa_error.InvalidSweepOptionsTypeError © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"database_serialization","url":"/iqm-exa-common/api/exa.common.sweep.database_serialization.html","description":"Functions that encode and decode all sweep arguments(different types of\\nsweeps, return parameters, settings, etc.). The module provides functions for\\nserializing and deserializing sweep arguments befo...","content":"Functions that encode and decode all sweep arguments(different types of\\nsweeps, return parameters, settings, etc.). The module provides functions for\\nserializing and deserializing sweep arguments before saving them to database. Full path: exa.common.sweep.database_serialization Functions decode_and_validate_sweeps (sweeps_json) Decodes and validates json string of list of Sweeps and tuples of Sweeps. decode_return_parameters (json_str) Deserialize return parameters. decode_settings (json_str) Deserialize settings from json string encode_nd_sweeps (sweeps, **kwargs) Encode sweeps to a JSON string. encode_return_parameters (return_parameters, ...) Encode sweeps to a JSON string. previous sweep next exa.common.sweep.database_serialization.decode_and_validate_sweeps © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"api","url":"/iqm-exa-common/api/exa.common.api.html","description":"API helpers. Full path: exa.common.api Subpackages and modules previous common next control © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26....","content":"API helpers. Full path: exa.common.api Subpackages and modules previous common next control © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"numpy_helper","url":"/iqm-exa-common/api/exa.common.helpers.numpy_helper.html","description":"Coercion of numpy types. Full path: exa.common.helpers.numpy_helper Functions coerce_numpy_type_to_native (value) Convert numpy types to underlying native types, and Windows-specific int32 arrays to i...","content":"Coercion of numpy types. Full path: exa.common.helpers.numpy_helper Functions coerce_numpy_type_to_native (value) Convert numpy types to underlying native types, and Windows-specific int32 arrays to int64s. previous exa.common.helpers.json_helper.get_json_encoder next exa.common.helpers.numpy_helper.coerce_numpy_type_to_native © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"helpers","url":"/iqm-exa-common/api/exa.common.helpers.html","description":"Miscellaneous helper functionality. Full path: exa.common.helpers Subpackages and modules data_helper  deprecation  json_helper  numpy_helper Coercion of numpy types. software_version_helper  yaml_hel...","content":"Miscellaneous helper functionality. Full path: exa.common.helpers Subpackages and modules data_helper  deprecation  json_helper  numpy_helper Coercion of numpy types. software_version_helper  yaml_helper YAML utilities. previous exa.common.errors.server_errors.ValidationError next data_helper © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.logger.logger.init_loggers","url":"/iqm-exa-common/api/exa.common.logger.logger.init_loggers.html","description":"Set the log level of given logger names. Logs with INFO or DEBUG logging levels are written into stdout, and logs with other levels are written into stderr. By default, the root logger uses WARNING le...","content":"Set the log level of given logger names. Logs with INFO or DEBUG logging levels are written into stdout, and logs with other levels are written into stderr. By default, the root logger uses WARNING level. See Python’s logging module for possible logging levels. loggers ( dict [ str , str | None ] | None ) – A mapping from logger name to (case insensitive) logging level. If logging level is None or empty\\nstring, default_level will be used for that logger. It is possible to fine tune logging for individual\\nmodules, since logger propagation is turned off. Overriding works both ways: a parent logger can have higher\\nlogging level than its descendants, and vice versa.\\nFor example, {\\"sqlalchemy\\": None, \\"sqlalchemy.engine\\": \\"debug\\"} will put\\n“sqlalchemy” and its descendants (i.e. “sqlalchemy.dialects”, “sqlalchemy.dialects.sqlite”, etc.) into default_level , except for “sqlalchemy.engine” for which DEBUG level is defined.\\nFor the root logger, use empty string key, for example: {\\"\\": \\"INFO\\"} .\\nIf empty dict or None is given, only the root logger will be initialized to its default WARNING level. default_level ( str ) – The default level (case insensitive) to be used for logger names given with loggers for which a level is not specified. verbose ( bool ) – If False, :const: BRIEF format will be used for log messages, otherwise :const: VERBOSE . extra_info_getter ( Callable [ [ ] , str ] | None ) – Optional callable to convey extra information to log messages. It will get called before\\neach log message emission and the output will get appended to the log message. None previous logger next ExtraFormatter © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"SettingNode","url":"/iqm-exa-common/api/exa.common.data.setting_node.SettingNode.html","description":"Bases: BaseModel A tree-structured Setting container. Each child of the node is a Setting , or another SettingNode .\\nIterating over the node returns all children, recursively.\\nSettings can be accessed...","content":"Bases: BaseModel A tree-structured Setting container. Each child of the node is a Setting , or another SettingNode .\\nIterating over the node returns all children, recursively.\\nSettings can be accessed by dictionary syntax or attribute syntax: name ( str ) – Name of the node. settings ( dict [ str , Any ] | None ) – Dict of setting path fraqment names (usually the same as the setting name) to the settings. Mostly\\nused when deserialising and otherwise left empty. subtrees ( dict [ str , Any ] | None ) – Dict of child node path fraqment names (usually the same as the child node name) to the settings.\\nMostly used when deserialising and otherwise left empty. path ( str ) – Optionally give a path for the node, by default empty. generate_paths ( bool ) – If set True , all subnodes will get their paths autogenerated correctly. Only set to False if the subnodes already have correct paths set (e.g. when deserialising). kwargs – The children given as keyword arguments. Each argument must be a Setting , Parameter , or a SettingNode . The keywords are used as the names of the nodes.\\nParameters will be cast into Settings with the value None . align_name ( bool ) – Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.data.setting_node Attributes all_settings Yields all Setting instances inside this node, recursively. child_nodes ItemsView of immediate child nodes of this node. child_settings ItemsView of settings of this node. children Dictionary of immediate child nodes of this node. model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name  settings  subtrees  path  align_name  Methods add_for_path Add nodes to self while creating the missing nodes in-between. diff Recursive diff between two SettingNodes. find_by_name Find first occurrence of Setting or SettingNode by name, by iterating recursively through all children. get_default_implementation_name Get the default implementation name for a given gate and locus. get_gate_node_for_locus Get the gate calibration sub-node for the locus given as a parameter if it exists in the settings tree. get_gate_properties_for_locus Get the gate characterization sub-node for the locus given as a parameter if it exists in the settings tree. get_locus_node_paths_for Get all the gate locus node paths for a given gate . get_node_for_path Return the node corresponding to the given path. get_parent_of Get the first SettingNode that has a Setting named name . merge Recursively combine the tree structures and values of two SettingNodes. merge_values Recursively combine the values from another SettingNode to this one. nodes_by_type Yields all nodes, filtered by given node_types . print_tree Print a tree representation of the contents of this node. prune Recursively delete all branches from this SettingNode that are not found in other . set_from_dict Recursively set values to Settings, taking values from a dictionary that has similar tree structure. setting_with_path_name Get a copy of a setting with its name replaced with the path name. transform_node_types Reduce any subclass of SettingNode and it's contents into instances of cls . update_setting Update an existing Setting in this tree. This method generates the paths and aligns the names when required. None List items and subtree names, so they occur in IPython autocomplete after node[<TAB> Yields all nodes, filtered by given node_types . Used to find and iterate over nodes of specific types. node_types ( type | tuple [ type , ... ] | None ) – when iterating over the tree, yields only instances that match this type\\nor any of the types in the tuple. By default, yields Settings and SettingNodes. recursive ( bool ) – If True, the search is carried recursively. If False, the search is limited to\\nimmediate child nodes. Iterator that yields the filtered nodes. Iterator Update an existing Setting in this tree. setting ( Setting ) – Setting that will replace an existing Setting with the same name. Or if the setting is an\\nelement-wise setting (i.e. it has a non-empty value of setting.element_indices ), the corresponding\\nelement will be updated in the collection. UnknownSettingError – If no setting is found in the children of this tree. None Yields all Setting instances inside this node, recursively. Dictionary of immediate child nodes of this node. ItemsView of settings of this node. ItemsView of immediate child nodes of this node. Get the first SettingNode that has a Setting named name . name ( str ) – Name of the setting to look for. A SettingNode that has a child name . SettingNode Find first occurrence of Setting or SettingNode by name, by iterating recursively through all children. name ( str ) – Name of the Setting or SettingNode to look for. First found item, or None if nothing is found. SettingNode | Setting | None Recursively combine the tree structures and values of two SettingNodes. In case of conflicting nodes,values in first take priority regardless of the replaced content in second . None values are not prioritized unless merge_nones is set to True . first ( SettingNode ) – SettingNode to merge, whose values and structure take priority second ( SettingNode ) – SettingNode to merge. merge_nones ( bool ) – Whether to merge also None values from first to second . align_name ( bool ) – Whether to align the paths (and also names if second does not use align_name==False )\\nwhen merging the nodes. Should never be set False unless the paths in first already align with\\nwhat they should be in second (setting it False in such cases can improve performance). deep_copy ( bool ) – Whether to deepcopy or just shallow copy all the sub-nodes. Set to False with high caution\\nand understand the consequences. A new SettingNode constructed from arguments. SettingNode Recursively combine the values from another SettingNode to this one. The resulting tree structure the same as that of self. other ( SettingNode ) – SettingNode to merge. prioritize_other ( bool ) – If True, will prioritize values in other. If False (default), only None values in self\\nwill be replaced. Recursively delete all branches from this SettingNode that are not found in other . other ( SettingNode ) – None Print a tree representation of the contents of this node. levels ( int ) – display this many levels, starting from the root. None Reduce any subclass of SettingNode and it’s contents into instances of cls . node ( SettingNode ) – node to transform. A new SettingNode with the same structure as the original, but where node instances are of type cls . SettingNode Recursively set values to Settings, taking values from a dictionary that has similar tree structure.\\nKeys that are not found in self are ignored, unless strict is True. dct ( dict [ str , Any ] ) – Dictionary containing the new values to use. strict ( bool ) – If True, will raise error if dct contains a setting that is not found in self . UnknownSettingError – If the condition of strict happens. None Get a copy of a setting with its name replaced with the path name. setting ( Setting ) – Setting Recursive diff between two SettingNodes. This function is meant to produce human-readable output, e.g. for debugging purposes.\\nIt returns the differences in a list of strings, each string detailing\\none specific difference. The diff is non-symmetric. other ( SettingNode ) – second node to compare self to path ( str ) – node path to the currently compared nodes (used in printing the results) differences from self to other , in depth-first order list [ str ] Turn a numerical value and unit, and return rescaled value and SI prefixed unit. Unit must be a whitelisted SI base unit. Return the node corresponding to the given path. path ( str ) – The path. The node at path in self. ValueError – If the given path cannot be found in self. Setting | SettingNode Add nodes to self while creating the missing nodes in-between. Whether the names and paths are aligned is determined by the attribute align_name of the current node\\n( self ). All the created missing nodes will use this same align_name value,\\nwhich determines whether their names will align with their paths. nodes ( Iterable [ Setting | Parameter | SettingNode ] | dict [ str , Setting | Parameter | SettingNode ] ) – Nodes to add as new leaves/branches of path . If of type dict , maps the keys used in self.settings or self.subtrees to the nodes themselves. If align_name=False , the key and\\nthe node name can differ, but otherwise the names will be replaced by the path anyways). path ( str ) – Path in self to which nodes will be added. If the path or any part (suffix) of it is not\\nfound in self, the associated nodes will be created automatically. override_values ( dict [ str , Any ] | None ) – Optionally override the values for the Settings corresponding to nodes . This dict\\nshould have the same structure as nodes , including matching names. None Get the default implementation name for a given gate and locus. Takes into account the global default implementation and a possible locus specific implementation and also\\nthe symmetry properties of the gate. NOTE: using this method requires the standard EXA settings tree structure. gate ( str ) – The name of the gate. locus ( str | Iterable [ str ] ) – Individual qubits, couplers, or combinations. The default implementation name. str Get the gate calibration sub-node for the locus given as a parameter if it exists in the settings tree. NOTE: using this method requires the standard EXA settings tree structure. gate ( str ) – The gate to retrieve the settings for. locus ( str | Iterable [ str ] ) – Individual qubits, couplers, or combinations. implementation ( str | None ) – Using a custom rather than the default gate implementation. The settings of the specified locus and gate. SettingNode Get all the gate locus node paths for a given gate . NOTE: using this method requires the standard EXA settings tree structure. gate ( str ) – Gate name. implementations ( list [ str ] | None ) – optionally limit the paths by these gate implementations. The locus node (string) paths corresponding to this gate. list [ str ] Get the gate characterization sub-node for the locus given as a parameter if it exists in the settings tree. NOTE: using this method requires the standard EXA settings tree structure. gate ( str ) – The gate to retrieve the settings for. locus ( str | Iterable [ str ] ) – Individual qubits, couplers, or combinations. implementation ( str | None ) – Using a custom rather than the default gate implementation. The settings of the specified locus and gate. SettingNode Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous setting_node next value © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"data_helper","url":"/iqm-exa-common/api/exa.common.helpers.data_helper.html","description":"Full path: exa.common.helpers.data_helper Functions add_data_array (ds, da[, name]) Add data array da to dataset ds . previous helpers next exa.common.helpers.data_helper.add_data_array © Copyright 20...","content":"Full path: exa.common.helpers.data_helper Functions add_data_array (ds, da[, name]) Add data array da to dataset ds . previous helpers next exa.common.helpers.data_helper.add_data_array © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"qcm_data","url":"/iqm-exa-common/api/exa.common.qcm_data.html","description":"Full path: exa.common.qcm_data Subpackages and modules chad_model Pydantic models for CHAD. chip_topology Chip topology class for parsing CHAD and other QPU related data into human-usable form. file_a...","content":"Full path: exa.common.qcm_data Subpackages and modules chad_model Pydantic models for CHAD. chip_topology Chip topology class for parsing CHAD and other QPU related data into human-usable form. file_adapter  immutable_base_model  qcm_data_client QCM (Quantum Computer Management) Data API client implementation. previous InfoFilter next chad_model © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"center_span_options","url":"/iqm-exa-common/api/exa.common.control.sweep.option.center_span_options.html","description":"Range specification to define a range around a center value. Full path: exa.common.control.sweep.option.center_span_options Classes CenterSpanOptions Range generation options. Inheritance previous Cen...","content":"Range specification to define a range around a center value. Full path: exa.common.control.sweep.option.center_span_options Classes CenterSpanOptions Range generation options. Inheritance previous CenterSpanBaseOptions next CenterSpanOptions © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"software_version_helper","url":"/iqm-exa-common/api/exa.common.helpers.software_version_helper.html","description":"Full path: exa.common.helpers.software_version_helper Functions get_all_software_versions ([reload_module]) Get all available software version information. get_vcs_description (root_directory) Get Ver...","content":"Full path: exa.common.helpers.software_version_helper Functions get_all_software_versions ([reload_module]) Get all available software version information. get_vcs_description (root_directory) Get Version Control System (VCS) description for the caller's current working directory. previous exa.common.helpers.numpy_helper.coerce_numpy_type_to_native next exa.common.helpers.software_version_helper.get_all_software_versions © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.helpers.deprecation.format_deprecated","url":"/iqm-exa-common/api/exa.common.helpers.deprecation.format_deprecated.html","description":"old ( str ) – new ( str | None ) – since ( str ) – LiteralString previous deprecation next json_helper © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26....","content":"old ( str ) – new ( str | None ) – since ( str ) – LiteralString previous deprecation next json_helper © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"CenterSpanOptions","url":"/iqm-exa-common/api/exa.common.control.sweep.option.center_span_options.CenterSpanOptions.html","description":"Bases: SweepOptions Range generation options. Values are generated over the interval with the center center and the size of span .\\nFor linear sweep range the number of generated values can be based ei...","content":"Bases: SweepOptions Range generation options. Values are generated over the interval with the center center and the size of span .\\nFor linear sweep range the number of generated values can be based either on count or step .\\nIn case count is empty and step is not, step is used for calculating count .\\nFor exponential sweep range only count is used. Module: exa.common.control.sweep.option.center_span_options Attributes asc Order of generated values. count Number of values to generate. data List of values for parameter step Size of spacing between values. center Value of interval center. span Size of the interval. Methods center ( int | float | complex ) – span ( int | float | complex ) – count ( int | None ) – step ( int | float | complex ) – asc ( bool | None ) – Value of interval center. Size of the interval. Number of values to generate.\\nIf count and step are empty, the default value of count is exa.common.control.sweep.option.constants.DEFAULT_COUNT . Size of spacing between values. Order of generated values. Default to ascending List of values for parameter previous center_span_options next constants © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"chad_model","url":"/iqm-exa-common/api/exa.common.qcm_data.chad_model.html","description":"Pydantic models for CHAD. Full path: exa.common.qcm_data.chad_model Classes CHAD Create a new model by parsing and validating input data from keyword arguments. Component Create a new model by parsing...","content":"Pydantic models for CHAD. Full path: exa.common.qcm_data.chad_model Classes CHAD Create a new model by parsing and validating input data from keyword arguments. Component Create a new model by parsing and validating input data from keyword arguments. Components Create a new model by parsing and validating input data from keyword arguments. ComputationalResonator Create a new model by parsing and validating input data from keyword arguments. Coupler Create a new model by parsing and validating input data from keyword arguments. Launcher Create a new model by parsing and validating input data from keyword arguments. ProbeLine Create a new model by parsing and validating input data from keyword arguments. Qubit Create a new model by parsing and validating input data from keyword arguments. Inheritance previous qcm_data next CHAD © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.errors.server_errors.InternalServerError","url":"/iqm-exa-common/api/exa.common.errors.server_errors.InternalServerError.html","description":"Error raised when an unexpected error happened on the server side. This error should never be raised when something expected happens,\\nand whenever the client encounters this, it should be considered a...","content":"Error raised when an unexpected error happened on the server side. This error should never be raised when something expected happens,\\nand whenever the client encounters this, it should be considered as a server bug. message ( str ) – previous exa.common.errors.server_errors.ForbiddenError next exa.common.errors.server_errors.NotFoundError © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"setting_node","url":"/iqm-exa-common/api/exa.common.data.setting_node.html","description":"A tree-structured container for Settings . The SettingNode class combines a bunch of Settings together.\\nIt may also contain other SettingNodes.\\nTogether, the contents form a tree structure that provid...","content":"A tree-structured container for Settings . The SettingNode class combines a bunch of Settings together.\\nIt may also contain other SettingNodes.\\nTogether, the contents form a tree structure that provides a useful way of grouping Settings. As an example, we manually construct a tree of SettingNodes with some dummy Settings, but it is usually not necessary.\\nThe root node in the following examples is called 'node' . The easiest way to see the content of the node is the SettingNode.print_tree() method: We see that the 'root' node has two children, named 'root.flux' and 'root.pulse' , which\\nthemselves are also SettingNodes.\\nThis follows the typical naming convention in EXA: Subnodes include the names of their parents, separated by a dot. The children contain some dummy Settings, showing the keys, labels and current values. For other ways to access the content of the node, see also SettingNode.children , SettingNode.all_settings , and SettingNode.nodes_by_type() . The values within the nodes can be accessed using the attribute or dictionary syntax: The values can be changed with a simple = syntax: Note node.setting refers to the Setting object. node.setting.value syntax refers to the data stored inside. SettingNode also supports “the path notation” by default (but not if align_name is set to False ,\\nsince it cannot be made to work consistently if nodes are allowed to be named differently from their paths): is the same as node['flux']['voltage'] . Adding and deleting new Settings and nodes is simple: It is usually a good idea to make a copy of the original node, so that it won’t be modified accidentally. The path notation of \`\` SettingNode\`\`also works when inserting: Any nodes that did not already exist under node will be inserted (in this case flux already existed, but\\nthe rest not, so under flux the nodes my , new , and path would be added), and then finally the\\nvalue is added as child to the final node. Note: SettingNode always alings the path and name of any nodes under it,\\nso this would result in the new setting being renamed as “flux.my.new.path.foo”: If align_name is set to False\\", the name and path of nodes are not automatically aligned, but otherwise the above path notation will still work. The added nodes will be named by just their path fragments (\\"my\\", \\"new\\", \\"path\\", and so on), and the Setting will be added under the key \\"foo\\", but it will still retain its name \\"bar\\". Note: the root node name will always be excluded from the paths (and names when they are aligned with the path), so that the path of \`\`root.foo.bar is \\"foo.bar\\" . To merge values of two SettingNodes, there are helpers SettingNode.merge() and SettingNode.merge_values() . The first one merges the tree structure and values of two nodes and outputs a third one as a result. None values are always replaced by a proper value if such exists. In case of conflicting nodes or values,\\nthe content of the first argument takes priority. Note how the result has values from node.flux , but also settings node.pulse that do not exist in node.flux . The SettingNode.merge_values() method is an in-place operation that only changes\\nthe values of Settings that already exist in the node, if possible: Sometimes, it is easier to collect values in a dictionary and set them all at once by using SettingNode.set_from_dict() . The nested structure of the dictionary should match\\nthe structure of the SettingNode. Keys that are not found in the tree are silently ignored, unless the strict flag is used. Full path: exa.common.data.setting_node Classes SettingNode A tree-structured Setting container. Inheritance previous Setting next SettingNode © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-exa-common","title":"exa.common.sweep.database_serialization.decode_return_parameters","url":"/iqm-exa-common/api/exa.common.sweep.database_serialization.decode_return_parameters.html","description":"Deserialize return parameters. For backwards compatibility, changes values of the return parameters dict to a new,\\nmore general format: NdSweeps, which is a list of tuples of Sweeps. Return parameters...","content":"Deserialize return parameters. For backwards compatibility, changes values of the return parameters dict to a new,\\nmore general format: NdSweeps, which is a list of tuples of Sweeps. Return parameters JSON syntax: [{\\"parameter\\": readout_parameter_json, \\"hard_sweeps\\": [hard_sweep,...]}, ...] . readout_parameter_json may be a Parameter or a Setting; both will be converted to a Parameter. hard_sweeps are converted with the following rules: 1 is converted to an empty NdSweep, i.e., a scalar. Other integers are converted to a linear_index_sweep() Sweep is converted to an NdSweep that contains only the sweep NdSweep and None are not converted. json_str ( str ) – JSON representation of the return_parameters loaded\\nfrom e.g. persistence a reconstituted, typed return_parameters structure dict [ Parameter , list [ tuple [ Sweep , …]] | None ] previous exa.common.sweep.database_serialization.decode_and_validate_sweeps next exa.common.sweep.database_serialization.decode_settings © Copyright 2019-2025, IQM Finland Oy, Release 26.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"Compilation using a locally created calibration set","url":"/iqm-pulla/Example - Compilation With Local Calibration Set.html","description":"This notebook shows how to construct a calibration set locally and use the local calibration set for compiling circuits. The calibration itself is done using IQM’s Graph Based Calibration (GBC) softwa...","content":"This notebook shows how to construct a calibration set locally and use the local calibration set for compiling circuits. The calibration itself is done using IQM’s Graph Based Calibration (GBC) software. In this notebook we show recalibration based on the latest calibration set. The usage of Pulla with a local calibration set works mostly the same way also for a full calibration from scratch. In that case you would just have to use a different GBC graph, and possibly manually add observations to the observation stash if it does not yet have all observations required for a valid calibration set. Using the principles shown in this notebook, it is possible to use all Pulla functionality as a helpful tool during the calibration process. NOTE: Some of the libraries used in this notebook are only available to on-premise customers and are not currently available publicly. First we prepare a Pulla object, a qiskit-iqm backend, and a circuit as explained in Quick Start.ipynb . Let’s also define a function that compiles and runs the above circuit using the given compiler state. This function will be used to compile and execute the circuit at different points of the calibration process: First we compile and execute the circuit using the compiler obtained above, which uses the current default calibration set on the server. The results of this execution can then be compared to the results after performing (parts of) the recalibration process. Now we will start recalibration using GBC. We need a CalibrationSetWrapper instance for handling calibration sets and a Calibrator for running the calibration: To start with, we run the first node that runs any actual calibration experiments: Then we can create a local calibration set based on the results of the above calibration node, and update the compiler to use this calibration set. We compile and execute a circuit using the updated compiler to see how our updates to the calibration set affect the results. Because many observations of the updated calibration set don’t yet take into account the results of the executed node, the results could even be worse than before updating the calibration set with these intermediate results. We could repeat the above steps multiple times for different nodes of the calibration graph, to see how the results change during the calibration process. Finally, we run the full recalibration, which runs all the remaining nodes that we did not run above: Then we again update the compiler using the results of the calibration in the same way as before. If the full recalibration was successful, the execution results should hopefully be at least as good as before the recalibration. By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"Configuration and Usage","url":"/iqm-pulla/Configuration and Usage.html","description":"This notebook describes the basic concepts and configuration of Pulla. Now let’s create a Pulla object. A Pulla object is conceptually an IQM quantum computer client for fetching calibration data and ...","content":"This notebook describes the basic concepts and configuration of Pulla. Now let’s create a Pulla object. A Pulla object is conceptually an IQM quantum computer client for fetching calibration data and constructing a circuit-to-pulse compiler. . It consists of: methods for fetching calibration sets from the server methods for fetching metadata about the QC from the server method for executing pulse-level instruction schedules (e.g. ones created by the compiler) A Compiler object defines a particular circuit-to-pulse compilation logic . It consists of: single calibration set schedule builder based on the calibration set circuit compilation options information about the QC (chip topology, channel properties, etc.) compilation stages set of available circuit-level quantum operations (“native operations”) (including user-defined operations) set of implementations for each native operation (including user-defined implementations) methods for manipulating the calibration, operations, and implementations Pulla can construct a standard compiler equivalent to the one used by the server side (CoCoS). You can also construct a Compiler manually. To create an instance of Pulla, you need to provide the URL of Station Control. Upon successful initialization, some configuration data is printed (the verbosity of such messages will be controlled by a debug level value). You can access various things like channel properties of the connected station, chip topology, or the current calibration. The initial calibration is the latest calibration of the connected station. Call get_standard_compiler() method to get an instance of Compiler . It will be pre-populated with the latest default calibration set and standard compilation stages. This standard compiler is the same one that CoCoS uses on the server side when processing circuits. get_standard_compiler() fetches the latest calibration set from the server. This network request takes a few moments. You may want to create many Compiler instances without such delay. It may also be possible that, due to human error, the latest calibration set stored on the server is invalid (or incompatible with your version of Pulla or IQM Pulse). In that case get_standard_compiler() will fail. To avoid this, you can pass the calibration set manually, and Pulla will construct the compiler with it instead of getting one from the server. If you want to reuse the calibration of an existing compiler, call Compiler.get_calibration() , e.g.: You can also get a specific calibration set from the server if you know its UUID by calling Pulla.fetch_calibration_set_by_id() , e.g.: The compiler initializes with the following default configuration options: circuit_boundary_mode='all' measurement_mode='all' heralding_mode='none' dd_mode='none' You can change them by changing the corresponding attributes of compiler.options . For the constant implementation of the measure operation, the readout type is controlled by the acquisition_type parameter. By default, it’s set to \\"threshold\\" . Let’s change it to \\"complex\\" . The full key in the calibration set dictionary is gates.measure.constant.QUBIT.acquisition_type , where QUBIT is the physical qubit name. Note that we call get_calibration() to get a copy of the compiler’s current calibration set, make changes to the copy, then replace the compiler’s set with the copy. The compiler always contains a single calibration set only. previous Quick Start next Compilation Stages By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"IQM Pulla","url":"/iqm-pulla/readme.html","description":"Pulla (pulse-level access) is a client-side software which allows the user to control the generation and\\nexecution of pulse schedules on a quantum computer. Within the existing IQM QCCSW stack, PulLA ...","content":"Pulla (pulse-level access) is a client-side software which allows the user to control the generation and\\nexecution of pulse schedules on a quantum computer. Within the existing IQM QCCSW stack, PulLA is somewhere between\\ncircuit-level execution and EXA-experiment. An interactive user guide is available as a Jupyter notebook in the docs folder. Create a virtual environment and install dependencies: The [qiskit] option is to enable Qiskit-related features and utilities, like converting Qiskit circuits to Pulla circuits, constructing a compatible compiler instance, or constructing a PullaBackend for running Qiskit jobs. The [qir] option is to enable QIR support, e.g. the qir_to_pulla function. The [notebook] option is to be able to run the example notebooks, using\\nand run it in Jupyter Notebook: Install development and testing dependencies: e2e testing is execution of all user guides (Jupyter notebooks). User guides cover the majority of user-level features,\\nso we achieve two things: end-to-end-test Pulla as a client library, and make sure the user guides are correct.\\n(Server-side use of Pulla is e2e-tested as part of CoCoS.) You have to provide CoCoS and Station Control URLs as environment variables: Notebooks are executed using jupyter execute command. It does not print any output if there are no errors. If you want\\nto run a particular notebook and see the output cells printed in the terminal, you can use nbconvert with jq ( https://jqlang.github.io/jq/download/ ) like so: Run unit tests, build docs, build package: Copyright 2025 IQM Licensed under the Apache License, Version 2.0 (the “License”);\\nyou may not use this file except in compliance with the License.\\nYou may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software\\ndistributed under the License is distributed on an “AS IS” BASIS,\\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\nSee the License for the specific language governing permissions and\\nlimitations under the License. previous IQM Pulla next Migration guide By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"Custom Gates and Gate Implementations","url":"/iqm-pulla/Custom Gates and Implementations.html","description":"This notebook demonstrates how to work with user-defined quantum operations and gate implementations that go beyond the standard gate set. Each quantum operation is associated with one or more GateImp...","content":"This notebook demonstrates how to work with user-defined quantum operations and gate implementations that go beyond the standard gate set. Each quantum operation is associated with one or more GateImplementation s which translate the high-level concepts to lower-level instructions accepted by the IQM server. This example shows how the user can Selecting a non-default implementation for a gate Add a custom implementation for an existing gate Add a custom gate and a custom implementation for it by using existing gates as building blocks (composite gates) Defining new pulse waveforms for implementations Please refer to the User Guide.ipynb for basic usage, termninology, and environment setup. Circuits are usually defined without specifying implementations for any of the gates.\\nThe implementations available in a given calibration set are listed in the corresponding dynamic quantum architecture, through Cocos. Let’s see a list of available implementations, with their parameters: You can specify a default implementation for each native operation type in the circuit, and then override it for specific loci.\\nLet’s change all cz gates to use the slepian implementation, and make an execption for the qubit pair (QB1, QB2) . Note that the default implementations are merely suggestions to the compiler. If the compiler does not have calibration data for a default implementation, it will ignore it and use what it can. If you executed the cell below, you would get an error if the requested implementation 'drag_gaussian' does not have calibration data. You can also force the compiler to use a specific implementation for each circuit instruction separately in the IQM Pulse native format, which describes a circuit as a list of CircuitOperation instances. IQM Pulse allows the user to define composite gates: gates consisting of other registered gates.\\nComposite gates are particularly useful because they allow reusing the calibrated of data of the other gates.\\nFurthermore, it is possible to use different calibration data for the registered gates inside a composite gate than outside it. Let’s define a prx implementation that acts like a normal prx , except it implements x with 2 pulses with a 100 ns wait between them.\\nThe __call__ method produces a TimeBox using IQM Pulse’s ScheduleBuilder.\\nIt’s worth mentioning that the composite gate is not restricted to using only registered gates; it could equally well return a TimeBox with lower level instructions. Now we register a new gate custom_x , which StretchedX implements. We want to make it compatible with the circuit-level prx , so we declare that it has the same parameters.\\nThen we change the fist prx in the IQM Pulse circuit to use our new implementation. Inspecting the schedule, we can see that the X gate in the circuit is indeed split into two pulses with a wait in between: Finally, let’s change the pulse waveforms of an existing gate. The tricky part of this is that we need to provide the calibration data by hand.\\nIQM Pulse provides several “gate with custom waveforms” base classes so that users need only write the waveforms. Let’s define a new implementation of PRX using a raised cosine pulse: The class attributes of the waveforms define the calibration data they require. The PRX_CustomWaveforms class adds some more. We can add the new prx implementation to the compiler, and check what calibration data it needs: Let us then make one of the prx gates in the circuit use our new implementation: Compiling this circuit right now would fail with an error: (The locus (‘QB1’,) may differ in your output due to the stochastic nature of routing.) The point is that the compiler does not have necessary calibration data for this new implementation. One way to fix this is to amend the current calibration. The numbers here are arbitrary, in reality you would need to calibrate the gate parameters somehow. Data with gates.prx.raised_cosine.* is now visible in compiler.get_calibration() . Note that we added the same calibration data to all qubits. In practice, this rarely makes sense, because each qubit\\nis usually calibrated differently. Now the compilation succeeds and we see that raised_cosine was used once. Using the schedule visualization you could also verify that the pulse shape is indeed different on the first prx instance. previous Compilation Stages next Examples By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"Example: Measuring T1","url":"/iqm-pulla/Example - Measuring T1.html","description":"T1 is an experiment that measures the relaxation time of a qubit. Information stored in a qubit decays exponentially. The time constant of the decay is called the relaxation time $T_1$. The experiment...","content":"T1 is an experiment that measures the relaxation time of a qubit. Information stored in a qubit decays exponentially. The time constant of the decay is called the relaxation time $T_1$. The experiment measures $T_1$ by preparing selected qubits in the  excited state by playing an X gate,\\nwaiting some time, and measuring the qubit. The waiting time is swept to reveal the exponential decay of the excited state probability. High-level QuantumOperations like Quantum gates can be implemented using different GateImplementations.\\nTo control low-level aspects of the execution, we can create custom operations, the implementation of which we can control. Here we invent a custom operation \\"custom\\" and write an implementation \\"Wait\\" , which only inserts a delay of certain duration.\\nIn principle, the custom gate implementation could include any number of low-level instructions,\\nbut for this task we only need a wait.\\nhttps://iqm-finland.github.io/docs/iqm-pulse/using_builder.html for more details about lower level controls. In later cells, we mix the custom gate with other, more familiar gates. We must register the operation, so that the compiler knows what to do with it: We need to select the physical qubits to work on. These are available on the QPU: Out of these, we select a few: Now we create all the circuits. In each circuit, we do a PRX(pi), or X, then our custom operation that waits, then measure all qubits.\\nWe create a circuit for each delay time we want on the time axis. Then compile the circuits. We tweak the settings so that the shots are averaged by the server, so that we don’t need to.\\nThe results therefore return as sampled probabilities. Extract the results We can also visualise the final playlist. We should see that each circuit is different and the waits at the end are increasing towards the end. previous Examples next Example: Dynamical decoupling By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"Example: Dynamical decoupling","url":"/iqm-pulla/Example - Simple Dynamical Decoupling.html","description":"There is a standard compilation stage for automatically applying dynamical decoupling (DD) sequences to an instruction schedule,\\ncontrolled by the dd_mode compiler option. By default the DD stage is d...","content":"There is a standard compilation stage for automatically applying dynamical decoupling (DD) sequences to an instruction schedule,\\ncontrolled by the dd_mode compiler option. By default the DD stage is disabled. The iqm.cpc.compiler.dd module contains various utility functions the DD stage uses, e.g. for locating specific instructions in a schedule, constructing DD sequences, and replacing select instructions with them. For example, we can find locations of Wait instructions on qubit drive channels with a certain minimum duration, and replace them with an arbitrary sequence of Wait and IQPulse instructions that dynamically decouples the qubit, given that the total duration of the sequence is the same as the duration of the original Wait . Let’s create and transpile a quantum circuit that prepares a superposition on one qubit, and then executes a long sequence of gates on other qubits while the first qubit is idling and experiencing decoherence. Finally we reverse the superposition and measure the qubits. Now let us create a pair of Pulla compilers, one with DD and one without. Compiling the circuit using the non-DD compiler produces a schedule with a long wait on QB1__drive.awg. We then execute this schedule and compute the probability of finding QB1 in the |0> state. Ideally this should be one, but due to the decoherence experienced by the superposition state it will be less. Compiling the circuit using the DD compiler instead produces a schedule where the long wait on QB1__drive.awg is replaced by a DD sequence. We execute the DD schedule and again compute the probability of finding QB1 in the |0> state, and will likely see that the probability has gone up, due to the DD sequence partially decoupling the idling QB1 from various decoherence sources and better preserving the superposition state. We can see that the long wait on QB1__drive.awg was indeed replaced by a DD sequence. previous Example: Measuring T1 next Executing QIR programs By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"Migration guide","url":"/iqm-pulla/migration_guide.html","description":"This document describes the changes that need to be made to existing code to migrate between major versions of Pulla. The changes in 4.0 are not truly breaking, as your code should still run. However,...","content":"This document describes the changes that need to be made to existing code to migrate between major versions of Pulla. The changes in 4.0 are not truly breaking, as your code should still run. However, there are some changes that\\nmight affect the compilation results, and you might want to adjust your code accordingly: New compilation pass prepend_reset added to the (TimeBox-level) standard compiler stage. It adds a reset timebox\\nto all circuits. It is the last pass of the TimeBox-level stage. If the calibration lacks reset_wait data, the prepend_reset will have no effect. Optional attribute :attr: .CircuitExecutionOptions.active_reset_cycles added to CircuitExecutionOptions ,\\nthat is used to control the reset functionality. By default, it is set to None , which results in delay by wait. :meth\`.Pulla.get_standard_compiler\` now has an optional argument for overriding default circuit execution options. The function iqm.pulla.utils_qiskit.qiskit_to_cpc was replaced by iqm.pulla.utils_qiskit.qiskit_circuits_to_pulla() and iqm.pulla.utils_qiskit.qiskit_to_pulla() . qiskit_circuits_to_pulla() is a more direct replacement, with the difference that it also requires a\\nmapping of qiskit qubit indices to physical qubit names which was not required before.\\nThis can be e.g. obtained from an iqm.qiskit_iqm.iqm_provider.IQMBackend instance. qiskit_to_pulla() is a convenience method that in addition to\\nconverting the Qiskit circuit(s) also returns a Compiler instance that can be used to compile them\\ninto a playlist. It takes as additional parameters a Pulla instance (for building the compiler),\\nand an IQMBackend instance (containing the calibration set ID and\\nqubit mapping to use). The IQMBackend instance should usually be the same one that was used to transpile\\nthe Qiskit circuits. Compiler code is consolidated under the iqm.cpc.compiler.compiler module.\\nThere is no more iqm.cpc.compiler.compiler2 . Compiler , CompilationStage are now under iqm.cpc.compiler.compiler . Pulla no longer needs CoCoS URL: Compiler initialization now requires all arguments to be keyword arguments. Pulla no longer retrieves qubit mapping from CoCoS. If your circuit uses same qubits names as physical qubits\\n(e.g. QB1 , QB2 , etc.), then you don’t have to do anything. If your circuit uses other qubit names, then you have to\\nprovide component_mapping to the Compiler like so: If you use Qiskit, the mapping can be generated with {str(idx): qb for idx, qb in backend._idx_to_qb.items()} . .Compiler.set_default_implementation_for_locus changed to Compiler.set_default_implementation_for_loci() : Compiler.amend_calibration_for_gate_implementation() now accepts a Locus (a tuple of strings)\\ninstead of string qubit name, so you can apply the change to multiple loci in a single call: iqm.pulla.utils.qiskit_to_cpc() and iqm.pulla.station_control_result_to_qiskit() , previously marked for\\ndeprecation in v. 1.0, are now removed. Use iqm.pulla.utils_qiskit.qiskit_to_cpc() and iqm.pulla.utils_qiskit.station_control_result_to_qiskit() , respectively. The main change in 1.0 is the splitting of Pulla and Compiler , and the move of some compiler-related methods to\\nthe more appropriate Compiler class. The Pulla class now only contains methods to retrieve calibration data,\\nconstruct a standard compiler instance, and submit pulse schedules to the server. Setting default implementation is now done in the compiler directly, and there is no need to manually refresh the\\ncompiler anymore. Same goes for adding implementations, and amending the calibration set with custom data for custom implementations: The calibration is now stored solely in the compiler instance, and can be retrieved using Compiler.get_calibration() : Fetching calibration sets from the server is still done via Pulla.fetch_latest_calibration_set() and Pulla.fetch_calibration_set_by_id() . Standard compilation stages are now available via get_standard_stages() . This ensures the immutability of\\nbuilt-in standard stages. previous IQM Pulla next User guides By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"Contributors","url":"/iqm-pulla/authors.html","description":"Rakhim Davletkaliyev < rakhim . davletkaliyev @ meetiqm . com > Ville Bergholm < ville @ meetiqm . com > Joni Ikonen < joni @ meetiqm . com > Arianne Meijer < qaremei @ meetiqm . com > Tuukka Hiltunen...","content":"Rakhim Davletkaliyev < rakhim . davletkaliyev @ meetiqm . com > Ville Bergholm < ville @ meetiqm . com > Joni Ikonen < joni @ meetiqm . com > Arianne Meijer < qaremei @ meetiqm . com > Tuukka Hiltunen < tuukka @ meetiqm . com > Jussi Ritvas < jussi . ritvas @ meetiqm . com > Miikka Koistinen < miikka @ meetiqm . com > previous Changelog next License By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"Common errors","url":"/iqm-pulla/common_errors.html","description":"This document describes some common errors which you may encounter when using Pulla, and ways to fix them. If you have modified any timing aspect of the schedule, you may encounter an error like this:...","content":"This document describes some common errors which you may encounter when using Pulla, and ways to fix them. If you have modified any timing aspect of the schedule, you may encounter an error like this: The granularity is an instrument limitation. Specifically, the part (e.g. HDAWG) which plays the drive pulses.\\nSome instrument may use e.g. a sample rate of 2.4 GHz, and each instruction duration must be an integer multiple of 16\\nsamples. Instructions therefore must be a multiple of 6.666ns (16 / 2.4 GHz).\\nDurations that are within 0.005 samples of an allowed number of samples are rounded to that\\n(the software assumes it is what the user meant), otherwise an error is raised. Different stations have different instruments.\\nIQM instruments use a fixed sample rate of 2 GHz, and have a granularity of 8 samples. You can view the granularity information in channel properties, for example Pulla.get_channel_properties()[0]['QB1__drive.awg'] : If you were to turn off the error and use an instruction with a duration that does not fit the granularity, it would\\njust silently be extended to the next longest allowed granularity, and would not do what you expect. previous iqm.pulla.utils_qiskit.IQMPullaBackend next Changelog By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"Quick Start","url":"/iqm-pulla/Quick Start.html","description":"IQM PulLA is a client-side software which allows the user to control the generation and execution of pulse-level instruction schedules on a quantum computer. Within the existing IQM QCCSW stack, PulLA...","content":"IQM PulLA is a client-side software which allows the user to control the generation and execution of pulse-level instruction schedules on a quantum computer. Within the existing IQM QCCSW stack, PulLA is somewhere between circuit-level execution and EXA-experiment. Namely, with pulse-level access the user can: compile a quantum circuit (e.g. a Qiskit circuit) into an instruction schedule on the client side access and modify the calibration data to be used for the circuit-to-schedule compilation view and modify the default implementations of quantum gates define custom implementations of quantum gates define new composite gates out of native gates and set their calibration data control the multi-step compilation procedure, and edit the intermediate data use custom pulse shapes This notebook contains a small meaningful example for a “quick start”. Refer to other chapters for more details on various aspects of Pulla. Pulla provides a Qiskit backend, with limited functionality. Its main purpose is to replace the normal execution of run() , which submits circuits to the remote server, with a local compilation and submission of pulse schedules to the remote server. IQMPullaBackend does not provide any new functionality, but rather packs existing features and actions behind an illusion of using a normal Qiskit backend. You can perform all of the actions of IQMPullaBackend manually, but you may choose to use IQMPullaBackend in these cases: You don’t need to control compilation, and want to use Pulla in the same way as a remote circuit-executing IQM Server uses it. You want to run some existing apps written for Qiskit, e.g. benchmarking tools; they often build on top ot the circuit abstraction, and don’t necessarily give you easy access to the circuits, which makes it harder to use Pulla normally. You don’t have access to a remote circuit-executing IQM Server, only to a pulse-executing IQM Server. You don’t have any remote servers at all; all of the quantum control software is running locally (relevant for niche research cases) To initialize an IQMPullaBackend instance, provide 3 arguments: Quantum architecture in QuantumArchitectureSpecification format of IQM Client Instance of Pulla Instance of Compiler When IQMPullaBackend.run() is called, the following steps are performed: Given Qiskit circuits are converted to Pulla format using qiskit_circuits_to_pulla() . Circuits are compiled with the provided compiler using Compiler.compile() . Settings are generated with the provided compiler using Compiler.build_settings() . Circuits are executed on the station associated with the provided Pulla instance. Results are retrieved and converted into a DummyJob , partially compatible with Qiskit Job . Working example below: If the remote station requires authentication: Install IQM Client CLI with pip install iqm-client[cli] Run iqmclient init . The wizard will start and ask questions. Accepting defaults is ok. Wizard will ask for Authentication server URL . Usually, it’s of the form https://STATION_ROOT/auth . E.g. if the Station Control URL is \\"https://abc.com/station/\\" , then the auth server URL is \\"https://abc.com/auth/\\" Run iqmclient auth login . You should see info like so: Set the environment variable IQM_TOKENS_FILE accordingly in your Jupyter notebook and pass get_token_callback to the Pulla initialization call like so: Setting IQM_TOKENS_FILE env. variable enables authentication for CoCoS as well, so your Qiskit runs against the same station will work, too. Pulla can also be used with IQM Resonance cloud service. You need to set the station URL to point to Resonance. In addition to that, you must provide a get_token_callback parameter function that returns your Resonance API token. IQM Pulse comes with a schedule visualizer. It takes a Playlist (i.e. a compressed list of instruction schedules) and a list of schedule/segment indices to inspect.\\nThe playlist variable below is the one which we derived from the original Qiskit circuit using the Pulla compiler, and it only has one schedule. previous User guides next Configuration and Usage By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"Compilation Stages","url":"/iqm-pulla/Compilation Stages.html","description":"The generic lifecycle of a Pulla job is a one-way multi-step transformation. The states are as follow: Quantum Circuit in a specific format (e.g. Qiskit, Cirq) Equivalent Quantum Circuit in an IQM Pul...","content":"The generic lifecycle of a Pulla job is a one-way multi-step transformation. The states are as follow: Quantum Circuit in a specific format (e.g. Qiskit, Cirq) Equivalent Quantum Circuit in an IQM Pulse format (list of CircuitOperations) IQM Pulse nested Timebox representation IQM Pulse Schedule representation Measurement results You don’t have to start with a circuit, you can define quantum operations directly (roughly starting from state 2), or define pulse shapes directly (roughly starting from state 3 or 4). The compilation which produces states 3 and 4 is itself multi-step: it consists of multiple stages, and each stage of one or more passes. Let’s go over the generic use case, starting from creating a Qiskit circuit to work on: Pulla has utility functions which accept circuits in different formats (Qiskit, Cirq, IQM JSON) and convert them into Pulla/IQM Pulse format, which is a list of CircuitOperation objects. Let’s do that. Note that none of the operations have an implementation specified ( implementation=None ). The Qiskit conversion utility also gives us a standard compiler with the same calibration set as the one used by backend , in this case the current default one. In order to understand how the compilation stages work, let’s remove the standard stages from the compiler: You can check the readiness of the compiler by calling compiler.ready() . Right now it would return False due to empty stages list. The compiler flow consists of one or more stages, and each stage consists of one or more passes. When the compiler is initialized created by Pulla, it is pre-populated with standard stages. You can define your own stages, with your own passes, grouping them in some meaningful way. Each pass is a function which accepts two arguments: data and context. Data is an iterable of objects of an applicable data type, and context is a dictionary of any additional information. Each pass can transform the data and modify the context, and must return both data and context. This convention allows the compiler to pipe arbitrary amount of passes. A stage is just an ordered collection of passes. The compiler has methods run_stage() and run_pass() allowing you to run particular stages or passes. The compile() method is just calling run_stage() in correct order and passes its initial context to the first pass of the first stage. Let’s write a simple compilation stage to illustrate the concept: Now let’s write two simple passes for that stage. For the first: perhaps we want to add a leading barrier to each circuit. add_leading_barrier below determines the locations of qubits used in the circuit and adds a barrier on those qubits as the first instruction. Note that the function takes data and context and returns data and context. It happens to neither use nor modify the context, but it should still provide it down to the next passes. Ok, let’s define another pass: this one would increase the phase of each prx operation by 0.25 . This may or may\\nnot make practical sense, but bear with us for the purposes of illustration: Now let’s add those two passes to our stage, then replace the empty stages property of the compiler with a list consisting of our single stage, and then call show_stages() : The boolean flag full of show_stages() is optional; when True , the doc strings of each pass are printed on the screen. Now that the compiler is ready and we can run compile . The compiler always operates on batches of circuits, so you need to provide an iterable; in our case, it’s a list with a single circuit. Note that it did not really compile the circuits into pulse schedules, because the only passes we’ve defined only modify the circuits, but don’t perform the conversion to pulse schedules. The compilation to pulse schedules usually consists of converting circuits to TimeBox es, then resolving TimeBox es into a single TimeBox , then resolving it into a Schedule , and finally converting a Schedule into a final Schedule ready to be submitted to the server. There might be cases when your compilation stages need additional data. You can provide such data as a custom context dictionary. Get the initial compiler context and modify it, then pass it when calling compile . As mentioned earlier, Pulla comes with a pre-defined “standard” set of stages which you can use and, if needed, modify. These standard stages are used by CoCoS if you were to submit a circuit to CoCoS (without using Pulla). Thus, if you use the same version of the Pulla library that the remote CoCoS uses, you will be able to produce and inspect the same pulse schedules that CoCoS would (assuming you use the same calibration set). Let’s replace our current single stage with standard stages, and view them: There are 7 standard stages: circuit-level: takes care of validating the circuit, renaming some deprecated names, gathering\\ninformation for the next stages circuit resolution: converts circuits to TimeBox es timebox-level: optimizes “measure” gates by multiplexing them if possible timebox resolution: converts TimeBox es to Schedule schedule-level: applies dynamical decoupling schedule-level: potentially applies some corrections, then cleans up the schedules schedule resolution: converts Schedule to the final Playlist ready to be executed Variable data now contains the Playlist in its final form, and context contains a dictionary of various things\\nwhich were either necessary in some of the passes, or will be necessary for the final execution. It also contains a\\ncopy of schedules from before the final playlist resolution. Some of those pieces of data will be needed to build\\nStation  Control settings (more on that later). Instead of calling compile() , which runs all the stages, you can run each stage, or even each separate pass, by yourself. In that case you will have to take care of two things: Provide initial context to the first pass of the first stage. Save data and context returned by each pass (or stage) in order to provide it to the next pass (or stage). To help you with 1, the compiler has a method compiler_context() which returns a dictionary of initial context. (Note: to run a pass of any particular stage: compiler.stages[0].passes[0](data, context) ) Let’s create another circuit and compile it manually. We’ll use this example to understand each standard stage: The first stage is circuit-level passes: When defining a circuit in IQM JSON or IQM Pulse format directly, you can specify an implementation for each gate (selecting from implementations provided by the calibration set). If no implementation is specified, the standard circuit-level stage will select the default implementation for each gate automatically. Currently, the choice of the default implementation is global: e.g. prx may have drag_gaussian as the default. In the future, the calibration may yield different implementations for different loci, striving to provide the best quality. Now we can convert the circuit to TimeBox es. TimeBox is a concept of IQM Pulse: a container for one or more instruction schedule fragments, to be scheduled according to a given scheduling strategy. timeboxes is a list of TimeBox objects, and you can edit them manually. A TimeBox can contain multiple children TimeBox es, each containing either more TimeBox es or a Schedule . A TimeBox containing a Schedule rather than children is referred to as “atomic”. In our example here the circuit was converted into one TimeBox containing 11 children atomic TimeBox es, which correspond to 11 circuit operations (7 gates + 1 barrier gate + 3 measurement gates). An atomic TimeBox holds its Schedule in an atom property: Next is a timebox-level stage, which only has one pass: multiplexing measurements. The measure_all() we called when\\ncreating the circuit adds a single TimeBox with the gate implementation Measure_Constant for each qubit in the\\ncircuit.\\nWith the measurement_mode='all' option, the first stage has also added a measurement TimeBox for the unused qubits. Multiplexing means executing all of these measurements at once, instead of one after the other.\\nThe multiplexing pass does this optimization for us: If you construct a circuit in Qiskit, and want to ensure multiplexing of measurement instructions, you have to “wrap” a group of measurement instructions with barrier s. This would prevent the Qiskit transpiler from putting any other instructions, acting on the same qubits, in between measurements, thus allowing the compiler to multiplex. Next we convert TimeBox es into a single Schedule . This is a recursive process which resolves all nested TimeBox es into atomic TimeBox es, and finally assembles a single Schedule out each of batches of TimeBox es. At this stage, all relative timings between pulses are resolved and fixed. Dynamical decoupling pulse sequences get inserted to replace Wait instructions. The process is controlled by a user-submitted dynamical decoupling strategy. By default, this stage is disabled. Please see other notebooks for examples of how to enable and apply dynamical decoupling. Next is a schedule-level stage. Its first pass applies calibrated phase corrections if MOVE gates are used (only applicable to QCs with computational resonator, i.e. IQM Star Architecture). The second pass removes non-functional instructions from the schedules. Finally, the last stage builds a final schedule from a number of instruction schedules. A playlist is just a compressed Schedule with no duplicate information, ready to be submitted for execution. In order to submit this final schedule for execution, we have to do one more thing: build the Station Control settings. The settings control the behaviour of instruments. At this point everything is ready to be submitted for execution to the server. Namely, these three objects will be used to construct a request to Station Control Service: playlist : sequence of instruction schedules corresponding to the batch of circuits to be executed settings : Station Control settings node context['readout_mappings'] : a mapping from measurement keys to the names of readout controller acquisition labels that will hold the measurement results Now we can convert these raw results into a Qiskit Result object: We can also submit the same circuit to CoCoS for execution. CoCoS is essentially a server-side Pulla with fixed standard stages. Since we started with a normal Qiskit backend and a circuit, execution is as simple as: previous Configuration and Usage next Custom Gates and Gate Implementations By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"IQM Pulla","url":"/iqm-pulla/index.html","description":"7.14 2025-04-26 Client-side library for Pulse-level access to IQM quantum computers. Index Module Index Search Page next IQM Pulla By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Releas...","content":"7.14 2025-04-26 Client-side library for Pulse-level access to IQM quantum computers. Index Module Index Search Page next IQM Pulla By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"API Reference","url":"/iqm-pulla/API.html","description":"iqm.cpc IQM Circuit to Pulse Compiler. iqm.pulla Client-side library for Pulse-level access to IQM quantum computers. previous Executing QIR programs next iqm.cpc By IQM Pulla developers © Copyright 2...","content":"iqm.cpc IQM Circuit to Pulse Compiler. iqm.pulla Client-side library for Pulse-level access to IQM quantum computers. previous Executing QIR programs next iqm.cpc By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"Examples","url":"/iqm-pulla/examples.html","description":"previous Custom Gates and Gate Implementations next Example: Measuring T1 By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26....","content":"previous Custom Gates and Gate Implementations next Example: Measuring T1 By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"References","url":"/iqm-pulla/references.html","description":"Nic Ezzell, Bibek Pokharel, Lina Tewala, Gregory Quiroz, and Daniel A. Lidar. Dynamical decoupling for superconducting qubits: a performance survey. Phys. Rev. Appl. , 20:064027, Dec 2023. arXiv:2207....","content":"Nic Ezzell, Bibek Pokharel, Lina Tewala, Gregory Quiroz, and Daniel A. Lidar. Dynamical decoupling for superconducting qubits: a performance survey. Phys. Rev. Appl. , 20:064027, Dec 2023. arXiv:2207.03670 , doi:10.1103/PhysRevApplied.20.064027 . previous License By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"User guides","url":"/iqm-pulla/user_guides.html","description":"previous Migration guide next Quick Start By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26....","content":"previous Migration guide next Quick Start By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"Import required packages","url":"/iqm-pulla/Example - Randomized Benchmarking.html","description":"Contact: pedro.romero@meetiqm.com & manish.thapa@meetiqm.com NB: Familiarity with quantum channels, gates and Clifford gates is assumed. The idea behind Clifford Randomized Benchmarking (CRB) is that ...","content":"Contact: pedro.romero@meetiqm.com & manish.thapa@meetiqm.com NB: Familiarity with quantum channels, gates and Clifford gates is assumed. The idea behind Clifford Randomized Benchmarking (CRB) is that under certain (simplified) types of noise, the average survival probability of the initial state of a quantum system under uniformly random sequences of multi-qubit Clifford gates with sequence inversion will decay exponentially in the length of the sequences. From such decay, one can in turn infer the average fidelity of the corresponding Clifford group. CRB sequences are of the form $$\\\\mathcal{S} m:=\\\\mathcal{C} {m+1}\\\\circ\\\\mathcal{C}_m\\\\circ\\\\cdots\\\\circ\\\\mathcal{C}_1,$$ for any $m\\\\geq1$, where $\\\\mathcal{C} i(\\\\cdot):=C_i(\\\\cdot)C_i^\\\\dagger$ is a unitary channel with $C_i$ being a Clifford gate, and where by definition $$\\\\mathcal{C} {m+1}=(\\\\mathcal{C}_m\\\\circ\\\\cdots\\\\circ\\\\mathcal{C} 1)^{-1}.$$ It is important to notice that $C {m+1}$ is itself a Clifford gate, i.e., one would not implement the sequence $\\\\mathcal{C}_m\\\\circ\\\\cdots\\\\circ\\\\mathcal{C} 1$ in practice, but rather compile the corresponding unitary operator $C_mC {m-1}\\\\cdots{C}_1$ into a single Clifford gate. The main assumption is that the real noisy gates can be approximately modeled independently by a quantum channel $\\\\mathcal{E}$ (completely positive, trace non-increasing map) as $\\\\tilde{\\\\mathcal{C}}_i\\\\approx\\\\mathcal{E}\\\\circ\\\\mathcal{C}_i$, or (ultimately equivalently) as $\\\\tilde{\\\\mathcal{C}}_i\\\\approx\\\\mathcal{C}_i\\\\circ\\\\mathcal{E}$. This implies that the noise is modeled as Markovian , time-stationary and gate-independent — while here we will take these for granted, a lot about RB in more general regimes is known, but it is in general more complicated, and often this simplistic scenario goes a long way as a useful first approximation. NB: CRB is not generally intended to work for $n>2$, both because of the scaling of the size of the $n$-qubit Clifford group in $n$, and because such gates have to eventually be transpiled to a native basis of 1Q and 2Q gates! While a high level of optimization in transpile is usually desirable, one must be careful for the optimization not to mess with the Clifford gates, i.e., we want the transformations between barriers in the circuit to implement a Clifford regardless of how it is decomposed. The specific decomposition still matters, however, because the (average) number of 2Q and 1Q gates (i.e., cz and r , respectively) will dictate how noisily we can implement the Cliffords on average, i.e., the average gate fidelity we will ultimately obtain. We will not do this check here, but it is now known that a good decomposition of Clifford gates in our basis will have on average 8.25 cz gates and 1.5 r gates (e.g., see arXiv:1402.4848 ). We can count the number of native 1Q and 2Q gates by using the circuit attribute count_ops() One important reason why CRB works –and why specifically it uses Clifford gates–, is that the uniformly distributed multi-qubit Clifford group forms a unitary 2-design. This essentially means that any quantity that takes two copies of the pair $C, C^\\\\dagger$ and then averaged over all possible $C$s, will be exactly the same as if $C$ had been any uniformly distributed (so-called Haar) random unitary. This matters because there are plenty of results allowing to easily compute such quantities (i.e., second moments) over the whole uniformly distributed unitary group — in fact, such second moment simply takes the form of a depolarizing channel (RB precisely extracts the average gate fidelity through the corresponding polarization parameter). The CRB sequences are quantities of this type because of the final inverse at the end (i.e. all sequences will have 2 copies of pairs $C_i,C_i^\\\\dagger$ for all $i=1,2,\\\\ldots,m$). This is the reason why the theory behind RB, under the noise assumptions above, can ensure that the decay in average fidelity, i.e., quantities like $$f_0=\\\\langle0|\\\\mathcal{S}_m(|0\\\\rangle!\\\\langle0|)|0\\\\rangle$$ take the form of a function $$f_0=Ap^m+B$$ for $0\\\\leq{A,B,p}\\\\leq1$. Furthermore, it ensures that $p$ will encode the average gate fidelity of the noisy Clifford gates, whilst $A,B$ will encode (and isolate) errors due to state preparation and measurement. This is what is meant by RB being SPAM-robust. In the modeling with assummptions of noisy gates above, this means $p\\\\sim\\\\int{d}\\\\psi\\\\langle\\\\psi|\\\\mathcal{E}(|\\\\psi\\\\rangle!\\\\langle\\\\psi|)|\\\\psi\\\\rangle$ for all possible uniformly distributed pure states $|\\\\psi\\\\rangle$, and $A\\\\sim\\\\langle0|\\\\mathcal{E} \\\\text{spam}(|0\\\\rangle!\\\\langle0|)|0\\\\rangle$, $B\\\\sim\\\\langle0|\\\\mathcal{E} \\\\text{spam}(\\\\mathbb{I}/2^n)|0\\\\rangle$ for a composition of the state preparation and measurement noise. We may now fix a number of circuit samples and sequence lengths. Despite the Clifford group having a (super) exponential amount of terms (e.g., 24 for 1Q, then 11,520 for 2Q), approximating the average over the whole group with finite samples quickly converges to the Haar average. On the other hand, the sequence lengths can be chosen as exponentially spaced and aiming at long sequences, if possible, serves to better determine the offset constant (often named the nuisance parameter, for obvious reasons) in the decay. Depending on how many circuits we want to execute, we could either generate all circuit samples for all circuit lengths and send all for execution once, or we may, for example, generate a given amount of circuits, send them to execution while meanwhile continuing to generate circuits and sending them. In either case, one may retrieve the results later. Here we will generate all circuits for all sequence lengths, and send them to execute as a single batch on the backend. It is generally a good idea to store (at least at this stage) both the abstract and the transpiled circuits, so that we can inspect them later on. We can inspect the circuits just as a sanity check Task : Count the average number of 1Q and 2Q gates in the circuits for each sequence length. Task : Since the Clifford group is a 2-design, its so-called frame potential (see e.g., arXiv:1610.04903 ) has to satisfy $\\\\displaystyle{\\\\sum_{k,,k^\\\\prime=1}^K}\\\\left|\\\\mathrm{tr}\\\\left(C_{k^\\\\prime}^{\\\\dagger}C_k\\\\right)\\\\right|^4/K^2 = 2$. Verify this condition for the 1Q Clifford group. warning for the 2Q Clifford group: there are in total $n=11,520^2 = 132,710,400$ values in the sum! It suffices to compute the values in a triangular part of the matrix $U_{k^\\\\prime}^{\\\\dagger}U_k$  — so you can definitely verify this property, however there will still be $n(n-1)/2$ such terms for your computer to sum up! We can now send the transpiled circuits to be run on the hardware. NB: It is generally preferable to use backend.run instead of execute command, since the latter performs a transpilation pass “under the hood”. We can now inspect the results for a given sequence length (we will use the one defined above). The counts at the ground state relate to the survival probability (or state fidelity) of such state under our random Clifford circuits. Task : Compare the histograms between the outcomes for the narrowest and the deepest circuits NB: You can wrap plot_histogram() with display(*) to show both results in one cell By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"Executing QIR programs","url":"/iqm-pulla/Example - Executing QIR programs.html","description":"If you have a QIR string or bitcode, you can start by creating Pulla-compatible circuits representation. You can also generate a QIR string or bitcode from a qiskit circuit using IQM’s fork of qiskit_...","content":"If you have a QIR string or bitcode, you can start by creating Pulla-compatible circuits representation. You can also generate a QIR string or bitcode from a qiskit circuit using IQM’s fork of qiskit_qir , available as the package iqm-qiskit-qir . previous Example: Dynamical decoupling next API Reference By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc","url":"/iqm-pulla/api/iqm.cpc.html","description":"IQM Circuit to Pulse Compiler. IQM Circuit to Pulse Compiler is a Python-based library for converting quantum circuits\\ninto instruction schedules (which map Station Control controller names to their p...","content":"IQM Circuit to Pulse Compiler. IQM Circuit to Pulse Compiler is a Python-based library for converting quantum circuits\\ninto instruction schedules (which map Station Control controller names to their pulse playlists) and Station Control settings\\nrequired for circuit execution, using the calibration data it is given.\\nThe generated schedules and settings can be sent to Station Control\\nfor execution on real or simulated quantum hardware. CPC is normally only accessed indirectly through Cocos or its reference client IQM client ,\\nor a frontend such as Cirq on IQM or Qiskit on IQM . Subpackages and modules compiler Compile quantum circuits into instruction schedules and settings that can be executed on a station. interface Pydantic models used by the API. previous API Reference next iqm.cpc.compiler By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils_qiskit.station_control_result_to_qiskit","url":"/iqm-pulla/api/iqm.pulla.utils_qiskit.station_control_result_to_qiskit.html","description":"Convert a Station Control result to a Qiskit Result. station_control_result ( StationControlResult ) – The Station Control result to convert. shots ( int ) – number of shots requested execution_option...","content":"Convert a Station Control result to a Qiskit Result. station_control_result ( StationControlResult ) – The Station Control result to convert. shots ( int ) – number of shots requested execution_options ( CircuitExecutionOptions ) – Circuit execution options used to produce the result. The equivalent Qiskit Result. Result previous iqm.pulla.utils_qiskit.qiskit_to_pulla next iqm.pulla.utils_qiskit.DummyJob By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils.replace_instruction_in_place","url":"/iqm-pulla/api/iqm.pulla.utils.replace_instruction_in_place.html","description":"Replace an instruction in a schedule with one or more instructions. schedule ( Schedule ) – The schedule to modify. channel_name ( str ) – The name of the channel containing the instruction to replace...","content":"Replace an instruction in a schedule with one or more instructions. schedule ( Schedule ) – The schedule to modify. channel_name ( str ) – The name of the channel containing the instruction to replace. index ( int ) – The index of the instruction to replace. replacement ( Iterable [ Instruction ] ) – Instructions to replace the original instruction with. The modified schedule. Schedule previous iqm.pulla.utils.print_schedule next iqm.pulla.utils_cirq By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils.convert_sweep_spot_with_heralding_mode_zero","url":"/iqm-pulla/api/iqm.pulla.utils.convert_sweep_spot_with_heralding_mode_zero.html","description":"Like convert_sweep_spot() , but for results that contain heralding measurements. For each circuit we only keep the shots for which the heralding result is zero for all the\\nqubits used in the circuit. ...","content":"Like convert_sweep_spot() , but for results that contain heralding measurements. For each circuit we only keep the shots for which the heralding result is zero for all the\\nqubits used in the circuit. results ( dict [ str , ndarray ] ) – Mapping of acquisition labels to 1D arrays of readout results with the length num_shots * num_triggers_for_label_in_batch . The herald\\nresults are found under HERALDING_KEY . readout_mappings ( tuple [ dict [ str , tuple [ str , ... ] ] , ... ] ) – For each circuit in the batch, a mapping of measurement keys to corresponding\\ntuples of acquisition labels. converted, filtered measurement results, with the heralding measurement data removed list [ dict [ str , list [ list [ int ]]]] previous iqm.pulla.utils.convert_sweep_spot next iqm.pulla.utils.extract_readout_controller_result_names By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.interface","url":"/iqm-pulla/api/iqm.cpc.interface.html","description":"Pydantic models used by the API. Subpackages and modules compiler Pydantic models used by the API. previous iqm.cpc.compiler.station_settings.Map next iqm.cpc.interface.compiler By IQM Pulla developer...","content":"Pydantic models used by the API. Subpackages and modules compiler Pydantic models used by the API. previous iqm.cpc.compiler.station_settings.Map next iqm.cpc.interface.compiler By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.standard_stages.resolve_timeboxes","url":"/iqm-pulla/api/iqm.cpc.compiler.standard_stages.resolve_timeboxes.html","description":"Resolve the timeboxes to schedules. timeboxes ( Iterable [ TimeBox ] ) – builder ( ScheduleBuilder ) – list [ Schedule ] previous iqm.cpc.compiler.standard_stages.resolve_circuits next iqm.cpc.compile...","content":"Resolve the timeboxes to schedules. timeboxes ( Iterable [ TimeBox ] ) – builder ( ScheduleBuilder ) – list [ Schedule ] previous iqm.cpc.compiler.standard_stages.resolve_circuits next iqm.cpc.compiler.standard_stages.validate_circuits By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.errors.CircuitError","url":"/iqm-pulla/api/iqm.cpc.compiler.errors.CircuitError.html","description":"There is something wrong with the quantum circuit. previous iqm.cpc.compiler.errors.CalibrationError next iqm.cpc.compiler.errors.ClientError By IQM Pulla developers © Copyright 2024-2025, IQM Finland...","content":"There is something wrong with the quantum circuit. previous iqm.cpc.compiler.errors.CalibrationError next iqm.cpc.compiler.errors.ClientError By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils.circuit_operations_to_cpc","url":"/iqm-pulla/api/iqm.pulla.utils.circuit_operations_to_cpc.html","description":"Convert a list of CircuitOperations to an IQM CPC Circuit. circ_ops ( tuple [ CircuitOperation ] ) – The CircuitOperations to convert. name ( str | None ) – Optional name of the circuit. The equivalen...","content":"Convert a list of CircuitOperations to an IQM CPC Circuit. circ_ops ( tuple [ CircuitOperation ] ) – The CircuitOperations to convert. name ( str | None ) – Optional name of the circuit. The equivalent IQM CPC Circuit. Circuit previous iqm.pulla.utils.calset_to_cal_data_tree next iqm.pulla.utils.convert_sweep_spot By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.errors.UnknownLogicalQubitError","url":"/iqm-pulla/api/iqm.cpc.compiler.errors.UnknownLogicalQubitError.html","description":"A logical qubit in the circuit has not been defined in the qubit mapping. previous iqm.cpc.compiler.errors.UnknownHardwareComponentError next iqm.cpc.compiler.standard_stages By IQM Pulla developers ©...","content":"A logical qubit in the circuit has not been defined in the qubit mapping. previous iqm.cpc.compiler.errors.UnknownHardwareComponentError next iqm.cpc.compiler.standard_stages By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.dd.insert_dd_sequences","url":"/iqm-pulla/api/iqm.cpc.compiler.dd.insert_dd_sequences.html","description":"Insert dynamical decoupling sequences into the given schedule. Note Modifies schedule in-place. Note Assumes that the PRX implementation used only applies non-wait instructions on a single drive chann...","content":"Insert dynamical decoupling sequences into the given schedule. Note Modifies schedule in-place. Note Assumes that the PRX implementation used only applies non-wait instructions on a single drive channel,\\nand that the PRX duration does not depend on its arguments. builder ( ScheduleBuilder ) – Schedule builder used to build schedule , containing channel information. schedule ( Schedule ) – Schedule to modify. strategy ( DDStrategy ) – Dynamical decoupling strategy to use. None previous iqm.cpc.compiler.dd.STANDARD_DD_STRATEGY next iqm.cpc.compiler.dd.merge_wait_instructions_in_schedule By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.standard_stages","url":"/iqm-pulla/api/iqm.cpc.compiler.standard_stages.html","description":"Standard compilation stages, their constituent compiler passes, and functions for implementing them. There are 6 standard compilation stages: Circuit-to-circuit. Circuit-to-timebox. Timebox-to-timebox...","content":"Standard compilation stages, their constituent compiler passes, and functions for implementing them. There are 6 standard compilation stages: Circuit-to-circuit. Circuit-to-timebox. Timebox-to-timebox. Timebox-to-schedule. Schedule-to-schedule. Schedule-to-playlist. Breakdown of compiler passes of each stage: Validate the circuit execution options. Map backwards-compatible aliases for quantum operation names into the current name. This is needed until old\\noperation names such as phased_rx and measurement are no longer supported. Validate the contents of the circuits. Map the logical QPU components to physical QPU components. Provided mapping is used, if any.\\nOtherwise, identity mapping is used. Choose implementations for circuit operations based on the calibration set. Derive mapping between station acquisition labels and user’s measurement keys. Populates readout_mappings and heralded_components of context. Resolve the circuits to timeboxes using ScheduleBuilder.circuit_to_timebox() . Merge any MultiplexedProbeTimeBoxes inside each TimeBox using TimeBox.composite() . Add the heralding measurement timebox to all circuits if HeraldingMode in circuit execution options\\nrequires it. Add a reset timebox to all circuits. Resolve the timeboxes to schedules using ScheduleBuilder.resolve_timebox() . Apply dynamical decoupling sequences to the schedule if requested. Apply resonator-related phase corrections if MOVE gates are used. Remove non-functional instructions from schedules using ScheduleBuilder._finish_schedule() . Build the playlist from the schedules using ScheduleBuilder.build_playlist() . Functions apply_dd_strategy (schedules, builder, options) Insert dynamical decoupling sequences into the schedules, if dynamical decoupling is enabled. apply_move_gate_phase_corrections (schedules, ...) Apply calibrated phase corrections if MOVE gates are used. build_playlist (schedules, builder) Build the playlist from the schedules. choose_op_implementations (circuits, builder, ...) Analyze the instructions in the circuits and pick an implementation for each (operation, locus). clean_schedule (schedules, builder) Remove non-functional instructions from schedules . derive_readout_mappings (circuits, builder, ...) Derive mapping between station acquisition labels and user's measurement keys. get_standard_stages ([idempotent]) Get a copy of the standard compilation stages. map_components (circuits, builder, ...) Map the logical QPU components to physical QPU components using component_mapping . map_old_operations (circuits) Map backwards-compatible aliases for quantum operation names into the current name. merge_multiplexed_timeboxes (circuit_box) Merge any MultiplexedProbeTimeBoxes inside a TimeBox representing a circuit. multiplex_readout (timeboxes) Merge any MultiplexedProbeTimeBoxes inside a TimeBox representing a circuit. prepend_heralding (timeboxes, builder, ...) Add the heralding measurement timebox to all circuits. prepend_reset (timeboxes, builder, options, ...) Add a reset timebox to all circuits. resolve_circuits (circuits, builder) Resolve the circuits to timeboxes. resolve_timeboxes (timeboxes, builder) Resolve the timeboxes to schedules. validate_circuits (circuits, builder) Validate the contents of the quantum circuits. validate_execution_options (circuits, options) Validate the circuit execution options (only some combinations make sense). previous iqm.cpc.compiler.errors.UnknownLogicalQubitError next iqm.cpc.compiler.standard_stages.apply_dd_strategy By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils_qiskit","url":"/iqm-pulla/api/iqm.pulla.utils_qiskit.html","description":"Utilities for working with Qiskit objects. Functions qiskit_circuits_to_pulla (qiskit_circuits, ...) Convert Qiskit quantum circuits into IQM Pulse quantum circuits. qiskit_to_pulla (pulla, backend, q...","content":"Utilities for working with Qiskit objects. Functions qiskit_circuits_to_pulla (qiskit_circuits, ...) Convert Qiskit quantum circuits into IQM Pulse quantum circuits. qiskit_to_pulla (pulla, backend, qiskit_circuits) Convert transpiled Qiskit quantum circuits to IQM Pulse quantum circuits. station_control_result_to_qiskit (...) Convert a Station Control result to a Qiskit Result. Classes DummyJob (backend, qiskit_result) A dummy job object that can be used to retrieve the result of a locally compiled circuit. IQMPullaBackend (architecture, pulla, compiler) A backend that compiles circuits locally using Pulla and submits them to Station Control for execution. Inheritance previous iqm.pulla.utils_qir.qir_to_pulla next iqm.pulla.utils_qiskit.qiskit_circuits_to_pulla By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils_dd.generate_phases_of_urn_sequence","url":"/iqm-pulla/api/iqm.pulla.utils_dd.generate_phases_of_urn_sequence.html","description":"Generate PRX gate phases for the URn sequence. More information on the URn sequence is available in [ 1 ] , at the end in Appendix A.1. n ( int ) – Number of single qubit PRX pulses with different pha...","content":"Generate PRX gate phases for the URn sequence. More information on the URn sequence is available in [ 1 ] , at the end in Appendix A.1. n ( int ) – Number of single qubit PRX pulses with different phases to apply, must be a positive even number. Phases to be used by the URn sequence. list [ float ] previous iqm.pulla.utils_dd next iqm.pulla.utils_qir By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.standard_stages.choose_op_implementations","url":"/iqm-pulla/api/iqm.cpc.compiler.standard_stages.choose_op_implementations.html","description":"Analyze the instructions in the circuits and pick an implementation for each (operation, locus). Note This function modifies circuits in place. circuits ( Iterable [ Circuit ] ) – builder ( ScheduleBu...","content":"Analyze the instructions in the circuits and pick an implementation for each (operation, locus). Note This function modifies circuits in place. circuits ( Iterable [ Circuit ] ) – builder ( ScheduleBuilder ) – options ( CircuitExecutionOptions ) – tuple [ list [ Circuit ], dict [ str , Any ]] previous iqm.cpc.compiler.standard_stages.build_playlist next iqm.cpc.compiler.standard_stages.clean_schedule By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.compiler.Compiler","url":"/iqm-pulla/api/iqm.cpc.compiler.compiler.Compiler.html","description":"Bases: object Stateful object that contains a calibration set, a schedule builder, and a set\\nof compilation stages. The compiler’s state does not include the data to be compiled. calibration_set ( Cal...","content":"Bases: object Stateful object that contains a calibration set, a schedule builder, and a set\\nof compilation stages. The compiler’s state does not include the data to be compiled. calibration_set ( CalibrationSet ) – Calibration data. chip_topology ( ChipTopology ) – Physical layout and connectivity of the quantum chip. channel_properties ( dict [ str , ChannelProperties ] ) – Channel properties. component_channels ( dict [ str , dict [ str , str ] ] ) – Mapping between components and their control channels. component_mapping ( dict [ str , str ] | None ) – Custom mapping of components. Defaults to None. options ( CircuitExecutionOptions ) – Circuit execution options.\\nDefaults to STANDARD_CIRCUIT_EXECUTION_OPTIONS. stages ( list [ CompilationStage ] | None ) – List of compilation stages. Defaults to None.\\nNote that in the absence of stages, the compiler will not be ready to compile circuits. strict ( bool ) – If True, raises CalibrationError on calibration validation failures.\\nIf False, only logs warnings. Defaults to False. CalibrationError – When strict=True and calibration validation fails during compiler initialization. Attributes gates Registered quantum gates. Methods _refresh () Refresh the compiler by re-creating the ScheduleBuilder and validating the calibration. add_implementation (op_name, impl_name, ...) Adds a new implementation of a quantum operation (gate). amend_calibration_for_gate_implementation (...) Update the current local calibration set with calibration values for a specific gate/implementation/locus. build_settings (context, shots) Build the settings for the execution. compile (data[, context]) Run all compiler stages. compiler_context () Return initial compiler context dictionary. get_calibration () Returns a copy of the current local calibration set. print_all_implementations_trees () Prints all implementations of all currently known quantum operations (gates), including parameters. print_implementations_trees (op) Prints all implementation of a particular quantum operation (gate). ready () Check if the compiler is ready to compile circuits. set_calibration (calibration) Sets the current calibration set to a given calibration set, then refreshes the compiler. set_default_implementation (gate_name, ...) Set the default implementation of a gate. set_default_implementation_for_loci (...) Set the default implementation for a gate for a specific loci. show_stages ([full]) Print the stages and passes defined in the compiler. Returns a copy of the current local calibration set. dict [ str , bool | str | int | float | complex | ndarray ] Sets the current calibration set to a given calibration set, then refreshes the compiler. calibration ( dict [ str , bool | str | int | float | complex | ndarray ] ) – The calibration set to be set as the current calibration set. None Registered quantum gates. Set the default implementation of a gate. gate_name ( str ) – Name of the gate. implementation_name ( str ) – Name of the implementation to set as the default. None Set the default implementation for a gate for a specific loci. gate_name ( str ) – Name of the gate. implementation_name ( str ) – Name of the implementation to set as the default for loci . loci ( Iterable [ tuple [ str , ... ] ] ) – Loci of the gate for which to set implementation_name as the default. None Update the current local calibration set with calibration values for a specific gate/implementation/locus. The calibration values are given as a dictionary\\nof parameter names and their values. This method refreshes the compiler after amending the calibration set. gate_name ( str ) – Name of the gate to which the calibration values are applied. impl_name ( str ) – Name of the implementation of the gate to which the calibration values are applied. locus ( tuple [ str , ... ] ) – Locus of the gate to which the calibration values are applied. params ( dict [ str , Any ] ) – Updated parameter names and their values. None Adds a new implementation of a quantum operation (gate). Refreshes the compiler after adding a new implementation. op_name ( str ) – The gate name for which to register a new implementation. impl_name ( str ) – The “human-readable” name with which the new gate implementation will be found e.g. in settings. implementation ( type [ GateImplementation ] ) – The python class of the new gate implementation to be added. set_as_default ( bool ) – Whether to set the new implementation as the default implementation for the gate. overwrite ( bool ) – If True, allows replacing any existing implementation of the same name. quantum_op_specs ( QuantumOp | dict | None ) – The quantum operation this gate represents. If a QuantumOp is given, it is used as is.\\nIf None is given and the same gate has been registered before, the previously registered properties are\\nused.\\nOtherwise, the given dict values are given to the constructor of QuantumOp .\\nFor any missing constructor values, some defaults suitable for a 1-QB gate are used. None Check if the compiler is ready to compile circuits. The compiler is ready if at least one stage is defined, and\\nall the stages are non-empty. bool Prints all implementations of all currently known quantum operations (gates), including parameters. None Prints all implementation of a particular quantum operation (gate). op ( QuantumOp ) – Quantum operation (gate) to print implementations of. None Print the stages and passes defined in the compiler. full ( bool ) – Iff True, also print the docstring of each pass function. None Return initial compiler context dictionary. Used automatically by Compiler.compile() . dict [ str , Any ] Run all compiler stages. Initial context will be derived from Compiler.compiler_context() unless a custom\\ncontext dictionary is provided. data ( Iterable [ Any ] ) – An iterable of circuits to be compiled. context ( dict [ str , Any ] | None ) – Custom initial compiler context dictionary. tuple [ Iterable [ Any ], dict [ str , Any ]] Build the settings for the execution. Updates context[“circuit_metrics”] with schedule_duration and\\nmin_execution_time. context ( dict [ str , Any ] ) – A dictionary containing the necessary data for building the settings. shots ( int ) – The number of shots to be executed. A dictionary containing the settings for the execution.\\ncontext: The updated context. settings previous iqm.cpc.compiler.compiler.CompilationStage next iqm.cpc.compiler.dd By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.interface.CircuitMeasurementResultsBatch","url":"/iqm-pulla/api/iqm.pulla.interface.CircuitMeasurementResultsBatch.html","description":"Type that represents measurement results for a batch of circuits. alias of list [ dict [ str , list [ list [ int ]]]] previous iqm.pulla.interface.CircuitMeasurementResults next iqm.pulla.interface.BU...","content":"Type that represents measurement results for a batch of circuits. alias of list [ dict [ str , list [ list [ int ]]]] previous iqm.pulla.interface.CircuitMeasurementResults next iqm.pulla.interface.BUFFER_AFTER_MEASUREMENT_PROBE By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils.InstructionLocation","url":"/iqm-pulla/api/iqm.pulla.utils.InstructionLocation.html","description":"Bases: tuple Return type for locate_instructions() . Attributes channel_name Alias for field number 0 duration Alias for field number 2 index Alias for field number 1 Methods __getnewargs__ () Return ...","content":"Bases: tuple Return type for locate_instructions() . Attributes channel_name Alias for field number 0 duration Alias for field number 2 index Alias for field number 1 Methods __getnewargs__ () Return self as a plain tuple. __new__ (_cls, channel_name, index, duration) Create new instance of InstructionLocation(channel_name, index, duration) __repr__ () Return a nicely formatted representation string _asdict () Return a new dict which maps field names to their values. _make (iterable) Make a new InstructionLocation object from a sequence or iterable _replace (**kwds) Return a new InstructionLocation object replacing specified fields with new values Alias for field number 0 Alias for field number 2 Alias for field number 1 previous iqm.pulla.utils next iqm.pulla.utils.build_settings By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.interface.Instruction","url":"/iqm-pulla/api/iqm.pulla.interface.Instruction.html","description":"Bases: BaseModel An instruction in a quantum circuit. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name name of...","content":"Bases: BaseModel An instruction in a quantum circuit. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name name of the quantum operation implementation name of the implementation qubits names of the logical qubits the operation acts on args arguments for the operation Methods to_dataclass () Convert the model to a dataclass. name ( str ) – implementation ( str | None ) – qubits ( tuple [ str , ... ] ) – args ( dict [ str , Any ] ) – name of the quantum operation name of the implementation names of the logical qubits the operation acts on arguments for the operation Convert the model to a dataclass. CircuitOperation Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.pulla.interface.Circuit next iqm.pulla.interface.StationControlResult By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.interface.TaskStatus","url":"/iqm-pulla/api/iqm.pulla.interface.TaskStatus.html","description":"Bases: StrEnum Status of a Station Control task. Attributes READY Task has completed successfully FAILED Task has failed PROGRESS Task is being executed PENDING Task is waiting to be executed Methods ...","content":"Bases: StrEnum Status of a Station Control task. Attributes READY Task has completed successfully FAILED Task has failed PROGRESS Task is being executed PENDING Task is waiting to be executed Methods __format__ (format_spec, /) Return a formatted version of the string as described by format_spec. __new__ (value)  __str__ () Return str(self). Task has completed successfully Task has failed Task is being executed Task is waiting to be executed previous iqm.pulla.interface.StationControlResult next iqm.pulla.interface.CHADRetrievalException By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.compiler.pass_function_idempotent","url":"/iqm-pulla/api/iqm.cpc.compiler.compiler.pass_function_idempotent.html","description":"Wrap a pass function to make it idempotent. function ( Callable [ [ Any , dict [ str , Any ] ] , tuple [ Any , dict [ str , Any ] ] ] ) – Callable [[ Any , dict [ str , Any ]], tuple [ Any , dict [ st...","content":"Wrap a pass function to make it idempotent. function ( Callable [ [ Any , dict [ str , Any ] ] , tuple [ Any , dict [ str , Any ] ] ] ) – Callable [[ Any , dict [ str , Any ]], tuple [ Any , dict [ str , Any ]]] previous iqm.cpc.compiler.compiler.compiler_pass next iqm.cpc.compiler.compiler.CompilationStage By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.interface.compiler.ReadoutMappingBatch","url":"/iqm-pulla/api/iqm.cpc.interface.compiler.ReadoutMappingBatch.html","description":"Type that represents tuple of readout mappings, one per each circuit in a circuit batch. alias of tuple [ dict [ str , tuple [ str , …]], …] previous iqm.cpc.interface.compiler.ReadoutMapping next iqm...","content":"Type that represents tuple of readout mappings, one per each circuit in a circuit batch. alias of tuple [ dict [ str , tuple [ str , …]], …] previous iqm.cpc.interface.compiler.ReadoutMapping next iqm.cpc.interface.compiler.Circuit By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils.initialize_schedule_builder","url":"/iqm-pulla/api/iqm.pulla.utils.initialize_schedule_builder.html","description":"Initialize a new schedule builder for the station, validate that it is configured properly. calibration_set ( dict [ str , bool | str | int | float | complex | ndarray ] ) – calibration data for the s...","content":"Initialize a new schedule builder for the station, validate that it is configured properly. calibration_set ( dict [ str , bool | str | int | float | complex | ndarray ] ) – calibration data for the station the circuits are executed on chip_topology ( ChipTopology ) – topology of the QPU the circuits are executed on channel_properties ( dict [ str , ChannelProperties ] ) – properties of control channels on the station component_channels ( dict [ str , dict [ str , str ] ] ) – QPU component to function to channel mapping schedule builder for the station ScheduleBuilder previous iqm.pulla.utils.get_hash_for next iqm.pulla.utils.iqm_circuit_to_gate_implementation By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils.build_settings","url":"/iqm-pulla/api/iqm.pulla.utils.build_settings.html","description":"Construct the Station Control settings needed for executing a batch of quantum circuits. shots ( int ) – number of times to execute/sample each circuit calibration_set ( dict [ str , bool | str | int ...","content":"Construct the Station Control settings needed for executing a batch of quantum circuits. shots ( int ) – number of times to execute/sample each circuit calibration_set ( dict [ str , bool | str | int | float | complex | ndarray ] ) – calibration data for the station the circuits are executed on builder ( ScheduleBuilder ) – schedule builder object, encapsulating station properties and gate calibration data circuit_metrics ( Iterable [ CircuitMetrics ] ) – statistics about the circuits to be executed options ( CircuitExecutionOptions ) – various discrete options for circuit execution that affect compilation Station Control settings SettingNode previous iqm.pulla.utils.InstructionLocation next iqm.pulla.utils.calset_from_observations By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.interface.compiler.CircuitExecutionOptions","url":"/iqm-pulla/api/iqm.cpc.interface.compiler.CircuitExecutionOptions.html","description":"Bases: object Various discrete options for quantum circuit execution. Attributes measurement_mode  heralding_mode  dd_mode  dd_strategy  circuit_boundary_mode  move_gate_validation  move_gate_frame_tr...","content":"Bases: object Various discrete options for quantum circuit execution. Attributes measurement_mode  heralding_mode  dd_mode  dd_strategy  circuit_boundary_mode  move_gate_validation  move_gate_frame_tracking  active_reset_cycles  Methods __delattr__ (name) Implement delattr(self, name). __eq__ (other) Return self==value. __hash__ () Return hash(self). __repr__ () Return repr(self). __setattr__ (name, value) Implement setattr(self, name, value). measurement_mode ( MeasurementMode ) – heralding_mode ( HeraldingMode ) – dd_mode ( DDMode ) – dd_strategy ( DDStrategy | None ) – circuit_boundary_mode ( CircuitBoundaryMode ) – move_gate_validation ( MoveGateValidationMode ) – move_gate_frame_tracking ( MoveGateFrameTrackingMode ) – active_reset_cycles ( int | None ) – previous iqm.cpc.interface.compiler.CircuitCompilationResult next iqm.cpc.interface.compiler.CircuitMetrics By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.standard_stages.map_components","url":"/iqm-pulla/api/iqm.cpc.compiler.standard_stages.map_components.html","description":"Map the logical QPU components to physical QPU components using component_mapping . circuits ( Iterable [ Circuit ] ) – builder ( ScheduleBuilder ) – component_mapping ( dict [ str , str ] ) – previou...","content":"Map the logical QPU components to physical QPU components using component_mapping . circuits ( Iterable [ Circuit ] ) – builder ( ScheduleBuilder ) – component_mapping ( dict [ str , str ] ) – previous iqm.cpc.compiler.standard_stages.get_standard_stages next iqm.cpc.compiler.standard_stages.map_old_operations By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.standard_stages.resolve_circuits","url":"/iqm-pulla/api/iqm.cpc.compiler.standard_stages.resolve_circuits.html","description":"Resolve the circuits to timeboxes. circuits ( Iterable [ Circuit ] ) – builder ( ScheduleBuilder ) – list [ TimeBox ] previous iqm.cpc.compiler.standard_stages.prepend_reset next iqm.cpc.compiler.stan...","content":"Resolve the circuits to timeboxes. circuits ( Iterable [ Circuit ] ) – builder ( ScheduleBuilder ) – list [ TimeBox ] previous iqm.cpc.compiler.standard_stages.prepend_reset next iqm.cpc.compiler.standard_stages.resolve_timeboxes By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.station_settings.Map","url":"/iqm-pulla/api/iqm.cpc.compiler.station_settings.Map.html","description":"Bases: object Mapping from a calibration observation path to a corresponding station settings path. If settings_path_template is None , it is derived from observation_path_template . A Parameter objec...","content":"Bases: object Mapping from a calibration observation path to a corresponding station settings path. If settings_path_template is None , it is derived from observation_path_template . A Parameter object is included in the mapping to conveniently handle the unit and data type.\\nIts name is unused. Attributes required  settings_path_template  parameter  observation_path_template  Methods __delattr__ (name) Implement delattr(self, name). __eq__ (other) Return self==value. __hash__ () Return hash(self). __repr__ () Return repr(self). __setattr__ (name, value) Implement setattr(self, name, value). observation_path (component) Observation path for the given component. settings_path (component) Settings path for the given component. parameter ( Parameter ) – observation_path_template ( str ) – settings_path_template ( str | None ) – required ( bool ) – Observation path for the given component. component ( str ) – str Settings path for the given component. component ( str ) – str previous iqm.cpc.compiler.station_settings.find_observation next iqm.cpc.interface By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.interface","url":"/iqm-pulla/api/iqm.pulla.interface.html","description":"Common data types and exceptions for the IQM Pulla interface. Many of these must be identical to those in iqm-client. Module Attributes CircuitMeasurementResults Measurement results from a single circ...","content":"Common data types and exceptions for the IQM Pulla interface. Many of these must be identical to those in iqm-client. Module Attributes CircuitMeasurementResults Measurement results from a single circuit/schedule. CircuitMeasurementResultsBatch Type that represents measurement results for a batch of circuits. BUFFER_AFTER_MEASUREMENT_PROBE Buffer that allows the readout resonator and qubit state to stabilize after a probe pulse, in s. Classes Circuit (*, name, instructions[, metadata]) Quantum circuit to be executed. Instruction (*, name[, implementation]) An instruction in a quantum circuit. StationControlResult (sweep_id, task_id, status) Result of a station control task TaskStatus (value[, names, module, qualname, ...]) Status of a Station Control task. Exceptions CHADRetrievalException Exception for CHAD retrieval failures. ChipLabelRetrievalException Exception for chip label retrieval failures. SettingsRetrievalException Exception for Station Control settings retrieval failures. Inheritance previous iqm.pulla.calibration.CalibrationDataProvider next iqm.pulla.interface.CircuitMeasurementResults By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils_qiskit.DummyJob","url":"/iqm-pulla/api/iqm.pulla.utils_qiskit.DummyJob.html","description":"Bases: JobV1 A dummy job object that can be used to retrieve the result of a locally compiled circuit. The job_id is the same as the sweep_id of the StationControlResult . Attributes Methods result ()...","content":"Bases: JobV1 A dummy job object that can be used to retrieve the result of a locally compiled circuit. The job_id is the same as the sweep_id of the StationControlResult . Attributes Methods result () Return the results of the job. status () Return the status of the job, among the values of JobStatus . submit () Submit the job to the backend for execution. Return the results of the job. Return the status of the job, among the values of JobStatus . Submit the job to the backend for execution. previous iqm.pulla.utils_qiskit.station_control_result_to_qiskit next iqm.pulla.utils_qiskit.IQMPullaBackend By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.standard_stages.validate_circuits","url":"/iqm-pulla/api/iqm.cpc.compiler.standard_stages.validate_circuits.html","description":"Validate the contents of the quantum circuits. circuits ( Iterable [ Circuit ] ) – builder ( ScheduleBuilder ) – previous iqm.cpc.compiler.standard_stages.resolve_timeboxes next iqm.cpc.compiler.stand...","content":"Validate the contents of the quantum circuits. circuits ( Iterable [ Circuit ] ) – builder ( ScheduleBuilder ) – previous iqm.cpc.compiler.standard_stages.resolve_timeboxes next iqm.cpc.compiler.standard_stages.validate_execution_options By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.interface.CircuitMeasurementResults","url":"/iqm-pulla/api/iqm.pulla.interface.CircuitMeasurementResults.html","description":"Measurement results from a single circuit/schedule. For each measurement operation in the circuit,\\nmaps the measurement key to the corresponding results. The outer list elements correspond to shots,\\na...","content":"Measurement results from a single circuit/schedule. For each measurement operation in the circuit,\\nmaps the measurement key to the corresponding results. The outer list elements correspond to shots,\\nand the inner list elements to the qubits measured in the measurement operation. alias of dict [ str , list [ list [ int ]]] previous iqm.pulla.interface next iqm.pulla.interface.CircuitMeasurementResultsBatch By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.errors.ClientError","url":"/iqm-pulla/api/iqm.cpc.compiler.errors.ClientError.html","description":"Client submitted a bad request, and needs to be notified. Errors inheriting this class will be reported to the client in the message field of the failed job. previous iqm.cpc.compiler.errors.CircuitEr...","content":"Client submitted a bad request, and needs to be notified. Errors inheriting this class will be reported to the client in the message field of the failed job. previous iqm.cpc.compiler.errors.CircuitError next iqm.cpc.compiler.errors.CompilationPassError By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils_qiskit.qiskit_to_pulla","url":"/iqm-pulla/api/iqm.pulla.utils_qiskit.qiskit_to_pulla.html","description":"Convert transpiled Qiskit quantum circuits to IQM Pulse quantum circuits. Also provides the Compiler object for compiling them, with the correct\\ncalibration set and component mapping initialized. pull...","content":"Convert transpiled Qiskit quantum circuits to IQM Pulse quantum circuits. Also provides the Compiler object for compiling them, with the correct\\ncalibration set and component mapping initialized. pulla ( Pulla ) – Quantum computer pulse level access object. backend ( IQMBackend ) – qiskit-iqm backend used to transpile the circuits. Determines\\nthe calibration set to be used by the returned compiler. qiskit_circuits ( QuantumCircuit | Sequence [ QuantumCircuit ] ) – One or many transpiled Qiskit QuantumCircuits to convert. Equivalent IQM Pulse circuit(s), compiler for compiling them. tuple [ list [CPC_Circuit], Compiler ] previous iqm.pulla.utils_qiskit.qiskit_circuits_to_pulla next iqm.pulla.utils_qiskit.station_control_result_to_qiskit By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils_qir.qir_to_pulla","url":"/iqm-pulla/api/iqm.pulla.utils_qir.qir_to_pulla.html","description":"Convert a QIR module to a CPC circuit. pulla ( Pulla ) – The Pulla instance to get compiler from. qir ( str | bytes ) – The QIR source or bitcode to convert to a circuit. qubit_mapping ( dict [ slice ...","content":"Convert a QIR module to a CPC circuit. pulla ( Pulla ) – The Pulla instance to get compiler from. qir ( str | bytes ) – The QIR source or bitcode to convert to a circuit. qubit_mapping ( dict [ slice ( <class 'int'> , <class 'str'> , None ) ] | None ) – A dictionary mapping QIR qubit indexes to physical qubit names,\\nNone will assume opaque pointers match physical names. The QIR program name,\\ntuple[CircuitOperation, …]: The circuit operations extracted from the QIR code. str ValueError – If the QIR program has more than one basic block. previous iqm.pulla.utils_qir next iqm.pulla.utils_qiskit By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.interface.BUFFER_AFTER_MEASUREMENT_PROBE","url":"/iqm-pulla/api/iqm.pulla.interface.BUFFER_AFTER_MEASUREMENT_PROBE.html","description":"Buffer that allows the readout resonator and qubit state to stabilize after a probe pulse, in s.\\nTODO: not needed after EXA-2089 is done. previous iqm.pulla.interface.CircuitMeasurementResultsBatch ne...","content":"Buffer that allows the readout resonator and qubit state to stabilize after a probe pulse, in s.\\nTODO: not needed after EXA-2089 is done. previous iqm.pulla.interface.CircuitMeasurementResultsBatch next iqm.pulla.interface.Circuit By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils.calset_from_observations","url":"/iqm-pulla/api/iqm.pulla.utils.calset_from_observations.html","description":"Create a calibration set from the given observations. calset_observations ( Iterable [ ObservationBase ] ) – observations that form a calibration set calibration set dict [ str , bool | str | int | fl...","content":"Create a calibration set from the given observations. calset_observations ( Iterable [ ObservationBase ] ) – observations that form a calibration set calibration set dict [ str , bool | str | int | float | complex | ndarray ] previous iqm.pulla.utils.build_settings next iqm.pulla.utils.calset_to_cal_data_tree By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.errors.InsufficientContextError","url":"/iqm-pulla/api/iqm.cpc.compiler.errors.InsufficientContextError.html","description":"The context provided to the compilation pass does not contain all necessary fields. previous iqm.cpc.compiler.errors.CompilationPassError next iqm.cpc.compiler.errors.SettingsConventionError By IQM Pu...","content":"The context provided to the compilation pass does not contain all necessary fields. previous iqm.cpc.compiler.errors.CompilationPassError next iqm.cpc.compiler.errors.SettingsConventionError By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.standard_stages.validate_execution_options","url":"/iqm-pulla/api/iqm.cpc.compiler.standard_stages.validate_execution_options.html","description":"Validate the circuit execution options (only some combinations make sense). circuits ( Iterable [ Circuit ] ) – options ( CircuitExecutionOptions ) – previous iqm.cpc.compiler.standard_stages.validate...","content":"Validate the circuit execution options (only some combinations make sense). circuits ( Iterable [ Circuit ] ) – options ( CircuitExecutionOptions ) – previous iqm.cpc.compiler.standard_stages.validate_circuits next iqm.cpc.compiler.station_settings By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils.extract_readout_controller_result_names","url":"/iqm-pulla/api/iqm.pulla.utils.extract_readout_controller_result_names.html","description":"Prepare readout controller names for the request. readout_mappings ( tuple [ dict [ str , tuple [ str , ... ] ] , ... ] ) – set [ str ] previous iqm.pulla.utils.convert_sweep_spot_with_heralding_mode_...","content":"Prepare readout controller names for the request. readout_mappings ( tuple [ dict [ str , tuple [ str , ... ] ] , ... ] ) – set [ str ] previous iqm.pulla.utils.convert_sweep_spot_with_heralding_mode_zero next iqm.pulla.utils.find_circuit_boundary By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils.convert_sweep_spot","url":"/iqm-pulla/api/iqm.pulla.utils.convert_sweep_spot.html","description":"Convert the sweep measurement results from Station Control into circuit measurement results. results ( dict [ str , ndarray ] ) – mapping of acquisition labels to 1D arrays of readout results with the...","content":"Convert the sweep measurement results from Station Control into circuit measurement results. results ( dict [ str , ndarray ] ) – mapping of acquisition labels to 1D arrays of readout results with the length num_shots * num_triggers_for_label_in_batch readout_mappings ( tuple [ dict [ str , tuple [ str , ... ] ] , ... ] ) – for each circuit in the batch, a mapping of measurement keys to corresponding\\ntuples of acquisition labels converted measurement results list [ dict [ str , list [ list [ int ]]]] previous iqm.pulla.utils.circuit_operations_to_cpc next iqm.pulla.utils.convert_sweep_spot_with_heralding_mode_zero By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.standard_stages.clean_schedule","url":"/iqm-pulla/api/iqm.cpc.compiler.standard_stages.clean_schedule.html","description":"Remove non-functional instructions from schedules . schedules ( Iterable [ Schedule ] ) – builder ( ScheduleBuilder ) – list [ Schedule ] previous iqm.cpc.compiler.standard_stages.choose_op_implementa...","content":"Remove non-functional instructions from schedules . schedules ( Iterable [ Schedule ] ) – builder ( ScheduleBuilder ) – list [ Schedule ] previous iqm.cpc.compiler.standard_stages.choose_op_implementations next iqm.cpc.compiler.standard_stages.derive_readout_mappings By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.circuit_compilation_request_handler.handle_circuit_compilation_request","url":"/iqm-pulla/api/iqm.cpc.compiler.circuit_compilation_request_handler.handle_circuit_compilation_request.html","description":"Compile a batch of quantum circuits into a form that can be executed by Station Control. job_id ( str ) – ID of the job requesting compilation, used in logging circuits ( list [ Circuit ] ) – quantum ...","content":"Compile a batch of quantum circuits into a form that can be executed by Station Control. job_id ( str ) – ID of the job requesting compilation, used in logging circuits ( list [ Circuit ] ) – quantum circuits to compile into schedules shots ( int ) – number of times to repeat the execution of each circuit calibration_set ( dict [ str , bool | str | int | float | complex | ndarray ] ) – calibration data for the station the circuits are executed on chip_topology ( ChipTopology ) – topology of the QPU the circuits are executed on channel_properties ( dict [ str , ChannelProperties ] ) – properties of control channels on the station component_channels ( dict [ str , dict [ str , str ] ] ) – QPU component to function to channel mapping options ( CircuitExecutionOptions ) – various discrete options for circuit execution that affect compilation custom_settings ( SettingNode | None ) – additional Station Control settings to override generated settings qubit_mapping ( dict [ str , str ] | None ) – Mapping of logical qubit names to physical qubit names. None means the identity mapping. trace_context ( dict [ str , Any ] | None ) – telemetry context to be propagated during circuit compilation circuit compilation result CircuitCompilationResult previous iqm.cpc.compiler.circuit_compilation_request_handler next iqm.cpc.compiler.compiler By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.interface.compiler.MoveGateFrameTrackingMode","url":"/iqm-pulla/api/iqm.cpc.interface.compiler.MoveGateFrameTrackingMode.html","description":"Bases: StrEnum MOVE gate frame tracking mode for circuit compilation. Attributes FULL Perform complete MOVE gate frame tracking, applying both the explicit z rotations on the resonator and the dynamic...","content":"Bases: StrEnum MOVE gate frame tracking mode for circuit compilation. Attributes FULL Perform complete MOVE gate frame tracking, applying both the explicit z rotations on the resonator and the dynamic phase correction due to qubit-resonator detuning to the qubit at the end of a MOVE sandwich. NO_DETUNING_CORRECTION Do not apply the detuning correction at the end of a MOVE sandwich. NONE Do not perform any MOVE gate frame tracking. Methods __format__ (format_spec, /) Return a formatted version of the string as described by format_spec. __new__ (value)  __str__ () Return str(self). Perform complete MOVE gate frame tracking, applying both the explicit z rotations\\non the resonator and the dynamic phase correction due to qubit-resonator detuning to\\nthe qubit at the end of a MOVE sandwich. Do not apply the detuning correction at the end of a MOVE sandwich. Do not perform any MOVE gate frame tracking. previous iqm.cpc.interface.compiler.MeasurementMode next iqm.cpc.interface.compiler.MoveGateValidationMode By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.standard_stages.build_playlist","url":"/iqm-pulla/api/iqm.cpc.compiler.standard_stages.build_playlist.html","description":"Build the playlist from the schedules. schedules ( Iterable [ Schedule ] ) – builder ( ScheduleBuilder ) – tuple [ Playlist , dict [ str , Any ]] previous iqm.cpc.compiler.standard_stages.apply_move_g...","content":"Build the playlist from the schedules. schedules ( Iterable [ Schedule ] ) – builder ( ScheduleBuilder ) – tuple [ Playlist , dict [ str , Any ]] previous iqm.cpc.compiler.standard_stages.apply_move_gate_phase_corrections next iqm.cpc.compiler.standard_stages.choose_op_implementations By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.interface.SettingsRetrievalException","url":"/iqm-pulla/api/iqm.pulla.interface.SettingsRetrievalException.html","description":"Exception for Station Control settings retrieval failures. previous iqm.pulla.interface.ChipLabelRetrievalException next iqm.pulla.pulla By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, ...","content":"Exception for Station Control settings retrieval failures. previous iqm.pulla.interface.ChipLabelRetrievalException next iqm.pulla.pulla By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.interface.compiler.MoveGateValidationMode","url":"/iqm-pulla/api/iqm.cpc.interface.compiler.MoveGateValidationMode.html","description":"Bases: StrEnum MOVE gate validation mode for circuit compilation. Attributes STRICT MOVE(qubit, resonator) gates must only appear in sandwiches (pairs). ALLOW_PRX Allow PRX gates on the MOVE qubit ins...","content":"Bases: StrEnum MOVE gate validation mode for circuit compilation. Attributes STRICT MOVE(qubit, resonator) gates must only appear in sandwiches (pairs). ALLOW_PRX Allow PRX gates on the MOVE qubit inside MOVE sandwiches during validation. NONE Do not perform any MOVE gate validation. Methods __format__ (format_spec, /) Return a formatted version of the string as described by format_spec. __new__ (value)  __str__ () Return str(self). MOVE(qubit, resonator) gates must only\\nappear in sandwiches (pairs). Inside a sandwich there must be no gates acting on the\\nMOVE qubit, and no other MOVE gates acting on the resonator. Perform standard MOVE gate validation Allow PRX gates on the MOVE qubit inside MOVE sandwiches during validation. Do not perform any MOVE gate validation. previous iqm.cpc.interface.compiler.MoveGateFrameTrackingMode next iqm.pulla By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.compiler.PassFunction","url":"/iqm-pulla/api/iqm.cpc.compiler.compiler.PassFunction.html","description":"A function that takes the data and context as arguments and returns the modified data and context.\\nThe context is a dictionary that can contain any information that needs to be passed between the pass...","content":"A function that takes the data and context as arguments and returns the modified data and context.\\nThe context is a dictionary that can contain any information that needs to be passed between the passes. alias of Callable [ Any , dict [ str , Any ], tuple [ Any , dict [ str , Any ]]] previous iqm.cpc.compiler.compiler next iqm.cpc.compiler.compiler.compiler_pass By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.circuit_compilation_request_handler","url":"/iqm-pulla/api/iqm.cpc.compiler.circuit_compilation_request_handler.html","description":"Convert quantum circuits into instruction schedules. This is the entry-point for integrations, e.g. for a server-side component performing circuit-to-pulse compilation. Functions handle_circuit_compil...","content":"Convert quantum circuits into instruction schedules. This is the entry-point for integrations, e.g. for a server-side component performing circuit-to-pulse compilation. Functions handle_circuit_compilation_request (job_id, ...) Compile a batch of quantum circuits into a form that can be executed by Station Control. previous iqm.cpc.compiler next iqm.cpc.compiler.circuit_compilation_request_handler.handle_circuit_compilation_request By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.interface.compiler.CircuitBoundaryMode","url":"/iqm-pulla/api/iqm.cpc.interface.compiler.CircuitBoundaryMode.html","description":"Bases: StrEnum Circuit boundary mode for circuit compilation. Attributes NEIGHBOUR Circuit boundary consists of those QPU elements (qubits and couplers) that are adjacent to the qubits and couplers us...","content":"Bases: StrEnum Circuit boundary mode for circuit compilation. Attributes NEIGHBOUR Circuit boundary consists of those QPU elements (qubits and couplers) that are adjacent to the qubits and couplers used by the circuit, but do not belong to them. ALL Circuit boundary consists of all the QPU elements that are not used in the circuit. Methods __format__ (format_spec, /) Return a formatted version of the string as described by format_spec. __new__ (value)  __str__ () Return str(self). Circuit boundary consists of those QPU elements (qubits and couplers) that\\nare adjacent to the qubits and couplers used by the circuit, but do not belong to them.\\nSpecifically, Boundary qubits are connected to a circuit qubit by any coupler, but are not circuit qubits themselves. Boundary couplers are connected to at least one circuit qubit, but are not used in the circuit themselves. Circuit boundary consists of all the QPU elements that are not used in the circuit. previous iqm.cpc.interface.compiler.Circuit next iqm.cpc.interface.compiler.CircuitCompilationResult By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.pulla.Pulla","url":"/iqm-pulla/api/iqm.pulla.pulla.Pulla.html","description":"Bases: object Pulse level access library for IQM’s circuit-to-pulse compiler and Station Control API.\\nConceptually, represents a connection to a remote quantum computer, and a provider of calibration ...","content":"Bases: object Pulse level access library for IQM’s circuit-to-pulse compiler and Station Control API.\\nConceptually, represents a connection to a remote quantum computer, and a provider of calibration data.\\nCan create a compiler instance ready to be used with the connected quantum computer. station_control_url ( str ) – URL to a Station Control instance. get_token_callback ( Callable [ [ ] , str ] | None ) – An optional function that returns an authentication token for the Station Control API. Methods _get_station_control_settings () Returns the Station Control settings node that was fetched from the IQM server during Pulla initialization. execute (playlist, context, settings[, verbose]) Executes a quantum circuit on the remote quantum computer. fetch_calibration_set_by_id (calibration_set_id) Fetches a specific calibration set from the server, and returns its decoded representation. fetch_latest_calibration_set () Fetches the latest default calibration set from the server, and returns its decoded representation and id. get_channel_properties () Control channel properties from Station Control controller settings. get_chip_label () Returns the chip label of the current quantum computer. get_chip_topology () Returns chip topology that was fetched from the IQM server during Pulla initialization. get_standard_compiler ([calibration_set, ...]) Returns a new instance of the compiler with the default calibration set and standard stages. Returns a new instance of the compiler with the default calibration set and standard stages. calibration_set ( dict [ str , bool | str | int | float | complex | ndarray ] | None ) – Calibration set to use. If None, the default calibration set will be used. circuit_execution_options ( CircuitExecutionOptions | dict | None ) – circuit execution options to use for the compiler. If a CircuitExecutionOptions\\nobject is provided, the compiler use it as is. If a dict is provided, the default values will be\\noverridden for the present keys in that dict. If left None , the default options will be used. The compiler object. Compiler Fetches the latest default calibration set from the server, and returns its decoded representation and id. tuple [ dict [ str , bool | str | int | float | complex | ndarray ], UUID ] Fetches a specific calibration set from the server, and returns its decoded representation.\\nAll calibration sets are cached in-memory, so if the calibration set with the given id has already been fetched,\\nit will be returned immediately. calibration_set_id ( UUID ) – id of the calibration set to fetch. dict [ str , bool | str | int | float | complex | ndarray ] Returns the chip label of the current quantum computer. The chip label is fetched from the Station Control API. str Returns chip topology that was fetched from the IQM server during Pulla initialization. ChipTopology Control channel properties from Station Control controller settings. Mapping from channel names to  their properties.\\ncomponent_to_channel: Mapping from chip component names to functions to channel names. For example, ‘QB1’ -> ‘drive’ -> ‘QB1__drive.awg’ Mapping from channel names to  their properties.\\ncomponent_to_channel: Mapping from chip component names to functions to channel names. For example, ‘QB1’ -> ‘drive’ -> ‘QB1__drive.awg’ channel_properties Executes a quantum circuit on the remote quantum computer. playlist ( Playlist ) – Final schedule to be executed. context ( dict [ str , Any ] ) – Context object of the successful compiler run, containing the readout mappings. settings ( SettingNode ) – Station settings. verbose ( bool ) – Whether to print results. results of the execution StationControlResult previous iqm.pulla.pulla next iqm.pulla.utils By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.errors.UnknownHardwareComponentError","url":"/iqm-pulla/api/iqm.cpc.compiler.errors.UnknownHardwareComponentError.html","description":"Circuit contains a reference to an unknown hardware component. previous iqm.cpc.compiler.errors.SettingsConventionError next iqm.cpc.compiler.errors.UnknownLogicalQubitError By IQM Pulla developers © ...","content":"Circuit contains a reference to an unknown hardware component. previous iqm.cpc.compiler.errors.SettingsConventionError next iqm.cpc.compiler.errors.UnknownLogicalQubitError By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.interface.compiler.Circuit","url":"/iqm-pulla/api/iqm.cpc.interface.compiler.Circuit.html","description":"Bases: object Quantum circuit to be executed. Attributes name name of the circuit instructions operations comprising the circuit Methods __eq__ (other) Return self==value. __repr__ () Return repr(self...","content":"Bases: object Quantum circuit to be executed. Attributes name name of the circuit instructions operations comprising the circuit Methods __eq__ (other) Return self==value. __repr__ () Return repr(self). name ( str ) – instructions ( tuple [ CircuitOperation , ... ] ) – name of the circuit operations comprising the circuit previous iqm.cpc.interface.compiler.ReadoutMappingBatch next iqm.cpc.interface.compiler.CircuitBoundaryMode By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.interface.compiler.PRXSequence","url":"/iqm-pulla/api/iqm.cpc.interface.compiler.PRXSequence.html","description":"A sequence of PRX gates. A generic PRX gate is defined by rotation angle and phase angle, Theta and Phi\\nrespectively. alias of list [ tuple [ float , float ]] previous iqm.cpc.interface.compiler.Circu...","content":"A sequence of PRX gates. A generic PRX gate is defined by rotation angle and phase angle, Theta and Phi\\nrespectively. alias of list [ tuple [ float , float ]] previous iqm.cpc.interface.compiler.CircuitBatch next iqm.cpc.interface.compiler.ReadoutMapping By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.errors.SettingsConventionError","url":"/iqm-pulla/api/iqm.cpc.compiler.errors.SettingsConventionError.html","description":"While parsing Station Control settings, something breaks a structural or naming convention. previous iqm.cpc.compiler.errors.InsufficientContextError next iqm.cpc.compiler.errors.UnknownHardwareCompon...","content":"While parsing Station Control settings, something breaks a structural or naming convention. previous iqm.cpc.compiler.errors.InsufficientContextError next iqm.cpc.compiler.errors.UnknownHardwareComponentError By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.calibration","url":"/iqm-pulla/api/iqm.pulla.calibration.html","description":"Provider of calibration sets and quality metrics from remote IQM servers. Classes CalibrationDataProvider (station_control_client) Access calibration info via station control client and cache data in ...","content":"Provider of calibration sets and quality metrics from remote IQM servers. Classes CalibrationDataProvider (station_control_client) Access calibration info via station control client and cache data in memory. Inheritance previous iqm.pulla next iqm.pulla.calibration.CalibrationDataProvider By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.compiler","url":"/iqm-pulla/api/iqm.cpc.compiler.compiler.html","description":"Convert quantum circuits into instruction schedules. This is the core module of CPC . It contains the functionality to define a compiler, whose job is to\\nconvert quantum circuits and calibration data ...","content":"Convert quantum circuits into instruction schedules. This is the core module of CPC . It contains the functionality to define a compiler, whose job is to\\nconvert quantum circuits and calibration data into configuration settings and instruction schedules that\\ncan be executed by the IQM server on quantum hardware. Module Attributes PassFunction A function that takes the data and context as arguments and returns the modified data and context. Functions compiler_pass (function) Convenience wrapper to create a valid compiler pass. pass_function_idempotent (function) Wrap a pass function to make it idempotent. Classes CompilationStage (name) Sequence of compiler passes that are applied to the data. Compiler (*, calibration_set, chip_topology, ...) Stateful object that contains a calibration set, a schedule builder, and a set of compilation stages. Inheritance previous iqm.cpc.compiler.circuit_compilation_request_handler.handle_circuit_compilation_request next iqm.cpc.compiler.compiler.PassFunction By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.interface.compiler.CircuitCompilationResult","url":"/iqm-pulla/api/iqm.cpc.interface.compiler.CircuitCompilationResult.html","description":"Bases: object Compiled circuit and associated settings returned by CPC to Cocos. Attributes playlist sequence of instruction schedules corresponding to the batch of circuits to be executed readout_map...","content":"Bases: object Compiled circuit and associated settings returned by CPC to Cocos. Attributes playlist sequence of instruction schedules corresponding to the batch of circuits to be executed readout_mappings For each circuit in the batch, mapping from measurement keys to the names of readout controller result parameters that will hold the measurement results. settings Station Control settings node containing the settings for circuit execution circuit_metrics metrics describing the circuit and its compilation result for each circuit in the batch Methods __eq__ (other) Return self==value. __repr__ () Return repr(self). playlist ( Playlist ) – readout_mappings ( tuple [ dict [ str , tuple [ str , ... ] ] , ... ] ) – settings ( SettingNode ) – circuit_metrics ( tuple [ CircuitMetrics , ... ] ) – sequence of instruction schedules corresponding to the batch of circuits to be executed For each circuit in the batch, mapping from measurement keys to the names of readout\\ncontroller result parameters that will hold the measurement results. If heralding is enabled, qubits\\nwhich are not measured in the circuit itself but are heralded appear under the reserved key “__herald. Station Control settings node containing the settings for circuit execution metrics describing the circuit and its compilation result for each circuit in the batch previous iqm.cpc.interface.compiler.CircuitBoundaryMode next iqm.cpc.interface.compiler.CircuitExecutionOptions By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.interface.compiler.HeraldingMode","url":"/iqm-pulla/api/iqm.cpc.interface.compiler.HeraldingMode.html","description":"Bases: StrEnum Heralding mode for circuit execution. Attributes NONE Do not do any heralding. ZEROS Perform a heralding measurement on all the components used in each circuit (if they have measurement...","content":"Bases: StrEnum Heralding mode for circuit execution. Attributes NONE Do not do any heralding. ZEROS Perform a heralding measurement on all the components used in each circuit (if they have measurement data available in the calset), only retain shots where all the components are measured to be in the zero state. Methods __format__ (format_spec, /) Return a formatted version of the string as described by format_spec. __new__ (value)  __str__ () Return str(self). Do not do any heralding. Perform a heralding measurement on all the components used in each circuit (if they have\\nmeasurement data available in the calset), only retain shots where all the components\\nare measured to be in the zero state. previous iqm.cpc.interface.compiler.DDStrategy next iqm.cpc.interface.compiler.MeasurementMode By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.interface.compiler","url":"/iqm-pulla/api/iqm.cpc.interface.compiler.html","description":"Pydantic models used by the API. Module Attributes CircuitBatch Type that represents a list of quantum circuits to be executed together in a single batch. PRXSequence A sequence of PRX gates. ReadoutM...","content":"Pydantic models used by the API. Module Attributes CircuitBatch Type that represents a list of quantum circuits to be executed together in a single batch. PRXSequence A sequence of PRX gates. ReadoutMapping Type for matching measurement keys from the quantum circuit with acquisition labels in Station Control. ReadoutMappingBatch Type that represents tuple of readout mappings, one per each circuit in a circuit batch. Classes Circuit (name, instructions) Quantum circuit to be executed. CircuitBoundaryMode (value[, names, module, ...]) Circuit boundary mode for circuit compilation. CircuitCompilationResult (playlist, ...) Compiled circuit and associated settings returned by CPC to Cocos. CircuitExecutionOptions (measurement_mode, ...) Various discrete options for quantum circuit execution. CircuitMetrics (components, ...[, gate_loci, ...]) Metrics describing a circuit and its compilation result. DDMode (value[, names, module, qualname, ...]) Dynamical Decoupling (DD) mode for circuit execution. DDStrategy ([merge_contiguous_waits, ...]) Describes a particular dynamical decoupling strategy. HeraldingMode (value[, names, module, ...]) Heralding mode for circuit execution. MeasurementMode (value[, names, module, ...]) Measurement mode for circuit execution. MoveGateFrameTrackingMode (value[, names, ...]) MOVE gate frame tracking mode for circuit compilation. MoveGateValidationMode (value[, names, ...]) MOVE gate validation mode for circuit compilation. Inheritance previous iqm.cpc.interface next iqm.cpc.interface.compiler.CircuitBatch By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.interface.compiler.MeasurementMode","url":"/iqm-pulla/api/iqm.cpc.interface.compiler.MeasurementMode.html","description":"Bases: StrEnum Measurement mode for circuit execution. Determines which QPU components are measured by Station Control in the final measurement.\\nMeasurement results which are not required by the circu...","content":"Bases: StrEnum Measurement mode for circuit execution. Determines which QPU components are measured by Station Control in the final measurement.\\nMeasurement results which are not required by the circuits to be executed are discarded. Attributes CIRCUIT In each circuit separately, measure only the components that have final measurement operations on them. ALL Measure all the components on the QPU that have measurement data in the calset. Methods __format__ (format_spec, /) Return a formatted version of the string as described by format_spec. __new__ (value)  __str__ () Return str(self). In each circuit separately, measure only the components that have final measurement\\noperations on them. Measure all the components on the QPU that have measurement data in the calset.\\nThis is typically how measurement is calibrated. previous iqm.cpc.interface.compiler.HeraldingMode next iqm.cpc.interface.compiler.MoveGateFrameTrackingMode By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils","url":"/iqm-pulla/api/iqm.pulla.utils.html","description":"Utility functions for IQM Pulla. Module Attributes InstructionLocation (channel_name, index, ...) Return type for locate_instructions() . Functions build_settings (shots, calibration_set, ...) Constru...","content":"Utility functions for IQM Pulla. Module Attributes InstructionLocation (channel_name, index, ...) Return type for locate_instructions() . Functions build_settings (shots, calibration_set, ...) Construct the Station Control settings needed for executing a batch of quantum circuits. calset_from_observations (calset_observations) Create a calibration set from the given observations. calset_to_cal_data_tree (calibration_set) Build an iqm-pulse QuantumOp calibration data tree from a calibration set. circuit_operations_to_cpc (circ_ops[, name]) Convert a list of CircuitOperations to an IQM CPC Circuit. convert_sweep_spot (results, readout_mappings) Convert the sweep measurement results from Station Control into circuit measurement results. convert_sweep_spot_with_heralding_mode_zero (...) Like convert_sweep_spot() , but for results that contain heralding measurements. extract_readout_controller_result_names (...) Prepare readout controller names for the request. find_circuit_boundary (mode, ...) Determine the boundary of a circuit executed on the QPU. get_hash_for (circuit) Get a unique id hash for a given circuit. initialize_schedule_builder (calibration_set, ...) Initialize a new schedule builder for the station, validate that it is configured properly. iqm_circuit_to_gate_implementation (circuit, ...) Wrap a circuit to a single GateImplementation that can then be registered as an independent \\"gate\\". locate_instructions (schedule, instruction_type) Locate specific instructions in a schedule. map_qubit_indices (circuits, context) Map qubit indices in circuits to the indices in the component mapping. map_sweep_results_to_logical_qubits (...) Convert sweep results returned by Station Control to the circuit measurement results the client expects. print_channel (schedule, channel_name) Print all instructions in a channel of a schedule. print_schedule (schedule) Print all instructions in each segment of a schedule. replace_instruction_in_place (schedule, ...) Replace an instruction in a schedule with one or more instructions. Classes InstructionLocation (channel_name, index, ...) Return type for locate_instructions() . Inheritance previous iqm.pulla.pulla.Pulla next iqm.pulla.utils.InstructionLocation By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.errors.CalibrationError","url":"/iqm-pulla/api/iqm.cpc.compiler.errors.CalibrationError.html","description":"A required calibration observation is missing from the calibration set, or an unknown\\ngate calibration observation is encountered. previous iqm.cpc.compiler.errors next iqm.cpc.compiler.errors.Circuit...","content":"A required calibration observation is missing from the calibration set, or an unknown\\ngate calibration observation is encountered. previous iqm.cpc.compiler.errors next iqm.cpc.compiler.errors.CircuitError By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils_dd","url":"/iqm-pulla/api/iqm.pulla.utils_dd.html","description":"Utilities for working with Dynamical Decoupling. Functions generate_phases_of_urn_sequence (n) Generate PRX gate phases for the URn sequence. previous iqm.pulla.utils_cirq.cirq_to_cpc next iqm.pulla.u...","content":"Utilities for working with Dynamical Decoupling. Functions generate_phases_of_urn_sequence (n) Generate PRX gate phases for the URn sequence. previous iqm.pulla.utils_cirq.cirq_to_cpc next iqm.pulla.utils_dd.generate_phases_of_urn_sequence By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.standard_stages.get_standard_stages","url":"/iqm-pulla/api/iqm.cpc.compiler.standard_stages.get_standard_stages.html","description":"Get a copy of the standard compilation stages. idempotent ( bool ) – If True, the passes will be made idempotent. The standard compilation stages. list [ CompilationStage ] previous iqm.cpc.compiler.s...","content":"Get a copy of the standard compilation stages. idempotent ( bool ) – If True, the passes will be made idempotent. The standard compilation stages. list [ CompilationStage ] previous iqm.cpc.compiler.standard_stages.derive_readout_mappings next iqm.cpc.compiler.standard_stages.map_components By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.station_settings.find_observation","url":"/iqm-pulla/api/iqm.cpc.compiler.station_settings.find_observation.html","description":"Return the value of the given calibration observation, or raise an error. observation_path ( str ) – observation we want to find in calibration_set calibration_set ( CalibrationSet ) – mapping of obse...","content":"Return the value of the given calibration observation, or raise an error. observation_path ( str ) – observation we want to find in calibration_set calibration_set ( CalibrationSet ) – mapping of observation paths to observation values required ( bool ) – iff True and the observation cannot be found, raise an error value of the observation, or None if not found CalibrationError – required is True and the observation cannot be\\n    found in calibration_set ObservationValue previous iqm.cpc.compiler.station_settings.build_station_settings next iqm.cpc.compiler.station_settings.Map By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.dd.STANDARD_DD_STRATEGY","url":"/iqm-pulla/api/iqm.cpc.compiler.dd.STANDARD_DD_STRATEGY.html","description":"The default DD strategy uses the following gate sequences: Simple symmetric CPMG sequence for short idling times. Asymmetric (left-aligned) universal XY4 sequence for medium idling times. Asymmetric (...","content":"The default DD strategy uses the following gate sequences: Simple symmetric CPMG sequence for short idling times. Asymmetric (left-aligned) universal XY4 sequence for medium idling times. Asymmetric (left-aligned) universal EDD sequence for longer idling times. previous iqm.cpc.compiler.dd next iqm.cpc.compiler.dd.insert_dd_sequences By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.interface.CHADRetrievalException","url":"/iqm-pulla/api/iqm.pulla.interface.CHADRetrievalException.html","description":"Exception for CHAD retrieval failures. previous iqm.pulla.interface.TaskStatus next iqm.pulla.interface.ChipLabelRetrievalException By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Relea...","content":"Exception for CHAD retrieval failures. previous iqm.pulla.interface.TaskStatus next iqm.pulla.interface.ChipLabelRetrievalException By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.standard_stages.prepend_reset","url":"/iqm-pulla/api/iqm.cpc.compiler.standard_stages.prepend_reset.html","description":"Add a reset timebox to all circuits. timeboxes ( Iterable [ TimeBox ] ) – builder ( ScheduleBuilder ) – options ( CircuitExecutionOptions ) – circuit_metrics ( Iterable [ CircuitMetrics ] ) – Iterable...","content":"Add a reset timebox to all circuits. timeboxes ( Iterable [ TimeBox ] ) – builder ( ScheduleBuilder ) – options ( CircuitExecutionOptions ) – circuit_metrics ( Iterable [ CircuitMetrics ] ) – Iterable [ TimeBox ] previous iqm.cpc.compiler.standard_stages.prepend_heralding next iqm.cpc.compiler.standard_stages.resolve_circuits By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.interface.compiler.CircuitBatch","url":"/iqm-pulla/api/iqm.cpc.interface.compiler.CircuitBatch.html","description":"Type that represents a list of quantum circuits to be executed together in a single batch. alias of list [ Circuit ] previous iqm.cpc.interface.compiler next iqm.cpc.interface.compiler.PRXSequence By ...","content":"Type that represents a list of quantum circuits to be executed together in a single batch. alias of list [ Circuit ] previous iqm.cpc.interface.compiler next iqm.cpc.interface.compiler.PRXSequence By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils_qir","url":"/iqm-pulla/api/iqm.pulla.utils_qir.html","description":"Utilities for working with a QIR module. Functions qir_to_pulla (pulla, qir[, qubit_mapping]) Convert a QIR module to a CPC circuit. previous iqm.pulla.utils_dd.generate_phases_of_urn_sequence next iq...","content":"Utilities for working with a QIR module. Functions qir_to_pulla (pulla, qir[, qubit_mapping]) Convert a QIR module to a CPC circuit. previous iqm.pulla.utils_dd.generate_phases_of_urn_sequence next iqm.pulla.utils_qir.qir_to_pulla By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.interface.compiler.CircuitMetrics","url":"/iqm-pulla/api/iqm.cpc.interface.compiler.CircuitMetrics.html","description":"Bases: object Metrics describing a circuit and its compilation result. Attributes min_execution_time shots * (instruction schedule duration + reset), in seconds. schedule_duration Duration of the inst...","content":"Bases: object Metrics describing a circuit and its compilation result. Attributes min_execution_time shots * (instruction schedule duration + reset), in seconds. schedule_duration Duration of the instruction schedule created for the circuit, in seconds. components Locus components used in the circuit. component_pairs_with_gates Pairs of locus components which have two-component gates between them in the circuit. gate_loci Mapping from operation name to mapping from implementation name to a counter of loci of that operation in the circuit. Methods __eq__ (other) Return self==value. __repr__ () Return repr(self). components ( frozenset [ str ] ) – component_pairs_with_gates ( frozenset [ tuple [ str , str ] ] ) – gate_loci ( dict [ str , dict [ str , Counter [ tuple [ str , ... ] ] ] ] ) – schedule_duration ( float ) – min_execution_time ( float ) – Locus components used in the circuit. Pairs of locus components which have two-component gates between them in the circuit. Mapping from operation name to mapping from implementation name to a counter of loci of\\nthat operation in the circuit. Duration of the instruction schedule created for the circuit, in seconds. shots * (instruction schedule duration + reset), in seconds. Lower bound on the actual execution time previous iqm.cpc.interface.compiler.CircuitExecutionOptions next iqm.cpc.interface.compiler.DDMode By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.standard_stages.apply_move_gate_phase_corrections","url":"/iqm-pulla/api/iqm.cpc.compiler.standard_stages.apply_move_gate_phase_corrections.html","description":"Apply calibrated phase corrections if MOVE gates are used. schedules ( Iterable [ Schedule ] ) – builder ( ScheduleBuilder ) – circuit_metrics ( Iterable [ CircuitMetrics ] ) – options ( CircuitExecut...","content":"Apply calibrated phase corrections if MOVE gates are used. schedules ( Iterable [ Schedule ] ) – builder ( ScheduleBuilder ) – circuit_metrics ( Iterable [ CircuitMetrics ] ) – options ( CircuitExecutionOptions ) – list [ Schedule ] previous iqm.cpc.compiler.standard_stages.apply_dd_strategy next iqm.cpc.compiler.standard_stages.build_playlist By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.errors.CompilationPassError","url":"/iqm-pulla/api/iqm.cpc.compiler.errors.CompilationPassError.html","description":"There is something wrong with the compilation pass. previous iqm.cpc.compiler.errors.ClientError next iqm.cpc.compiler.errors.InsufficientContextError By IQM Pulla developers © Copyright 2024-2025, IQ...","content":"There is something wrong with the compilation pass. previous iqm.cpc.compiler.errors.ClientError next iqm.cpc.compiler.errors.InsufficientContextError By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils.calset_to_cal_data_tree","url":"/iqm-pulla/api/iqm.pulla.utils.calset_to_cal_data_tree.html","description":"Build an iqm-pulse QuantumOp calibration data tree from a calibration set. Splits the dotted observation names that are prefixed with “gates.” into the corresponding\\ncalibration data tree paths. calib...","content":"Build an iqm-pulse QuantumOp calibration data tree from a calibration set. Splits the dotted observation names that are prefixed with “gates.” into the corresponding\\ncalibration data tree paths. calibration_set ( dict [ str , bool | str | int | float | complex | ndarray ] ) – dict [ str , dict [ str , dict [ tuple [ str , …] | None, dict [ str , Any ]]]] previous iqm.pulla.utils.calset_from_observations next iqm.pulla.utils.circuit_operations_to_cpc By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.dd.merge_wait_instructions_in_schedule","url":"/iqm-pulla/api/iqm.cpc.compiler.dd.merge_wait_instructions_in_schedule.html","description":"Merge adjacent Wait instructions in the drive channels of the given schedule. Makes a deep copy schedule and iterates through its drive channels to merge adjacent Wait instructions into a single Wait ...","content":"Merge adjacent Wait instructions in the drive channels of the given schedule. Makes a deep copy schedule and iterates through its drive channels to merge adjacent Wait instructions into a single Wait instruction. Also merges Wait instructions if they are separated by Block instructions. builder ( ScheduleBuilder ) – Provides channel information. schedule ( Schedule ) – Schedule to process. Deep copy of schedule with Wait instructions merged. Schedule previous iqm.cpc.compiler.dd.insert_dd_sequences next iqm.cpc.compiler.errors By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils.print_schedule","url":"/iqm-pulla/api/iqm.pulla.utils.print_schedule.html","description":"Print all instructions in each segment of a schedule. schedule ( Schedule ) – The schedule to print None previous iqm.pulla.utils.print_channel next iqm.pulla.utils.replace_instruction_in_place By IQM...","content":"Print all instructions in each segment of a schedule. schedule ( Schedule ) – The schedule to print None previous iqm.pulla.utils.print_channel next iqm.pulla.utils.replace_instruction_in_place By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils.map_sweep_results_to_logical_qubits","url":"/iqm-pulla/api/iqm.pulla.utils.map_sweep_results_to_logical_qubits.html","description":"Convert sweep results returned by Station Control to the circuit measurement results the client expects. sweep_results ( dict [ str , list [ ndarray ] ] ) – mapping of acquisition labels to a list of ...","content":"Convert sweep results returned by Station Control to the circuit measurement results the client expects. sweep_results ( dict [ str , list [ ndarray ] ] ) – mapping of acquisition labels to a list of soft sweep spots, each represented by a 1D\\narray of readout results, with shots * num_triggers_for_label elements. readout_mappings ( tuple [ dict [ str , tuple [ str , ... ] ] , ... ] ) – for each circuit in the batch, a mapping of measurement keys to corresponding\\ntuples of result parameter names. heralding_mode ( HeraldingMode ) – Heralding mode, either ZEROS (when doing heralded readout) or NONE . converted, filtered measurement results, with the heralding measurement data removed list [ dict [ str , list [ list [ int ]]]] previous iqm.pulla.utils.map_qubit_indices next iqm.pulla.utils.print_channel By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils_qiskit.qiskit_circuits_to_pulla","url":"/iqm-pulla/api/iqm.pulla.utils_qiskit.qiskit_circuits_to_pulla.html","description":"Convert Qiskit quantum circuits into IQM Pulse quantum circuits. Lower-level method, you may want to use qiskit_to_pulla() instead. qiskit_circuits ( QuantumCircuit | Sequence [ QuantumCircuit ] ) – O...","content":"Convert Qiskit quantum circuits into IQM Pulse quantum circuits. Lower-level method, you may want to use qiskit_to_pulla() instead. qiskit_circuits ( QuantumCircuit | Sequence [ QuantumCircuit ] ) – One or many Qiskit quantum circuits to convert. qubit_idx_to_name ( dict [ int , str ] ) – Mapping from Qiskit qubit indices to the names of the corresponding\\nqubit names. custom_gates ( Collection [ str ] ) – Names of custom gates that should be treated as additional native gates\\nby qiskit-iqm, i.e. they should be passed as-is to Pulla. Equivalent IQM Pulse circuit(s). list [ Circuit ] previous iqm.pulla.utils_qiskit next iqm.pulla.utils_qiskit.qiskit_to_pulla By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils.locate_instructions","url":"/iqm-pulla/api/iqm.pulla.utils.locate_instructions.html","description":"Locate specific instructions in a schedule. schedule ( Schedule ) – The schedule to search. instruction_type ( type [ Instruction ] ) – The type of the instruction to search for. min_duration ( int ) ...","content":"Locate specific instructions in a schedule. schedule ( Schedule ) – The schedule to search. instruction_type ( type [ Instruction ] ) – The type of the instruction to search for. min_duration ( int ) – The minimum duration of the instruction to search for (in samples). channels ( Iterable [ str ] | None ) – Names of channels in schedule to search. Iff None, search all the channels. For each located instruction, a namedtuple containing the channel name, instruction index, and duration. list [ InstructionLocation ] previous iqm.pulla.utils.iqm_circuit_to_gate_implementation next iqm.pulla.utils.map_qubit_indices By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils.print_channel","url":"/iqm-pulla/api/iqm.pulla.utils.print_channel.html","description":"Print all instructions in a channel of a schedule. schedule ( Schedule ) – The schedule to search. channel_name ( str ) – The name of the channel to print. None previous iqm.pulla.utils.map_sweep_resu...","content":"Print all instructions in a channel of a schedule. schedule ( Schedule ) – The schedule to search. channel_name ( str ) – The name of the channel to print. None previous iqm.pulla.utils.map_sweep_results_to_logical_qubits next iqm.pulla.utils.print_schedule By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils_cirq","url":"/iqm-pulla/api/iqm.pulla.utils_cirq.html","description":"Utilities for working with Cirq objects. Functions cirq_to_cpc () Convert a Cirq Circuit to an IQM CPC Circuit. previous iqm.pulla.utils.replace_instruction_in_place next iqm.pulla.utils_cirq.cirq_to_...","content":"Utilities for working with Cirq objects. Functions cirq_to_cpc () Convert a Cirq Circuit to an IQM CPC Circuit. previous iqm.pulla.utils.replace_instruction_in_place next iqm.pulla.utils_cirq.cirq_to_cpc By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.errors","url":"/iqm-pulla/api/iqm.cpc.compiler.errors.html","description":"Definitions of error classes used to raise issues during circuit compilation. Exceptions CalibrationError A required calibration observation is missing from the calibration set, or an unknown gate cal...","content":"Definitions of error classes used to raise issues during circuit compilation. Exceptions CalibrationError A required calibration observation is missing from the calibration set, or an unknown gate calibration observation is encountered. CircuitError There is something wrong with the quantum circuit. ClientError Client submitted a bad request, and needs to be notified. CompilationPassError There is something wrong with the compilation pass. InsufficientContextError The context provided to the compilation pass does not contain all necessary fields. SettingsConventionError While parsing Station Control settings, something breaks a structural or naming convention. UnknownHardwareComponentError Circuit contains a reference to an unknown hardware component. UnknownLogicalQubitError A logical qubit in the circuit has not been defined in the qubit mapping. previous iqm.cpc.compiler.dd.merge_wait_instructions_in_schedule next iqm.cpc.compiler.errors.CalibrationError By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.calibration.CalibrationDataProvider","url":"/iqm-pulla/api/iqm.pulla.calibration.CalibrationDataProvider.html","description":"Bases: object Access calibration info via station control client and cache data in memory. Methods get_calibration_set (cal_set_id) Get the calibration set from the database and cache it. get_latest_c...","content":"Bases: object Access calibration info via station control client and cache data in memory. Methods get_calibration_set (cal_set_id) Get the calibration set from the database and cache it. get_latest_calibration_set (chip_label) Get the latest calibration set id for chip label from the database. station_control_client ( StationControlClient ) – Get the calibration set from the database and cache it. cal_set_id ( UUID ) – dict [ str , bool | str | int | float | complex | ndarray ] Get the latest calibration set id for chip label from the database. tuple [ dict [ str , bool | str | int | float | complex | ndarray ], UUID ] previous iqm.pulla.calibration next iqm.pulla.interface By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.station_settings","url":"/iqm-pulla/api/iqm.cpc.compiler.station_settings.html","description":"Mapping calibration observations to station settings. Observations are physical quantities stored in the EXA database. CPC uses them to represent the\\ncalibrated values of various instrument settings a...","content":"Mapping calibration observations to station settings. Observations are physical quantities stored in the EXA database. CPC uses them to represent the\\ncalibrated values of various instrument settings and gate parameters, needed to execute quantum circuits.\\nThe following iqm.station_control.interface.models.observation.ObservationLite fields are needed\\nfor this purpose: dut_field : identifies the quantity, and possibly the QPU component(s) it is associated with value : value of the quantity unit : unit of the quantity (currently only base SI units are used, e.g. Hz instead of GHz) The calibration observations come from two conceptually different sources. ConfigurationSource observations determine the base operating point of the station\\n(in principle an arbitrary choice), and form the input of the calibration procedure. AnalysisSource observations are the output of the calibration procedure. When EXA saves its settings as observations, it maps the settings tree paths directly to observation dut_field paths. CPC uses the same direct mapping, with a single minor modification (“options.end_delay”),\\nto map observation dut_field paths to Station Control controller settings paths. Quantum operation parameters are stored in the EXA settings tree under the top-level branch gates .\\nThis data is only used in building the instruction schedules. The controller settings paths may change whenever Station Control is updated, since it\\nconsumes the settings. Hence, this may break old calibration sets. New paths may be introduced into the calibration set when the calibration procedure changes,\\nor a new gate implementation is introduced. CPC only consumes observations created by the calibration process, stored explicitly as calibration\\nsets in the database. In addition to the station settings obtained from the calibration set, circuit execution also\\nrequires some static settings that typically change only when Station Control is updated, or\\nthe station itself is physically modified. The settings that depend on the makeup of a particular\\nstation, e.g. the types of the control instruments, are set in the station.yml configuration file\\nif possible. Examples of such settings are the input and output ranges and powers of various instruments.\\nNote that these settings can also be considered a part of the definition of the basic operating point. For some station settings, the default value is already good. Finally, there are some static station settings that are defined in this module, mostly because if\\nthey were set in station.yml they might negatively interfere with running EXA experiments on\\nthe station. Functions build_station_settings (*, circuit_qubits, ...) Build the station settings for executing a batch of quantum circuits using the given QPU elements and calibration data. find_observation (observation_path, ...[, ...]) Return the value of the given calibration observation, or raise an error. Classes Map (parameter, observation_path_template[, ...]) Mapping from a calibration observation path to a corresponding station settings path. Inheritance previous iqm.cpc.compiler.standard_stages.validate_execution_options next iqm.cpc.compiler.station_settings.build_station_settings By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.pulla","url":"/iqm-pulla/api/iqm.pulla.pulla.html","description":"Pulse level access library for IQM’s circuit-to-pulse compiler and Station Control API. Classes Pulla (station_control_url, *[, ...]) Pulse level access library for IQM's circuit-to-pulse compiler and...","content":"Pulse level access library for IQM’s circuit-to-pulse compiler and Station Control API. Classes Pulla (station_control_url, *[, ...]) Pulse level access library for IQM's circuit-to-pulse compiler and Station Control API. Inheritance previous iqm.pulla.interface.SettingsRetrievalException next iqm.pulla.pulla.Pulla By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils.get_hash_for","url":"/iqm-pulla/api/iqm.pulla.utils.get_hash_for.html","description":"Get a unique id hash for a given circuit. In the context of this function, two CPC circuits are considered equal if they have:\\n1. The same CircuitOperations in the same order.\\n2. The loci of those cir...","content":"Get a unique id hash for a given circuit. In the context of this function, two CPC circuits are considered equal if they have:\\n1. The same CircuitOperations in the same order.\\n2. The loci of those circuit operations are the same in all operation. circuit ( Circuit ) – int previous iqm.pulla.utils.find_circuit_boundary next iqm.pulla.utils.initialize_schedule_builder By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils.map_qubit_indices","url":"/iqm-pulla/api/iqm.pulla.utils.map_qubit_indices.html","description":"Map qubit indices in circuits to the indices in the component mapping. circuits ( Iterable [ Circuit ] ) – context ( dict [ str , Any ] ) – tuple [ list [ Circuit ], dict [ str , Any ]] previous iqm.p...","content":"Map qubit indices in circuits to the indices in the component mapping. circuits ( Iterable [ Circuit ] ) – context ( dict [ str , Any ] ) – tuple [ list [ Circuit ], dict [ str , Any ]] previous iqm.pulla.utils.locate_instructions next iqm.pulla.utils.map_sweep_results_to_logical_qubits By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.compiler.compiler_pass","url":"/iqm-pulla/api/iqm.cpc.compiler.compiler.compiler_pass.html","description":"Convenience wrapper to create a valid compiler pass. When the wrapped function is called, the compilation data (e.g. circuits) is passed as the first argument.\\nIf function has any other arguments, the...","content":"Convenience wrapper to create a valid compiler pass. When the wrapped function is called, the compilation data (e.g. circuits) is passed as the first argument.\\nIf function has any other arguments, the wrapper takes their values from the context dict.\\nIf no matching key is found for a required argument, an error is raised. function\` must return either a tuple of \`\`(data, ctx) where data is the\\ncompilation result and ctx is a dict with any new context data, or only data .\\nThe contents of ctx will be merged to the input context.\\nNote the difference to a plain, unwrapped CompilationPass: not returning ctx is valid. Callable [[ Any , dict [ str , Any ]], tuple [ Any , dict [ str , Any ]]] previous iqm.cpc.compiler.compiler.PassFunction next iqm.cpc.compiler.compiler.pass_function_idempotent By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.standard_stages.multiplex_readout","url":"/iqm-pulla/api/iqm.cpc.compiler.standard_stages.multiplex_readout.html","description":"Merge any MultiplexedProbeTimeBoxes inside a TimeBox representing a circuit. timeboxes ( Iterable [ TimeBox ] ) – previous iqm.cpc.compiler.standard_stages.merge_multiplexed_timeboxes next iqm.cpc.com...","content":"Merge any MultiplexedProbeTimeBoxes inside a TimeBox representing a circuit. timeboxes ( Iterable [ TimeBox ] ) – previous iqm.cpc.compiler.standard_stages.merge_multiplexed_timeboxes next iqm.cpc.compiler.standard_stages.prepend_heralding By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla","url":"/iqm-pulla/api/iqm.pulla.html","description":"Client-side library for Pulse-level access to IQM quantum computers. Subpackages and modules calibration Provider of calibration sets and quality metrics from remote IQM servers. interface Common data...","content":"Client-side library for Pulse-level access to IQM quantum computers. Subpackages and modules calibration Provider of calibration sets and quality metrics from remote IQM servers. interface Common data types and exceptions for the IQM Pulla interface. pulla Pulse level access library for IQM's circuit-to-pulse compiler and Station Control API. utils Utility functions for IQM Pulla. utils_cirq Utilities for working with Cirq objects. utils_dd Utilities for working with Dynamical Decoupling. utils_qir Utilities for working with a QIR module. utils_qiskit Utilities for working with Qiskit objects. previous iqm.cpc.interface.compiler.MoveGateValidationMode next iqm.pulla.calibration By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.interface.compiler.DDMode","url":"/iqm-pulla/api/iqm.cpc.interface.compiler.DDMode.html","description":"Bases: StrEnum Dynamical Decoupling (DD) mode for circuit execution. Attributes DISABLED Do not apply dynamical decoupling. ENABLED Apply dynamical decoupling. Methods __format__ (format_spec, /) Retu...","content":"Bases: StrEnum Dynamical Decoupling (DD) mode for circuit execution. Attributes DISABLED Do not apply dynamical decoupling. ENABLED Apply dynamical decoupling. Methods __format__ (format_spec, /) Return a formatted version of the string as described by format_spec. __new__ (value)  __str__ () Return str(self). Do not apply dynamical decoupling. Apply dynamical decoupling. previous iqm.cpc.interface.compiler.CircuitMetrics next iqm.cpc.interface.compiler.DDStrategy By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils.find_circuit_boundary","url":"/iqm-pulla/api/iqm.pulla.utils.find_circuit_boundary.html","description":"Determine the boundary of a circuit executed on the QPU. See CircuitBoundaryMode for the definitions of the circuit boundaries. mode ( CircuitBoundaryMode ) – method of determining the circuit border ...","content":"Determine the boundary of a circuit executed on the QPU. See CircuitBoundaryMode for the definitions of the circuit boundaries. mode ( CircuitBoundaryMode ) – method of determining the circuit border circuit_components ( set [ str ] | frozenset [ str ] ) – all locus components used in the circuit circuit_couplers ( set [ str ] ) – all couplers used in the circuit to apply gates device ( ChipTopology ) – describes the QPU topology boundary locus components, boundary couplers ValueError – unknown mode tuple [ set [ str ], set [ str ]] previous iqm.pulla.utils.extract_readout_controller_result_names next iqm.pulla.utils.get_hash_for By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.standard_stages.derive_readout_mappings","url":"/iqm-pulla/api/iqm.cpc.compiler.standard_stages.derive_readout_mappings.html","description":"Derive mapping between station acquisition labels and user’s measurement keys. circuits ( Iterable [ Circuit ] ) – builder ( ScheduleBuilder ) – options ( CircuitExecutionOptions ) – circuit_metrics (...","content":"Derive mapping between station acquisition labels and user’s measurement keys. circuits ( Iterable [ Circuit ] ) – builder ( ScheduleBuilder ) – options ( CircuitExecutionOptions ) – circuit_metrics ( Iterable [ CircuitMetrics ] ) – tuple [ list [ Circuit ], dict [ str , Any ]] previous iqm.cpc.compiler.standard_stages.clean_schedule next iqm.cpc.compiler.standard_stages.get_standard_stages By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils.iqm_circuit_to_gate_implementation","url":"/iqm-pulla/api/iqm.pulla.utils.iqm_circuit_to_gate_implementation.html","description":"Wrap a circuit to a single GateImplementation that can then be registered as an independent “gate”. Returns a composite GateImplementation which, when called, produces a TimeBox with the circuit conte...","content":"Wrap a circuit to a single GateImplementation that can then be registered as an independent “gate”. Returns a composite GateImplementation which, when called, produces a TimeBox with the circuit contents\\nscheduled ASAP. The input circuit must contain only gates that are registered in IQM Pulse.\\nThe gate implementation does not need calibration data of its own: it uses the calibration of the registered gates. circuit ( Circuit ) – circuit to wrap, typically a small subset of a larger circuit. qubit_mapping ( dict [ str , str ] ) – Mapping from logical qubit names to physical qubit names. A new class CircuitAsComposite which can be registered as a new gate implementation. type [ CompositeGate ] previous iqm.pulla.utils.initialize_schedule_builder next iqm.pulla.utils.locate_instructions By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.interface.ChipLabelRetrievalException","url":"/iqm-pulla/api/iqm.pulla.interface.ChipLabelRetrievalException.html","description":"Exception for chip label retrieval failures. previous iqm.pulla.interface.CHADRetrievalException next iqm.pulla.interface.SettingsRetrievalException By IQM Pulla developers © Copyright 2024-2025, IQM ...","content":"Exception for chip label retrieval failures. previous iqm.pulla.interface.CHADRetrievalException next iqm.pulla.interface.SettingsRetrievalException By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.standard_stages.prepend_heralding","url":"/iqm-pulla/api/iqm.cpc.compiler.standard_stages.prepend_heralding.html","description":"Add the heralding measurement timebox to all circuits. timeboxes ( Iterable [ TimeBox ] ) – builder ( ScheduleBuilder ) – heralded_components ( tuple [ tuple [ str , ... ] , ... ] ) – options ( Circui...","content":"Add the heralding measurement timebox to all circuits. timeboxes ( Iterable [ TimeBox ] ) – builder ( ScheduleBuilder ) – heralded_components ( tuple [ tuple [ str , ... ] , ... ] ) – options ( CircuitExecutionOptions ) – list [ TimeBox ] previous iqm.cpc.compiler.standard_stages.multiplex_readout next iqm.cpc.compiler.standard_stages.prepend_reset By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.station_settings.build_station_settings","url":"/iqm-pulla/api/iqm.cpc.compiler.station_settings.build_station_settings.html","description":"Build the station settings for executing a batch of quantum circuits using the given QPU\\nelements and calibration data. circuit_qubits ( Iterable [ str ] ) – physical qubit names used in the circuit c...","content":"Build the station settings for executing a batch of quantum circuits using the given QPU\\nelements and calibration data. circuit_qubits ( Iterable [ str ] ) – physical qubit names used in the circuit circuit_couplers ( Iterable [ str ] ) – coupler names used in the circuit measured_probe_lines ( Iterable [ str ] ) – probe line names used in the measurements shots ( int ) – number of times to repeat each circuit’s execution calibration_set ( dict [ str , bool | str | int | float | complex | ndarray ] ) – calibration set as a mapping from observation paths to observation values boundary_qubits ( Iterable [ str ] ) – physical qubits connected to the boundary_couplers but not in circuit_qubits boundary_couplers ( Iterable [ str ] ) – coupler names of couplers connected to the circuit boundary but not in circuit_couplers flux_pulsed_qubits ( Collection [ str ] ) – names of qubits that have flux pulse capability station settings tree SettingNode previous iqm.cpc.compiler.station_settings next iqm.cpc.compiler.station_settings.find_observation By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler","url":"/iqm-pulla/api/iqm.cpc.compiler.html","description":"Compile quantum circuits into instruction schedules and settings that can be executed on a station. Subpackages and modules circuit_compilation_request_handler Convert quantum circuits into instructio...","content":"Compile quantum circuits into instruction schedules and settings that can be executed on a station. Subpackages and modules circuit_compilation_request_handler Convert quantum circuits into instruction schedules. compiler Convert quantum circuits into instruction schedules. dd Dynamical decoupling utilities. errors Definitions of error classes used to raise issues during circuit compilation. standard_stages Standard compilation stages, their constituent compiler passes, and functions for implementing them. station_settings Mapping calibration observations to station settings. previous iqm.cpc next iqm.cpc.compiler.circuit_compilation_request_handler By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.interface.compiler.DDStrategy","url":"/iqm-pulla/api/iqm.cpc.interface.compiler.DDStrategy.html","description":"Bases: object Describes a particular dynamical decoupling strategy. The current standard DD stategy can be found in STANDARD_DD_STRATEGY ,\\nbut users can use this class to provide their own dynamical d...","content":"Bases: object Describes a particular dynamical decoupling strategy. The current standard DD stategy can be found in STANDARD_DD_STRATEGY ,\\nbut users can use this class to provide their own dynamical decoupling strategies. See [ 1 ] for information on DD sequences. Attributes merge_contiguous_waits Merge contiguous Wait instructions into one if they are separated only by Block instructions. skip_leading_wait Skip processing leading Wait instructions. skip_trailing_wait Skip processing trailing Wait instructions. target_qubits Qubits on which dynamical decoupling should be applied. gate_sequences Available decoupling gate sequences to chose from in this strategy. Methods __eq__ (other) Return self==value. __repr__ () Return repr(self). merge_contiguous_waits ( bool ) – target_qubits ( frozenset [ str ] | None ) – skip_leading_wait ( bool ) – skip_trailing_wait ( bool ) – gate_sequences ( list [ tuple [ int , str | list [ tuple [ float , float ] ] , str ] ] ) – Merge contiguous Wait instructions into one if they are separated only by Block instructions. Qubits on which dynamical decoupling should be applied. If None , all qubits are targeted. Skip processing leading Wait instructions. Skip processing trailing Wait instructions. Available decoupling gate sequences to chose from in this strategy. Each sequence is defined by a tuple of (ratio, gate pattern, align) : ratio: Minimal duration for the sequence (in PRX gate durations). gate pattern: Gate pattern can be defined in two ways. It can be a string containing “X” and “Y” characters,\\nencoding a PRX gate sequence. For example, “YXYX” corresponds to the\\nXY4 sequence, “XYXYYXYX” to the EDD sequence, etc. If more flexibility is needed, a gate pattern can be\\ndefined as a sequence of PRX gate argument tuples (that contain a rotation angle and a phase angle). For\\nexample, sequence “YX” could be written as [(math.pi, math.pi / 2), (math.pi, 0)] . align: Controls the alignment of the sequence within the time window it is inserted in. Supported values: “asap”: Corresponds to a ASAP-aligned sequence with no waiting time before the first pulse. “center”: Corresponds to a symmetric sequence. “alap”: Corresponds to a ALAP-aligned sequence. The Dynamical Decoupling algorithm uses the best fitting gate sequence by first sorting them\\nby ratio in descending order. Then the longest fitting pattern is determined by comparing ratio with the duration of the time window divided by the PRX gate duration. previous iqm.cpc.interface.compiler.DDMode next iqm.cpc.interface.compiler.HeraldingMode By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.standard_stages.merge_multiplexed_timeboxes","url":"/iqm-pulla/api/iqm.cpc.compiler.standard_stages.merge_multiplexed_timeboxes.html","description":"Merge any MultiplexedProbeTimeBoxes inside a TimeBox representing a circuit. This pass optimizes a situation where multiple “measure” gates on disjoint set of loci exist sequentially in the\\ncircuit.\\nW...","content":"Merge any MultiplexedProbeTimeBoxes inside a TimeBox representing a circuit. This pass optimizes a situation where multiple “measure” gates on disjoint set of loci exist sequentially in the\\ncircuit.\\nWithout optimization, each gate would result in a separate trigger event, which results in worse performance.\\nFor example, with the measurement instructions [M(QB1), M(QB2), M(QB3)], we’d first measure QB1, then QB2, then QB3.\\nThis optimization merges the measurement timeboxes, so that we’ll measure QB1, QB2, and QB3 at the same time\\n(if the hardware channel configuration allows it), corresponding to M(QB1, QB2, QB3). Goes through the children of circuit_box , and places them in the same temporal order.\\nWhenever a MultiplexedProbeTimeBox is encountered (i.e. from a measure gate), it is merged with the previous pending\\nMultiplexedProbeTimeBox and left pending.\\nIf any other box type with colliding loci is encountered, first places the pending MultiplexedProbeTimeBox.\\nThis essentially delays all measurements until the last possible moment. circuit_box ( TimeBox ) – Timebox representing a circuit, where each child should represent a single gate. A new Timebox with the same content, except with some MultiplexedProbeTimeBoxes merged. TimeBox previous iqm.cpc.compiler.standard_stages.map_old_operations next iqm.cpc.compiler.standard_stages.multiplex_readout By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.compiler.CompilationStage","url":"/iqm-pulla/api/iqm.cpc.compiler.compiler.CompilationStage.html","description":"Bases: object Sequence of compiler passes that are applied to the data. The data and context are returned after all passes have been applied.\\nA pass is a function that takes the data and context as ar...","content":"Bases: object Sequence of compiler passes that are applied to the data. The data and context are returned after all passes have been applied.\\nA pass is a function that takes the data and context as arguments and\\nreturns the modified data and context. The context is a dictionary that can contain any information that needs to be\\npassed between the passes. Methods add_passes (*pass_functions) Add multiple passes to the stage. ready () Check if the stage is ready to run. run (data, context) Run all the passes in the stage on the data and context. name ( str ) – Check if the stage is ready to run. A stage is ready if it has at least one pass defined. bool Add multiple passes to the stage. pass_functions ( Callable [ [ Any , dict [ str , Any ] ] , tuple [ Any , dict [ str , Any ] ] ] ) – One or more pass functions to be added to the stage. None Run all the passes in the stage on the data and context. The data and context are returned after all passes have\\nbeen applied. data ( Any ) – The data to be processed. context ( dict [ str , Any ] ) – A dictionary containing any additional information that needs to be passed between the passes. The processed data and context. tuple [ Any , dict [ str , Any ]] previous iqm.cpc.compiler.compiler.pass_function_idempotent next iqm.cpc.compiler.compiler.Compiler By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.standard_stages.apply_dd_strategy","url":"/iqm-pulla/api/iqm.cpc.compiler.standard_stages.apply_dd_strategy.html","description":"Insert dynamical decoupling sequences into the schedules, if dynamical decoupling is enabled. schedules ( Iterable [ Schedule ] ) – builder ( ScheduleBuilder ) – options ( CircuitExecutionOptions ) – ...","content":"Insert dynamical decoupling sequences into the schedules, if dynamical decoupling is enabled. schedules ( Iterable [ Schedule ] ) – builder ( ScheduleBuilder ) – options ( CircuitExecutionOptions ) – list [ Schedule ] previous iqm.cpc.compiler.standard_stages next iqm.cpc.compiler.standard_stages.apply_move_gate_phase_corrections By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.interface.Circuit","url":"/iqm-pulla/api/iqm.pulla.interface.Circuit.html","description":"Bases: BaseModel Quantum circuit to be executed. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name name of the ...","content":"Bases: BaseModel Quantum circuit to be executed. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name name of the circuit instructions instructions comprising the circuit metadata arbitrary metadata associated with the circuit Methods to_dataclass () Convert the model to a dataclass. name ( str ) – instructions ( tuple [ Instruction , ... ] ) – metadata ( dict [ str , Any ] | None ) – name of the circuit instructions comprising the circuit arbitrary metadata associated with the circuit Convert the model to a dataclass. Circuit Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.pulla.interface.BUFFER_AFTER_MEASUREMENT_PROBE next iqm.pulla.interface.Instruction By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.interface.compiler.ReadoutMapping","url":"/iqm-pulla/api/iqm.cpc.interface.compiler.ReadoutMapping.html","description":"Type for matching measurement keys from the quantum circuit with acquisition labels in Station Control. In quantum circuits, measurements are identified by measurement keys.\\nMeasurements in Station Co...","content":"Type for matching measurement keys from the quantum circuit with acquisition labels in Station Control. In quantum circuits, measurements are identified by measurement keys.\\nMeasurements in Station Control are identified by acquisition labels specific to a readout controller.\\nThis type is a dictionary mapping measurement keys to lists of acquisition labels — each acquisition\\nlabel should hold the readout of a single qubit at a single point in the circuit, and the order in\\nthe list corresponds to the order of qubits in the measurement instruction. E.g. if one has\\nmeasurement instruction with key='mk' and qubits=[QB2, QB1] , then the corresponding entry in\\nthis dict would be 'mk': ('QB2__mk', 'QB1__mk') The values of the ReadoutMapping are used to determine which measurement results Station Control\\nshould return to Cocos. alias of dict [ str , tuple [ str , …]] previous iqm.cpc.interface.compiler.PRXSequence next iqm.cpc.interface.compiler.ReadoutMappingBatch By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.dd","url":"/iqm-pulla/api/iqm.cpc.compiler.dd.html","description":"Dynamical decoupling utilities. Module Attributes STANDARD_DD_STRATEGY The default DD strategy uses the following gate sequences: Functions insert_dd_sequences (builder, schedule, strategy) Insert dyn...","content":"Dynamical decoupling utilities. Module Attributes STANDARD_DD_STRATEGY The default DD strategy uses the following gate sequences: Functions insert_dd_sequences (builder, schedule, strategy) Insert dynamical decoupling sequences into the given schedule. merge_wait_instructions_in_schedule (builder, ...) Merge adjacent Wait instructions in the drive channels of the given schedule. previous iqm.cpc.compiler.compiler.Compiler next iqm.cpc.compiler.dd.STANDARD_DD_STRATEGY By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.interface.StationControlResult","url":"/iqm-pulla/api/iqm.pulla.interface.StationControlResult.html","description":"Bases: object Result of a station control task Attributes end_time Time when the sweep ended in the station control message Information about task failure result Sweep results converted to the circuit...","content":"Bases: object Result of a station control task Attributes end_time Time when the sweep ended in the station control message Information about task failure result Sweep results converted to the circuit measurement results expected by the client start_time Time when the sweep began in the station control sweep_id ID of the executed sweep task_id ID of the station control task status Status of the station control task Methods __eq__ (other) Return self==value. __repr__ () Return repr(self). sweep_id ( UUID ) – task_id ( UUID ) – status ( TaskStatus ) – start_time ( str | None ) – end_time ( str | None ) – result ( list [ dict [ str , list [ list [ int ] ] ] ] | None ) – message ( str | None ) – ID of the executed sweep ID of the station control task Status of the station control task Time when the sweep began in the station control Time when the sweep ended in the station control Sweep results converted to the circuit measurement results expected by the client Information about task failure previous iqm.pulla.interface.Instruction next iqm.pulla.interface.TaskStatus By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils_qiskit.IQMPullaBackend","url":"/iqm-pulla/api/iqm.pulla.utils_qiskit.IQMPullaBackend.html","description":"Bases: IQMBackendBase A backend that compiles circuits locally using Pulla and submits them to Station Control for execution. architecture ( DynamicQuantumArchitecture ) – Describes the backend archit...","content":"Bases: IQMBackendBase A backend that compiles circuits locally using Pulla and submits them to Station Control for execution. architecture ( DynamicQuantumArchitecture ) – Describes the backend architecture. pulla ( Pulla ) – Instance of Pulla used to execute the circuits. compiler ( Compiler ) – Instance of Compiler used to compile the circuits. Attributes max_circuits The maximum number of circuits (or Pulse schedules) that can be run in a single job. architecture Dynamic quantum architecture of the backend instance. name Name of the backend. description Optional human-readable description. online_date Date that the backend came online. backend_version Version of the backend being provided. Methods _default_options () Return the default options run (run_input, **options) Run on the backend. Run on the backend. This method returns a Job object\\nthat runs circuits. Depending on the backend this may be either an async\\nor sync call. It is at the discretion of the provider to decide whether\\nrunning should block until the execution is finished or not: the Job\\nclass can handle either situation. run_input ( QuantumCircuit or Schedule or ScheduleBlock or list ) – An\\nindividual or a list of QuantumCircuit , ScheduleBlock , or Schedule objects to\\nrun on the backend. options – Any kwarg options to pass to the backend for running the\\nconfig. If a key is also present in the options\\nattribute/object then the expectation is that the value\\nspecified will be used instead of what’s set in the options\\nobject. The job object for the run Job The maximum number of circuits (or Pulse schedules) that can be\\nrun in a single job. If there is no limit this will return None previous iqm.pulla.utils_qiskit.DummyJob next Common errors By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.pulla.utils_cirq.cirq_to_cpc","url":"/iqm-pulla/api/iqm.pulla.utils_cirq.cirq_to_cpc.html","description":"Convert a Cirq Circuit to an IQM CPC Circuit. previous iqm.pulla.utils_cirq next iqm.pulla.utils_dd By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04...","content":"Convert a Cirq Circuit to an IQM CPC Circuit. previous iqm.pulla.utils_cirq next iqm.pulla.utils_dd By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulla","title":"iqm.cpc.compiler.standard_stages.map_old_operations","url":"/iqm-pulla/api/iqm.cpc.compiler.standard_stages.map_old_operations.html","description":"Map backwards-compatible aliases for quantum operation names into the current name. circuits ( Iterable [ Circuit ] ) – previous iqm.cpc.compiler.standard_stages.map_components next iqm.cpc.compiler.s...","content":"Map backwards-compatible aliases for quantum operation names into the current name. circuits ( Iterable [ Circuit ] ) – previous iqm.cpc.compiler.standard_stages.map_components next iqm.cpc.compiler.standard_stages.merge_multiplexed_timeboxes By IQM Pulla developers © Copyright 2024-2025, IQM Finland Oy, Release 7.14. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"Concepts and Classes","url":"/iqm-pulse/concepts.html","description":"This section gives an overview of the main concepts and terminology in IQM Pulse. QPUs contain components : qubits, computational resonators, couplers, and probelines. Each component may have some con...","content":"This section gives an overview of the main concepts and terminology in IQM Pulse. QPUs contain components : qubits, computational resonators, couplers, and probelines. Each component may have some control channels connected to it. Control channels deliver physical control pulses\\nto the QPU. Quantum operations have a locus , which is the set of quantum information carrying components\\n(qubits and resonators) the operation acts on.\\nOne operation may involve sending pulses to multiple control channels. The assembly of a Playlist, or a batch of quantum circuits, can be summarized as follows: A Playlist contains multiple independent segments , to be executed as a batch. A segment is a conceptual unit at a time scale where the quantum information of the QPU can be\\nassumed to be preserved. A quantum circuit corresponds to one segment. What is executed during a segment is determined by a Schedule . A Schedule is a set of hardware control channels, each with a strictly timed sequence of Instructions . A Schedule is formed by scheduling a Timebox . A TimeBox can contain other TimeBoxes without precise relative timing,\\nor it can be atomic, in which case it contains a single Schedule . The image below illustrates how a Playlist of two segments is formed from TimeBoxes. Hardware instructions are the lowest-level construct visible on the client side.\\nInstructions are a set of atomic, real-time execution commands for the control hardware supported by IQM.\\nThey work in a time scale where the quantum information of the QPU can be assumed to be preserved.\\nExamples of Instructions are IQPulse to play a microwave pulse on a channel, VirtualRZ to adjust the modulation phase, ReadoutTrigger to acquire measurement data,\\nand Wait to delay the next Instruction for a given time.\\nSee iqm.pulse.playlist.instructions for the complete list. During execution, each hardware control channel executes its own sequence of Instructions.\\nEach Instruction blocks the next until it is completed.\\nInstructions are as explicit as possible, so that there is no ambiguity on what will be executed when.\\nIQM Station control transforms Instructions to machine-specific commands. All Instructions have a duration, measured in samples, though the duration can be zero.\\nThe durations are subject to hardware-specific granularity constraints.\\nFor example, some hardware might require all instructions to be a multiple of 16 samples long, with a minimum of 32.\\nInstructions violating the granularity constraints will raise an error.\\nHowever, a typical user does not need to concern themselves about the constraints, as\\nthe gate implementations and IQM Pulse’s scheduling ensures the constraints are respected.\\nThe philosophy is that Station Control, which is inaccessible to the user, does not attempt to do any smart\\n“magic” to fix inconsistencies in the user’s input, it simply executes the Playlist it is given.\\nInstead, the magic happens on the client side so that it is transparent to the user. Note For technical reasons, IQM Pulse mostly uses classes from iqm.pulse.playlist.instructions , but when\\nfinalizing the output, the instructions are converted to iqm.models.playlist.instructions .\\nThese two class families are semantically equivalent, apart from a few exceptions like Block which\\nonly exists on the client side to help with scheduling. Schedule contains a number of control channels, each with a lists of Instructions.\\nAll channels in a Schedule start executing at the same instant, and the timing is defined by the duration of the\\nindividual Instructions.\\nSchedules can be thought of as a fixed block that occupies some interval on a timeline of some channels. Schedules appear in two contexts: gate implementations and as complete segments.\\nFor example, when an implementation of a PRX gate is requested,\\na small Schedule involving the drive channel of a single qubit is created.\\nWhen all the desired gates in a circuit have been scheduled by concatenating the gate-schedules together,\\nthe end result, a segment, is a large Schedule occupying all necessary channels.\\nA typical segment starts with initializing the qubits and ends with reading out their state. Whereas a Schedule is a container with strict relative timing, a TimeBox is a container with undefined\\nrelative timing.\\nEach TimeBox can be labeled using a human-readable label describing it, and operates on a number\\nof locus components , using some of their control channels.\\nA composite TimeBox contains other TimeBoxes as children, whereas atomic TimeBoxes contain a Schedule. TimeBoxes are the main language in which users define the order and relative alignment of execution elements, be it\\ngates, Schedules, or larger TimeBoxes. A key process is the scheduling, in which TimeBoxes are resolved recursively into a fixed Schedule.\\nWhen resolving, all Schedules inside the TimeBox are concatenated and are either left-aligned (ASAP) or right-aligned\\n(ALAP), respecting the hardware constraints.\\nImportantly, if some TimeBoxes have content on disjoint channels, the Schedules are allowed to happen simultaneously.\\nIf they have content on partly overlapping channels, the Schedules are concatenated while preserving their internal\\ntiming.\\nAny interval that does not have explicit instructions is filled with Wait Instructions.\\nThe figure above demonstrates how TimeBoxes are resolved. The syntax and rules are explained in more detail in Using ScheduleBuilder . A higher-level concept, a QuantumOp can represent a unitary quantum gate,\\nor for example a measurement operation (not all QuantumOps necessarily represent a unitary gate).\\nQuantumOps are simple, abstract, self-contained actions one can execute on a station as parts of a quantum circuit.\\nThey include quantum gates like PRX, CZ, and measurements and resets.\\nWhereas Schedules and Instructions act on control channels, QuantumOps act on named components on the QPU, such as\\nqubits or computational resonators. A QuantumOp has unambiguous definition in terms of its intended effect on the computational subspace of the\\nQPU component, but it can be implemented in various ways.\\nEach implementation is represented as a GateImplementation. The list of available QuantumOps at runtime can be obtained with iqm.pulse.builder.build_quantum_ops() .\\nA new QuantumOp can be registered at runtime, together with an implementation, with iqm.pulse.gates.register_implementation() . A GateImplementation bridges the gap between QuantumOps and TimeBoxes.\\nWhen a user requests a QuantumOp from ScheduleBuilder with specific parameters and locus components, the\\nchosen GateImplementation (usually the default) for the operation is used to produce a TimeBox.\\nThis TimeBox, usually atomic, contains a Schedule on the appropriate control channels.\\nThe Instructions within are constructed following the calibration values from the ScheduleBuilder. All gate implementations are listed in iqm.pulse.gates .\\nSection Custom gate implementations explains how to add more implementations. Once all TimeBoxes are scheduled into large Schedules, one for each segment/circuit,\\nthe Schedules are collected into a Playlist .\\nThe Playlist is the final product that is sent to Station Control.\\nIts contents are compressed by indexing all unique Instructions and waveforms on each channel,\\nand representing the control channels in each segment as lists of Instruction indices. During execution, the segments in the Playlist are executed in order, and the whole sequence is repeated\\na number of times equal to the number of repetitions (shots). Segments are separated in time by end delay , a parameter outside the Playlist.\\nA long end delay can be used to prevent quantum information carrying from one segment to the next,\\nthus resetting the qubits.\\nAlternatively, the reset can be encoded in each segment as a long Wait instruction or using some active reset scheme. Station Control aims to execute all segments together, but sometimes this is not possible due to various memory\\nconstraints.\\nIn case the whole Playlist does not fit in memory, the segments are split into chunks which are executed separately.\\nThe delay between chunks is undefined.\\nTherefore, the time between segments is guaranteed to be at least the duration of the end delay, but can be much larger. inspect_playlist() provides a neat visual representation of the playlist, as blocks of instructions on a\\ntimeline. previous IQM Pulse next Using ScheduleBuilder © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"Using ScheduleBuilder","url":"/iqm-pulse/using_builder.html","description":"This section describes how to use ScheduleBuilder to compose pulse schedules.\\nScheduleBuilder encapsulates registered QuantumOps, the calibration information for them, QPU components and their\\ntopolog...","content":"This section describes how to use ScheduleBuilder to compose pulse schedules.\\nScheduleBuilder encapsulates registered QuantumOps, the calibration information for them, QPU components and their\\ntopology, and control channel properties. In the context of IQM Pulla and EXA, an instance of ScheduleBuilder is given by the framework,\\nand it contains all the necessary information to execute against a particular quantum computer instance.\\nHere, we assume that user has an instance of ScheduleBuilder builder to work with. A typical workflow begins with calling get_implementation() with the name of a desired QuantumOp and the locus\\nfor the operation.\\nThe locus is the logical target of the operation, usually a sequence of qubits or computational resonators.\\nThis outputs a an instance of GateImplementation , which is capable of producing TimeBoxes with the correct\\ncalibration for that locus. For example, here we ask for the GateImplementation of prx , cz , and measure , all of which are standard\\ngates recognized by IQM Pulse, for qubits QB1 and QB3 .\\nAny gate which is registered in the runtime can be requested this way. Notice how the number of qubits matches the operation: CZ acts on 2 qubits, while PRX acts on only one.\\nMeasure can act on any number of qubits. There might be several available implementations for an operation. get_implementation gives the implementation that is set as the default, unless a specific implementation is\\nrequested with a keyword argument. To instantiate some concrete TimeBoxes, we call time implementation with the logical parameters of the operations, as\\ndefined by the QuantumOps.\\nPRX has 2 parameters: the 2 angles of a phased rotation.\\nCZ does not have any parameters. One important method is the wait() , which blocks the control channels of the given components for a certain time: In all of the examples above, the TimeBoxes are atomic, which can be organized into composite TimeBoxes to decide\\ntheir relative order. TimeBoxes can be concatenated with the following rules: Addition ( + ) concatenates the children of the operands into a single TimeBox.\\nUse addition to allow gates on disjoint loci to execute simultaneously, for example doing a PRX on all qubits. The pipe operation ( | ) groups two TimeBoxes together without concatenating.\\nThis results in composite TimeBox with two children, the operands, which are scheduled separately.\\nUse the pipe to ensure that certain operations execute before some others. Iterables of TimeBoxes are treated as the sum of the elements. This would execute 2 PRX gates on QB1 and QB2 simultaneously: If the last operator was | instead, the second gate on QB2 would execute only after the first 3 gates. Together, these rules provide a handy way of defining complex circuits easily: A TimeBox are made atomic by resolving it using ScheduleBuilder.resolve_timebox() .\\nWhen using a framework like IQM Pulla or Exa, the framework will take care of the resolving as part of compilation,\\nso the user does not need to do it explicitly. TimeBoxes are resolved recursively: The children of a TimeBox are resolved, and resulting (sub-)Schedules are aligned\\naccording to the SchedulingStrategy (ASAP or ALAP) of the TimeBox.\\nThe time duration of a TimeBox is determined by its contents and the way they are scheduled during the resolution.\\nFinally, all channels are padded with Waits so that the total duration of Instructions on every channel is equal.\\nIn other words, the Schedule becomes a “rectangle”. An important part of the scheduling are the blocking rules, that is, whether the contents of two TimeBoxes block or\\nslide past each other.\\nThe rules are: An atomic TimeBox is considered to act on a component if it has instructions on any of the non-virtual channels\\nrelated to that component. A composite TimeBox acts on the union of its children’s locus components. A TimeBox blocks all channels related to any component it acts on. When scheduling two TimeBoxes, the instructions will not overlap in time if the TimeBoxes block overlapping channels. In addition to blocking the channels actually present in a TimeBox, it is possible to block neighbouring channels\\nas well (for example in order to limit cross-talk).\\nThe applied neighbourhood is specified in ScheduleBuilder.resolve_timebox() .\\nThe neighbourhood is defined as an integer such that 0 means “block only the involved channels”,\\n1 means “block the involved channels and the channels of any neighbouring couplers”,\\n2 means “the same as in (1) but in addition block all channels connected by those couplers”, and so on.\\nThe blocking rules do not add actual Wait or Block instructions are added to the neighbourhood channels, and two\\noverlapping neighbourhoods do not block each other.\\nThe blocking comes in question only when actual content would be added to those neighbourhood channels. In practice, the rules and default GateImplementations ensure that the user can concatenate arbitrary gates\\nwithout worrying that the gates have an adverse effect on each other.\\nFor example, the pulse of a PRX gate playing at the same time as a CZ gate or a measurement would ruin both operations.\\nIf overlapping of such gates is desired, the best way is to arrange the Instructions on the Schedule level and wrap the\\nschedule into an atomic TimeBox. Note Virtual channels are special channels that exist only to aid the scheduling algorithm.\\nExamples are tracking the phases of the MOVE gate, and timing of fast feedback.\\nThese channels are removed when the Playlist is finalized. You are encouraged to discover the many features of ScheduleBuilder and TimeBox by reading the\\nAPI: ScheduleBuilder , TimeBox . A quick reference of selected features is provided in the examples below. Finding information about the target system: Working with TimeBoxes: Some typical errors that are easy to make with the syntax: Not calling the implementation to get a TimeBox. The call is easy to forget especially if there are no parameters\\nto give: Giving a single component as locus: previous Concepts and Classes next Custom gate implementations © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"IQM Pulse","url":"/iqm-pulse/index.html","description":"9.5 2025-04-26 IQM Pulse provides an abstraction that transforms high-level quantum circuit operations\\nto a unified set of lower-level instructions for IQM quantum computers. A quantum circuit is an a...","content":"9.5 2025-04-26 IQM Pulse provides an abstraction that transforms high-level quantum circuit operations\\nto a unified set of lower-level instructions for IQM quantum computers. A quantum circuit is an abstract mathematical construct which conveniently hides all implementation\\ndetails such as the timing of microwave pulses, waveform shapes, sampling rates, signal capture, and so on.\\nBut in order to execute a circuit you need to convert it into a schedule of hardware instructions which involve\\nall of the above. IQM Pulse provides a framework for defining abstract quantum gates/operations, as well as their concrete implementations in terms of hardware instructions machinery to easily construct circuit-level gate sequences, and compile them into instruction schedules. a set of ready-made gates with implementations. IQM Pulse is not a standalone tool, but is used in IQM’s client libraries, IQM Pulla and Exa.\\nTo use them effectively, you are encouraged to familiarize yourself with IQM Pulse, especially the most common\\nconcepts. Index Module Index Search Page next Concepts and Classes © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"API Reference","url":"/iqm-pulse/API.html","description":"iqm.pulse Control pulses, gates and instruction schedules for quantum computers. previous Pulse timing next pulse © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26....","content":"iqm.pulse Control pulses, gates and instruction schedules for quantum computers. previous Pulse timing next pulse © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"References","url":"/iqm-pulse/references.html","description":"Eric Hyyppä, Antti Vepsäläinen, Miha Papič, Chun Fai Chan, Sinan Inel, Alessandro Landra, Wei Liu, Jürgen Luus, Fabian Marxer, Caspar Ockeloen-Korppi, and others. Reducing leakage of single-qubit gate...","content":"Eric Hyyppä, Antti Vepsäläinen, Miha Papič, Chun Fai Chan, Sinan Inel, Alessandro Landra, Wei Liu, Jürgen Luus, Fabian Marxer, Caspar Ockeloen-Korppi, and others. Reducing leakage of single-qubit gates for superconducting quantum processors using analytical control pulse envelopes. PRX Quantum , 5(3):030353, 2024. doi:10.1103/PRXQuantum.5.030353 . John M. Martinis and Michael R. Geller. Fast adiabatic qubit gates using only $\\\\sigma _z$ control. Phys. Rev. A , 90:022307, Aug 2014. arXiv:1402.5467 , doi:10.1103/PhysRevA.90.022307 . R. G. Lyons. Understanding Digital Signal Processing . Prentice Hall, 2nd edition, 2004. ISBN 978-0131089891. Cecilia Gisele Jarne. A heuristic approach to obtain signal envelope with a simple software implementation. ANALES AFA , 29(2):51–57, 2018. arXiv:1703.06812 , doi:10.31527/analesafa.2018.29.2.51 . Eyob A. Sete, Nicolas Didier, Angela Q. Chen, Shobhan Kulshreshtha, Riccardo Manenti, and Stefano Poletto. Parametric-resonance entangling gates with a tunable coupler. Phys. Rev. Appl. , 16:024050, Aug 2021. arXiv:2104.03511 , doi:10.1103/PhysRevApplied.16.024050 . Youngkyu Sung, Leon Ding, Jochen Braumüller, Antti Vepsäläinen, Bharath Kannan, Morten Kjaergaard, Ami Greene, Gabriel O. Samach, Chris McNally, David Kim, Alexander Melville, Bethany M. Niedzielski, Mollie E. Schwartz, Jonilyn L. Yoder, Terry P. Orlando, Simon Gustavsson, and William D. Oliver. Realization of high-fidelity CZ and ZZ-free iSWAP gates with a tunable coupler. Phys. Rev. X , 11:021058, Jun 2021. arXiv:2011.01261 , doi:10.1103/PhysRevX.11.021058 . previous Changelog next License © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"Pulse timing","url":"/iqm-pulse/pulse_timing.html","description":"The ReadoutTrigger Instruction responsible of qubit readout has several\\ntiming-related attributes.\\nThe measure.constant gate implementation produces the lower-level ReadoutTrigger instruction\\nfrom a s...","content":"The ReadoutTrigger Instruction responsible of qubit readout has several\\ntiming-related attributes.\\nThe measure.constant gate implementation produces the lower-level ReadoutTrigger instruction\\nfrom a simplified set of settings.\\nThe figure below shows how the settings relate to the more flexible attributes of the instruction. With conditional Instructions, we specify how the information from readout operations should affect Instructions at\\nruntime.\\nUsually, the goal is use the information as soon as possible, but it takes a finite time to propagate from the\\nacquisition unit to the drive channels that execute the Instructions conditionally. Note On all hardware supported by IQM QCCSW, ConditionalInstruction reads the signal bit at the time of\\nexcution, regardless of when the signal bit was last updated.\\nThis means that if the Conditionalinstruction is executed too early, the condition will be executed based on the\\nprevious state of the bit. To facilitate efficient timing of the feedback signals, IQM Pulse uses virtual channels between probeline channels\\n(the source of the signals) and drive channels (the destinations).\\nBlock instructions on the virtual channel represent the travel time of the signals. CCPRX_Composite is GateImplementation of the cc_prx (classically controlled PRX) that outputs two\\nTimeBoxes:\\nthe first one to represent the travel time, and the second one with the actual ConditionalInstruction .\\nIn typical use, both should be scheduled in the same order, to ensure the Conditionalinstrucion starts when the\\nsignal bit is available. The following image illustrates how the TimeBoxes are used for qubits QB2 and QB3 .\\nFor QB2, this is also how Reset_Conditional implements the reset operation. The equaivalent code would be Instructions are spaced out in time only for visual clarity. When scheduled ASAP, they would be left-aligned\\nsuch that the ConditionalInstructions start right after the associated control_delay has passed. The bottom of the image illustrates an alternative use of CCPRX_Composite to have more freedom in the timing.\\nThere, the optional delay TimeBox is not used for scheduling the Instructions on QB4.\\nInstead, the user has ensured that the other instructions take enough time for the signal to arrive.\\nThis could be used to act on the previous feedback signal (not shown). Note This section is not about IQM Pulse itself, but might help in understanding the details of the execution. The image below shows a typical timing of a Playlist segment with 2 AWG devices for driving, and a readout instrument.\\nHere, all statements that apply to an AWG apply to readout instruments as well.\\nThe AWGs can output an arbitrary sequence of pulses, and the readout instrument can additionally read out\\nthe response to the pulses. With readout, the raw signal response from the readout pulse will be integrated to produce a single number, such as a\\ncomplex number or a bit, corresponding to a particular qubit in a particular segment. In the figure, one of the AWGs has been selected as the trigger master, which means it sends trigger pulses to\\nstart the execution on the slave devices.\\nAs shown in the picture, different delays caused by the travel time of signals can be compensated for by\\nadjusting the trigger_delay setting of each device. Settings in the figure that can be adjusted by user in the higher level libraries: Setting Explanation <awg>.trigger_delay Wait time between the end of the trigger signal of the AWG master and the beginning of the pulse sequence. <awg>.trigger_delay (slave) Wait time between receiving the trigger signal at the AWG slave and the beginning of the pulse sequence. options.end_delay Wait time between the end of the pulse segment and the next trigger. <gate>.<implementation>.<locus>.duration The duration of the hardware instruction for a gate, possibly rounded to satisfy granularity constraints.\\nFor the ReadoutTrigger instruction, the meaning is different, see below. Other notes: The AWG spcecified by options.trigger_master is the only channel that does not wait for a trigger\\nat the start of a segment. Slave AWGs may also emit a trigger pulse to allow daisy chaining trigger signals. Systems with IQM Control System are triggered centrally and the channels run independently, and the options.trigger_master has no effect. Pipeline delays are delays between the execution of a command and the pulse actually getting outputted\\nfrom a device. This delay is caused by the hardware and cannot be changed.\\nIn practice, it can be thought as being part of the cable delays, and thus can be compensated with trigger_delay setting. previous Custom gate implementations next API Reference © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"Custom gate implementations","url":"/iqm-pulse/custom_gates.html","description":"Quantum gates are represented by QuantumOp data classes, containing the required\\nmetadata to define the gate. A QuantumOp is identified by its name , and arity defines number of locus components the o...","content":"Quantum gates are represented by QuantumOp data classes, containing the required\\nmetadata to define the gate. A QuantumOp is identified by its name , and arity defines number of locus components the operation acts on. For example,\\nthe PRX operation (Phased X Rotation) is a single-qubit operation, so its arity is 1, whereas the CZ (Controlled-Z) gate\\nacts on two qubits, having arity 2. Arity 0 has a special meaning that the operation in question can act on any number\\nof components (for example Barrier ). The attribute symmetric defines whether the effect of the quantum operation\\nis symmetric with respect to changing the order of its locus components. As an example, the CZ gate is a symmetric\\ntwo-qubit gate, whereas CNOT (Controlled-NOT) is not symmetric. Some quantum operations are defined as “functions”, taking one or more parameters to define the effect. These\\narguments are stored in the attribute params . As an example, the PRX gate\\ntakes two arguments, angle (the rotation angle with respect to the z-axis of the Bloch sphere), and phase (the rotation phase in the rotating frame). On the other hand, many operations do not require any parameters, in\\nwhich case this field is an empty tuple (e.g. the CZ gate). A QuantumOp has unambiguous definition in terms of its intended effect on the computational subspace of the\\nQPU component, but it can be implemented in various ways. Each implementation is represented as a GateImplementation subclass. A QuantumOp stores its known implementations in the\\nfield implementations . Note that even though QuantumOp is a frozen data class, the implementations dictionary can be modified, e.g.\\nto add new implementations or to change their order (usually programmatically by some client procedure, but nothing as\\nsuch prevents the user from manipulating the contents manually). The default implementation is how the user prefers\\nto implement the operation unless otherwise specified (in effect, this is what will get called in most cases the\\noperation is invoked). In the implementations dict, the default implementation is defined as the first entry.\\nQuantumOp contains helpful methods that allow setting and returning the default implementation for specific cases: set_default_implementation() , get_default_implementation_for_locus() , and set_default_implementation_for_locus() . The attribute unitary stores a function that can be used to get the unitary\\nmatrix representing the quantum operation in question. The unitary function must have the same arguments\\nas defined in params , such that for each collection of these parameters it\\ngives the associated unitary matrix. Note that not all QuantumOps necessarily even represent a unitary gate (e.g.\\nthe measure operation is not one), or the exact form of the unitary matrix might not be known. In these cases, the\\nfield can be left None . The unitary does not need to be defined for most of the basic usage of a QuantumOp, but certain\\nalgorithmic methods (e.g. some implementations of Randomized Benchmarking) may require the unitary matrices to be known,\\nand such operations that do not define the getter function cannot then be used in these contexts. For more information, see the API docs of QuantumOp for the full list of fields needed\\nto define a quantum operation and the available class methods. While QuantumOp represents an abstract quantum operation, its implementations contain\\nthe concrete logic of how to make that operation happen using QC hardware. Gate implementations are subclasses of GateImplementation . In this section, the main features of that class are\\nintroduced (for a full list of class methods see the API docs), with the emphasis being on how to create your own\\ngate implementations. Starting with __init__() , it is important to note that the init\\nmethods of all gate implementations must have the exact same signature: Here, parent is the QuantumOp this gate implementation implements, and name is the implementation’s name in\\nthe dictionary implementations . locus is the set of (usually logical) components\\nthe QuantumOp acts on (the size of the locus must be consistent with the parent ’s arity ), while calibration_data gives the required calibration data values\\nfor this implementation and locus (can be empty in case the implementation needs no calibration data). Finally,\\nThe implementations store a reference to the ScheduleBuilder that created it. This is\\nbecause GateImplementations are practically never created manually by calling the init method itself. Instead, one\\nneeds a builder and uses get_implementation() . The responsibility of the init method is to (at least) store the calibration_data provided from the builder for\\nfurther use, but in many cases, one might want to create some intermediate objects like pulses or instructions from that calibration data already at this point. Note that ScheduleBuilder caches its GateImplementations per each locus and calibration_data , so as long as the calibration is not changed, the code in init will be called just once per locus. GateImplementations are Callables, i.e. they implement the __call__ method. It should take as its arguments at least\\nthe QuantumOpt parameters defined for the parent in params , but in\\naddition it may have optional extra arguments. The call method should return a TimeBox object\\nthat contains the pulses, instructions and other logic required to implement the quantum operation in question. The\\ntypical usage of gate implementations then looks like this (See Using ScheduleBuilder and Pulse timing for more\\ninfo on scheduling and the ScheduleBuilder): The base class __call__() method does automatic TimeBox caching based\\non the unique values of the call arguments, and in many cases, one does not want to reimplement this caching in their own\\nimplementations. For this reason, there is the method _call which contains just the pure TimeBox creation logic.\\nDevelopers can choose to override that instead of __call__ in cases where the call args are hashable python types,\\nand then they can utilize the default caching of TimeBoxes from the base class. When writing a GateImplementation, a developer should consider what parts of the logic should go to the class init and\\nwhat to the __call__ or _call method. A general rule of thumb would be that any parts that can be precomputed\\nand do not depend on the call arguments can go to init, and the rest to call. As an example, let’s go through a simple PRX _call method (note that the default PRX implementations do not\\nuse this exact call method, as this is a simplified example for educational purposes): Here, we first create an IQPulse object which is a low-level Instruction. IQPulse\\nmeans a “complex pulse” which has two orthogonal components i and q – this what drive pulses look like in general. In\\nthis simplified example, we have hardcoded the pulse waveforms into TruncatedGaussian and TruncatedGaussianDerivative for the i and q components, respectively (this is a DRAG implementation, so the\\nq component is the derivative of the i component). The waveforms are parametrized by the calibration_data for the\\ngiven locus (see the next subsection for more info on Waveforms and calibration data). The PRX QuantumOp param angle scales the pulse amplitude linearly (the waveforms are normalized to one), and the param phase defines relative\\nphase modulation. Then the returned TimeBox is created out of the instruction . Note that\\nsince we override _call here, instead of __call__ , so this implementation would utilize the default base class\\ncaching such that the TimeBoxes are cached per unique values of (angle, phase) . Another important concept is a the so called locus mapping of a gate implementation. Locus mappings define on which\\nloci, i.e. groups of components, a given implementation can be defined. They are used to relay the information which\\nloci are supported to a client application (e.g. EXA). In addition, the gate implementation itself can programmatically\\nuse this information self.builder.chip_topology . For example, a PRX can be defined on all single components that are connected to a drive line, and CZ can be defined on\\nconnected pairs of qubits. Locus mappings live in ScheduleBuilder.chip_topology which is a ChipTopology object. Locus mapping is a dict whose keys are the loci\\n( tuple[str, ...] keys denote asymmetric loci where the order of the components matter, and frozenset[str] type\\nloci denote symmetric ones), and the values are groups of components, typed tuple[str, ...] , where each locus can be\\nmapped with some additional components that are needed for the operation of the implementation. For example, some CZ\\nimplementation that tries to correct for crosstalk could map the non-locus components that see this crosstalk here.\\nThe values of the dict can be left empty or just replicate the key components in case such extra information is not\\nneeded. GateImplementations can define their locus mappings via get_custom_locus_mapping() or if a client application already\\nadds the mapping, we can just return its name via get_locus_mapping_name() .\\nIf neither of these methods are overridden in a GateImplementation class, the default behaviour will be such that an arity==1 loci will be assumed to use the mapping where all single qubits are the keys, and arity==2 loci the\\n(symmetric) mapping where the keys are all pairs of connected qubits. For other arities there is no default behaviour,\\nso it is then mandatory to define the mapping explicitly using the aforementioned methods. In order to implement most QuantumOps, one has to physically alter the state of the QPU. This is typically done by playing\\nspecified and correctly calibrated pulses via the control electronics (this applies to all typical logical gates such as\\ne.g. PRX or CZ – non-physcial metaoperations such as Barrier are an exception). In defining these pulses, there are two\\nlevels of abstractions: Waveform and Instruction . Waveform represents the physical form of the control pulse, typically normalized to the interval [-1.0, 1.0] . The\\nEach Waveform subclass can define any number of waveform parameters as class\\nattributes, which can be used to programmatically define the waveform. For example, a Gaussian could be defined in terms\\nof the average mu and spread sigma . A Waveform class then essentially contains just the parameters\\nand a recipe for computing the samples as an np.ndarray . As an example, here is how one writes the Waveform class\\nfor Gaussian : The Instructions RealPulse and IQPulse allow handling the amplitudes (via the attribute scale ) without\\nhaving to resample the waveform for every different amplitude value. However, one can always choose to include\\nthe amplitude into the sampling and then use scale=1 . The waveform parameters (like sigma in the above Gaussian) typically require calibration when the Waveform is used\\nin a quantum gate. However, the GateImplementation usually has other calibrated parameters as well defined in the\\nimplementation itself. As an example, here are the implementation-level parameters of the default PRX implementation,\\ndefined as class attribute: Note the amplitudes are defined here on this level, since the default PRX uses normalized Waveforms and factors in the\\namplitudes via scale . In these parameters, the unit is not just metadata. The control electronics understand time\\nin terms of samples and their sample rate, while human users typically want to input seconds instead of doing the sample\\nconversion manually. For this reason, there is logic that converts anything that has the unit \\"s\\" into samples.\\nSimilarly, parameters with \\"Hz\\" units are converted to 1/sample . For the Waveform parameters, the same logic\\napplies, but by default it is assumed that all parameters are time-like and this converted from seconds to samples.\\nIf some Waveform parameters needs to be made unitless or e.g. frequency-like (with \\"Hz\\" units), it can be achieved\\nwith the method non_timelike_attributes() : In the above dict, the keys should be the attribute names and values their units. To make creating new GateImplementations more comfortable, there are additional base classes on top of GateImplementation itself. CompositeGate allows quick implementation of gates in terms of other gates,\\nusing a similar syntax as with creating/scheduling several TimeBoxes together (see Using ScheduleBuilder ). At it\\nsimplest, a ComposteGate is just the _call method: Here, one could use also builder.get_implementation instead of build() , but the latter allows calibrating the member gates\\ncase specifically for this composite if they are first registered via registered_gates (in this case, there is\\njust one member, PRX). Creating new implementations for the PRX, CZ and Measure gates often means just coming up with new waveforms for the\\ncontrol pulses. If this is the case, there are helpful base classes that make those implementations into oneliners\\n(outside of defining the Waveforms themselves): PRX_CustomWaveforms , FluxPulseGate , and Measure_CustomWaveforms . Using these\\nbase classes at its simplest looks like this: All of these classes automatically include the associated Waveform parameters into the calibration parameters of\\nthe implementation itself. There is also a general base class for any gate that implements a single IQPulse (both PRX_CustomWaveForms and Measure_MyCoolWaveforms actually inherit from it), regardless of the context: CustomIQWaveforms . Gate definitions (i.e. QuantumOps) are stored in ScheduleBuilder ’s attribute op_table . When the builder is created, the op_table comes preloaded with the all the basic QuantumOps needed for\\ntypical circuit execution and their default implementations. These include e.g. the PRX gate, the CZ gate, the measure\\noperation, the conditional prx operation, the reset operation, and the barrier operation. In order to add custom operations, there is a helpful function register_implementation() that\\nin addition to adding new implementations allows one to add altogether new quantum operations. As an example here is a snippet that adds the CNOT gate, and its implementation, into an existing builder: Here, the CNOT implementation MyCNotClass needs to be of course defined first (a QuantumOp always needs at least one\\nimplementation). Note: The end user cannot modify the canonical mapping (defined in iqm-pulse) between implementation_name and implementation_class . Note that often ScheduleBuilder is created and operated by some client application, and the same application usually\\nhas its own interface for adding/manipulating QuantumOps. However, if the user has access to the builder object, the\\nabove method will always work. previous Using ScheduleBuilder next Pulse timing © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.playlist.hd_drag.evaluate_hd_drag_q_envelope","url":"/iqm-pulse/api/iqm.pulse.playlist.hd_drag.evaluate_hd_drag_q_envelope.html","description":"Evaluate Q-envelope of HD DRAG given the coefficients of the derivative terms and the cosine terms. The Q-envelope is defined as \\\\(Q(t) = \\\\sum_{n=0}^{K} \\\\beta_{2n} g^{(2n+1)}(t)\\\\) , where \\\\(K\\\\) is the...","content":"Evaluate Q-envelope of HD DRAG given the coefficients of the derivative terms and the cosine terms. The Q-envelope is defined as \\\\(Q(t) = \\\\sum_{n=0}^{K} \\\\beta_{2n} g^{(2n+1)}(t)\\\\) , where \\\\(K\\\\) is the number\\nof suppressed frequency ranges, \\\\(\\\\{beta_{2n}\\\\}\\\\) are the coefficients of the derivative terms, and \\\\(g(t)\\\\) is the basis envelope. The pulse is assumed to start at time -pulse_duration/2 ,\\nand end at time pulse_duration/2 . t_arr ( ndarray ) – Array of time points, at which the function is to be evaluated pulse_duration ( float ) – Pulse duration in the same units as t_arr derivative_coefs_arr ( ndarray ) – Coefficients of the derivatives cosine_coefs_arr ( ndarray ) – Coefficients of the cosine terms in the basis envelope Q-envelope of a HD DRAG pulse evaluated at t_arr ndarray previous iqm.pulse.playlist.hd_drag.evaluate_hd_drag_i_envelope next iqm.pulse.playlist.hd_drag.evaluate_nth_derivative_of_basis_envelope © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"SegmentPointer","url":"/iqm-pulse/api/iqm.pulse.scheduler.SegmentPointer.html","description":"Bases: object Tool for working with Segments. Serves as a time pointer inside the Segment. Module: iqm.pulse.scheduler Attributes frac time, in seconds, after the start of the current instruction rema...","content":"Bases: object Tool for working with Segments. Serves as a time pointer inside the Segment. Module: iqm.pulse.scheduler Attributes frac time, in seconds, after the start of the current instruction remainder Remaining duration of the current instruction (in seconds). source contents of the Segment idx index of the current instruction TOL time durations equal or smaller than this tolerance are considered zero (in seconds) Methods cut_tail Cut the source of the pointer at the current index. fastforward Move the pointer forward by duration seconds. get Current instruction. next Move to the beginning of the next instruction. rewind Move the pointer back by duration seconds. tail Instructions from the current index onwards. source ( list [ Instruction ] ) – idx ( int ) – TOL ( float ) – frac ( float ) – contents of the Segment index of the current instruction time durations equal or smaller than this tolerance are considered zero (in seconds) time, in seconds, after the start of the current instruction Current instruction. Instruction Remaining duration of the current instruction (in seconds). Move to the beginning of the next instruction. bool Cut the source of the pointer at the current index. Truncate source at idx , make self point to\\nthe cut tail part only. frac is not changed. Note: modifies source . None Instructions from the current index onwards. Sequence [ Instruction ] Move the pointer back by duration seconds. duration ( float ) – None Move the pointer forward by duration seconds. duration ( float ) – bool previous iqm.pulse.scheduler.extend_schedule_new next timebox © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"PRX_DRAGCosineRiseFallSX","url":"/iqm-pulse/api/iqm.pulse.gates.prx.PRX_DRAGCosineRiseFallSX.html","description":"Bases: PRX_CustomWaveformsSX PRX gate, DRAG / CosineRiseFall IQ pulse with VZ implementation. See PRX_CustomWaveformsVZ . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q cha...","content":"Bases: PRX_CustomWaveformsSX PRX gate, DRAG / CosineRiseFall IQ pulse with VZ implementation. See PRX_CustomWaveformsVZ . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). excluded_parameters Parameters names to be excluded from self.parameters . parameters Required calibration data, may be nested Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Parameters names to be excluded from self.parameters . Inheriting classes may override this if certain\\nparameters are not wanted in that class (also parameters defined by the waveforms can be excluded). Builds a single sqrt(X) pulse from the calibration data. IQPulse If set True , the Q channel waveform is considered to depend on the I channel’s waveform\\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\\nwill be initialised as True . Required calibration data, may be nested alias of CosineRiseFall alias of CosineRiseFallDerivative previous PRX_DRAGCosineRiseFall next PRX_DRAGGaussian © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.builder.build_quantum_ops","url":"/iqm-pulse/api/iqm.pulse.builder.build_quantum_ops.html","description":"Builds the table of known quantum operations. Hardcoded default native ops table is extended by the ones in ops .\\nIn case of name collisions, the content of ops takes priority over the defaults. ops (...","content":"Builds the table of known quantum operations. Hardcoded default native ops table is extended by the ones in ops .\\nIn case of name collisions, the content of ops takes priority over the defaults. ops ( dict [ str , Any ] ) – Contents of the gate_definitions section defining file. ( the quantum operations in the configuration YAML ) – function. ( Modified by the ) – Mapping from quantum operation name to its definition dict [ str , QuantumOp ] previous builder next iqm.pulse.builder.load_config © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"PRX_HdDrag","url":"/iqm-pulse/api/iqm.pulse.gates.prx.PRX_HdDrag.html","description":"Bases: PRX_CustomWaveforms PRX gate, HD DRAG IQ pulse based on amplitude scaling See PRX_CustomWaveforms . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform i...","content":"Bases: PRX_CustomWaveforms PRX gate, HD DRAG IQ pulse based on amplitude scaling See PRX_CustomWaveforms . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). parameters Required calibration data, may be nested Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – If set True , the Q channel waveform is considered to depend on the I channel’s waveform\\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\\nwill be initialised as True . Required calibration data, may be nested alias of HdDragI alias of HdDragQ previous PRX_GateImplementation next PRX_HdDragSX © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"flux_multiplexer","url":"/iqm-pulse/api/iqm.pulse.gates.flux_multiplexer.html","description":"GateImplementation for correcting flux crosstalk for a given set of flux-pulse TimeBoxes Full path: iqm.pulse.gates.flux_multiplexer Module Attributes TOLERANCE Tolerance for the maximum absolute valu...","content":"GateImplementation for correcting flux crosstalk for a given set of flux-pulse TimeBoxes Full path: iqm.pulse.gates.flux_multiplexer Module Attributes TOLERANCE Tolerance for the maximum absolute value in a waveform for considering it to be uniformly zero. Classes FluxMultiplexer_SampleLinear Linear flux pulse multiplexed (user for correcting flux crosstalk). Inheritance previous XYGate next iqm.pulse.gates.flux_multiplexer.TOLERANCE © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"MOVE_CRF_CRF","url":"/iqm-pulse/api/iqm.pulse.gates.move.MOVE_CRF_CRF.html","description":"Bases: MOVE_CustomWaveforms Qubit-resonator MOVE gate using the CRF waveform for the coupler and the qubit flux pulse. Module: iqm.pulse.gates.move Attributes parameters Required calibration data, may...","content":"Bases: MOVE_CustomWaveforms Qubit-resonator MOVE gate using the CRF waveform for the coupler and the qubit flux pulse. Module: iqm.pulse.gates.move Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of CosineRiseFall Required calibration data, may be nested alias of CosineRiseFall True iff the implementation is symmetric in its locus components.\\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous iqm.pulse.gates.move.validate_move_instructions next MOVE_CustomWaveforms © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"hd_drag","url":"/iqm-pulse/api/iqm.pulse.playlist.hd_drag.html","description":"Waveform definitions for a higher-derivative (HD) DRAG pulse based on Appendix B of [ 1 ] . Full path: iqm.pulse.playlist.hd_drag Module Attributes COSINE_COEFFICIENTS_DICT Pre-computed coefficients o...","content":"Waveform definitions for a higher-derivative (HD) DRAG pulse based on Appendix B of [ 1 ] . Full path: iqm.pulse.playlist.hd_drag Module Attributes COSINE_COEFFICIENTS_DICT Pre-computed coefficients of the cosine terms in the basis envelope (0th derivative). Functions evaluate_hd_drag_i_envelope (t_arr, ...) Evaluate I-envelope of HD DRAG given the coefficients of the derivative terms and the cosine terms. evaluate_hd_drag_q_envelope (t_arr, ...) Evaluate Q-envelope of HD DRAG given the coefficients of the derivative terms and the cosine terms. evaluate_nth_derivative_of_basis_envelope (...) Evaluate nth derivative of the basis envelope for HD DRAG based on a cosine series. solve_cosine_coefs_for_hd_drag (...) Solve cosine coefficients of the basis envelope given the number of suppressed frequencies. solve_hd_drag_coefficients_from_suppressed_frequencies (...) Solve coefficients of the derivative terms in a HD DRAG pulse given pulse duration and frequencies to suppress. Classes HdDrag Base class for higher-derivative DRAG based on Eqs. HdDragI I-component of the higher derivative (HD) drag pulse. HdDragQ Q-component of the higher derivative (HD) drag pulse. Inheritance previous SuppressedPulse next iqm.pulse.playlist.hd_drag.COSINE_COEFFICIENTS_DICT © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"Reset_Conditional","url":"/iqm-pulse/api/iqm.pulse.gates.reset.Reset_Conditional.html","description":"Bases: CompositeGate Conditional reset operation. Uses a measurement followed by a conditional PRX gate with angle \\\\(\\\\pi\\\\) .\\nIt is assumed the measurement projects the state into the computational bas...","content":"Bases: CompositeGate Conditional reset operation. Uses a measurement followed by a conditional PRX gate with angle \\\\(\\\\pi\\\\) .\\nIt is assumed the measurement projects the state into the computational basis. The conditional PRX implementation handles any necessary waits to accommodate for the feedback result propagation\\ndelay. This reset implementation is factorizable. It can act upon any set of locus components, and the measurement\\nused in the conditional reset will be multiplexed to those components. However, only locus components that have\\nreadout and drive can be reset via conditional reset. Otherwise, locus components will just have their channels\\nblocked. Module: iqm.pulse.gates.reset Attributes registered_gates Gates that can be calibrated separately from their common calibration existing in self.builder . Methods get_locus_mapping_name Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Gates that can be calibrated separately from their common calibration existing in self.builder . The gate\\nnames should correspond to the keys in self.builder.op_table . Other gates besides the ones given here can\\nalso be constructed via self.builder , but these will always use the common calibration. The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs\\nin the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. By default, it is \\"<operation_name>.<implementation_name>\\" . Inheriting classes may\\noverride this for different behaviour. operation_name ( str ) – name of the quantum operation. implementation_name ( str ) – name of the implementation name of the locus mapping str previous iqm.pulse.gates.reset.RESET_FEEDBACK_KEY next Reset_Wait © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"PRX_DRAGCosineRiseFall","url":"/iqm-pulse/api/iqm.pulse.gates.prx.PRX_DRAGCosineRiseFall.html","description":"Bases: PRX_CustomWaveforms PRX gate, DRAG / CosineRiseFall IQ pulse implementation. See PRX_CustomWaveforms . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel wavefor...","content":"Bases: PRX_CustomWaveforms PRX gate, DRAG / CosineRiseFall IQ pulse implementation. See PRX_CustomWaveforms . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). excluded_parameters Parameters names to be excluded from self.parameters . parameters Required calibration data, may be nested Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Parameters names to be excluded from self.parameters . Inheriting classes may override this if certain\\nparameters are not wanted in that class (also parameters defined by the waveforms can be excluded). Builds an x_pi pulse out of the calibration data. IQPulse If set True , the Q channel waveform is considered to depend on the I channel’s waveform\\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\\nwill be initialised as True . Required calibration data, may be nested alias of CosineRiseFall alias of CosineRiseFallDerivative previous PRX_CustomWaveformsSX next PRX_DRAGCosineRiseFallSX © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"SuppressedPulse","url":"/iqm-pulse/api/iqm.pulse.playlist.fast_drag.SuppressedPulse.html","description":"Bases: Waveform Base class for a control pulse using a series expansion to suppress certain frequencies in its envelope spectrum The base class describes control pulses, in which the coefficients of t...","content":"Bases: Waveform Base class for a control pulse using a series expansion to suppress certain frequencies in its envelope spectrum The base class describes control pulses, in which the coefficients of the basis functions\\nare chosen to suppress specific frequencies or frequency ranges in the frequency spectrum of the pulse envelope.\\nExamples include FAST DRAG and HD DRAG. The pulse argument compute_coefs_from_frequencies allows the user to choose whether the basis function\\ncoefficients are computed from suppressed_frequencies during the post-initialization of the pulse\\n(thus, overriding any pre-computed values in coefficients ), or if the (pre-computed) values in coefficients are directly used and suppressed_frequencies are neglected. The classes deriving from this base class should\\nimplement the post-initialization logic specific to the given pulse. full_width ( float ) – Full width of the pulse corresponding to the pulse duration with non-zero amplitude (in s). coefficients ( ndarray ) – Pre-computed coefficients of the series expansion. suppressed_frequencies ( ndarray ) – Frequencies to be suppressed or center frequencies of intervals to be suppressed\\n(in Hz). compute_coefs_from_frequencies ( bool ) – Boolean value indicating whether we compute the coefficients from the\\nsuppressed frequencies or whether we use the pre-computed coefficients. If True, suppressed_frequencies are used to compute and override coefficients in the post-initialization. If False, pre-computed coefficients are used, and suppressed_frequencies are ignored. n_samples ( int ) – Module: iqm.pulse.playlist.fast_drag Attributes full_width  coefficients  suppressed_frequencies  compute_coefs_from_frequencies  n_samples Requested number of samples for the waveform. Methods Scale the pulse samples to the interval (-1, 1) to avoid clipping at the instruments. samples ( ndarray ) – Array of pulse samples re-scaled Array of pulse samples ndarray previous FastDragQ next hd_drag © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.scheduler.NONSOLID","url":"/iqm-pulse/api/iqm.pulse.scheduler.NONSOLID.html","description":"Instructions that can be converted to Wait after scheduling. previous scheduler next iqm.pulse.scheduler.BLOCKING © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26....","content":"Instructions that can be converted to Wait after scheduling. previous scheduler next iqm.pulse.scheduler.BLOCKING © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"MOVE_CustomWaveforms","url":"/iqm-pulse/api/iqm.pulse.gates.move.MOVE_CustomWaveforms.html","description":"Bases: FluxPulseGate Qubit-resonator MOVE gate using flux pulses on both components. This class implements the extra phase bookkeeping logic required to make the MOVE\\ngates work as intended. Due to th...","content":"Bases: FluxPulseGate Qubit-resonator MOVE gate using flux pulses on both components. This class implements the extra phase bookkeeping logic required to make the MOVE\\ngates work as intended. Due to the unknown phase in the MOVE gate definition, the MOVEs\\nneed to be applied in pairs, i.e. the resonator state is always moved back to the qubit\\nit came from. Between this pair of MOVE gates you can apply any number of other two-component\\ngates (CZs for example) between the resonator and other qubits. This sequence of\\ngates acting on the resonator is called a MOVE sandwich . At the end of a sandwich we have\\nto apply a local phase correction (z rotation) on the state that was moved back to the qubit. The __call__() method of this class uses the MoveMarker annotation instruction\\nto mark the beginning and end of each MOVE sandwich, in order to enable the calculation of the\\nangle of the z rotation to be applied on the moved qubit at the end of the sandwich to\\ncounteract the phase accumulation during the sandwich relative to the computational frame of\\nthe qubit.\\nThe phase accumulation has two sources: Phase due to the frequency detuning between the qubit and the resonator,\\nproportional to the time duration the MOVE sandwich. Phase due to the virtual z rotations applied on the resonator as\\ngates are applied between it and another qubit, which need to be summed up.\\nBy convention the resonator VirtualRZ angle of the MOVE implementation itself is currently\\nalways zero (since only the sum of the resonator and qubit z rotation angles matters for MOVE),\\nbut we also include it in the sum for completeness. The phases are calculated and applied on the qubits using apply_move_gate_phase_corrections() . Module: iqm.pulse.gates.move Attributes coupler_wave Flux pulse Waveform to be played in the coupler flux AWG. parameters Required calibration data, may be nested qubit_wave Flux pulse Waveform to be played in the qubit flux AWG. root_parameters Include the frequency difference between qubit and resonator in the gate parameters for phase tracking. symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Include the frequency difference between qubit and resonator in the gate parameters for phase tracking. The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs\\nin the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox Flux pulse Waveform to be played in the coupler flux AWG. Required calibration data, may be nested Flux pulse Waveform to be played in the qubit flux AWG. True iff the implementation is symmetric in its locus components.\\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous MOVE_CRF_CRF next MOVE_TGSS_CRF © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.quantum_ops.validate_op_calibration","url":"/iqm-pulse/api/iqm.pulse.quantum_ops.validate_op_calibration.html","description":"Validates quantum operation calibration data against the known quantum operations. NOTE: calibration data parameters that have a defined default value are not required to be in the calibration data. c...","content":"Validates quantum operation calibration data against the known quantum operations. NOTE: calibration data parameters that have a defined default value are not required to be in the calibration data. calibration ( OpCalibrationDataTree ) – quantum operation calibration data tree to validate ops ( QuantumOpTable ) – known quantum operations and their implementations ValueError – there is something wrong with the calibration data None previous iqm.pulse.quantum_ops.validate_locus_calibration next QuantumOp © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"instructions","url":"/iqm-pulse/api/iqm.pulse.playlist.instructions.html","description":"Instructions for control instruments. Full path: iqm.pulse.playlist.instructions Classes AcquisitionMethod Describes a way to acquire readout data. Block Behave strictly as if outputting zero-valued s...","content":"Instructions for control instruments. Full path: iqm.pulse.playlist.instructions Classes AcquisitionMethod Describes a way to acquire readout data. Block Behave strictly as if outputting zero-valued samples for the duration of the instruction. ComplexIntegration Perform a weighted integration of the IQ raw signal, resulting in a complex number. ConditionalInstruction Choice between multiple Instructions, depending on a condition. FluxPulse RealPulse representing a flux pulse. IQPulse Play an upconverted pulse that contains real in-phase and quadrature waveforms. Instruction Command that can be executed by the quantum computer on a control channel. MultiplexedIQPulse Instruction to simultaneously play multiple IQ pulses. ReadoutTrigger Instruction for playing a probe pulse and acquiring the associated readout results. RealPulse Play a real-valued pulse. ThresholdStateDiscrimination Perform a weighted integration of the IQ raw signal and compare the real part of the result against a threshold value, resulting in a boolean. TimeTrace Capture the raw IQ signal without integration. VirtualRZ Change the upconversion phase reference. Wait Behave as if outputting zero-valued samples for the duration of the instruction. Inheritance previous HdDragQ next AcquisitionMethod © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"MoveMarker","url":"/iqm-pulse/api/iqm.pulse.gates.move.MoveMarker.html","description":"Bases: Wait Special annotation instruction to indicate the beginning and ending of MOVE gates. The same instance of this instruction will be inserted into the qubit drive channel and the\\nresonator vir...","content":"Bases: Wait Special annotation instruction to indicate the beginning and ending of MOVE gates. The same instance of this instruction will be inserted into the qubit drive channel and the\\nresonator virtual drive channel, right before the beginning MOVE VirtualRZ instructions,\\nto link the channels together (otherwise, there would be nothing explicit in the Schedule\\nindicating that there is a MOVE gate happening between the qubit and the resonator). Another shared instance will be inserted to the aforementioned channels right before the ending\\nMOVE VirtualRZ instruction. The VirtualRZ instructions between the markers on the resonator\\nchannel will be applied to the qubit instead in a post-compilation pass. Module: iqm.pulse.gates.move Attributes duration Time duration of the instruction. qubit  resonator  detuning  Methods duration ( int ) – qubit ( str ) – resonator ( str ) – detuning ( float ) – Time duration of the instruction. In samples at the channel sample rate. previous MOVE_TGSS_CRF next prx © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.playlist.hd_drag.COSINE_COEFFICIENTS_DICT","url":"/iqm-pulse/api/iqm.pulse.playlist.hd_drag.COSINE_COEFFICIENTS_DICT.html","description":"Pre-computed coefficients of the cosine terms in the basis envelope (0th derivative). This dictionary contains a\\nmapping from the number of suppressed frequencies to the coefficients of the cosine ter...","content":"Pre-computed coefficients of the cosine terms in the basis envelope (0th derivative). This dictionary contains a\\nmapping from the number of suppressed frequencies to the coefficients of the cosine terms computed using the\\nfunction solve_cosine_coefs_for_hd_drag . previous hd_drag next iqm.pulse.playlist.hd_drag.evaluate_hd_drag_i_envelope © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"ProbeChannelProperties","url":"/iqm-pulse/api/iqm.pulse.playlist.channel.ProbeChannelProperties.html","description":"Bases: ChannelProperties ChannelProperties for probe line channels. Module: iqm.pulse.playlist.channel Attributes center_frequency Center frequency for the channel. integration_start_dead_time Dead ti...","content":"Bases: ChannelProperties ChannelProperties for probe line channels. Module: iqm.pulse.playlist.channel Attributes center_frequency Center frequency for the channel. integration_start_dead_time Dead time samples before integration. integration_stop_dead_time Dead time samples after integration. sample_rate sample rate of the instrument responsible for the channel (in Hz) instruction_duration_granularity all instruction durations on this channel must be multiples of this granularity (in samples) instruction_duration_min all instruction durations on this channel must at least this long (in samples) compatible_instructions instruction types that are allowed on this channel Methods sample_rate ( float ) – instruction_duration_granularity ( int ) – instruction_duration_min ( int ) – compatible_instructions ( tuple [ type [ Instruction ] , ... ] ) – is_iq ( bool ) – is_virtual ( bool ) – blocks_component ( bool ) – center_frequency ( float ) – integration_start_dead_time ( int ) – integration_stop_dead_time ( int ) – Center frequency for the channel. Dead time samples before integration. Dead time samples after integration. previous IQChannelConfig next RealChannelConfig © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"visualisation","url":"/iqm-pulse/api/iqm.pulse.playlist.visualisation.html","description":"Full path: iqm.pulse.playlist.visualisation Subpackages and modules base Function for visualising playlists. previous Segment next base © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated...","content":"Full path: iqm.pulse.playlist.visualisation Subpackages and modules base Function for visualising playlists. previous Segment next base © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"ModulatedCosineRiseFall","url":"/iqm-pulse/api/iqm.pulse.playlist.waveforms.ModulatedCosineRiseFall.html","description":"Bases: Waveform Modulated Cosine Rise Fall waveform. This waveform takes the waveform CosineRiseFall and modulates it with a cosine signal\\nwhich then has parameters frequency and phase , additional to...","content":"Bases: Waveform Modulated Cosine Rise Fall waveform. This waveform takes the waveform CosineRiseFall and modulates it with a cosine signal\\nwhich then has parameters frequency and phase , additional to the parameters full_width , rise_time , and center_offset , see description of TruncatedGaussianSmoothedSquare for\\nfurther details. full_width ( float ) – Full width of the pulse, >= 2 * rise_time . rise_time ( float ) – Duration of the sinusoidal rise (and fall) part of the waveform, >= 0. modulation_frequency ( float ) – Modulation frequency. phase ( float ) – Phase of the modulation. center_offset ( float ) – The waveform is centered around this sampling window coordinate.\\nIf zero, the pulse is placed in the middle of the sampling window. n_samples ( int ) – Module: iqm.pulse.playlist.waveforms Attributes center_offset  modulation_frequency  phase  full_width  rise_time  n_samples Requested number of samples for the waveform. Methods non_timelike_attributes Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Actually samples the waveform. sample_coords ( ndarray ) – coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) ndarray Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Used to construct the parameters for the calibration data required by the waveform.\\nBy default all the waveform attributes are “timelike” (the unit for their calibration data is s).\\nHowever, some waveform attributes can be dimensionless, e.g. the relative amplitudes in a sum of\\nconsisting of multiple terms, or frequency-like (calibration data has the unit ‘Hz’).\\nIf a Waveform subclass has non-timelike attributes, it needs to redefine this method. When the Waveform is constructed, all timelike calibration data is converted to units of the\\nsampling window duration, and all frequency-like calibration data into units of inverse sampling\\nwindow duration. dict [ str , str ] previous CosineRiseFallDerivative next Slepian © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"HdDragQ","url":"/iqm-pulse/api/iqm.pulse.playlist.hd_drag.HdDragQ.html","description":"Bases: HdDrag Q-component of the higher derivative (HD) drag pulse. The Q-component is defined according to Eq. (B1) of [ 1 ] , where \\\\(\\\\{\\\\beta_{2n}\\\\}\\\\) are the coefficients, and \\\\(g(t)\\\\) is the basis...","content":"Bases: HdDrag Q-component of the higher derivative (HD) drag pulse. The Q-component is defined according to Eq. (B1) of [ 1 ] , where \\\\(\\\\{\\\\beta_{2n}\\\\}\\\\) are the coefficients, and \\\\(g(t)\\\\) is the basis envelope given by where \\\\(d_k\\\\) are pre-computed to ensure continuous derivatives up to order \\\\(2K + 1\\\\) , \\\\(t_p\\\\) denotes the pulse duration, and the pulse is defined across \\\\(t \\\\in (-t_p/2, t_p/2)\\\\) . The sampled pulse is always normalized to have a maximum value of slightly below 1.0. Module: iqm.pulse.playlist.hd_drag Attributes full_width  coefficients  suppressed_frequencies  compute_coefs_from_frequencies  n_samples Requested number of samples for the waveform. Methods n_samples ( int ) – full_width ( float ) – coefficients ( ndarray ) – suppressed_frequencies ( ndarray ) – compute_coefs_from_frequencies ( bool ) – center_offset ( float ) – Actually samples the waveform. sample_coords ( ndarray ) – coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) ndarray previous HdDragI next instructions © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"ConditionalInstruction","url":"/iqm-pulse/api/iqm.pulse.playlist.instructions.ConditionalInstruction.html","description":"Bases: Instruction Choice between multiple Instructions, depending on a condition. Module: iqm.pulse.playlist.instructions Attributes condition can be evaluated to an integer >= 0 outcomes maps possib...","content":"Bases: Instruction Choice between multiple Instructions, depending on a condition. Module: iqm.pulse.playlist.instructions Attributes condition can be evaluated to an integer >= 0 outcomes maps possible outcomes of the condition to the corresponding instructions duration Time duration of the instruction. Methods get_child_instructions Returns all the child Instructions the Instruction contains. validate Validate the instruction attributes. duration ( int ) – condition ( str ) – outcomes ( tuple [ Instruction , ... ] ) – can be evaluated to an integer >= 0 maps possible outcomes of the condition to the corresponding instructions Validate the instruction attributes. ValueError – something about the instruction is not ok Returns all the child Instructions the Instruction contains. tuple [ Instruction , …] previous ComplexIntegration next FluxPulse © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"CCPRX_Composite","url":"/iqm-pulse/api/iqm.pulse.gates.conditional.CCPRX_Composite.html","description":"Bases: CompositeGate Classically controlled PRX gate. Applies a PRX gate conditioned on a discriminated readout result obtained in the same segment (active feedback).\\nApplies a PRX gate if the result ...","content":"Bases: CompositeGate Classically controlled PRX gate. Applies a PRX gate conditioned on a discriminated readout result obtained in the same segment (active feedback).\\nApplies a PRX gate if the result is 1, and a Wait of equal duration if the result is 0.\\nUses the default implementation of PRX underneath, so no extra calibration is needed. Module: iqm.pulse.gates.conditional Attributes parameters control_delays contains the times it takes for the classical control signal from each probe line (readout instrument) to become usable for the drive AWG implementing the PRX gate. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – control_delays contains the times it takes for the classical control signal from each\\nprobe line (readout instrument) to become usable for the drive AWG implementing the PRX gate.\\nThe delays must be in the same order as the probe lines are listed in\\nthe {drive_controller}.awg.feedback_sources station setting. Two TimeBoxes that together implement the classically controlled PRX gate. The first Timebox is for the control signal delay, and the second has a ConditionalInstruction.\\nThe delay TimeBox operates only on a virtual channel and is used to block the pulse TimeBox\\nuntil there has been enough time for the control signal to arrive.\\nThe delay is specified by the control_delays gate parameter. In normal operation, the boxes can be placed sequentially without causing unnecessary delays.\\nTo care of the timing yourself, simply ignore the first TimeBox. angle ( float ) – The PRX rotation angle (rad). phase ( float ) – The PRX rotation phase (rad). feedback_qubit ( str ) – The qubit that was measured to create the feedback bit. feedback_key ( str ) – Identifies the feedback signal if feedback_qubit was measured multiple times.\\nThe feedback label is then f\\"{feedback_qubit}__{feedback_key}\\" .\\nTODO: currently the HW does not support multiple feedback keys per drive channel, so this argument has\\nno effect. The conditional prx will always listen feedback from the label f\\"{feedback_qubit}__{FEEDBACK_KEY}\\" . When the HW is improved, the actual key the user inputs\\nshould be used. A TimeBox for the signal delay, and a TimeBox with a ConditionalInstruction inside. list [ TimeBox ] previous conditional next CCPRX_Composite_DRAGCosineRiseFall © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.playlist.fast_drag.evaluate_fast_drag_q_envelope","url":"/iqm-pulse/api/iqm.pulse.playlist.fast_drag.evaluate_fast_drag_q_envelope.html","description":"Evaluate Q-envelope of FAST DRAG for given coefficients. The Q-envelope is defined as \\\\(Q(t) = \\\\sum_{n=1}^{N} c_n n (-1)^n \\\\sin(2\\\\pi n t/t_p)]\\\\) , where \\\\(N\\\\) is\\nthe number of cosine terms in the seri...","content":"Evaluate Q-envelope of FAST DRAG for given coefficients. The Q-envelope is defined as \\\\(Q(t) = \\\\sum_{n=1}^{N} c_n n (-1)^n \\\\sin(2\\\\pi n t/t_p)]\\\\) , where \\\\(N\\\\) is\\nthe number of cosine terms in the series, \\\\(\\\\{c_n\\\\}\\\\) are the coefficients, and the pulse is defined on the\\ninterval \\\\(t \\\\in [-t_p/2, t_p/2]\\\\) . t_arr ( ndarray ) – Array of time points, at which the function is to be evaluated pulse_duration ( float ) – Pulse duration in the same units as t_arr coefficients ( ndarray ) – Coefficients of a FAST DRAG pulse Q-envelope of a FAST DRAG pulse evaluated at t_arr ndarray previous iqm.pulse.playlist.fast_drag.evaluate_fast_drag_i_envelope next iqm.pulse.playlist.fast_drag.fourier_transform_of_cos_basis_functions_as_tensor © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.scheduler.BLOCKING","url":"/iqm-pulse/api/iqm.pulse.scheduler.BLOCKING.html","description":"Nonsolid Instructions that nevertheless block. previous iqm.pulse.scheduler.NONSOLID next iqm.pulse.scheduler.extend_hard_boundary © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2...","content":"Nonsolid Instructions that nevertheless block. previous iqm.pulse.scheduler.NONSOLID next iqm.pulse.scheduler.extend_hard_boundary © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"PRX_GateImplementation","url":"/iqm-pulse/api/iqm.pulse.gates.prx.PRX_GateImplementation.html","description":"Bases: GateImplementation ABC for different implementations of the PRX gate. Module: iqm.pulse.gates.prx Attributes Methods clifford One-qubit XY Clifford gates. get_locus_mapping_name Get the name of...","content":"Bases: GateImplementation ABC for different implementations of the PRX gate. Module: iqm.pulse.gates.prx Attributes Methods clifford One-qubit XY Clifford gates. get_locus_mapping_name Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. rx X rotation gate. ry Y rotation gate. parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Phased x rotation gate. angle ( float ) – rotation angle (in radians) phase ( float ) – phase angle (in radians) boxed instruction schedule implementing the phased x rotation gate TimeBox X rotation gate. angle ( float ) – rotation angle (in radians) boxed instruction schedule implementing the x rotation gate TimeBox Y rotation gate. angle ( float ) – rotation angle (in radians) boxed instruction schedule implementing the y rotation gate TimeBox One-qubit XY Clifford gates. xy_gate ( XYGate ) – Clifford gate boxed instruction schedule implementing the requested Clifford gate TimeBox Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. By default, it is \\"<operation_name>.<implementation_name>\\" . Inheriting classes may\\noverride this for different behaviour. operation_name ( str ) – name of the quantum operation. implementation_name ( str ) – name of the implementation name of the locus mapping str previous PRX_FastDragSX next PRX_HdDrag © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.playlist.hd_drag.evaluate_nth_derivative_of_basis_envelope","url":"/iqm-pulse/api/iqm.pulse.playlist.hd_drag.evaluate_nth_derivative_of_basis_envelope.html","description":"Evaluate nth derivative of the basis envelope for HD DRAG based on a cosine series. The basis envelope is given by \\\\(g(t) = \\\\sum_{k=1}^{K+1} d_k (1 - \\\\cos(2\\\\pi k t/t_p + k\\\\pi))\\\\) , where the\\npulse is ...","content":"Evaluate nth derivative of the basis envelope for HD DRAG based on a cosine series. The basis envelope is given by \\\\(g(t) = \\\\sum_{k=1}^{K+1} d_k (1 - \\\\cos(2\\\\pi k t/t_p + k\\\\pi))\\\\) , where the\\npulse is defined on the interval \\\\(t \\\\in [-t_p/2, t_p/2]\\\\) . The returned derivatives are normalized\\nvia multiplication by \\\\(((t_p/(2\\\\pi))^n\\\\) , where \\\\(n\\\\) is the order of the derivative. t_arr ( ndarray ) – Array of time points, at which the function is to be evaluated pulse_duration ( float ) – Pulse duration in the same units as t_arr cosine_coefs_arr ( ndarray ) – Coefficients of the cosine terms in the basis envelope n ( int ) – order of derivative Array containing the nth derivative of the basis envelope evaluated at t_arr ndarray previous iqm.pulse.playlist.hd_drag.evaluate_hd_drag_q_envelope next iqm.pulse.playlist.hd_drag.solve_cosine_coefs_for_hd_drag © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"MultiplexedProbeTimeBox","url":"/iqm-pulse/api/iqm.pulse.timebox.MultiplexedProbeTimeBox.html","description":"Bases: TimeBox A TimeBox that contains any number of multiplexed readout pulses for probe channels. A MultiplexedProbeTimeBox ’s atom contains exactly one ReadoutTrigger for each probe channel. Module...","content":"Bases: TimeBox A TimeBox that contains any number of multiplexed readout pulses for probe channels. A MultiplexedProbeTimeBox ’s atom contains exactly one ReadoutTrigger for each probe channel. Module: iqm.pulse.timebox Attributes label Description the contents of the box for users' convenience. locus_components Names of the QPU components on which this timebox operates. atom Resolved contents of the TimeBox, or None if not resolved. children Further Timeboxes inside this TimeBox. neighborhood_components Dict of neighborhood range integers mapped to sets of components neighboring the locus of this TimeBox . Methods from_readout_trigger Build an atomic MultiplexedProbeTimeBox\` from a single \`\`ReadoutTrigger instruction. label ( str ) – locus_components ( set [ str ] ) – atom ( Schedule | None ) – children ( tuple [ TimeBox , ... ] ) – scheduling ( SchedulingStrategy ) – scheduling_algorithm ( SchedulingAlgorithm ) – neighborhood_components ( dict [ int , set [ str ] ] ) – Build an atomic MultiplexedProbeTimeBox\` from a single \`\`ReadoutTrigger instruction. readout_trigger ( ReadoutTrigger ) – Readout trigger instruction. probe_channel ( str ) – Name of the probe channel to play readout_trigger in. locus_components ( Iterable [ str ] ) – Locus components. label ( str ) – Label of the new timebox. block_channels ( Iterable [ str ] ) – Names of channels to block. block_duration ( int ) – Duration of the required blocking (in samples). atomic timebox containing readout_trigger in the channel probe_channel . MultiplexedProbeTimeBox previous timebox next SchedulingAlgorithm © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"RZ_Virtual","url":"/iqm-pulse/api/iqm.pulse.gates.rz.RZ_Virtual.html","description":"Bases: GateImplementation Implementation of the RZ gate using the virtual z rotation technique. Implements the RZ gate on a specific qubit using a VirtualRZ instruction, which\\nsimply changes the phase...","content":"Bases: GateImplementation Implementation of the RZ gate using the virtual z rotation technique. Implements the RZ gate on a specific qubit using a VirtualRZ instruction, which\\nsimply changes the phase of the local oscillator driving that qubit.\\nThis requires no calibration data as of now.\\nThe generated VirtualRZ instruction has the shortest possible duration allowed by the instruments. The virtual z rotation method is based on algebraically commuting the RZ gates towards the end\\nof the circuit, until they hit a measurement operation, at which point they are eliminated. It assumes that all the multi-qubit gates in the circuit commute with arbitrary RZ gates (this holds e.g. for CZ\\nsince it is diagonal), measurements are projective and happen in the z basis, so that RZ gates that immediately\\nprecede them do not affect the measurement result or the state after the measurement, and thus\\ncan be removed, and conjugating the single-qubit gates in the circuit with RZ is equivalent to incrementing the phase of the drive\\n(holds for PRX ), which can be accomplished either by incrementing the phase of\\nthe local oscillator of the drive channel, or incrementing the phases of all the IQPulse s\\nfollowing it on the drive channel. If all these assumptions hold we may implement an RZ gate using a VirtualRZ instruction,\\nwith phase_increment equal to the negated rotation angle. channel – name of the drive channel on which the VirtualRZ acts duration – time duration of the VirtualRZ instruction, in seconds parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Module: iqm.pulse.gates.rz Attributes parameters Required calibration data, may be nested Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). get_locus_mapping_name Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. Z rotation gate. angle ( float ) – rotation angle (in radians) pulse schedule implementing the z rotation gate TimeBox Required calibration data, may be nested Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.\\nSubclasses can reimplement this method in case it makes sense in their context. float Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. By default, it is \\"<operation_name>.<implementation_name>\\" . Inheriting classes may\\noverride this for different behaviour. operation_name ( str ) – name of the quantum operation. implementation_name ( str ) – name of the implementation name of the locus mapping str previous RZ_PRX_Composite next sx © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"PRX_CustomWaveforms","url":"/iqm-pulse/api/iqm.pulse.gates.prx.PRX_CustomWaveforms.html","description":"Bases: PRX_SinglePulse_GateImplementation , CustomIQWaveforms ABC for PRX gates implemented using a single IQ pulse and hot-swappable waveforms. Module: iqm.pulse.gates.prx Attributes dependent_waves ...","content":"Bases: PRX_SinglePulse_GateImplementation , CustomIQWaveforms ABC for PRX gates implemented using a single IQ pulse and hot-swappable waveforms. Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). root_parameters Parameters independent of the of Waveforms. wave_i Waveform for the I channel. wave_q Waveform for the Q channel. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Parameters independent of the of Waveforms. Inheriting classes may override this to include parameters common\\nto all such implementations. Builds an x_pi pulse out of the calibration data. amplitude_i ( float ) – amplitude_q ( float ) – n_samples ( int ) – IQPulse If set True , the Q channel waveform is considered to depend on the I channel’s waveform\\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\\nwill be initialised as True . previous Constant_PRX_with_smooth_rise_fall next PRX_CustomWaveformsSX © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"HdDragI","url":"/iqm-pulse/api/iqm.pulse.playlist.hd_drag.HdDragI.html","description":"Bases: HdDrag I-component of the higher derivative (HD) drag pulse. The I-component is defined according to Eq. (B1) of [ 1 ] , where \\\\(\\\\{\\\\beta_{2n}\\\\}_{n=0}^K\\\\) are the coefficients of the derivative ...","content":"Bases: HdDrag I-component of the higher derivative (HD) drag pulse. The I-component is defined according to Eq. (B1) of [ 1 ] , where \\\\(\\\\{\\\\beta_{2n}\\\\}_{n=0}^K\\\\) are the coefficients of the derivative terms, \\\\(K\\\\) is the number of\\nsuppressed frequencies, and \\\\(g(t)\\\\) is the basis envelope given by where \\\\(d_k\\\\) are pre-computed to ensure continuous derivatives up to order \\\\(2K + 1\\\\) , \\\\(t_p\\\\) denotes the pulse duration, and the pulse is defined across \\\\(t \\\\in (-t_p/2, t_p/2)\\\\) . The sampled pulse is always normalized to have a maximum value slightly below 1.0. Module: iqm.pulse.playlist.hd_drag Attributes full_width  coefficients  suppressed_frequencies  compute_coefs_from_frequencies  n_samples Requested number of samples for the waveform. Methods n_samples ( int ) – full_width ( float ) – coefficients ( ndarray ) – suppressed_frequencies ( ndarray ) – compute_coefs_from_frequencies ( bool ) – center_offset ( float ) – Actually samples the waveform. sample_coords ( ndarray ) – coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) ndarray previous HdDrag next HdDragQ © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"MultiplexedIQPulse","url":"/iqm-pulse/api/iqm.pulse.playlist.instructions.MultiplexedIQPulse.html","description":"Bases: Instruction Instruction to simultaneously play multiple IQ pulses. Each component pulse can have an arbitrary delay from the beginning of this instruction.\\nOutside the interval of the Multiplex...","content":"Bases: Instruction Instruction to simultaneously play multiple IQ pulses. Each component pulse can have an arbitrary delay from the beginning of this instruction.\\nOutside the interval of the MultiplexedIQPulse, the component pulses are truncated.\\nWhere overlapping, samples of component pulse entries are summed.\\nWhere the interval of a MultiplexedIQPulse does not overlap with any of its component pulses,\\nits samples are zeroes. Module: iqm.pulse.playlist.instructions Attributes entries ( pulse , offset ) pairs. duration Time duration of the instruction. Methods duration ( int ) – entries ( tuple [ tuple [ IQPulse , int ] , ... ] ) – ( pulse , offset ) pairs. offset is the number of samples pulse is delayed from the beginning of the instruction.\\nIt has no granularity constraints. Negative values are allowed, but beginning will be truncated. previous Instruction next ReadoutTrigger © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"gates","url":"/iqm-pulse/api/iqm.pulse.gates.html","description":"Implementations of quantum gates. The GateImplementation subclasses in this subpackage construct TimeBox instances to\\nimplement specific native gates, using the calibration data that the class has bee...","content":"Implementations of quantum gates. The GateImplementation subclasses in this subpackage construct TimeBox instances to\\nimplement specific native gates, using the calibration data that the class has been initialized with.\\nEach GateImplementation instance encapsulates the calibration data for a specific implementation of a specific\\nnative gate acting on a specific locus. Several different implementations and calibration schemes can be supported for a given gate,\\neach represented by its own GateImplementation subclass.\\nLikewise, a single GateImplementation subclass can be sometimes used to implement several different gates\\nthrough different calibration data. Full path: iqm.pulse.gates Functions expose_implementation (implementation[, ...]) Add the given gate implementation to the list of known implementations. get_implementation_class (class_name) Get gate implementation class by class name. register_implementation (operations, ...[, ...]) Register a new gate implementation, and a new gate (operation) if needed. Subpackages and modules barrier Barrier metaoperation. conditional Classically controlled gates. cz Two-qubit controlled-Z (CZ) gate. default_gates This file defines the default quantum gates and operations for IQM's pulse control system delay Force a delay between instructions on the control channels of specific locus components. enums Enumerations for representing a set of important one- and two-qubit gates. flux_multiplexer GateImplementation for correcting flux crosstalk for a given set of flux-pulse TimeBoxes measure Projective measurement in the Z basis. move Two-qubit MOVE gate. prx Single-qubit PRX gate. reset Resetting qubits to the zero state. rz Single-qubit RZ gate. sx Single-qubit sqrt(X) gate. u Single-qubit SU(2) gate. previous SinglePulseGate next iqm.pulse.gates.expose_implementation © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"u","url":"/iqm-pulse/api/iqm.pulse.gates.u.html","description":"Single-qubit SU(2) gate. The SU(2) matrix in the computational basis is parametrized using Euler angles: where the angles \\\\(\\\\theta\\\\) , \\\\(\\\\phi\\\\) and \\\\(\\\\lambda\\\\) are in radians. They are the angles of s...","content":"Single-qubit SU(2) gate. The SU(2) matrix in the computational basis is parametrized using Euler angles: where the angles \\\\(\\\\theta\\\\) , \\\\(\\\\phi\\\\) and \\\\(\\\\lambda\\\\) are in radians. They are the angles of subsequent\\nZ, Y and Z Euler rotations: It rotates the qubit state around an arbitrary axis on the Bloch sphere. Some common single-qubit gates expressed as U gates: References https://openqasm.com/language/gates.html#built-in-gates Full path: iqm.pulse.gates.u Functions get_unitary_u (theta, phi, lam) Unitary for an SU(2) gate. Classes UGate SU(2) gate implemented using PRX. Inheritance previous SXGate next iqm.pulse.gates.u.get_unitary_u © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.gate_implementation.OCalibrationData","url":"/iqm-pulse/api/iqm.pulse.gate_implementation.OCalibrationData.html","description":"For a particular quantum operation, maps implementation names to their calibration data. alias of dict [ str , dict [ tuple [ str , …] | None , dict [ str , Any ]]] previous iqm.pulse.gate_implementat...","content":"For a particular quantum operation, maps implementation names to their calibration data. alias of dict [ str , dict [ tuple [ str , …] | None , dict [ str , Any ]]] previous iqm.pulse.gate_implementation.OICalibrationData next iqm.pulse.gate_implementation.OpCalibrationDataTree © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.gate_implementation.OpCalibrationDataTree","url":"/iqm-pulse/api/iqm.pulse.gate_implementation.OpCalibrationDataTree.html","description":"Maps quantum operation names to their calibration data. alias of dict [ str , dict [ str , dict [ tuple [ str , …] | None , dict [ str , Any ]]]] previous iqm.pulse.gate_implementation.OCalibrationDat...","content":"Maps quantum operation names to their calibration data. alias of dict [ str , dict [ str , dict [ tuple [ str , …] | None , dict [ str , Any ]]]] previous iqm.pulse.gate_implementation.OCalibrationData next iqm.pulse.gate_implementation.NestedParams © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"SchedulingAlgorithm","url":"/iqm-pulse/api/iqm.pulse.timebox.SchedulingAlgorithm.html","description":"Bases: Enum Algorithms for resolving composite TimeBoxes into atomic ones. Module: iqm.pulse.timebox Attributes HARD_BOUNDARY Respects the TimeBox boundary such that the longest channel with a box def...","content":"Bases: Enum Algorithms for resolving composite TimeBoxes into atomic ones. Module: iqm.pulse.timebox Attributes HARD_BOUNDARY Respects the TimeBox boundary such that the longest channel with a box defines its boundary and all other channels are padded to this length (using the specified SchedulingStrategy ). TETRIS Will pack the schedule as tightly as possible while respecting the defined scheduling neighborhood. Methods Respects the TimeBox boundary such that the longest channel with a box defines\\nits boundary and all other channels are padded to this length (using the specified SchedulingStrategy ). Will pack the schedule as tightly as possible while respecting the defined scheduling neighborhood. previous MultiplexedProbeTimeBox next SchedulingStrategy © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"delay","url":"/iqm-pulse/api/iqm.pulse.gates.delay.html","description":"Force a delay between instructions on the control channels of specific locus components. Ideally the delay corresponds to an identity gate. In reality it of course allows decoherence\\nto act on the qua...","content":"Force a delay between instructions on the control channels of specific locus components. Ideally the delay corresponds to an identity gate. In reality it of course allows decoherence\\nto act on the quantum state for some time. Full path: iqm.pulse.gates.delay Module Attributes DELAY_MAX_DURATION_SECONDS Maximum duration for individual Delay operations, in seconds. Classes Delay Applies a delay on the control channels of its locus components. Inheritance previous default_gates next iqm.pulse.gates.delay.DELAY_MAX_DURATION_SECONDS © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.gates.reset.RESET_MEASUREMENT_KEY","url":"/iqm-pulse/api/iqm.pulse.gates.reset.RESET_MEASUREMENT_KEY.html","description":"Constant measurement key for the measure operation required in the fast-feedback reset gate (the double underscore\\nemphasizes the fact that this label should not be manually used in fast feedback). pr...","content":"Constant measurement key for the measure operation required in the fast-feedback reset gate (the double underscore\\nemphasizes the fact that this label should not be manually used in fast feedback). previous reset next iqm.pulse.gates.reset.RESET_FEEDBACK_KEY © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"scheduler","url":"/iqm-pulse/api/iqm.pulse.scheduler.html","description":"Tools for composing instruction schedules in time. Under the idealized, noiseless, crosstalk-less computational model, the scheduling algorithms\\nshould preserve the effect of the schedules on the comp...","content":"Tools for composing instruction schedules in time. Under the idealized, noiseless, crosstalk-less computational model, the scheduling algorithms\\nshould preserve the effect of the schedules on the computational subspace, i.e.\\nexecuting Schedule A immediately followed by B should be equivalent to\\nexecuting the composed schedule A+B . The composing is always done so that in A+B all the channels of B start\\ntheir execution simultaneously, and remain in sync. Nothing instructions can be added\\nas spacers between the channels of A and B as necessary to make this happen. Typically the scheduling algorithms also try to minimize the total duration of the composed schedule. Full path: iqm.pulse.scheduler Module Attributes NONSOLID Instructions that can be converted to Wait after scheduling. BLOCKING Nonsolid Instructions that nevertheless block. Functions extend_hard_boundary (schedule, ...) Merge two Schedules together such that the timebox boundary is respected. extend_hard_boundary_in_seconds (schedule, ...) The same as extend_hard_boundary , but the scheduling is done in seconds. extend_schedule (A, B, channels, *[, TOL]) Extend a Schedule with another Schedule. extend_schedule_new (A, B, channels, *[, TOL]) Extend a Schedule with another Schedule. Classes SegmentPointer Tool for working with Segments. Inheritance previous QuantumOp next iqm.pulse.scheduler.NONSOLID © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"ChirpImag","url":"/iqm-pulse/api/iqm.pulse.playlist.waveforms.ChirpImag.html","description":"Bases: Chirp Imaginary part of the linear chirp, which sets the phase to $-pi/2$. n_samples ( int ) – freq_start ( float ) – freq_stop ( float ) – alpha ( float ) – phase ( float ) – Phase of the puls...","content":"Bases: Chirp Imaginary part of the linear chirp, which sets the phase to $-pi/2$. n_samples ( int ) – freq_start ( float ) – freq_stop ( float ) – alpha ( float ) – phase ( float ) – Phase of the pulse. Defaults to $pi/2$ float Module: iqm.pulse.playlist.waveforms Attributes phase  freq_start  freq_stop  n_samples Requested number of samples for the waveform. Methods previous Chirp next Cosine © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"CZ_CRF_ACStarkCRF","url":"/iqm-pulse/api/iqm.pulse.gates.cz.CZ_CRF_ACStarkCRF.html","description":"Bases: CouplerFluxPulseQubitACStarkPulseGate Controlled-Z two-qubit gate. CZ gate implemented using a cosine rise fall flux pulse for the coupler and a modulated\\ncosine rise fall (CRF) AC Stark pulse ...","content":"Bases: CouplerFluxPulseQubitACStarkPulseGate Controlled-Z two-qubit gate. CZ gate implemented using a cosine rise fall flux pulse for the coupler and a modulated\\ncosine rise fall (CRF) AC Stark pulse on one qubit. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of CosineRiseFall Required calibration data, may be nested alias of ModulatedCosineRiseFall True iff the implementation is symmetric in its locus components.\\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous CZ_CRF next CZ_GaussianSmoothedSquare © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.gates.prx.get_unitary_prx","url":"/iqm-pulse/api/iqm.pulse.gates.prx.get_unitary_prx.html","description":"Unitary for a PRX gate. angle ( float ) – rotation angle (in rad) phase ( float ) – phase angle (in rad) 2x2 unitary representing prx(angle, phase) . ndarray previous prx next ABC_Constant_smooth © Co...","content":"Unitary for a PRX gate. angle ( float ) – rotation angle (in rad) phase ( float ) – phase angle (in rad) 2x2 unitary representing prx(angle, phase) . ndarray previous prx next ABC_Constant_smooth © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.base_utils.merge_dicts","url":"/iqm-pulse/api/iqm.pulse.base_utils.merge_dicts.html","description":"Merge two dictionaries recursively, leaving the originals unchanged. A ( dict ) – dictionary B ( dict ) – another dictionary merge_nones ( bool ) – whether to also merge None and empty Sized values fr...","content":"Merge two dictionaries recursively, leaving the originals unchanged. A ( dict ) – dictionary B ( dict ) – another dictionary merge_nones ( bool ) – whether to also merge None and empty Sized values from B to A. copy of A, with the contents of B merged in (and taking precedence) recursively dict previous base_utils next builder © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.gate_implementation.OICalibrationData","url":"/iqm-pulse/api/iqm.pulse.gate_implementation.OICalibrationData.html","description":"For a particular implementation of a particular quantum operation, maps operation loci to their calibration data. alias of dict [ tuple [ str , …] | None , dict [ str , Any ]] previous iqm.pulse.gate_...","content":"For a particular implementation of a particular quantum operation, maps operation loci to their calibration data. alias of dict [ tuple [ str , …] | None , dict [ str , Any ]] previous iqm.pulse.gate_implementation.OILCalibrationData next iqm.pulse.gate_implementation.OCalibrationData © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"Slepian","url":"/iqm-pulse/api/iqm.pulse.playlist.waveforms.Slepian.html","description":"Bases: Waveform Slepian waveform, which minimizes non-adiabatic errors during a gate. It is assumed that the user has done the minimization in a prior step, such that the optimal \\\\(\\\\lambda_n\\\\) for\\na s...","content":"Bases: Waveform Slepian waveform, which minimizes non-adiabatic errors during a gate. It is assumed that the user has done the minimization in a prior step, such that the optimal \\\\(\\\\lambda_n\\\\) for\\na specific length \\\\(\\\\tau_\\\\text{pulse}\\\\) (in the accelerated frame) is known. This class then reconstructs the\\nwaveform with the following steps: Calculate \\\\(\\\\theta(\\\\tau)\\\\) (Slepian in the accelerated frame and in \\\\(\\\\theta\\\\) space) Calculate \\\\(t(\\\\tau)\\\\) (mapping time in the accelerated frame to time in the lab frame) Interpolate \\\\(\\\\theta(t)\\\\) (Slepian in the lab frame and in \\\\(\\\\theta\\\\) space) Calculate \\\\(f(t)\\\\) (Slepian in the lab frame and in frequency space) Calculate \\\\(V(t)\\\\) (Slepian in the lab frame and in voltage space) Since the waveform is normalized, any voltage pre-factor should go into the pulse amplitude. The user is advised to look up [ 2 ] for further details, since the derivation is mathematically\\nheavy. full_width ( float ) – Duration of the support of the waveform. lambda_1 ( float ) – First coefficient of Slepian waveform. lambda_2 ( float ) – Second coefficient of Slepian waveform. frequency_initial_normalized ( float ) – Initial frequency of the pulsed component (usually coupler),\\nnormalized by the maximum frequency of the pulsed component. frequency_to_minimize_normalized ( float ) – Frequency of the static component (usually qubit) which to\\nminimize the leakage from/to, normalized by the maximum frequency of the pulsed component. coupling_strength_normalized ( float ) – Coupling strength between pulsed component and static component,\\nnormalized by the maximum frequency of the pulsed component. center_offset ( float ) – The waveform is centered at this offset from the midpoint of the sampling window. squid_asymmetry ( float ) – Squid asymmetry. n_samples ( int ) – Module: iqm.pulse.playlist.waveforms Attributes center_offset  squid_asymmetry  full_width  lambda_1  lambda_2  frequency_initial_normalized  frequency_to_minimize_normalized  coupling_strength_normalized  n_samples Requested number of samples for the waveform. Methods non_timelike_attributes Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Used to construct the parameters for the calibration data required by the waveform.\\nBy default all the waveform attributes are “timelike” (the unit for their calibration data is s).\\nHowever, some waveform attributes can be dimensionless, e.g. the relative amplitudes in a sum of\\nconsisting of multiple terms, or frequency-like (calibration data has the unit ‘Hz’).\\nIf a Waveform subclass has non-timelike attributes, it needs to redefine this method. When the Waveform is constructed, all timelike calibration data is converted to units of the\\nsampling window duration, and all frequency-like calibration data into units of inverse sampling\\nwindow duration. dict [ str , str ] Actually samples the waveform. sample_coords ( ndarray ) – coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) ndarray Calculate the samples of the actual Slepian waveform. coords ( ndarray ) – normalized sample coordinates, in \\\\([0, 1]\\\\) samples of the Slepian waveform ndarray Convert time in the accelerated frame to the lab frame (real time). Since the conversion is defined via an integral, finding an analytical solution was not possible. Therefore, we\\nintegrate the expression numerically with scipy.integrate.romb() . tau ( float | ndarray ) – Time in the accelerated frame. num_samples ( int ) – Number of samples for the numerical integration. Must be of the form 2 ** k + 1. tau converted to the lab frame ndarray Parametrization of the Slepian waveform in the accelerated frame. The Slepian waveform is parametrized using Fourier base functions, where we only take the cosine terms into\\naccount ( [ 2 ] has shown that this is a reasonable assumption).\\nHere, \\\\(\\\\lambda_n\\\\) is the amplitude of the \\\\(n\\\\) -th term of the Fourier base function.\\nIt is usually sufficient to take only up to second order terms into account, i.e. only \\\\(\\\\lambda_1\\\\) and \\\\(\\\\lambda_2\\\\) are non-zero. tau ( ndarray ) – Time in the accelerated frame, normalized to [0, 1] with tau_pulse. Slepian waveform in the theta space and accelerated frame. ndarray previous ModulatedCosineRiseFall next quantum_ops © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.gates.expose_implementation","url":"/iqm-pulse/api/iqm.pulse.gates.expose_implementation.html","description":"Add the given gate implementation to the list of known implementations. implementation ( type [ GateImplementation ] ) – GateImplementation to add so that it can be found with get_implementation_class...","content":"Add the given gate implementation to the list of known implementations. implementation ( type [ GateImplementation ] ) – GateImplementation to add so that it can be found with get_implementation_class() . overwrite ( bool ) – If True, does not raise an error if implementation already exists. None previous gates next iqm.pulse.gates.get_implementation_class © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"SchedulingStrategy","url":"/iqm-pulse/api/iqm.pulse.timebox.SchedulingStrategy.html","description":"Bases: Enum Different scheduling strategies for the contents of composite TimeBoxes. Module: iqm.pulse.timebox Attributes ASAP TimeBox contents are scheduled as soon as possible within the box. ALAP T...","content":"Bases: Enum Different scheduling strategies for the contents of composite TimeBoxes. Module: iqm.pulse.timebox Attributes ASAP TimeBox contents are scheduled as soon as possible within the box. ALAP TimeBox contents are scheduled as late as possible within the box. Methods TimeBox contents are scheduled as soon as possible within the box. TimeBox contents are scheduled as late as possible within the box. previous SchedulingAlgorithm next TimeBox © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"CZ_Slepian_ACStarkCRF","url":"/iqm-pulse/api/iqm.pulse.gates.cz.CZ_Slepian_ACStarkCRF.html","description":"Bases: CouplerFluxPulseQubitACStarkPulseGate Controlled-Z two-qubit gate. CZ gate implemented using a slepian flux pulse for the coupler and a modulated cosine rise fall (CRF) AC Stark\\npulse on one qu...","content":"Bases: CouplerFluxPulseQubitACStarkPulseGate Controlled-Z two-qubit gate. CZ gate implemented using a slepian flux pulse for the coupler and a modulated cosine rise fall (CRF) AC Stark\\npulse on one qubit. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of Slepian Required calibration data, may be nested alias of ModulatedCosineRiseFall True iff the implementation is symmetric in its locus components.\\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous CZ_Slepian next CZ_Slepian_CRF © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"CustomIQWaveforms","url":"/iqm-pulse/api/iqm.pulse.gate_implementation.CustomIQWaveforms.html","description":"Bases: GateImplementation Base class for GateImplementations using custom waveform definition with IQPulses. The class contains logic for automatic gate calibration parameters handling for such gates ...","content":"Bases: GateImplementation Base class for GateImplementations using custom waveform definition with IQPulses. The class contains logic for automatic gate calibration parameters handling for such gates (see the class\\nattributes for more info). With given Waveform waveform definitions Something and SomethingElse ,\\nan inheriting class may define the waveforms for the I and Q channels like this: class MyGate(CustomIQWaveforms, i_wave=Something, q_wave=SomethingElse) . Module: iqm.pulse.gate_implementation Attributes excluded_parameters Parameters names to be excluded from self.parameters . root_parameters Parameters independent of the of Waveforms. wave_i Waveform for the I channel. wave_q Waveform for the Q channel. dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Waveform for the I channel. Waveform for the Q channel. If set True , the Q channel waveform is considered to depend on the I channel’s waveform\\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\\nwill be initialised as True . Parameters independent of the of Waveforms. Inheriting classes may override this to include parameters common\\nto all such implementations. Parameters names to be excluded from self.parameters . Inheriting classes may override this if certain\\nparameters are not wanted in that class (also parameters defined by the waveforms can be excluded). previous CompositeGate next GateImplementation © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"CompositeGate","url":"/iqm-pulse/api/iqm.pulse.gate_implementation.CompositeGate.html","description":"Bases: GateImplementation Utility base class for creating gate implementations that are defined in terms of other gate implementations. Gates can be implemented using other pre-existing gate implement...","content":"Bases: GateImplementation Utility base class for creating gate implementations that are defined in terms of other gate implementations. Gates can be implemented using other pre-existing gate implementations by just utilizing the ScheduleBuilder in builder in the __call__() method (e.g. by calling self.builder.get_implementation(<some gate>, <some locus>) . In this way, any such “member gates” will use\\nthe common calibration that exists in builder . In order for a composite gate\\nimplementation to be able to calibrate its member gates with different calibration values from the common\\ncalibration, it needs to know what gates it considers as its “members”. This is what the CompositeGate ABC is for. Inheriting from this class and defining e.g. registered_gates = [\\"prx\\", \\"cz\\"] allows one to calibrate the\\nmember operations (i.e. \\"prx\\" and \\"cz\\" in this example) inside this composite gate differently from the\\ncommon calibration. However, if no specific calibration data is provided, the gate implementation will be calibrated\\nwith the common calibration. Module: iqm.pulse.gate_implementation Attributes default_implementations Mapping from operation names to the designated default implementation of that operation. registered_gates Gates that can be calibrated separately from their common calibration existing in self.builder . Methods build Construct a member gate implementation. parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Gates that can be calibrated separately from their common calibration existing in self.builder . The gate\\nnames should correspond to the keys in self.builder.op_table . Other gates besides the ones given here can\\nalso be constructed via self.builder , but these will always use the common calibration. Mapping from operation names to the designated default implementation of that operation. Filling this attribute\\nallows one to define a different default implementation from the common default in self.builder.op_table to\\nbe used in he context of this composite gate. If an operation is not found in this dict as a key, this\\nCompositeGate will use the common default as the default implementation for it. Construct a member gate implementation. If the gate op_name is registered, a specific calibration for it in the context of this CompositeGate\\nwill be sought for from self.builder.calibration . If any (non-empty) calibration values are found in self.builder.calibration[self.name][op_name][<impl_name>] they will be merged to the common calibration\\n(only non-empty values will be merged). If there are no values found, the\\ncommon calibration will be used. op_name ( str ) – operation name locus ( tuple [ str , ... ] ) – locus the operation acts on impl_name ( str | None ) – Implementation name. If not given, uses the default implementation defined in the class instance\\nif any, and otherwise the common default in self.builder.op_table strict_locus ( bool ) – iff False, for non-symmetric implementations of symmetric ops the locus order may\\nbe changed if no calibration data is available for the requested locus order Calibrated gate implementation. GateImplementation previous CompositeCache next CustomIQWaveforms © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"utils","url":"/iqm-pulse/api/iqm.pulse.utils.html","description":"Utility functions. Full path: iqm.pulse.utils Functions map_waveform_param_types (type_hint) Map a python typehint into EXA Parameter's (DataType, CollectionType) tuple. normalize_angle (angle) Normal...","content":"Utility functions. Full path: iqm.pulse.utils Functions map_waveform_param_types (type_hint) Map a python typehint into EXA Parameter's (DataType, CollectionType) tuple. normalize_angle (angle) Normalize the given angle to (-pi, pi]. phase_transformation ([psi_1, psi_2]) Implement an arbitrary (RZ, PRX, RZ) gate sequence by modifying the parameters of the IQ pulse implementing the PRX. previous TimeBox next iqm.pulse.utils.map_waveform_param_types © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.playlist.channel.round_duration_to_granularity_samples","url":"/iqm-pulse/api/iqm.pulse.playlist.channel.round_duration_to_granularity_samples.html","description":"Round a time duration to the least common multiple of the granularities of the given channels. Note Assumes that all the given control channels have the same sample rate. channels ( Iterable [ Channel...","content":"Round a time duration to the least common multiple of the granularities of the given channels. Note Assumes that all the given control channels have the same sample rate. channels ( Iterable [ ChannelProperties ] ) – all these channels must be able to handle the rounded duration duration ( float ) – time duration in s round_up ( bool ) – whether to round the duration up, or to the closest granularity force_min_duration ( bool ) – whether to force the duration to be at least the largest instruction_duration_min of channels duration rounded to common channel granularity, in samples int previous iqm.pulse.playlist.channel.get_channel_properties_from_station_settings next ChannelConfiguration © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"playlist","url":"/iqm-pulse/api/iqm.pulse.playlist.playlist.html","description":"Sequences of instruction schedules to execute. Full path: iqm.pulse.playlist.playlist previous Wait next schedule © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26....","content":"Sequences of instruction schedules to execute. Full path: iqm.pulse.playlist.playlist previous Wait next schedule © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"TimeBox","url":"/iqm-pulse/api/iqm.pulse.timebox.TimeBox.html","description":"Bases: object Container for one or more instruction schedule fragments, to be scheduled according to a given strategy. Each TimeBox can be labeled using a human-readable label describing it, and opera...","content":"Bases: object Container for one or more instruction schedule fragments, to be scheduled according to a given strategy. Each TimeBox can be labeled using a human-readable label describing it, and operates on a number\\nof locus components , using some of their control channels.  It can be either atomic or composite . An atomic box only contains a single Schedule . A composite box contains a sequence of other TimeBoxes as its children.\\nThe locus components are the union of the locus components of the children.\\nIf two children use the same channel so that they cannot happen simultaneously, they must\\nhappen in the order they occur in the sequence. A box can be made atomic by resolving it using ScheduleBuilder.resolve_timebox .\\nThe time duration of the box is determined by its contents and the way they are scheduled during the resolution. TimeBoxes can be concatenated with the following rules: Addition concatenates the children of the operands into a single TimeBox. The pipe operation groups two TimeBoxes together without concatenating. Iterables of Boxes are treated as the sum of the elements. Let a, b, c, d be TimeBoxes. Then Module: iqm.pulse.timebox Attributes scheduling Determines how the contents of a composite TimeBox are scheduled by ScheduleBuilder. scheduling_algorithm Determines the algorithm used in converting the TimeBox to a Schedule. label Description the contents of the box for users' convenience. locus_components Names of the QPU components on which this timebox operates. atom Resolved contents of the TimeBox, or None if not resolved. children Further Timeboxes inside this TimeBox. neighborhood_components Dict of neighborhood range integers mapped to sets of components neighboring the locus of this TimeBox . Methods atomic Build an atomic timebox from a schedule. composite Build a composite timebox from a sequence of timeboxes. print Print a simple representation of the contents of this box. set_alap Set the scheduling strategy to As late as possible (ALAP). set_asap Set the scheduling strategy to As soon as possible (ASAP). validate Validate the contents of the TimeBox. label ( str ) – locus_components ( set [ str ] ) – atom ( Schedule | None ) – children ( tuple [ TimeBox , ... ] ) – scheduling ( SchedulingStrategy ) – scheduling_algorithm ( SchedulingAlgorithm ) – neighborhood_components ( dict [ int , set [ str ] ] ) – Description the contents of the box for users’ convenience. Has no functional effect. Names of the QPU components on which this timebox operates. These can include additional components\\nto the ones included in one of the channels occupied by this TimeBox . The components included in this\\nattribute will be blocked in scheduling, in addition to the ones dictated by the neighborhood range (see neighborhood_components ). Resolved contents of the TimeBox, or None if not resolved. Further Timeboxes inside this TimeBox. Determines how the contents of a composite TimeBox are scheduled by ScheduleBuilder.\\nHas no meaning for an atomic TimeBox. Determines the algorithm used in converting the TimeBox to a Schedule. Dict of neighborhood range integers mapped to sets of components neighboring the locus of this TimeBox .\\nThese are used in the scheduling when the corresponding neighborhood range is used.\\nThe scheduling algorithm computes the neighborhood components (unless it has been already precomputed by\\ne.g. the GateImplementation ) and caches them under this attribute. Neighborhood range 0 means just the components\\naffected by one of the channels in self.atom + self.locus , 1 means also neighboring couplers, 2 the\\ncomponents connected to those couplers, and so on. Note: range 0 may differ from self.locus_components : it can\\nhave additional components that have occupied channels in self but are not defined as a part of the ‘locus’ of\\nthis TimeBox for any reason. Build a composite timebox from a sequence of timeboxes. boxes ( Iterable [ TimeBox | Iterable [ TimeBox ] ] ) – contents of the new timebox. Any iterables of timeboxes will be flattened (recursively) and extended\\nto the contents in the same order. label ( str ) – label of the new timebox scheduling ( SchedulingStrategy ) – scheduling strategy to use when resolving the new timebox scheduling_algorithm ( SchedulingAlgorithm ) – scheduling algorithm to use when resolving the new timebox composite timebox containing boxes as its children TimeBox Build an atomic timebox from a schedule. schedule ( Schedule ) – contents of the new timebox locus_components ( Iterable [ str ] ) – names QPU components schedule operates on label ( str ) – label of the new timebox atomic timebox containing schedule TimeBox Validate the contents of the TimeBox. path ( tuple [ str , ... ] ) – Labels of ancestor boxes, to generate a better error message. None Set the scheduling strategy to As soon as possible (ASAP). TimeBox Set the scheduling strategy to As late as possible (ALAP). TimeBox Print a simple representation of the contents of this box. _idxs ( tuple [ int , ... ] ) – None previous SchedulingStrategy next utils © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"CircuitOperation","url":"/iqm-pulse/api/iqm.pulse.builder.CircuitOperation.html","description":"Bases: object Specific quantum operation applied on a specific part of the QPU, e.g. in a quantum circuit. Module: iqm.pulse.builder Attributes implementation name of the implementation name name of t...","content":"Bases: object Specific quantum operation applied on a specific part of the QPU, e.g. in a quantum circuit. Module: iqm.pulse.builder Attributes implementation name of the implementation name name of the quantum operation locus names of the information-bearing QPU components (qubits, computational resonators...) the operation acts on args arguments for the operation Methods validate Validate the operation against a table of operation definitions. name ( str ) – locus ( tuple [ str , ... ] ) – args ( dict [ str , Any ] ) – implementation ( str | None ) – name of the quantum operation names of the information-bearing QPU components (qubits, computational resonators…) the operation acts on arguments for the operation name of the implementation Validate the operation against a table of operation definitions. op_table ( dict [ str , QuantumOp ] ) – table containing allowed quantum operations ValueError – operation is not valid None previous iqm.pulse.builder.validate_quantum_circuit next ScheduleBuilder © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.gates.move.validate_move_instructions","url":"/iqm-pulse/api/iqm.pulse.gates.move.validate_move_instructions.html","description":"Circuit-level pass to prepare a circuit containing MOVE gates for compilation. Validates that circuit conforms to the MOVE gate constraints. instructions ( Iterable [ CircuitOperation ] ) – quantum ci...","content":"Circuit-level pass to prepare a circuit containing MOVE gates for compilation. Validates that circuit conforms to the MOVE gate constraints. instructions ( Iterable [ CircuitOperation ] ) – quantum circuit to validate builder ( ScheduleBuilder ) – schedule builder, encapsulating information about the station validate_prx ( bool ) – whether to validate the circuit for PRX gates between MOVE sandwiches as well instructions , unmodified ValueError – Circuit does not conform to MOVE constraints. Iterable [ CircuitOperation ] previous iqm.pulse.gates.move.apply_move_gate_phase_corrections next MOVE_CRF_CRF © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.playlist.channel.get_channel_properties","url":"/iqm-pulse/api/iqm.pulse.playlist.channel.get_channel_properties.html","description":"Internal function to get channel properties. chip_topology ( ChipTopology ) – drive_controllers ( dict [ str , SettingNode ] ) – flux_controllers ( dict [ str , SettingNode ] ) – readout_controllers (...","content":"Internal function to get channel properties. chip_topology ( ChipTopology ) – drive_controllers ( dict [ str , SettingNode ] ) – flux_controllers ( dict [ str , SettingNode ] ) – readout_controllers ( dict [ str , SettingNode ] ) – tuple [ dict [ str , ChannelProperties ], dict [ str , dict [ str , str ]]] previous channel next iqm.pulse.playlist.channel.get_channel_properties_from_station_settings © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"FastDrag","url":"/iqm-pulse/api/iqm.pulse.playlist.fast_drag.FastDrag.html","description":"Bases: SuppressedPulse Base class for IQ components of the Fourier Ansatz Spectrum Tuning (FAST) DRAG pulse. The FAST DRAG pulse shapes the I-envelope in the frequency domain to suppress specified fre...","content":"Bases: SuppressedPulse Base class for IQ components of the Fourier Ansatz Spectrum Tuning (FAST) DRAG pulse. The FAST DRAG pulse shapes the I-envelope in the frequency domain to suppress specified frequency intervals\\naccording to given weights. Furthermore, the Q-envelope is obtained as a derivative of the I-envelope\\nsimilarly to ordinary DRAG. This class represents a base class for an implementation using cosine functions\\nas the I-envelope basis functions. See [ 1 ] for more details on FAST DRAG. number_of_cos_terms ( int ) – Number of cosine terms in the Fourier series expression of the I-component suppressed_interval_widths ( ndarray ) – Widths of the suppressed frequency intervals (in Hz). The last element corresponds\\nto the width of a potential cutoff interval. weights ( ndarray ) – Weights corresponding to the suppressed frequency intervals n_samples ( int ) – full_width ( float ) – coefficients ( ndarray ) – suppressed_frequencies ( ndarray ) – compute_coefs_from_frequencies ( bool ) – center_offset ( float ) – Module: iqm.pulse.playlist.fast_drag Attributes center_offset  number_of_cos_terms  suppressed_interval_widths  weights  full_width  coefficients  suppressed_frequencies  compute_coefs_from_frequencies  n_samples Requested number of samples for the waveform. Methods non_timelike_attributes Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Used to construct the parameters for the calibration data required by the waveform.\\nBy default all the waveform attributes are “timelike” (the unit for their calibration data is s).\\nHowever, some waveform attributes can be dimensionless, e.g. the relative amplitudes in a sum of\\nconsisting of multiple terms, or frequency-like (calibration data has the unit ‘Hz’).\\nIf a Waveform subclass has non-timelike attributes, it needs to redefine this method. When the Waveform is constructed, all timelike calibration data is converted to units of the\\nsampling window duration, and all frequency-like calibration data into units of inverse sampling\\nwindow duration. dict [ str , str ] previous iqm.pulse.playlist.fast_drag.solve_fast_coefficients_for_given_weights_and_ranges next FastDragI © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"move","url":"/iqm-pulse/api/iqm.pulse.gates.move.html","description":"Two-qubit MOVE gate. The MOVE gate is a population exchange operation between a qubit and a resonator,\\nmediated by a coupler, that has the following properties: MOVE is unitary. The effect of MOVE is ...","content":"Two-qubit MOVE gate. The MOVE gate is a population exchange operation between a qubit and a resonator,\\nmediated by a coupler, that has the following properties: MOVE is unitary. The effect of MOVE is only defined in the invariant\\nsubspace \\\\(S = \\\\text{span}\\\\{|00\\\\rangle, |01\\\\rangle, |10\\\\rangle\\\\}\\\\) , where it swaps the populations of the states \\\\(|01\\\\rangle\\\\) and \\\\(|10\\\\rangle\\\\) . Anything may happen in the orthogonal subspace as long as it is unitary and\\ninvariant. In the subspace where it is defined, MOVE is an involution: \\\\(\\\\text{MOVE}_S^2 = I_S\\\\) . Thus MOVE has the following presentation in the subspace \\\\(S\\\\) : where \\\\(a\\\\) is an undefined complex phase. This degree of freedom (in addition to the undefined effect of the gate\\nin the orthogonal subspace) means there is a continuum of different MOVE gates, all equally valid.\\nThe phase \\\\(a\\\\) is canceled when the MOVE gate is applied a second time due to the involution property. Full path: iqm.pulse.gates.move Functions apply_move_gate_phase_corrections (schedule, ...) Schedule-level pass applying resonator-related phase corrections in MOVE sandwiches to the moved qubit. validate_move_instructions (instructions, builder) Circuit-level pass to prepare a circuit containing MOVE gates for compilation. Classes MOVE_CRF_CRF Qubit-resonator MOVE gate using the CRF waveform for the coupler and the qubit flux pulse. MOVE_CustomWaveforms Qubit-resonator MOVE gate using flux pulses on both components. MOVE_TGSS_CRF Qubit-resonator MOVE gate using the TGSS waveform for the coupler flux pulse and the CRF waveform for the qubit flux pulse. MoveMarker Special annotation instruction to indicate the beginning and ending of MOVE gates. Inheritance previous ProbePulse_CustomWaveforms next iqm.pulse.gates.move.apply_move_gate_phase_corrections © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.circuit_operations.get_unitary_from_op","url":"/iqm-pulse/api/iqm.pulse.circuit_operations.get_unitary_from_op.html","description":"Unitary matrix representing an operation within the context of the circuit. First, fetches the unitary corresponding to the correct operation from the QuantumOpTable. If that unitary\\nis a function, ge...","content":"Unitary matrix representing an operation within the context of the circuit. First, fetches the unitary corresponding to the correct operation from the QuantumOpTable. If that unitary\\nis a function, gets the matrix by calling the function with values of quantum operation params stored\\nin the operation. Checks whether the size of the unitary is correct. Then, optionally extends that unitary to act\\non the Hilbert space of the entire circuit. op ( CircuitOperation ) – quantum operation instance table ( dict [ str , QuantumOp ] ) – registered quantum operations qubits ( list [ str ] ) – qubits of the whole circuit, in big-endian order Unitary matrix representing op on the Hilbert space of the circuit. ndarray previous iqm.pulse.circuit_operations.get_unitary_from_circuit next iqm.pulse.circuit_operations.reorder © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.builder.validate_quantum_circuit","url":"/iqm-pulse/api/iqm.pulse.builder.validate_quantum_circuit.html","description":"Validate a sequence of circuit operations constituting a quantum circuit. operations ( Iterable [ CircuitOperation ] ) – quantum circuit to be validated op_table ( dict [ str , QuantumOp ] ) – table c...","content":"Validate a sequence of circuit operations constituting a quantum circuit. operations ( Iterable [ CircuitOperation ] ) – quantum circuit to be validated op_table ( dict [ str , QuantumOp ] ) – table containing allowed/calibrated quantum operations require_measurements ( bool ) – iff True the circuit must include at least one measurement operation ValueError – operations do not constitute a valid quantum circuit None previous iqm.pulse.builder.load_config next CircuitOperation © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"CosineFall","url":"/iqm-pulse/api/iqm.pulse.playlist.waveforms.CosineFall.html","description":"Bases: Waveform Cosine Rise waveform. This waveform assumes that during its duration, the only thing occurring is signal falling to 0.\\nThe waveform is made for pairing with ‘Constant’ waveform to enab...","content":"Bases: Waveform Cosine Rise waveform. This waveform assumes that during its duration, the only thing occurring is signal falling to 0.\\nThe waveform is made for pairing with ‘Constant’ waveform to enable arbitrarily long pulses with smooth fall part.\\nThe fall time is equal to pulse duration. Module: iqm.pulse.playlist.waveforms Attributes n_samples Requested number of samples for the waveform. Methods n_samples ( int ) – Actually samples the waveform. sample_coords ( ndarray ) – coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) ndarray previous Cosine next CosineRise © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"CZ_Slepian_CRF","url":"/iqm-pulse/api/iqm.pulse.gates.cz.CZ_Slepian_CRF.html","description":"Bases: FluxPulseGate CZ gate using a Slepian flux pulse on the coupler and a CosineRiseFall flux pulse on the qubit. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be ...","content":"Bases: FluxPulseGate CZ gate using a Slepian flux pulse on the coupler and a CosineRiseFall flux pulse on the qubit. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of Slepian Required calibration data, may be nested alias of CosineRiseFall True iff the implementation is symmetric in its locus components.\\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous CZ_Slepian_ACStarkCRF next CZ_TruncatedGaussianSmoothedSquare © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"RZ_ACStarkShift_CosineRiseFall","url":"/iqm-pulse/api/iqm.pulse.gates.rz.RZ_ACStarkShift_CosineRiseFall.html","description":"Bases: RZ_ACStarkShift AC stark pulse implemented as a modulated cosine rise fall pulse. Constructs an instance of the AC Stark pulse for the given locus. Module: iqm.pulse.gates.rz Attributes paramet...","content":"Bases: RZ_ACStarkShift AC stark pulse implemented as a modulated cosine rise fall pulse. Constructs an instance of the AC Stark pulse for the given locus. Module: iqm.pulse.gates.rz Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of ModulatedCosineRiseFall Required calibration data, may be nested True iff the implementation is symmetric in its locus components.\\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous RZ_ACStarkShift next RZ_ACStarkShift_smoothConstant © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.validation.AWGScheduleValidationError","url":"/iqm-pulse/api/iqm.pulse.validation.AWGScheduleValidationError.html","description":"Error raised when schedule validation for an AWG fails. previous AWGScheduleValidationData next iqm.pulse.validation.InvalidInstructionError © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last up...","content":"Error raised when schedule validation for an AWG fails. previous AWGScheduleValidationData next iqm.pulse.validation.InvalidInstructionError © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"ComplexIntegration","url":"/iqm-pulse/api/iqm.pulse.playlist.instructions.ComplexIntegration.html","description":"Bases: AcquisitionMethod Perform a weighted integration of the IQ raw signal, resulting in a complex number. Module: iqm.pulse.playlist.instructions Attributes weights Integration weights. label Ident...","content":"Bases: AcquisitionMethod Perform a weighted integration of the IQ raw signal, resulting in a complex number. Module: iqm.pulse.playlist.instructions Attributes weights Integration weights. label Identifier for the returned data, like QB1__readout.time_trace . delay_samples Delay from beginning of probe pulse to beginning of acquisition window, in samples. Methods label ( str ) – delay_samples ( int ) – weights ( IQPulse ) – Integration weights. previous Block next ConditionalInstruction © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.scheduler.extend_schedule_new","url":"/iqm-pulse/api/iqm.pulse.scheduler.extend_schedule_new.html","description":"Extend a Schedule with another Schedule. Extends A with B , modifying A . The extension can add new channels to A . Can also handle cases where B has a ragged left side, i.e. some of its channels begi...","content":"Extend a Schedule with another Schedule. Extends A with B , modifying A . The extension can add new channels to A . Can also handle cases where B has a ragged left side, i.e. some of its channels begin\\nwith Nothing instructions. A ( Schedule ) – schedule to be extended B ( Schedule ) – schedule to extend A with channels ( dict [ str , ChannelProperties ] ) – properties of the control channels TOL ( float ) – time durations equal or smaller than this are considered zero (in seconds) None previous iqm.pulse.scheduler.extend_schedule next SegmentPointer © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"FluxPulseGate_TGSS_CRF","url":"/iqm-pulse/api/iqm.pulse.gates.cz.FluxPulseGate_TGSS_CRF.html","description":"Bases: FluxPulseGate CZ gate using a TruncatedGaussianSmoothedSquare flux pulse on the coupler and a CosineRiseFall\\nflux pulse on the qubit. Module: iqm.pulse.gates.cz Attributes parameters Required c...","content":"Bases: FluxPulseGate CZ gate using a TruncatedGaussianSmoothedSquare flux pulse on the coupler and a CosineRiseFall\\nflux pulse on the qubit. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of TruncatedGaussianSmoothedSquare Required calibration data, may be nested alias of CosineRiseFall True iff the implementation is symmetric in its locus components.\\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous FluxPulseGate_CRF_CRF next default_gates © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_FLUX_AWG_LOCUS_MAPPING","url":"/iqm-pulse/api/iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_FLUX_AWG_LOCUS_MAPPING.html","description":"Locus mapping name for mapping all components that have the flux operation defined and the flux controller\\nhas an AWG. previous iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_READOUT_LOCUS_MAPPI...","content":"Locus mapping name for mapping all components that have the flux operation defined and the flux controller\\nhas an AWG. previous iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_READOUT_LOCUS_MAPPING next iqm.pulse.gate_implementation.PROBE_LINES_LOCUS_MAPPING © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"Measure_Constant","url":"/iqm-pulse/api/iqm.pulse.gates.measure.Measure_Constant.html","description":"Bases: Measure_CustomWaveforms Implementation of a single-qubit projective, dispersive measurement in the Z basis. Uses a constant probe pulse. Module: iqm.pulse.gates.measure Attributes dependent_wav...","content":"Bases: Measure_CustomWaveforms Implementation of a single-qubit projective, dispersive measurement in the Z basis. Uses a constant probe pulse. Module: iqm.pulse.gates.measure Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). parameters Required calibration data, may be nested Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – If set True , the Q channel waveform is considered to depend on the I channel’s waveform\\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\\nwill be initialised as True . Required calibration data, may be nested alias of Constant alias of Constant previous measure next Measure_Constant_Qnd © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.validation.validate_awg_and_schedule_compatibility","url":"/iqm-pulse/api/iqm.pulse.validation.validate_awg_and_schedule_compatibility.html","description":"Validates that the given playlist is compatible with the provided AWG data.\\nThe following requirements are validated as they are the same for all controllers. Playlist sampling rate vs. Actual control...","content":"Validates that the given playlist is compatible with the provided AWG data.\\nThe following requirements are validated as they are the same for all controllers. Playlist sampling rate vs. Actual controller sampling rate Instruction granularity with respect to the controllers granularity requirements Checks that no other than supported instructions are used. Checks that instruction length matches waveform length in IQ and RealPulse Checks that all instructions are at least the length of minimum number of samples Checks that Conditional instruction has the same duration in every child instruction channel_description ( ChannelDescription ) – Contains instructions used as well as the channel specific configuration from playlist device_constraints ( AWGScheduleValidationData ) – Contains the actual hardware limitations previous validation next iqm.pulse.validation.validate_channel © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"PRX_SinglePulse_GateImplementation","url":"/iqm-pulse/api/iqm.pulse.gates.prx.PRX_SinglePulse_GateImplementation.html","description":"Bases: SinglePulseGate , PRX_GateImplementation ABC for PRX gates implemented using a single IQ pulse. This class implements phased x rotation gates on a specific qubit using an IQPulse instance, deri...","content":"Bases: SinglePulseGate , PRX_GateImplementation ABC for PRX gates implemented using a single IQ pulse. This class implements phased x rotation gates on a specific qubit using an IQPulse instance, derived from the pulse calibration data provided at construction by\\nthe static method _single_iq_pulse() .\\nThe pulse is used to resonantly drive the qubit to effect the required rotation. The pulse calibration data consists of the parameters of an \\\\(x_\\\\pi\\\\) IQPulse only.\\nIt is assumed that the transfer function from the AWG to the qubit is linear, i.e.,\\nother rotation angles can be obtained by linearly scaling the pulse amplitude, and other phase angles can be obtained by adjusting the IQ modulation phase. The generated pulses all have the same time duration, also for identity rotations. In the special case of the\\nduration being zero, the gate implementation will apply a Block(0) instruction to the qubit’s drive channel. Module: iqm.pulse.gates.prx Attributes iq_pulse Alias for self.pulse for backward compatibility Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Phased x rotation gate. angle ( float ) – rotation angle (in radians) phase ( float ) – phase angle (in radians) boxed instruction schedule implementing the phased x rotation gate TimeBox Alias for self.pulse for backward compatibility previous PRX_ModulatedDRAGCosineRiseFall next reset © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"Measure_CustomWaveforms","url":"/iqm-pulse/api/iqm.pulse.gates.measure.Measure_CustomWaveforms.html","description":"Bases: CustomIQWaveforms Base class for implementing dispersive measurement operations with custom probe pulse waveforms. You may define a measurement implementation that uses the Waveform instances S...","content":"Bases: CustomIQWaveforms Base class for implementing dispersive measurement operations with custom probe pulse waveforms. You may define a measurement implementation that uses the Waveform instances Something and SomethingElse as the probe pulse waveforms in the\\nI and Q channels as follows: class MyGate(Measure_CustomWaveforms, i_wave=Something, q_wave=SomethingElse) . The measure operation is factorizable, and its arity is 0, which together mean that it can operate\\non loci of any dimensionality, but is calibrated only on single component loci. When the gate is constructed in the len(locus) > 1 , case (e.g. builder.get_implementation('measure', ('QB1', 'QB2', 'QB3'))() ) the resulting TimeBox is constructed from the calibrated single-component gates. For each measured component, the readout IQPulse will be modulated with the\\nintermediate frequency (IF), computed as the difference between the readout\\nfrequency of that component and the probe line center frequency, and offset in phase\\nby the readout phase of the component. The measurement is implemented using a ReadoutTrigger instruction, with a duration set by the\\nrequirements of the acquisition(s). Note that this is typically different from gates.measure.constant.{locus}.duration , which is the probe pulse duration. Module: iqm.pulse.gates.measure Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). root_parameters Parameters independent of the of Waveforms. wave_i Waveform for the I channel. wave_q Waveform for the Q channel. Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). get_locus_mapping_name Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. probe_timebox Returns a \\"naked\\" probe timebox that supports convenient multiplexing through MultiplexedProbeTimeBox.__add__ . time_trace Returns a multiplexed simultaneous measurement with an additional time trace acquisition. parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Parameters independent of the of Waveforms. Inheriting classes may override this to include parameters common\\nto all such implementations. Cache for probe_timebox() . Cache for time_trace() . Builds a probe pulse and an acquisition method using the calibration data. Subclasses may override this method if needed. waveform_params ( dict [ str , Any ] ) – root_params ( dict [ str , Any ] ) – if_freq ( float ) – tuple [ IQPulse , AcquisitionMethod ] Returns a “naked” probe timebox that supports convenient multiplexing through MultiplexedProbeTimeBox.__add__ . This method can be used if the user wants to control the multiplexing explicitly. With two MultiplexedProbeTimeBox\`\`es \`\`A and B the result A + B has all the ReadoutTrigger instructions\\non each probe channel of A and B multiplexed together and played simultaneously. key ( str ) – The readout results generated on this trigger will be assigned to f\\"{qubit}__{key}\\" , where qubit goes over the component names in self.locus . If empty,\\nthe key “readout.result” will be used to maintain backwards compatibility. feedback_key ( str ) – The signals generated by this measure operation are routed using this key for\\nfast feedback purposes. See __call__() . do_acquisition ( bool ) – if False, no acquisitions are added. MultiplexedProbeTimeBox containing the ReadoutTrigger instruction. MultiplexedProbeTimeBox Returns a TimeBox containing the multiplexed simultaneous measurement. If len(self.locus) == 1 , the TimeBox contains the measurement for just that component, otherwise\\nthe measurements of components that belong to the same probeline are multiplexed together. The returned TimeBox instances behave like any other TimeBox in scheduling and circuit\\ngeneration. With measurement TimeBoxes A and B the result A + B first plays the ReadoutTrigger instructions of A and only then those of B in each probe channel. If the multiplexing features of MultiplexedProbeTimeBox are needed, the method probe_timebox() can be used. In scheduling, the returned TimeBox blocks the locus components and the probe\\nlines they are associated with. key ( str ) – Readout results generated on this trigger will be assigned to the acquisition labels f\\"{qubit}__{key}\\" , where qubit goes over the component names in self.locus .\\nIf empty, the key \\"readout.result\\" will be used to maintain backwards compatibility. feedback_key ( str ) – If the readout mode is “threshold”, the results generated by this measure operation\\nare routed using the label f\\"{qubit}__{feedback_key}\\" for fast feedback purposes.\\nThe signals are picked up by ConditionalInstruction\`s that have the same label. The default value \` ””\`\` means the signal is not routed anywhere. TODO: currently the HW does not\\nsupport multiple feedback keys per drive channel, so the actual key used will be FEEDBACK_KEY whenever any non-empty key is inputted. When the HW is improved, the actual key the user inputs\\nshould be passed. TimeBox containing the ReadoutTrigger instruction. TimeBox Returns a multiplexed simultaneous measurement with an additional time trace acquisition. The returned TimeBox is the same as the one returned by __call__() except the time trace\\nacquisition is appended to the acquisitions of each probe line’s ReadoutTrigger instruction. key ( str ) – Readout results generated on this trigger will be used to assigned to f\\"{qubit}__{key}\\" , where qubit goes over the component names in self.locus , whereas\\nthe recorded time traces will be assigned to f\\"{probe_line}__{key}\\" where probe_line goes through all the probe lines associated with self.locus .\\nIf empty, the key \\"readout.result\\" will be used for integrated results and the key \\"readout.time_trace\\" for the recorded time traces. acquisition_delay ( float | None ) – optionally override the time trace acquisition delay with this value (given in\\nseconds). Does not affect the acqusition delays of the integrated measurements. acquisition_duration ( float | None ) – optionally override the time trace acquisition duration with this value (given in\\nseconds). Does not affect the integration lengths of the integrated measurements. feedback_key ( str ) – The signals generated by the integration are routed using this label, prefixed by\\nthe component. See __call__() . TimeBox containing the ReadoutTrigger instruction. TimeBox Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.\\nSubclasses can reimplement this method in case it makes sense in their context. float Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. By default, it is \\"<operation_name>.<implementation_name>\\" . Inheriting classes may\\noverride this for different behaviour. operation_name ( str ) – name of the quantum operation. implementation_name ( str ) – name of the implementation name of the locus mapping str If set True , the Q channel waveform is considered to depend on the I channel’s waveform\\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\\nwill be initialised as True . previous Measure_Constant_Qnd next ProbePulse_CustomWaveforms © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"CosineRise","url":"/iqm-pulse/api/iqm.pulse.playlist.waveforms.CosineRise.html","description":"Bases: Waveform Cosine Rise waveform. This waveform assumes that during its duration, the only thing happening is signal occurring to the required\\namplitude.\\nThe waveform is made for pairing with ‘Con...","content":"Bases: Waveform Cosine Rise waveform. This waveform assumes that during its duration, the only thing happening is signal occurring to the required\\namplitude.\\nThe waveform is made for pairing with ‘Constant’ waveform to enable arbitrarily long pulses with smooth rise part.\\nThe rise time is equal to pulse duration. rise_time – Dummy parameter, used only as due to a bug. FIXME it is not used, placed for resolving exa bug n_samples ( int ) – Module: iqm.pulse.playlist.waveforms Attributes n_samples Requested number of samples for the waveform. Methods Actually samples the waveform. sample_coords ( ndarray ) – coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) ndarray previous CosineFall next CosineRiseFallDerivative © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.gate_implementation.NestedParams","url":"/iqm-pulse/api/iqm.pulse.gate_implementation.NestedParams.html","description":"Nested dict defining the parameters required by GateImplementation classes. alias of dict [ str , Parameter | Setting | dict ] previous iqm.pulse.gate_implementation.OpCalibrationDataTree next iqm.pul...","content":"Nested dict defining the parameters required by GateImplementation classes. alias of dict [ str , Parameter | Setting | dict ] previous iqm.pulse.gate_implementation.OpCalibrationDataTree next iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_DRIVE_LOCUS_MAPPING © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_READOUT_LOCUS_MAPPING","url":"/iqm-pulse/api/iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_READOUT_LOCUS_MAPPING.html","description":"Locus mapping name for mapping all components that have the readout operation defined. previous iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_DRIVE_LOCUS_MAPPING next iqm.pulse.gate_implementat...","content":"Locus mapping name for mapping all components that have the readout operation defined. previous iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_DRIVE_LOCUS_MAPPING next iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_FLUX_AWG_LOCUS_MAPPING © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"CCPRX_Composite_DRAGGaussian","url":"/iqm-pulse/api/iqm.pulse.gates.conditional.CCPRX_Composite_DRAGGaussian.html","description":"Bases: CCPRX_Composite Conditional drag_gaussian pulse. Module: iqm.pulse.gates.conditional Attributes default_implementations Mapping from operation names to the designated default implementation of ...","content":"Bases: CCPRX_Composite Conditional drag_gaussian pulse. Module: iqm.pulse.gates.conditional Attributes default_implementations Mapping from operation names to the designated default implementation of that operation. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Mapping from operation names to the designated default implementation of that operation. Filling this attribute\\nallows one to define a different default implementation from the common default in self.builder.op_table to\\nbe used in he context of this composite gate. If an operation is not found in this dict as a key, this\\nCompositeGate will use the common default as the default implementation for it. previous CCPRX_Composite_DRAGCosineRiseFall next cz © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.scheduler.extend_hard_boundary","url":"/iqm-pulse/api/iqm.pulse.scheduler.extend_hard_boundary.html","description":"Merge two Schedules together such that the timebox boundary is respected. This scheduling algorithm treats the Schedules as hard, rectangular boxes where any ragged edges\\nwill be padded with Waits, an...","content":"Merge two Schedules together such that the timebox boundary is respected. This scheduling algorithm treats the Schedules as hard, rectangular boxes where any ragged edges\\nwill be padded with Waits, and the boxes are not allowed to overlap. The algorithm is as follows: 1. When adding child_schedule to schedule , the longest channel in schedule that overlaps with the\\nchannels present in child determines the earliest possible starting time for the child_schedule , and all other\\nchannels in schedule are padded with Wait to the aforementioned max length. 2. An occupied channel in schedule will always occupy all channels of the corresponding component (qubit,\\ncoupler, …). This is handled by keeping track of occupied durations for each component (no unnecessary padding\\nis added to channels which do not have an actual physical pulse). 3. After the schedules are combined, all the common channels of schedule and child_schedule are blocked\\nup to their common maximum length. This algorithm should not be used with variable sampling rates in the schedule channels. In that case, use extend_hard_boundary_in_seconds() instead. schedule ( Schedule ) – Schedule that should be extended with child_schedule . Modified in place. child_schedule ( Schedule ) – Child schedule to be added. child_components ( set [ str ] ) – Components (qubits, couplers, computational_resonators) that have at least\\none channel in child_schedule . neighborhood_components ( set [ str ] ) – QPU components neighboring the child_components that should\\nadditionally be blocked in the scheduling. component_durations ( dict [ str , int ] ) – Blocked durations for each component used by schedule .\\nThese act as the earliest starting points for a new segment added to any of the channels\\nof the component, but will also block the component even if it has no occupied channels\\nin the schedule yet or ever (e.g. a computational resonator).\\nModified in place. is_alap ( bool ) – Whether the scheduling strategy is ALAP (As Late As Possible). None previous iqm.pulse.scheduler.BLOCKING next iqm.pulse.scheduler.extend_hard_boundary_in_seconds © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.gates.move.apply_move_gate_phase_corrections","url":"/iqm-pulse/api/iqm.pulse.gates.move.apply_move_gate_phase_corrections.html","description":"Schedule-level pass applying resonator-related phase corrections in MOVE sandwiches to the moved qubit. Note Assumes the MOVE gate implementation is based on MOVE_CustomWaveforms . Processes all the M...","content":"Schedule-level pass applying resonator-related phase corrections in MOVE sandwiches to the moved qubit. Note Assumes the MOVE gate implementation is based on MOVE_CustomWaveforms . Processes all the MOVE sandwiches in schedule , summing up the VirtualRZ instructions\\non the resonator virtual drive channels, adding the phase difference resulting from\\nqubit-resonator detuning to the total, and applying it on the qubit at the end of each sandwich. schedule ( Schedule ) – instruction schedule to process builder ( ScheduleBuilder ) – schedule builder that was used to build schedule apply_detuning_corrections ( bool ) – if True, also apply detuning phase corrections copy of schedule with the phase corrections applied Schedule previous move next iqm.pulse.gates.move.validate_move_instructions © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"QuantumOp","url":"/iqm-pulse/api/iqm.pulse.quantum_ops.QuantumOp.html","description":"Bases: object Describes a native quantum operation type. Quantum operations (or “ops” in short), are simple, abstract, self-contained actions one can\\nexecute on a station as parts of a quantum circuit...","content":"Bases: object Describes a native quantum operation type. Quantum operations (or “ops” in short), are simple, abstract, self-contained actions one can\\nexecute on a station as parts of a quantum circuit. They include quantum gates, measurements,\\nand resets. They must have an unambiguous definition in terms of their intended effect on the\\ncomputational subspace of the quantum subsystems (qubits, qudits, qumodes…) they act on.\\nThey are implemented on the hardware using instruction schedules . A QuantumOp can also be a metaoperation , which (in an idealized picture) has no effect on the\\nquantum state, but affects the scheduling of the other ops. Execution barriers are an example of a metaoperation. The ops can have any number of named parameters. For example, PRX is a two-parameter\\nquantum gate family, whereas CZ is a single gate with no parameters. A locus (plural: loci) is a tuple[str, ...] (an ordered sequence) of CHAD component names\\nan instance of a quantum operation acts on. The locus consists of those QPU components that store the\\nquantum information the operation acts on. For example, a CZ gate implemented using a flux\\npulse on the coupler connecting the qubits does not include the coupler in its locus, since the\\ncoupler is simply an implementation detail. In a quantum circuit each operation type normally has several different loci. For example, you\\ncould have a PRX gate being used on qubits {('QB1',), ('QB2',), ('QB5',)} , or a CZ gate used on qubit pairs {('QB1', 'QB3'), ('QB3', 'QB5',), ('QB1', 'QB5',)} . Each quantum operation can have any number of named implementations , each represented by a GateImplementation subclass. For example, we may have two implementations of the CZ gate,\\none with just a single flux pulse applied to the coupler, and another one with additional flux\\npulses applied to the qubits as well. operation defines the abstract intention (what) implementation defines the concrete method (how) locus defines the target of the operation (where) The quantum operations are typically calibrated using specific calibration experiments that\\noutput the required calibration data. Each implementation of each operation can require\\nits own, independent set of calibration data for each locus. Module: iqm.pulse.quantum_ops Attributes default_implementation Name of the default implementation (the global default). factorizable True iff the operation is always factorizable to independent single-subsystem operations, which is also how it is implemented, for example parallel single-qubit measurements. params Names of required operation parameters, if any. symmetric True iff the effect of operation is symmetric in the quantum subsystems it acts on. unitary Unitary matrix that represents the effect of this quantum operation in the computational basis, or None if the quantum operation is not unitary or the exact unitary is not known. name Unique name of the operation. arity Number of locus components the operation acts on. implementations Maps implementation names to GateImplementation classes that provide them. defaults_for_locus Optionally define the implementation default individually per each locus. Methods copy Make a copy of self with the given changes applied to the contents. get_default_implementation_for_locus Get the default (highest priority) implementation for the given locus. set_default_implementation Sets the given implementation as the default. set_default_implementation_for_locus Set the locus-specific default implementation. name ( str ) – arity ( int ) – params ( tuple [ str , ... ] ) – implementations ( dict [ str , type [ GateImplementation ] ] ) – symmetric ( bool ) – factorizable ( bool ) – defaults_for_locus ( dict [ tuple [ str , ... ] , str ] ) – unitary ( Callable [ ... , np.ndarray ] | None ) – Unique name of the operation. Number of locus components the operation acts on.\\nEach locus component corresponds to a quantum subsystem in the definition of the operation.\\nThe computational subspace always consists of the lowest two levels of the subsystem.\\nZero means the operation can be applied on any number of locus components. Names of required operation parameters, if any. Maps implementation names to GateImplementation classes that provide them.\\nEach such class should describe the implementation in detail in its docstring.\\nThe implementations are in the dict in priority order, highest-priority (default) first. This global priority\\norder can be overridden per locus by the attribute defaults_for_locus . True iff the effect of operation is symmetric in the quantum subsystems it acts on.\\nOnly meaningful if self.arity != 1 . True iff the operation is always factorizable to independent single-subsystem operations, which\\nis also how it is implemented, for example parallel single-qubit measurements.\\nIn this case the operation calibration data is for individual subsystems as well. Optionally define the implementation default individually per each locus. Maps the locus to the default\\ngate implementation name. If a locus is not found in this dict (by default, the dict is empty), falls back to the\\nglobal order defined in implementations . The implementations must be first registered in implementations . Unitary matrix that represents the effect of this quantum operation in the computational basis, or None if the quantum operation is not unitary or the exact unitary is not known.\\nThe Callable needs to take exactly the arguments given in params , for example if params=('angle','phase') , the function must have signature f(angle:float, phase: float) -> np.ndarray .\\nFor operations acting on more than 1 qubit, unitary should be given in the big-endian order, i.e. in the basis np.kron(first_qubit_basis_ket, second_qubit_basis_ket) . Make a copy of self with the given changes applied to the contents. QuantumOp Name of the default implementation (the global default). Sets the given implementation as the default. default ( str ) – name of the new default implementation ValueError – default is unknown or is a special implementation. None Get the default (highest priority) implementation for the given locus. If no locus-specific priority is defined, returns the global default. locus ( Iterable [ str ] ) – tuple of component names defining the locus. The default implementation name. str Set the locus-specific default implementation. default ( str ) – name of the new default implementation for locus . locus ( Iterable [ str ] ) – tuple of component names defining the locus. ValueError – if there is no implementation defined with the name default or default is a special\\n    implementation. None previous iqm.pulse.quantum_ops.validate_op_calibration next scheduler © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"MOVE_TGSS_CRF","url":"/iqm-pulse/api/iqm.pulse.gates.move.MOVE_TGSS_CRF.html","description":"Bases: MOVE_CustomWaveforms Qubit-resonator MOVE gate using the TGSS waveform for the coupler flux pulse and the\\nCRF waveform for the qubit flux pulse. Module: iqm.pulse.gates.move Attributes paramete...","content":"Bases: MOVE_CustomWaveforms Qubit-resonator MOVE gate using the TGSS waveform for the coupler flux pulse and the\\nCRF waveform for the qubit flux pulse. Module: iqm.pulse.gates.move Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of TruncatedGaussianSmoothedSquare Required calibration data, may be nested alias of CosineRiseFall True iff the implementation is symmetric in its locus components.\\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous MOVE_CustomWaveforms next MoveMarker © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.gates.enums.TWO_QUBIT_UNITARIES","url":"/iqm-pulse/api/iqm.pulse.gates.enums.TWO_QUBIT_UNITARIES.html","description":"Mapping of TwoQubitGates to the corresponding U(4) matrices previous iqm.pulse.gates.enums.XYGATE_UNITARIES next TwoQubitGate © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-0...","content":"Mapping of TwoQubitGates to the corresponding U(4) matrices previous iqm.pulse.gates.enums.XYGATE_UNITARIES next TwoQubitGate © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"Constant_PRX_with_smooth_rise_fall","url":"/iqm-pulse/api/iqm.pulse.gates.prx.Constant_PRX_with_smooth_rise_fall.html","description":"Bases: ABC_Constant_smooth Constant PRX pulse with cosine rise and fall padding.\\nImplemented as a 3-instruction Schedule. Constructs an instance of the AC Stark pulse for the given locus. Module: iqm....","content":"Bases: ABC_Constant_smooth Constant PRX pulse with cosine rise and fall padding.\\nImplemented as a 3-instruction Schedule. Constructs an instance of the AC Stark pulse for the given locus. Module: iqm.pulse.gates.prx Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of CosineFall alias of Constant Required calibration data, may be nested alias of CosineRise True iff the implementation is symmetric in its locus components.\\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous ABC_Constant_smooth next PRX_CustomWaveforms © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"Reset_Wait","url":"/iqm-pulse/api/iqm.pulse.gates.reset.Reset_Wait.html","description":"Bases: GateImplementation Reset operation by relaxation (idling for a time comparable to the relaxation time of the component). Adds a Wait pulse for all the (non-virtual) channels of the locus compon...","content":"Bases: GateImplementation Reset operation by relaxation (idling for a time comparable to the relaxation time of the component). Adds a Wait pulse for all the (non-virtual) channels of the locus components. In addition, blocks all the probes\\nassociated with the locus and in case the locus is connected via couplers, blocks them as well. The operation\\nis factorizable, so that the calibration data it uses (i.e. the wait duration in seconds) is defined for each\\ncomponent, and when acting on multiple components, the maximum of the associated wait durations will be applied. Reset by relaxation is intended to be used in the circuit initialisation between shots / segments.\\nIt also can be called on specific qubits inside a segment, but as it works by\\nwaiting longer than the qubit relaxation time, the states of all the other qubits\\nwill likely have been destroyed as well by the time the reset has finished. Module: iqm.pulse.gates.reset Attributes parameters Required calibration data, may be nested Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). get_custom_locus_mapping Supported loci: all components that have channels. wait_box TimeBox that contains Wait instructions for all non-virtual channels associated with self.locus . parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Required calibration data, may be nested TimeBox that contains Wait instructions for all non-virtual channels associated with self.locus . Does not block any additional components beside the locus itself. TimeBox The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs\\nin the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.\\nSubclasses can reimplement this method in case it makes sense in their context. float Supported loci: all components that have channels. chip_topology ( ChipTopology ) – component_to_channels ( dict [ str , Iterable [ str ] ] ) – dict [ tuple [ str , …] | frozenset [ str ], tuple [ str , …]] | None previous Reset_Conditional next rz © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"schedule","url":"/iqm-pulse/api/iqm.pulse.playlist.schedule.html","description":"Instruction schedules for controlling the instruments. Full path: iqm.pulse.playlist.schedule Module Attributes TOLERANCE remove when COMP-1281 is done. Classes Nothing Used to extend a control channe...","content":"Instruction schedules for controlling the instruments. Full path: iqm.pulse.playlist.schedule Module Attributes TOLERANCE remove when COMP-1281 is done. Classes Nothing Used to extend a control channel in time, without blocking it, during scheduling. Schedule Set of synchronously executed AWG/readout programs that start on a single trigger. Segment Sequence of instructions, for a single channel. Inheritance previous playlist next iqm.pulse.playlist.schedule.TOLERANCE © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"AWGScheduleValidationData","url":"/iqm-pulse/api/iqm.pulse.validation.AWGScheduleValidationData.html","description":"Bases: object Controller specific validation data Module: iqm.pulse.validation Attributes sampling_rate  granularity  min_number_of_samples  compatible_instructions  Methods sampling_rate ( float ) – ...","content":"Bases: object Controller specific validation data Module: iqm.pulse.validation Attributes sampling_rate  granularity  min_number_of_samples  compatible_instructions  Methods sampling_rate ( float ) – granularity ( int ) – min_number_of_samples ( int ) – compatible_instructions ( tuple [ type [ Operation ] , ... ] ) – previous iqm.pulse.validation.validate_playlist_compatibility next iqm.pulse.validation.AWGScheduleValidationError © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"Schedule","url":"/iqm-pulse/api/iqm.pulse.playlist.schedule.Schedule.html","description":"Bases: object Set of synchronously executed AWG/readout programs that start on a single trigger. Consists of a number of channels , each containing a Segment of Instruction s for a specific controller...","content":"Bases: object Set of synchronously executed AWG/readout programs that start on a single trigger. Consists of a number of channels , each containing a Segment of Instruction s for a specific controller.  For each channel, maps the channel name to\\nits Segment of Instructions. Mutable. To make an independent copy, use copy() . contents ( Mapping [ str , Iterable [ Instruction ] ] | None ) – mapping from channel name to a list of Instructions for that channel duration ( int | None ) – Optional precomputed duration (in samples). In cases where the duration is known and performance\\nis critical, the duration can be given in the constructor, allowing one to skip computing it. Module: iqm.pulse.playlist.schedule Attributes duration The maximum duration of the Schedule's channels, in samples. Methods add_channels Add new empty channels to the schedule. append Append a single Instruction to a specific channel in the Schedule. channels The channels occupied in self . cleanup Cleans up the schedule by removing things that do not affect the execution. copy Make an independent copy of the schedule. duration_in_seconds Schedule duration in seconds, taking into account the sample rates of the channels. extend Append given Instruction to a specific channel in the Schedule. front_pad Modifies the schedule in place by front-padding it with Wait instructions. front_pad_in_seconds Modifies the schedule in place by front-padding it with Wait instructions. has_content_in Returns True if self has content in any of the given channels, otherwise False . items Iterator over the schedule channel names and segments. pad_to_hard_box Pad channels in self to the maximum channel length found within with Wait instructions. pad_to_hard_box_in_seconds Pad channels in self to the maximum channel length (seconds) found within with Wait instructions. pprint Fixed-width character graphics representation of the Schedule. reverse Copy of the schedule with the order of the instructions in each channel reversed. reverse_hard_box Copy of the schedule with the order of the instructions in each channel reversed. validate Validate the contents of the schedule. The maximum duration of the Schedule’s channels, in samples. Computed only when needed and cached for performance. Schedule duration in seconds, taking into account the sample rates of the channels. channel_properties ( dict [ str , ChannelProperties ] ) – channel properties. schedule duration (in seconds) float Fixed-width character graphics representation of the Schedule. Assumes the Instruction.duration s are in samples. time_unit ( int ) – unit of time represented by a single symbol (in samples) str Iterator over the schedule channel names and segments. The channels occupied in self . KeysView Make an independent copy of the schedule. Mutating the original must not affect the copy, or vice versa.\\nInstructions are immutable, so they need not be copied. copy of the schedule Schedule Add new empty channels to the schedule. If a given channel (identified by its controller name) already exist in the schedule,\\nit is unchanged. Modifies self . channel_names ( Iterable [ str ] ) – names of the controllers for which empty channels are added None Append a single Instruction to a specific channel in the Schedule. channel ( str ) – name of the channel to append the instruction to instruction ( Instruction ) – instruction to append None Append given Instruction to a specific channel in the Schedule. channel ( str ) – name of the channel to append the instructions to instructions ( Iterable [ Instruction ] ) – instructions to append None Modifies the schedule in place by front-padding it with Wait instructions. NOTE: this method cannot be used when there are variable sampling rates present in the schedule. In that\\ncase, use the method front_pad_in_seconds . to_duration ( int ) – duration of the resulting schedule, in samples self , with the padding Schedule Modifies the schedule in place by front-padding it with Wait instructions. The new duration is given in seconds, and this method works also with variable sample rates. channel_properties ( dict [ str , ChannelProperties ] ) – channel properties. to_duration ( float ) – self , with the padding Pad channels in self to the maximum channel length found within with Wait instructions. The Wait\`\`s are appended to the end of the segments. NOTE: this method cannot be used when there are variable sampling rates present in the schedule. In that case, use the method \`\`pad_to_hard_box_in_seconds . None Pad channels in self to the maximum channel length (seconds) found within with Wait instructions. The Waits are appended to the end of the segments. The segment durations are compared in seconds, so this\\nmethod works in the case of variable sampling rates as well. The padding is added to a channel only if the\\ndifference between the channel’s duration and the maximum duration is larger than the smallest possible\\ninstruction duration for that channel. channel_properties ( dict [ str , ChannelProperties ] ) – channel properties (containing the sampling rates and granularities). None Copy of the schedule with the order of the instructions in each channel reversed. NOTE: this method cannot be used when there are variable sampling rates present in the schedule. To preserve synchronization of the channels, the channels are first rear-padded\\nwith Nothing instructions. Schedule Copy of the schedule with the order of the instructions in each channel reversed. No additional time-synchronisation logic is implemented, so this method will break the synchronisation\\nif self is not a schedule with matching durations in all segments. Schedule Cleans up the schedule by removing things that do not affect the execution. Removes empty channels, and channels that only have idling instructions. Modifies self . Schedule Validate the contents of the schedule. path ( tuple [ str , ... ] ) – None Returns True if self has content in any of the given channels, otherwise False . channel_names ( Iterable [ str ] ) – bool previous Nothing next Segment © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"ThresholdStateDiscrimination","url":"/iqm-pulse/api/iqm.pulse.playlist.instructions.ThresholdStateDiscrimination.html","description":"Bases: ComplexIntegration Perform a weighted integration of the IQ raw signal and compare the real part of the result\\nagainst a threshold value, resulting in a boolean. Module: iqm.pulse.playlist.inst...","content":"Bases: ComplexIntegration Perform a weighted integration of the IQ raw signal and compare the real part of the result\\nagainst a threshold value, resulting in a boolean. Module: iqm.pulse.playlist.instructions Attributes feedback_signal_label In fast feedback routing, the transmitted signals are associated with this label. threshold The real part of the integration result is compared against this. weights Integration weights. label Identifier for the returned data, like QB1__readout.time_trace . delay_samples Delay from beginning of probe pulse to beginning of acquisition window, in samples. Methods label ( str ) – delay_samples ( int ) – weights ( IQPulse ) – threshold ( float ) – feedback_signal_label ( str ) – The real part of the integration result is compared against this. In fast feedback routing, the transmitted signals are associated with this label.\\nConditionalInstructions whose “condition” field has the string value of feedback_signal_label will receive the signal from this ThresholdStateDiscrimination.\\nEmpty string (default) means the signal is not routed anywhere.\\nThe same feedback_signal_label may not be used multiple times within the same ReadoutTrigger.\\nThe same feedback_signal_label can be used in different ReadoutTriggers and different segments. previous RealPulse next TimeTrace © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"FastDragQ","url":"/iqm-pulse/api/iqm.pulse.playlist.fast_drag.FastDragQ.html","description":"Bases: FastDrag Q-component of the Fourier Ansatz Spectrum Tuning (FAST) drag pulse. The Q-envelope is defined as where \\\\(N\\\\) is the number of cosine terms in the series, \\\\(\\\\{c_n\\\\}\\\\) are the coefficie...","content":"Bases: FastDrag Q-component of the Fourier Ansatz Spectrum Tuning (FAST) drag pulse. The Q-envelope is defined as where \\\\(N\\\\) is the number of cosine terms in the series, \\\\(\\\\{c_n\\\\}\\\\) are the coefficients, and\\nthe pulse is defined on the interval \\\\(t \\\\in [-t_p/2, t_p/2]\\\\) . Module: iqm.pulse.playlist.fast_drag Attributes number_of_cos_terms  suppressed_interval_widths  weights  full_width  coefficients  suppressed_frequencies  compute_coefs_from_frequencies  n_samples Requested number of samples for the waveform. Methods n_samples ( int ) – full_width ( float ) – coefficients ( ndarray ) – suppressed_frequencies ( ndarray ) – compute_coefs_from_frequencies ( bool ) – number_of_cos_terms ( int ) – suppressed_interval_widths ( ndarray ) – weights ( ndarray ) – center_offset ( float ) – Actually samples the waveform. sample_coords ( ndarray ) – coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) ndarray previous FastDragI next SuppressedPulse © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"FastDragI","url":"/iqm-pulse/api/iqm.pulse.playlist.fast_drag.FastDragI.html","description":"Bases: FastDrag I-component of the Fourier Ansatz Spectrum Tuning (FAST) drag pulse. The I-envelope is defined as where \\\\(N\\\\) is the number of cosine terms in the series, \\\\(\\\\{c_n\\\\}\\\\) are the coefficie...","content":"Bases: FastDrag I-component of the Fourier Ansatz Spectrum Tuning (FAST) drag pulse. The I-envelope is defined as where \\\\(N\\\\) is the number of cosine terms in the series, \\\\(\\\\{c_n\\\\}\\\\) are the coefficients, and\\nthe pulse is defined on the interval \\\\(t \\\\in [-t_p/2, t_p/2]\\\\) . Module: iqm.pulse.playlist.fast_drag Attributes number_of_cos_terms  suppressed_interval_widths  weights  full_width  coefficients  suppressed_frequencies  compute_coefs_from_frequencies  n_samples Requested number of samples for the waveform. Methods n_samples ( int ) – full_width ( float ) – coefficients ( ndarray ) – suppressed_frequencies ( ndarray ) – compute_coefs_from_frequencies ( bool ) – number_of_cos_terms ( int ) – suppressed_interval_widths ( ndarray ) – weights ( ndarray ) – center_offset ( float ) – Actually samples the waveform. sample_coords ( ndarray ) – coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) ndarray previous FastDrag next FastDragQ © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"Delay","url":"/iqm-pulse/api/iqm.pulse.gates.delay.Delay.html","description":"Bases: GateImplementation Applies a delay on the control channels of its locus components. This operation applies Wait instructions on all the control channels of all its locus\\ncomponents.  The durati...","content":"Bases: GateImplementation Applies a delay on the control channels of its locus components. This operation applies Wait instructions on all the control channels of all its locus\\ncomponents.  The duration of all the Waits is the same, and it is given as a parameter for the\\noperation, rounded up to the nearest possible duration the hardware can handle. Note We can only guarantee that the delay is at least of the requested duration.  Also, when\\nDelay is used in a quantum circuit, the delay between the preceding and following operations is\\nagain at least the requested duration, but could be much more depending on the other operations\\nin the circuit.  To see why, consider e.g. the circuit [CZ(a, b), Delay(1, a), Delay(10, b), CZ(a, b)] where a and b are qubits.\\nIn this case the actual delay between the two CZ gates will be 10 time units rounded up to\\nhardware granularity. Module: iqm.pulse.gates.delay Attributes symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – True iff the implementation is symmetric in its locus components.\\nOnly meaningful if arity != 1 , and the locus components are of the same type. Delay instruction. duration ( float ) – Duration of the requested wait (in seconds). Will be rounded up to the nearest\\nduration that the hardware enables, with the exception that a duration of zero will\\ncause no waiting. However, as usual, during scheduling all channels the TimeBox is\\nacting on will be extended to the duration of the longest channel in the TimeBox. TimeBox previous iqm.pulse.gates.delay.DELAY_MAX_DURATION_SECONDS next enums © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"RZ_ACStarkShift_smoothConstant","url":"/iqm-pulse/api/iqm.pulse.gates.rz.RZ_ACStarkShift_smoothConstant.html","description":"Bases: Constant_PRX_with_smooth_rise_fall Constant AC stark pulse with cosine rise and fall padding.\\nImplemented as a 3-instruction Schedule. Constructs an instance of the AC Stark pulse for the given...","content":"Bases: Constant_PRX_with_smooth_rise_fall Constant AC stark pulse with cosine rise and fall padding.\\nImplemented as a 3-instruction Schedule. Constructs an instance of the AC Stark pulse for the given locus. Module: iqm.pulse.gates.rz Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of CosineFall alias of Constant Required calibration data, may be nested alias of CosineRise True iff the implementation is symmetric in its locus components.\\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous RZ_ACStarkShift_CosineRiseFall next RZ_PRX_Composite © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.validation.PlaylistValidationError","url":"/iqm-pulse/api/iqm.pulse.validation.PlaylistValidationError.html","description":"Error raised when Playlist validation fails. previous iqm.pulse.validation.InvalidInstructionError next Changelog © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26....","content":"Error raised when Playlist validation fails. previous iqm.pulse.validation.InvalidInstructionError next Changelog © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.gates.u.get_unitary_u","url":"/iqm-pulse/api/iqm.pulse.gates.u.get_unitary_u.html","description":"Unitary for an SU(2) gate. See iqm.pulse.gates.u for the definition of the gate parameters. theta ( float ) – y rotation angle phi ( float ) – z rotation angle lam ( float ) – another z rotation angle...","content":"Unitary for an SU(2) gate. See iqm.pulse.gates.u for the definition of the gate parameters. theta ( float ) – y rotation angle phi ( float ) – z rotation angle lam ( float ) – another z rotation angle 2x2 unitary representing u(theta, phi, lam) . ndarray previous u next UGate © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"FluxPulseGate_CRF_CRF","url":"/iqm-pulse/api/iqm.pulse.gates.cz.FluxPulseGate_CRF_CRF.html","description":"Bases: FluxPulseGate CZ gate using a CosineRiseFall flux pulse on the coupler and on the qubit. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested symmetric True...","content":"Bases: FluxPulseGate CZ gate using a CosineRiseFall flux pulse on the coupler and on the qubit. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of CosineRiseFall Required calibration data, may be nested alias of CosineRiseFall True iff the implementation is symmetric in its locus components.\\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous FluxPulseGate next FluxPulseGate_TGSS_CRF © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.builder.load_config","url":"/iqm-pulse/api/iqm.pulse.builder.load_config.html","description":"Load quantum operation definitions and calibration data from a YAML config file. path ( str ) – path to a YAML config file quantum operation definitions, calibration data tree tuple [ dict [ str , Qua...","content":"Load quantum operation definitions and calibration data from a YAML config file. path ( str ) – path to a YAML config file quantum operation definitions, calibration data tree tuple [ dict [ str , QuantumOp ], dict [ str , dict [ str , dict [ tuple [ str , …] | None , dict [ str , Any ]]]]] previous iqm.pulse.builder.build_quantum_ops next iqm.pulse.builder.validate_quantum_circuit © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"PRX_DRAGGaussian","url":"/iqm-pulse/api/iqm.pulse.gates.prx.PRX_DRAGGaussian.html","description":"Bases: PRX_CustomWaveforms PRX gate, DRAG / TruncatedGaussian IQ pulse implementation. See PRX_CustomWaveforms . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel wave...","content":"Bases: PRX_CustomWaveforms PRX gate, DRAG / TruncatedGaussian IQ pulse implementation. See PRX_CustomWaveforms . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). parameters Required calibration data, may be nested Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – If set True , the Q channel waveform is considered to depend on the I channel’s waveform\\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\\nwill be initialised as True . Required calibration data, may be nested alias of TruncatedGaussian alias of TruncatedGaussianDerivative previous PRX_DRAGCosineRiseFallSX next PRX_DRAGGaussianSX © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"ChannelDescription","url":"/iqm-pulse/api/iqm.pulse.playlist.channel.ChannelDescription.html","description":"Bases: object Channel specific data, including tables for the instructions and waveforms used. name ( str ) – name of the controller handling the channel, also the name of the channel config ( RealCha...","content":"Bases: object Channel specific data, including tables for the instructions and waveforms used. name ( str ) – name of the controller handling the channel, also the name of the channel config ( RealChannelConfig ) – properties of the channel instruction_table – mapping of the instructions to be executed on this channel. Each\\ninstruction should be unique. waveform_table – Contains mapping of the waveforms to be executed on this channel. Each\\nwaveform should be unique. Module: iqm.pulse.playlist.channel Attributes name  config  instruction_table  waveform_table  Methods add_instruction Add an instruction to the channel. Add an instruction to the channel. Each unique instruction in a channel gets assigned an integer index that can be used to refer to it.\\nIf the instruction has associated Waveform s, they are indexed in a similar manner. instruction ( Instruction ) – instruction to be added index of the instruction int previous ChannelConfiguration next ChannelProperties © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"CouplerFluxPulseQubitACStarkPulseGate","url":"/iqm-pulse/api/iqm.pulse.gates.cz.CouplerFluxPulseQubitACStarkPulseGate.html","description":"Bases: GateImplementation Base class for CZ gates with coupler flux pulse and a qubit AC Stark pulse. Analogous to the fast qubit flux pulse, the AC Stark pulse can tune the frequency of the qubit. To...","content":"Bases: GateImplementation Base class for CZ gates with coupler flux pulse and a qubit AC Stark pulse. Analogous to the fast qubit flux pulse, the AC Stark pulse can tune the frequency of the qubit. Together with the\\ncoupler flux pulse, this can implement a fast qubit pulsed CZ gate. Module: iqm.pulse.gates.cz Attributes excluded_parameters Parameters names to be excluded from self.parameters . root_parameters  coupler_wave Flux pulse Waveform to be played in the coupler flux AWG. qubit_drive_wave Qubit drive pulse waveform to be played in the qubit drive AWG. Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). get_locus_mapping_name Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Flux pulse Waveform to be played in the coupler flux AWG. Qubit drive pulse waveform to be played in the qubit drive AWG. Parameters names to be excluded from self.parameters . Inheriting classes may override this if certain\\nparameters are not wanted in that class (also parameters defined by the waveforms can be excluded). Returns an AC Stark pulse which consists of a modulated I and modulated Q waveform, where the Q quadrature\\nhas an additional phase of -pi/2. phase ( float ) – amplitude ( float ) – phase_increment ( float ) – IQPulse The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs\\nin the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.\\nSubclasses can reimplement this method in case it makes sense in their context. float Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. By default, it is \\"<operation_name>.<implementation_name>\\" . Inheriting classes may\\noverride this for different behaviour. operation_name ( str ) – name of the quantum operation. implementation_name ( str ) – name of the implementation name of the locus mapping str previous CZ_TruncatedGaussianSmoothedSquare next FluxPulseGate © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"Segment","url":"/iqm-pulse/api/iqm.pulse.playlist.schedule.Segment.html","description":"Bases: object Sequence of instructions, for a single channel. Basically a list[Instruction] that keeps track of the time duration of its contents. instructions ( Iterable [ Instruction ] ) – contents ...","content":"Bases: object Sequence of instructions, for a single channel. Basically a list[Instruction] that keeps track of the time duration of its contents. instructions ( Iterable [ Instruction ] ) – contents of the segment duration ( int | None ) – If None, compute the sum of the durations of instructions .\\nOtherwise, the time duration (in samples) of the segment, which must match\\nthe aforementioned sum if the Segment is still to be modified. Module: iqm.pulse.playlist.schedule Attributes duration Sum of the durations of the instructions in the segment, in samples. Methods append Append an instruction to the end of the segment. copy Make an independent copy of the segment. extend Append all instructions from an iterable to the end of the segment. pop Remove and return the instruction at the given index of the segment. prepend Prepend an instruction to the beginning of the segment. contents total duration of the segment, in samples Make an independent copy of the segment. Mutating the original must not affect the copy, or vice versa.\\nInstructions are immutable, so they need not be copied. copy of the segment Segment Append an instruction to the end of the segment. instruction ( Instruction ) – None Prepend an instruction to the beginning of the segment. instruction ( Instruction ) – None Append all instructions from an iterable to the end of the segment. instructions ( Iterable [ Instruction ] ) – None Remove and return the instruction at the given index of the segment. idx ( int ) – Instruction Sum of the durations of the instructions in the segment, in samples. previous Schedule next visualisation © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"FluxPulseGate","url":"/iqm-pulse/api/iqm.pulse.gates.cz.FluxPulseGate.html","description":"Bases: GateImplementation Discrete two locus component gate implemented using flux pulses, virtual RZs,\\nand the interaction mediated by the coupler. Does not take any parameters since it is discrete. ...","content":"Bases: GateImplementation Discrete two locus component gate implemented using flux pulses, virtual RZs,\\nand the interaction mediated by the coupler. Does not take any parameters since it is discrete. The two locus components of the gate must be coupled by a tunable coupler. Consists of a flux pulse for the coupler, and possibly another one for the first locus component,\\nassumed to be a qubit, both with arbitrary waveforms, and virtual RZs on both components.\\nInherit from this class and assign\\nwaveforms to the coupler_wave and qubit_wave pulse slots to create a specific implementation. Can be used as a base class for both CZ and MOVE gate implementations. Note: the coupler and qubit pulses typically have the same duration (given in the calibration data), and in the\\nspecial case of the duration being zero, the gate implementation will apply Block(0) instructions\\nto all the channels where it would otherwise apply flux pulses or virtual z rotations. flux_pulses – mapping from flux channel name to its flux pulse rz – mapping from drive channel name to the virtual z rotation angle, in radians, that should be performed on it parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Module: iqm.pulse.gates.cz Attributes excluded_parameters Parameters names to be excluded from self.parameters . root_parameters Parameters shared by all FluxPulseGate classes. coupler_wave Flux pulse Waveform to be played in the coupler flux AWG. qubit_wave Flux pulse Waveform to be played in the qubit flux AWG. Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). get_locus_mapping_name Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. Flux pulse Waveform to be played in the coupler flux AWG. Flux pulse Waveform to be played in the qubit flux AWG. Parameters shared by all FluxPulseGate classes. Inheriting classes may override this if there’s\\na need for additional calibration parameters. Parameters names to be excluded from self.parameters . Inheriting classes may override this if certain\\nparameters are not wanted in that class (also parameters defined by the waveforms can be excluded). The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs\\nin the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.\\nSubclasses can reimplement this method in case it makes sense in their context. float Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. By default, it is \\"<operation_name>.<implementation_name>\\" . Inheriting classes may\\noverride this for different behaviour. operation_name ( str ) – name of the quantum operation. implementation_name ( str ) – name of the implementation name of the locus mapping str previous CouplerFluxPulseQubitACStarkPulseGate next FluxPulseGate_CRF_CRF © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"RealPulse","url":"/iqm-pulse/api/iqm.pulse.playlist.instructions.RealPulse.html","description":"Bases: Instruction Play a real-valued pulse. Module: iqm.pulse.playlist.instructions Attributes wave Shape of the pulse. scale Scaling factor for the waveform. duration Time duration of the instructio...","content":"Bases: Instruction Play a real-valued pulse. Module: iqm.pulse.playlist.instructions Attributes wave Shape of the pulse. scale Scaling factor for the waveform. duration Time duration of the instruction. Methods get_waveforms Returns all the waveforms the Instruction contains. validate Validate the instruction attributes. duration ( int ) – wave ( Waveform ) – scale ( float ) – Shape of the pulse. Scaling factor for the waveform. Validate the instruction attributes. ValueError – something about the instruction is not ok Returns all the waveforms the Instruction contains. tuple [ Waveform , …] previous ReadoutTrigger next ThresholdStateDiscrimination © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"CZ_CRF","url":"/iqm-pulse/api/iqm.pulse.gates.cz.CZ_CRF.html","description":"Bases: FluxPulseGate CZ gate using a CosineRiseFall flux pulse on the coupler. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested qubit_wave Flux pulse Waveform ...","content":"Bases: FluxPulseGate CZ gate using a CosineRiseFall flux pulse on the coupler. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested qubit_wave Flux pulse Waveform to be played in the qubit flux AWG. symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of CosineRiseFall Required calibration data, may be nested Flux pulse Waveform to be played in the qubit flux AWG. True iff the implementation is symmetric in its locus components.\\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous cz next CZ_CRF_ACStarkCRF © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.validation.InvalidInstructionError","url":"/iqm-pulse/api/iqm.pulse.validation.InvalidInstructionError.html","description":"Error raised when encountering an invalid instruction. previous iqm.pulse.validation.AWGScheduleValidationError next iqm.pulse.validation.PlaylistValidationError © Copyright 2019-2025, IQM Finland Oy,...","content":"Error raised when encountering an invalid instruction. previous iqm.pulse.validation.AWGScheduleValidationError next iqm.pulse.validation.PlaylistValidationError © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.quantum_ops.validate_locus_calibration","url":"/iqm-pulse/api/iqm.pulse.quantum_ops.validate_locus_calibration.html","description":"Validates calibration for a particular gate implementation at particular locus. cal_data ( OILCalibrationData ) – Calibration data tree for the locus. impl ( type [ GateImplementation ] ) – GateImplem...","content":"Validates calibration for a particular gate implementation at particular locus. cal_data ( OILCalibrationData ) – Calibration data tree for the locus. impl ( type [ GateImplementation ] ) – GateImplementation class that defines the required parameters. op ( QuantumOp ) – QuantumOp that impl implements. impl_name ( str ) – name of the implementation, for error messages. locus ( tuple [ str , ... ] ) – Locus of the operation ValueError – there is something wrong with the calibration data None previous iqm.pulse.quantum_ops.QuantumOpTable next iqm.pulse.quantum_ops.validate_op_calibration © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.gate_implementation.PROBE_LINES_LOCUS_MAPPING","url":"/iqm-pulse/api/iqm.pulse.gate_implementation.PROBE_LINES_LOCUS_MAPPING.html","description":"Locus mapping name for mapping all probe lines. previous iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_FLUX_AWG_LOCUS_MAPPING next iqm.pulse.gate_implementation.get_waveform_parameters © Copyri...","content":"Locus mapping name for mapping all probe lines. previous iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_FLUX_AWG_LOCUS_MAPPING next iqm.pulse.gate_implementation.get_waveform_parameters © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"CCPRX_Composite_DRAGCosineRiseFall","url":"/iqm-pulse/api/iqm.pulse.gates.conditional.CCPRX_Composite_DRAGCosineRiseFall.html","description":"Bases: CCPRX_Composite Conditional drag_crf pulse. Module: iqm.pulse.gates.conditional Attributes default_implementations Mapping from operation names to the designated default implementation of that ...","content":"Bases: CCPRX_Composite Conditional drag_crf pulse. Module: iqm.pulse.gates.conditional Attributes default_implementations Mapping from operation names to the designated default implementation of that operation. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Mapping from operation names to the designated default implementation of that operation. Filling this attribute\\nallows one to define a different default implementation from the common default in self.builder.op_table to\\nbe used in he context of this composite gate. If an operation is not found in this dict as a key, this\\nCompositeGate will use the common default as the default implementation for it. previous CCPRX_Composite next CCPRX_Composite_DRAGGaussian © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"Wait","url":"/iqm-pulse/api/iqm.pulse.playlist.instructions.Wait.html","description":"Bases: Instruction Behave as if outputting zero-valued samples for the duration of the instruction. Used to idle QPU components. However, may be replaced with a dynamical decoupling sequence\\nafter the...","content":"Bases: Instruction Behave as if outputting zero-valued samples for the duration of the instruction. Used to idle QPU components. However, may be replaced with a dynamical decoupling sequence\\nafter the scheduling step. If you want to make sure that this does not happen, use Block instead. Module: iqm.pulse.playlist.instructions Attributes duration Time duration of the instruction. Methods duration ( int ) – previous VirtualRZ next playlist © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.scheduler.extend_hard_boundary_in_seconds","url":"/iqm-pulse/api/iqm.pulse.scheduler.extend_hard_boundary_in_seconds.html","description":"The same as extend_hard_boundary , but the scheduling is done in seconds. Used when the probe channel sampling rate differs from the other channels’ rate.\\nThe incoming schedules measure Instruction du...","content":"The same as extend_hard_boundary , but the scheduling is done in seconds. Used when the probe channel sampling rate differs from the other channels’ rate.\\nThe incoming schedules measure Instruction durations in samples, but component_durations is in seconds. schedule ( Schedule ) – Schedule that should be extended with child_schedule . Modified in place. child_schedule ( Schedule ) – Child schedule to be added. child_components ( set [ str ] ) – Components (qubits, couplers, computational_resonators) that have at least\\none channel in child_schedule . neighborhood_components ( set [ str ] ) – Components neighboring the child_components that should\\nadditionally be blocked in the scheduling. component_durations ( dict [ str , float ] ) – Blocked durations for each component in schedule .\\nThese act as the earliest starting points for new segment added to any of the channels\\nof a given component, but will also block the component even if it has no occupied channels\\nin the schedule yet or ever (e.g. a computational resonator).\\nThe durations are in seconds. Modified in place. is_alap ( bool ) – Whether the scheduling strategy is ALAP (As Late As Possible). channel_properties ( dict [ str , ChannelProperties ] ) – Mapping from channel name to its properties (e.g. the sample rates\\nand granularities). None previous iqm.pulse.scheduler.extend_hard_boundary next iqm.pulse.scheduler.extend_schedule © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"GateImplementation","url":"/iqm-pulse/api/iqm.pulse.gate_implementation.GateImplementation.html","description":"Bases: ABC ABC for implementing quantum gates and other quantum operations using instruction schedules. There is a separate GateImplementation subclass for every implementation of every operation type...","content":"Bases: ABC ABC for implementing quantum gates and other quantum operations using instruction schedules. There is a separate GateImplementation subclass for every implementation of every operation type.\\nEach GateImplementation instance represents a particular locus for that implementation, and encapsulates\\nthe calibration data it requires. All GateImplementation subclasses __init__ must have exactly the below arguments in order to be\\nusable via ScheduleBuilder.get_implementation() . GateImplementations also have the __call__() method, which takes the operation parameters\\n(e.g. rotation angles) as input, and returns a TimeBox instance which implements\\nan instance of the operation at that locus. parent ( QuantumOp ) – Quantum operation this instance implements. name ( str ) – Name of the implementation provided by this instance. locus ( Locus ) – Locus the operation acts on. calibration_data ( OILCalibrationData ) – (Raw) calibration data for the (operation, implementation, locus) represented by this instance builder ( ScheduleBuilder ) – Schedule builder. Module: iqm.pulse.gate_implementation Attributes parameters Required calibration data, may be nested qualified_name Qualified name of the implementation. special_implementation Set to True if  the implementation is a special purpose implementation that should never get called in ScheduleBuilder.get_implementation unless explicitly requested via the impl_name argument. symmetric True iff the implementation is symmetric in its locus components. Methods build Utility method for constructing a GateImplementation with self.builder . convert_calibration_data Convert time-like items in the calibration data to fractions of the time duration of the gate. duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). get_custom_locus_mapping Get custom locus mapping for this GateImplementation. get_locus_mapping_name Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. get_parameters Calibration data tree the GateImplementation subclass expects for each locus. needs_calibration Whether the implementation needs calibration data to_timebox Wraps the given instruction schedule into an atomic/resolved timebox. True iff the implementation is symmetric in its locus components.\\nOnly meaningful if arity != 1 , and the locus components are of the same type. Required calibration data, may be nested Set to True if  the implementation is a special purpose implementation that should never get called in ScheduleBuilder.get_implementation unless explicitly requested via the impl_name argument. Qualified name of the implementation. Whether the implementation needs calibration data Returns True if the calibration dict must contain a node with keyed with\\n<operation name>: <implementation name>: <appropriate locus> in order to use this implementation. bool The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs\\nin the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox | list [ TimeBox ] Utility method for constructing a GateImplementation with self.builder . Inheriting classes may override this in order to add additional logic. op_name ( str ) – operation name locus ( tuple [ str , ... ] ) – locus the operation acts on impl_name ( str | None ) – implementation name. Uses the assigned default implementation if not specified. strict_locus ( bool ) – iff False, for non-symmetric implementations of symmetric ops the locus order may\\nbe changed if no calibration data is available for the requested locus order Calibrated gate implementation. GateImplementation Wraps the given instruction schedule into an atomic/resolved timebox. schedule ( Schedule ) – TimeBox Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.\\nSubclasses can reimplement this method in case it makes sense in their context. float Convert time-like items in the calibration data to fractions of the time duration of the gate. This is a convenience method for converting calibration data items involving time\\ndurations measured in seconds into fractions of the duration of the gate. Values of items that are not measured in seconds or Hz are returned as is. Additionally, converts duration to channel samples and adds it in the converted\\ncalibration data under the key \\"n_samples\\" , while the original \\"duration\\" key is removed. calibration_data ( OILCalibrationData ) – (subset of) calibration data for the gate/implementation/locus params ( NestedParams ) – (subset of) cls.parameters specifying the calibration_data items\\nto convert and return channel_props ( ChannelProperties ) – used to convert \\"duration\\" from seconds into channel samples duration ( float | None ) – Time duration of the gate, in seconds. If None, calibration_data must have\\nan item named \\"duration\\" , measured in seconds, which will be used instead. converted calibration_data items OILCalibrationData Calibration data tree the GateImplementation subclass expects for each locus. Helper method for EXA use. locus ( Iterable [ str ] ) – Locus component names to replace the wildcard character \\"*\\" in the calibration\\nparameter names. One Setting will be generated for each component name in locus .\\nIf there are no wildcard characters in cls.parameters , this argument has no effect. path ( Iterable [ str ] ) – parts of the dotted name for the root node, if any. EXA setting node describing the required calibration data for each locus.\\nAll the Setting values are None . SettingNode Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. By default, it is \\"<operation_name>.<implementation_name>\\" . Inheriting classes may\\noverride this for different behaviour. operation_name ( str ) – name of the quantum operation. implementation_name ( str ) – name of the implementation name of the locus mapping str Get custom locus mapping for this GateImplementation. This method can be used to return the locus mapping (wrt. to the given ChipTopology ) for this GateImplementation . Overriding this method allows a GateImplementation to be “self-sufficient” in the\\nsense that it knows its own locus mapping. chip_topology ( ChipTopology ) – ChipTopology instance in which context to create the custom locus mapping. component_to_channels ( dict [ str , Iterable [ str ] ] ) – dict mapping QPU component names to an Iterable of channel operation names\\navailable for this component (i.e. “readout”, “drive”, “flux”). This info is often needed\\nin building a locus mapping. Custom locus mapping for this GateImplementation or None if the gate implementation has no need for a custom locus mapping, otherwise the returned mapping should be like in ChipTopology.set_locus_mapping() custom locus mapping, otherwise the returned mapping should be like in ChipTopology.set_locus_mapping() dict [ tuple [ str , …] | frozenset [ str ], tuple [ str , …]] | None previous CustomIQWaveforms next SinglePulseGate © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"circuit_operations","url":"/iqm-pulse/api/iqm.pulse.circuit_operations.html","description":"Representing quantum circuits as lists of CircuitOperations. Full path: iqm.pulse.circuit_operations Functions get_unitary_from_circuit (circuit[, table, ...]) Calculate the overall unitary implemente...","content":"Representing quantum circuits as lists of CircuitOperations. Full path: iqm.pulse.circuit_operations Functions get_unitary_from_circuit (circuit[, table, ...]) Calculate the overall unitary implemented by a sequence of CircuitOperations. get_unitary_from_op (op, table, qubits) Unitary matrix representing an operation within the context of the circuit. reorder (A, perm) Permutes the order of the qubits in an n-qubit operator matrix. reshape_unitary (unitary, indices, n_qubits) Extend a unitary propagator to act on a larger system. Classes CircuitOperationList List of CircuitOperation objects representing a quantum circuit. Inheritance previous ScheduleBuilder next iqm.pulse.circuit_operations.get_unitary_from_circuit © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"builder","url":"/iqm-pulse/api/iqm.pulse.builder.html","description":"Tools for building instruction schedules. Full path: iqm.pulse.builder Functions build_quantum_ops (ops) Builds the table of known quantum operations. load_config (path) Load quantum operation definit...","content":"Tools for building instruction schedules. Full path: iqm.pulse.builder Functions build_quantum_ops (ops) Builds the table of known quantum operations. load_config (path) Load quantum operation definitions and calibration data from a YAML config file. validate_quantum_circuit (operations, op_table, *) Validate a sequence of circuit operations constituting a quantum circuit. Classes CircuitOperation Specific quantum operation applied on a specific part of the QPU, e.g. in a quantum circuit. ScheduleBuilder Builds instruction schedules out of quantum circuits or individual quantum operations. Inheritance previous iqm.pulse.base_utils.merge_dicts next iqm.pulse.builder.build_quantum_ops © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"ABC_Constant_smooth","url":"/iqm-pulse/api/iqm.pulse.gates.prx.ABC_Constant_smooth.html","description":"Bases: PRX_GateImplementation ABC class for creating gates with an arbitrarily long Constant pulses with smooth rise and fall.\\nThis pulse creates a :’Segment’ consisting of three instructions : [rise_...","content":"Bases: PRX_GateImplementation ABC class for creating gates with an arbitrarily long Constant pulses with smooth rise and fall.\\nThis pulse creates a :’Segment’ consisting of three instructions : [rise_waveform, main_waveform, fall_waveform].\\nThis class is created so that one can use middle waveform as a constant, thus enabling to use arbitrarily\\nlong pulses, not limited by the awg memory. main_waveform: The middle part of the pulse, which should (but doesn’t have to) be a Constant waveform\\nrise_waveform: rise part of the pulse\\nfall_waveform: fall part of the pulse\\nchannel: Name of the drive channel on which the AC Stark pulse is played. Constructs an instance of the AC Stark pulse for the given locus. Module: iqm.pulse.gates.prx Attributes main_waveform  rise_waveform  fall_waveform  Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Phased x rotation gate. angle ( float ) – rotation angle (in radians) phase ( float ) – phase angle (in radians) boxed instruction schedule implementing the phased x rotation gate TimeBox Returns the main part pulse. Waveform is the same for both I and Q channels n_samples ( int ) – amplitude_i ( float ) – amplitude_q ( float ) – phase ( float ) – IQPulse Returns a rise pulse. n_samples ( int ) – amplitude_i ( float ) – amplitude_q ( float ) – IQPulse Returns a fall pulse n_samples ( int ) – amplitude_i ( float ) – amplitude_q ( float ) – IQPulse previous iqm.pulse.gates.prx.get_unitary_prx next Constant_PRX_with_smooth_rise_fall © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.playlist.channel.get_channel_properties_from_station_settings","url":"/iqm-pulse/api/iqm.pulse.playlist.channel.get_channel_properties_from_station_settings.html","description":"Get channel properties from Station Control controller settings following the standard convention. settings ( SettingNode ) – Flat tree of all controllers. chip_topology ( ChipTopology ) – Chip topolo...","content":"Get channel properties from Station Control controller settings following the standard convention. settings ( SettingNode ) – Flat tree of all controllers. chip_topology ( ChipTopology ) – Chip topology. mapping from channel name to its properties\\ncomponent_to_channel: mapping from chip component to function name to channel name. channel_properties previous iqm.pulse.playlist.channel.get_channel_properties next iqm.pulse.playlist.channel.round_duration_to_granularity_samples © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"TimeTrace","url":"/iqm-pulse/api/iqm.pulse.playlist.instructions.TimeTrace.html","description":"Bases: AcquisitionMethod Capture the raw IQ signal without integration. Module: iqm.pulse.playlist.instructions Attributes duration_samples Length of the capture window, in samples. label Identifier f...","content":"Bases: AcquisitionMethod Capture the raw IQ signal without integration. Module: iqm.pulse.playlist.instructions Attributes duration_samples Length of the capture window, in samples. label Identifier for the returned data, like QB1__readout.time_trace . delay_samples Delay from beginning of probe pulse to beginning of acquisition window, in samples. Methods label ( str ) – delay_samples ( int ) – duration_samples ( int ) – Length of the capture window, in samples. previous ThresholdStateDiscrimination next VirtualRZ © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"ScheduleBuilder","url":"/iqm-pulse/api/iqm.pulse.builder.ScheduleBuilder.html","description":"Bases: object Builds instruction schedules out of quantum circuits or individual quantum operations. Encapsulates known quantum ops, the calibration information for them, QPU components and their\\ntopo...","content":"Bases: object Builds instruction schedules out of quantum circuits or individual quantum operations. Encapsulates known quantum ops, the calibration information for them, QPU components and their\\ntopology, and controller properties. op_table ( QuantumOpTable ) – definitions of known quantum ops calibration ( OpCalibrationDataTree ) – calibration data tree for the quantum ops chip_topology ( ChipTopology ) – Chip topology derived from the CHAD. channels ( dict [ str , ChannelProperties ] ) – mapping of controller names to the configurations of their channels component_channels ( dict [ str , dict [ str , str ] ] ) – Mapping from QPU component name to a mapping of ('drive', 'flux', 'readout') to the name of the control channel responsible for that function of the component. Module: iqm.pulse.builder Attributes composite_cache Cache for the CompositeGate TimeBoxes. Methods build_playlist Build a playlist from a number of instruction schedules. circuit_to_timebox Convert a quantum circuit to a TimeBox. get_calibration Calibration data for the given quantum operation, implementation and locus. get_control_channels Control channels that directly affect quantum operations at the given locus. get_drive_channel Drive channel for the given QPU component. get_flux_channel Flux channel for the given QPU component. get_implementation Provide an implementation for a quantum operation at a given locus. get_implementation_class Implementation class for the given operation. get_probe_channel Probe line channel for the probe line component belongs to. get_virtual_feedback_channel_for Get virtual feedback channel for feedback to a given AWG from a given probe line. get_virtual_feedback_channels All virtual feedback signal channels for the given QPU component. has_calibration Is there calibration data for the given quantum operation, implementation and locus? inject_calibration Inject new calibration data, changing self.calibration after the ScheduleBuilder initialisation. resolve_timebox Resolve a TimeBox. timebox_to_schedule Convert a TimeBox to a finished instruction schedule, ready for execution. timeboxes_to_front_padded_playlist Temporary helper function, for converting a sequence of TimeBoxes to a Playlist. timeboxes_to_playlist Convert a sequence of TimeBoxes to a Playlist. validate_calibration Check that the calibration data matches the known quantum operations. validate_quantum_circuit Validate a sequence of circuit operations constituting a quantum circuit. wait Utility method for applying Block instructions on every channel of the given locus. Cached GateImplementations. The tree has the same structure as OpCalibrationDataTree. Cache for the CompositeGate TimeBoxes. Flushed whenever ANY calibration data is injected into the builder. self.component_channels mapping inverted cached for scheduling algorithm performance. This mapping is\\nused in the scheduling to determine the components to block based on their associated channels. Only\\nblocking channels are included in this mapping, non-blocking channels (e.g. certain virtual channels) do not\\nblock their components, just themselves. Cache the probe and non-probe channel names for the scheduling algorithm performance Whether to require scheduling of probe instructions in seconds instead of in samples. This can happen for two\\nreasons: 1) the probe channel has a different sampling rate to the other channels (e.g. with UHFQA) or\\n2) the probe channels have a different instruction granularity to some of the other channels (e.g. with\\nmixed stations that have the RO device from a different vendor than some of the AWGs). Cache representative channel properties for a probe and a non-probe channel for the scheduling algorithm\\nperformance. Inject new calibration data, changing self.calibration after the ScheduleBuilder initialisation. Invalidates the gate_implementation cache for the affected operations/implementations/loci. Also invalidates\\nthe cache for any factorizable gate implementation, if any of its locus components was affected. partial_calibration ( dict [ str , dict [ str , dict [ tuple [ str , ... ] | None , dict [ str , Any ] ] ] ] ) – data to be injected. Must have the same structure as self.calibration but does not\\nhave to contain all operations/implementations/loci/values. Only the parts of the data that are\\nfound will be merged into self.calibration (including any None values). self._cache will\\nbe invalidated for the found operations/implementations/loci and only if the new calibration data\\nactually differs from the previous. None Check that the calibration data matches the known quantum operations. ValueError – there is something wrong with the calibration data None Drive channel for the given QPU component. component ( str ) – name of a QPU component Name of the drive channel for component , if it exists. KeyError – if component does not exist or does not have a drive channel str Flux channel for the given QPU component. See get_drive_channel() . component ( str ) – str Probe line channel for the probe line component belongs to. See get_drive_channel() . component ( str ) – str All virtual feedback signal channels for the given QPU component. A virtual feedback channel between a source and a destination exists if the station configuration allows it. component can be either the source or the destination of the signal. component ( str ) – name of a QPU component Names of the virtual channels. list [ str ] Get virtual feedback channel for feedback to a given AWG from a given probe line. awg_name ( str ) – name of the awg node that receives the feedback bit. feedback_qubit ( str ) – which qubit’s measurement resulted in the feedback bit The virtual feedback channel name. ValueError – if the given AWG does not support fast feedback from the given probe line. str Control channel name for the given QPU component and operation. name of the channel KeyError – if component does not exist or does not have the operation component ( str ) – operation ( str ) – str Is there calibration data for the given quantum operation, implementation and locus? op_name ( str ) – name of the quantum operation impl_name ( str ) – name of the implementation locus ( tuple [ str , ... ] ) – locus of the operation True iff requested calibration data was found bool Calibration data for the given quantum operation, implementation and locus. op_name ( str ) – name of the quantum operation impl_name ( str ) – name of the implementation locus ( tuple [ str , ... ] ) – locus of the operation requested calibration data ValueError – requested calibration data was not found dict [ str , Any ] Control channels that directly affect quantum operations at the given locus. Includes the probe, drive and flux channels of the locus QPU components.\\nDoes not include e.g. any neighboring coupler channels, these will have to be added\\nseparately in the TimeBox resolution phase. Will only return channels that are known to exist, i.e. are found in ScheduleBuilder.channels . locus ( Iterable [ str ] ) – locus on which the operation acts names of the control channels that directly affect the operation tuple [ str , …] Utility method for applying Block instructions on every channel of the given locus. The Block instructions guarantee the locus components to idle for the given duration,\\nand cannot e.g. be replaced with e.g. dynamical decoupling sequences.\\nThey are treated the same as any other TimeBox contents: Blocks on different channels remain aligned in time during scheduling. The actual waiting time on a particular channel may thus be >= duration ,\\nif the other channels have less non-blocking space on either side. Note TODO For now, this method can round duration to the nearest value allowed by each\\nchannel if requested. This is for the benefit of EXA sweeping over waiting durations.\\nIn the future, EXA sweep generation should be responsible for doing the rounding. locus ( Iterable [ str ] ) – locus components that should experience the wait duration ( float ) – how long to wait (in seconds) rounding ( bool ) – Iff True, for each channel separately, duration will be rounded to the\\nnearest value allowed by the granularity of that channel. The Waits will start\\nsimultaneously. box containing Block instructions on every control channel of locus TimeBox Provide an implementation for a quantum operation at a given locus. op_name ( str ) – name of the quantum operation locus ( Iterable [ str ] ) – locus of the operation impl_name ( str | None ) – name of the implementation ( None means the implementation is chosen automatically\\nusing the logic described below) strict_locus ( bool ) – iff False, for non-symmetric implementations of symmetric ops the locus order may\\nbe changed if no calibration data is available for the requested locus order use_priority_order ( bool ) – Only has an effect if impl_name is None . Iff False , QuantumOp.get_default_implementation_for_locus() is used. Otherwise, the first implementation in\\nthe priority order that has calibration data for locus is chosen. The priority order is as follows:\\n1. The locus-specific priority defined in QuantumOp.defaults_for_locus[locus] if any.\\n2. The global priority order defined in QuantumOp.implementations . priority_calibration ( dict [ str , Any ] | None ) – Calibration data from which to load the calibration instead of the common calibration\\ndata in calibration . If no calibration is found for the given implementation or priority_calibration is None , the common calibration is used. Any non-empty\\nvalues found in priority_calibration will be merged to the common calibration. Note:\\nusing priority_calibration will prevent saving/loading via the cache. requested implementation ValueError – requested implementation could not be provided GateImplementation Find an implementation and locus for the given quantum operation instance compatible\\nwith the calibration data. op ( QuantumOp ) – quantum operation impl_name ( str | None ) – Name of the implementation. None means use the highest-priority implementation for\\nwhich we have calibration data. locus ( tuple [ str , ... ] ) – locus of the operation strict_locus ( bool ) – iff False, for non-symmetric implementations of symmetric ops the locus order may\\nbe changed to an equivalent one if no calibration data is available for the requested locus order chosen implementation name, locus ValueError – requested implementation could not be found ValueError – requested implementation had no calibration data for this locus ValueError – no specific implementation was requested, but no known implementation had\\n    calibration data for this locus tuple [ str , tuple [ str , …]] Build a factory class for the given quantum operation, implementation and locus. The GateImplementations are built when they are first requested, and cached for later use. op ( QuantumOp ) – quantum operation impl_name ( str | None ) – Name of the implementation. None means use the highest-priority implementation for\\nwhich we have calibration data. locus ( tuple [ str , ... ] ) – locus of the operation strict_locus ( bool ) – iff False, for non-symmetric implementations of symmetric ops the locus order may\\nbe changed if no calibration data is available for the requested locus order priority_calibration ( dict [ str , Any ] | None ) – Calibration data from which to load the calibration instead of the common\\ncalibration data. Priority calibration should be either a dict of the type OILCalibrationData ,\\ni.e. containing the operation name, implementation name, and locus, or just a dict containing\\nthe calibration data for the locus implied by the args op , impl_name and locus . requested implementation ValueError – requested implementation could not be provided or had no calibration data for this locus GateImplementation Implementation class for the given operation. op_name ( str ) – name of the quantum operation impl_name ( str | None ) – name of the implementation ( None means use the default implementation) requested implementation class type [ GateImplementation ] Validate a sequence of circuit operations constituting a quantum circuit. operations ( Iterable [ CircuitOperation ] ) – quantum circuit to be validated require_measurements ( bool ) – iff True the circuit must include at least one measurement operation ValueError – operations do not constitute a valid quantum circuit None Convert a quantum circuit to a TimeBox. circuit ( Iterable [ CircuitOperation ] ) – quantum circuit name ( str ) – name of the circuit scheduling_algorithm ( SchedulingAlgorithm ) – scheduling algorithm to be used in resolving the TimeBoxes. locus_mapping ( dict [ str , str ] | None ) – optional mapping of placeholder component names to the physical component names used\\nwhile resolving the circuit into a TimeBox. unresolved TimeBox that implements circuit TimeBox Temporary helper function, for converting a sequence of TimeBoxes to a Playlist. Each individual TimeBox in boxes is resolved into a Schedule, and then\\neach schedules is front-padded with Wait instructions on each channel\\nsuch that the resulting Schedules have equal durations. This is required since\\nfor now in Station Control the delay before the final measurement is the same for\\nall the Schedules in a Playlist, and we do not wish to lose coherence waiting for\\nthe measurement after each Schedule is done. TODO Once Station Control can handle measurements better, this method should be removed,\\nand timeboxes_to_playlist() be used instead. boxes ( Iterable [ TimeBox ] ) – TimeBoxes to include in the playlist neighborhood ( int ) – During scheduling, block neighboring channels of the used components this far. By default,\\nblocks only the defined locus components and any other components which have occupied channels. playlist that implements boxes Playlist Convert a sequence of TimeBoxes to a Playlist. Resolves the boxes, converts them to Schedules, removes unnecessary channels, and then packs\\nthe Schedules into a Playlist. Assumes all the TimeBoxes refer to the same QPU and its control channels. boxes ( Iterable [ TimeBox ] ) – TimeBoxes to include in the playlist neighborhood ( int ) – During scheduling, block neighboring channels of the used components this far.\\nThe default value ensures that quantum operations work as intended, assuming the station\\nis properly calibrated. Higher values may help defend against crosstalk, at the expense\\nof a longer instruction schedule and thus more decoherence. playlist that implements boxes Playlist Convert a TimeBox to a finished instruction schedule, ready for execution. Resolves the box, then converts the durations of the instructions in the schedule to samples\\nat the channel sample_rate. box ( TimeBox ) – TimeBox to resolve neighborhood ( int ) – During scheduling, block neighboring channels of the used components this far.\\nThe default value ensures that quantum operations work as intended, assuming the station\\nis properly calibrated. Higher values may help defend against crosstalk, at the expense\\nof a longer instruction schedule and thus more decoherence. finished schedule that implements box Schedule Finishes the instruction schedule. filters out zero-duration Blocks and Waits converts all spacer instructions used during scheduling to Waits merges consequent Waits removes channels that only have Waits in them This should be the final step of the schedule building process, after this the\\nresulting Schedule can no longer be consistently extended with another (since\\nall the spacer instructions are gone). schedule ( Schedule ) – schedule to finish finished copy of schedule Schedule Fuse long-distance (i.e. out-of-gate-locus) VirtualRZ corrections with the next drive pulse\\nhappening after the FluxPulse they are correcting. schedule ( Schedule ) – Schedule Resolve a TimeBox. Resolves recursively each of the children of the box, and then concatenates the resulting\\nSchedules into a new one using a specific scheduling strategy and algorithm. The supported algorithms are HARD_BOUNDARY , which treats each composite TimeBox as a solid rectangle (the\\nlongest channel within defines the duration) and TETRIS , which packs the schedule as tightly as possible\\n(solid instructions still cannot overlap) regardless of the TimeBox boundaries. Modifies box so that it becomes atomic, if it isn’t already. box ( TimeBox ) – TimeBox to resolve neighborhood ( int ) – During scheduling, block control channels of neighboring QPU components this far\\nfrom the locus. Values higher than 0 may help defend against crosstalk, at the expense\\nof a longer instruction schedule and thus more decoherence. compute_neighborhood_hard_boundary ( bool ) – Whether to precompute the neighborhood components while resolving\\na composite TimeBox in the HARD_BOUNDARY algorithm. Typically one does not want to do this on\\nthe top layer composite TimeBox , since it would be unused. The algorithm sets this True on\\nlower layers, where it improves the performance as the neighborhood components are needed in scheduling. instruction schedule that implements box Schedule Resolves a TimeBox using the HARD_BOUNDARY algorithm, which treats each composite TimeBox as a solid\\nrectangle (the longest channel within defines the duration). box ( TimeBox ) – neighborhood ( int ) – compute_neighborhood ( bool ) – Schedule Computes and caches the blocking neighborhoods for HARD_BOUNDARY algorithm. box ( TimeBox ) – Atomic TimeBox whose neighborhood to compute. neighborhood ( int ) – Return QPU components this far from the locus. QPU components (plus maybe channels?) belonging the the given neighborhood of box . set [ str ] Resolves a TimeBox using the TETRIS algorithm, which packs the schedule as tightly as possible\\n(solid instructions still cannot overlap) regardless of the TimeBox boundaries. box ( TimeBox ) – neighborhood ( int ) – Schedule Add additional blocked channels to the schedule, preventing their use during the schedule. In the idealized computational model we assume that in a (correctly calibrated) quantum computer\\nthere is no effective interaction between QPU components (in the computational frame and subspace) while\\na Wait instruction is acting on the flux channel of the coupler connecting those components\\n(i.e., the coupler is idling).\\nHence a QPU component experiences no effective evolution if Wait instructions are\\nacting on its drive, flux and probe channels, and the flux channels of all its couplers. Of course, in reality the QPU will experience at least some decoherence during a Wait, and\\npossibly some crosstalk.\\nIn some applications, e.g. decoherence experiments, it is essential to Wait for a specific time,\\nsince it’s precisely the decoherence that we are interested in. However, if we are only interested in applying well-defined local quantum operations on specific\\nloci, it is essential to shut down all unwanted dynamics by adding Block instructions on\\ncontrol channels of the unused and neighboring channels.\\nThey act like Waits (and are converted into Waits at the end of the scheduling), but are allowed\\nto overlap in time, since we are only interested in blocking those channels for the duration of the\\nquantum operation. schedule ( Schedule ) – instruction schedule to modify locus ( set [ str ] ) – information-carrying QPU components schedule is meant to operate on (does not include couplers) neighborhood ( int ) – How far should we block neighboring QPU components?\\nZero means just the locus qubits, one means neighboring couplers, two means their neighboring\\nqubits etc. schedule , with added Block instructions on all the neighbor channels,\\nfor the duration of the schedule None Build a playlist from a number of instruction schedules. This involves compressing the schedules so that no duplicate information\\nneeds to be transferred to Station Control. All virtual channels are dropped at this point. schedules ( Iterable [ Schedule ] ) – finished instruction schedules to include in the playlist finish_schedules ( bool ) – whether to finalise the schedules before building the playlist. Should be set True unless some process has already finalised them before calling this function. playlist containing the schedules ValueError – if the schedules contain channels with non-uniform sampling rates Playlist Create shortcut for self.get_implementation(<op_name>, …) as self.<op_name>(…) . If there is a name collision with another attribute in self , the shortcut method won’t be added and\\na warning is raised. op_name ( str ) – None previous CircuitOperation next circuit_operations © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"pulse","url":"/iqm-pulse/api/iqm.pulse.html","description":"Control pulses, gates and instruction schedules for quantum computers. Full path: iqm.pulse Subpackages and modules base_utils Base utility functions with no dependencies on other iqm.pulse modules. b...","content":"Control pulses, gates and instruction schedules for quantum computers. Full path: iqm.pulse Subpackages and modules base_utils Base utility functions with no dependencies on other iqm.pulse modules. builder Tools for building instruction schedules. circuit_operations Representing quantum circuits as lists of CircuitOperations. gate_implementation Implementing abstract quantum operations as instruction schedules. gates Implementations of quantum gates. playlist Control pulses and instruction schedules for quantum computers. quantum_ops Quantum operations. scheduler Tools for composing instruction schedules in time. timebox Reserving QPU resources in instruction scheduling. utils Utility functions. validation Validation of playlists and instructions schedules. previous API Reference next base_utils © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.utils.map_waveform_param_types","url":"/iqm-pulse/api/iqm.pulse.utils.map_waveform_param_types.html","description":"Map a python typehint into EXA Parameter’s (DataType, CollectionType) tuple. type – python typehint. type_hint ( type ) – A (DataType, CollectionType) tuple ValueError – for a non-supported type. tupl...","content":"Map a python typehint into EXA Parameter’s (DataType, CollectionType) tuple. type – python typehint. type_hint ( type ) – A (DataType, CollectionType) tuple ValueError – for a non-supported type. tuple [ DataType , CollectionType ] previous utils next iqm.pulse.utils.normalize_angle © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"CosineRiseFallDerivative","url":"/iqm-pulse/api/iqm.pulse.playlist.waveforms.CosineRiseFallDerivative.html","description":"Bases: Waveform Derivative of a waveform that has a sinusoidal rise and fall, and a constant part in between. where \\\\(c\\\\) is center_offset , \\\\(r\\\\) is rise_time , and \\\\(p\\\\) is the plateau width,\\ncalcul...","content":"Bases: Waveform Derivative of a waveform that has a sinusoidal rise and fall, and a constant part in between. where \\\\(c\\\\) is center_offset , \\\\(r\\\\) is rise_time , and \\\\(p\\\\) is the plateau width,\\ncalculated via \\\\(p :=\\\\) full_width - 2 * rise_time . Its values are in \\\\([-1, 1]\\\\) . full_width ( float ) – Duration of the support of the pulse, >= 2 * rise_time . rise_time ( float ) – Duration of the sinusoidal rise (and fall) part of the waveform, >= 0. center_offset ( float ) – The waveform is centered at this offset from the midpoint of the sampling window. n_samples ( int ) – Module: iqm.pulse.playlist.waveforms Attributes center_offset  full_width  rise_time  n_samples Requested number of samples for the waveform. Methods Actually samples the waveform. sample_coords ( ndarray ) – coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) ndarray previous CosineRise next ModulatedCosineRiseFall © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.validation.validate_channel","url":"/iqm-pulse/api/iqm.pulse.validation.validate_channel.html","description":"Validate a single channel. channel_description ( ChannelDescription ) – device_constraints ( ChannelProperties ) – None previous iqm.pulse.validation.validate_awg_and_schedule_compatibility next iqm.p...","content":"Validate a single channel. channel_description ( ChannelDescription ) – device_constraints ( ChannelProperties ) – None previous iqm.pulse.validation.validate_awg_and_schedule_compatibility next iqm.pulse.validation.validate_instruction_and_wf_length © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.playlist.fast_drag.compute_matrix_of_summed_fourier_transform_inner_products","url":"/iqm-pulse/api/iqm.pulse.playlist.fast_drag.compute_matrix_of_summed_fourier_transform_inner_products.html","description":"Evaluate matrix \\\\(A\\\\) defined in Eq. (5) of [ 1 ] . The matrix element \\\\(A_{nm}\\\\) is defined as where n,m are the row and column indices starting from 1 and extending to \\\\(N\\\\) denoting the\\nnumber of b...","content":"Evaluate matrix \\\\(A\\\\) defined in Eq. (5) of [ 1 ] . The matrix element \\\\(A_{nm}\\\\) is defined as where n,m are the row and column indices starting from 1 and extending to \\\\(N\\\\) denoting the\\nnumber of basis functions, \\\\(f_{l,j}\\\\) and \\\\(f_{h,j}\\\\) denote the starting and ending frequency of the\\nj’th frequency range to suppress, \\\\(\\\\hat{g}_n(f)\\\\) denotes the Fourier transform of \\\\(g_n(f) = 1 -  \\\\cos(2 \\\\pi n t/t_p)\\\\) with \\\\(t_p\\\\) being the pulse duration. Importantly, the computations are fully vectorized for fast evaluation. n_arr ( ndarray ) – 1d array containing indices of basis functions used in the series expansion,\\ntypically ranging from 1 to N weights ( ndarray ) – 1d array of weights corresponding to the suppressed frequency ranges suppressed_freq_ranges_2darr ( ndarray ) – 2d array describing the frequency ranges (in Hz), over which we want to suppress\\nthe Fourier transform. The array should have two columns, the first giving the starting frequency\\nfor each range and the second giving the ending frequency for each range.\\nNote that frequencies will be symmetrically suppressed around the center frequency. pulse_duration ( float ) – Pulse duration (in s) without zero padding. time_scaling_factor ( float ) – Scaling factor for time to avoid excessively large or small values in the matrix. Scaling\\nfactor of frequency is obtained as the inverse. n_points_for_integration ( int ) – Number of points at which the integrand is evaluated for each interval. At least 50\\npoints are recommended for the numerical approximation error to be low. 2d array representing the A matrix with dimensions (len(n_arr), len(n_arr)) ndarray previous fast_drag next iqm.pulse.playlist.fast_drag.evaluate_fast_drag_i_envelope © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.gates.reset.RESET_FEEDBACK_KEY","url":"/iqm-pulse/api/iqm.pulse.gates.reset.RESET_FEEDBACK_KEY.html","description":"The feedback key used in fast-feedback reset gate (the double underscore emphasizes the fact that this label should\\nnot be manually used in fast feedback). previous iqm.pulse.gates.reset.RESET_MEASURE...","content":"The feedback key used in fast-feedback reset gate (the double underscore emphasizes the fact that this label should\\nnot be manually used in fast feedback). previous iqm.pulse.gates.reset.RESET_MEASUREMENT_KEY next Reset_Conditional © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_DRIVE_LOCUS_MAPPING","url":"/iqm-pulse/api/iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_DRIVE_LOCUS_MAPPING.html","description":"Locus mapping name for mapping all components that have the drive operation defined. previous iqm.pulse.gate_implementation.NestedParams next iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_READO...","content":"Locus mapping name for mapping all components that have the drive operation defined. previous iqm.pulse.gate_implementation.NestedParams next iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_READOUT_LOCUS_MAPPING © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"CZ_GaussianSmoothedSquare","url":"/iqm-pulse/api/iqm.pulse.gates.cz.CZ_GaussianSmoothedSquare.html","description":"Bases: FluxPulseGate CZ gate using a GaussianSmoothedSquare flux pulse on the coupler. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested qubit_wave Flux pulse W...","content":"Bases: FluxPulseGate CZ gate using a GaussianSmoothedSquare flux pulse on the coupler. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested qubit_wave Flux pulse Waveform to be played in the qubit flux AWG. symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of GaussianSmoothedSquare Required calibration data, may be nested Flux pulse Waveform to be played in the qubit flux AWG. True iff the implementation is symmetric in its locus components.\\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous CZ_CRF_ACStarkCRF next CZ_Slepian © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.gates.register_implementation","url":"/iqm-pulse/api/iqm.pulse.gates.register_implementation.html","description":"Register a new gate implementation, and a new gate (operation) if needed. operations ( dict [ str , QuantumOp ] ) – Known operations, mapping gate names to QuantumOps gate_name ( str ) – The gate name...","content":"Register a new gate implementation, and a new gate (operation) if needed. operations ( dict [ str , QuantumOp ] ) – Known operations, mapping gate names to QuantumOps gate_name ( str ) – The gate name to register impl_name ( str ) – The name for this implementation impl_class ( type [ GateImplementation ] ) – The implementation class set_as_default ( bool ) – Whether to set as default implementation overwrite ( bool ) – If True, allows replacing existing operation/implementation quantum_op_specs ( QuantumOp | dict | None ) – Specs for creating new quantum op if needed ValueError – If operation/implementation exists and overwrite=False None previous iqm.pulse.gates.get_implementation_class next barrier © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"reset","url":"/iqm-pulse/api/iqm.pulse.gates.reset.html","description":"Resetting qubits to the zero state. The reset operation is a non-unitary quantum channel that sets the state of a qubit to \\\\(|0\\\\rangle\\\\) . Full path: iqm.pulse.gates.reset Module Attributes RESET_MEAS...","content":"Resetting qubits to the zero state. The reset operation is a non-unitary quantum channel that sets the state of a qubit to \\\\(|0\\\\rangle\\\\) . Full path: iqm.pulse.gates.reset Module Attributes RESET_MEASUREMENT_KEY Constant measurement key for the measure operation required in the fast-feedback reset gate (the double underscore emphasizes the fact that this label should not be manually used in fast feedback). RESET_FEEDBACK_KEY The feedback key used in fast-feedback reset gate (the double underscore emphasizes the fact that this label should not be manually used in fast feedback). Classes Reset_Conditional Conditional reset operation. Reset_Wait Reset operation by relaxation (idling for a time comparable to the relaxation time of the component). Inheritance previous PRX_SinglePulse_GateImplementation next iqm.pulse.gates.reset.RESET_MEASUREMENT_KEY © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"Measure_Constant_Qnd","url":"/iqm-pulse/api/iqm.pulse.gates.measure.Measure_Constant_Qnd.html","description":"Bases: Measure_CustomWaveforms Implementation of a single-qubit projective, non quantum demolition, dispersive\\nmeasurements in the Z basis. Uses a constant probe pulse. Module: iqm.pulse.gates.measure...","content":"Bases: Measure_CustomWaveforms Implementation of a single-qubit projective, non quantum demolition, dispersive\\nmeasurements in the Z basis. Uses a constant probe pulse. Module: iqm.pulse.gates.measure Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). parameters Required calibration data, may be nested Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – If set True , the Q channel waveform is considered to depend on the I channel’s waveform\\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\\nwill be initialised as True . Required calibration data, may be nested alias of Constant alias of Constant previous Measure_Constant next Measure_CustomWaveforms © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"validation","url":"/iqm-pulse/api/iqm.pulse.validation.html","description":"Validation of playlists and instructions schedules. Full path: iqm.pulse.validation Functions validate_awg_and_schedule_compatibility (...) Validates that the given playlist is compatible with the pro...","content":"Validation of playlists and instructions schedules. Full path: iqm.pulse.validation Functions validate_awg_and_schedule_compatibility (...) Validates that the given playlist is compatible with the provided AWG data. validate_channel (channel_description, ...) Validate a single channel. validate_instruction_and_wf_length (instruction) Validate that instruction and waveform lengths match validate_playlist_compatibility (playlist, ...) Validates that the given playlist is compatible with the provided AWG data. Classes AWGScheduleValidationData Controller specific validation data Exceptions AWGScheduleValidationError Error raised when schedule validation for an AWG fails. InvalidInstructionError (instruction[, ...]) Error raised when encountering an invalid instruction. PlaylistValidationError Error raised when Playlist validation fails. Inheritance previous iqm.pulse.utils.phase_transformation next iqm.pulse.validation.validate_awg_and_schedule_compatibility © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"measure","url":"/iqm-pulse/api/iqm.pulse.gates.measure.html","description":"Projective measurement in the Z basis. Full path: iqm.pulse.gates.measure Classes Measure_Constant Implementation of a single-qubit projective, dispersive measurement in the Z basis. Measure_Constant_...","content":"Projective measurement in the Z basis. Full path: iqm.pulse.gates.measure Classes Measure_Constant Implementation of a single-qubit projective, dispersive measurement in the Z basis. Measure_Constant_Qnd Implementation of a single-qubit projective, non quantum demolition, dispersive measurements in the Z basis. Measure_CustomWaveforms Base class for implementing dispersive measurement operations with custom probe pulse waveforms. ProbePulse_CustomWaveforms Base class for implementing a probe line measurement pulse with custom waveforms in the I and Q channels. Inheritance previous FluxMultiplexer_SampleLinear next Measure_Constant © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"VirtualRZ","url":"/iqm-pulse/api/iqm.pulse.playlist.instructions.VirtualRZ.html","description":"Bases: Instruction Change the upconversion phase reference. The phase change can be done either by updating the phase of the local oscillator directly using\\na hardware instruction, or algebraically by...","content":"Bases: Instruction Change the upconversion phase reference. The phase change can be done either by updating the phase of the local oscillator directly using\\na hardware instruction, or algebraically by incrementing IQPulse.phase of all the IQPulses\\nfollowing the VirtualRZ instruction in the Segment . Module: iqm.pulse.playlist.instructions Attributes phase_increment Phase increment for the local oscillator of a drive channel, in radians. duration Time duration of the instruction. Methods duration ( int ) – phase_increment ( float ) – Phase increment for the local oscillator of a drive channel, in radians. previous TimeTrace next Wait © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"gate_implementation","url":"/iqm-pulse/api/iqm.pulse.gate_implementation.html","description":"Implementing abstract quantum operations as instruction schedules. Note Note the conceptual difference between quantum operations (ops) and instruction schedules . Ops represent abstract, ideal comput...","content":"Implementing abstract quantum operations as instruction schedules. Note Note the conceptual difference between quantum operations (ops) and instruction schedules . Ops represent abstract, ideal computational\\noperations, whereas instruction schedules represent concrete control signal sequences for the\\nquantum computer. One can (approximately) implement an op using a number of different\\ninstruction schedules. Full path: iqm.pulse.gate_implementation Module Attributes Locus Sequence of QPU component physical names a quantum operation is acting on. OILCalibrationData Calibration data for a particular implementation of a particular quantum operation at a particular locus. OICalibrationData For a particular implementation of a particular quantum operation, maps operation loci to their calibration data. OCalibrationData For a particular quantum operation, maps implementation names to their calibration data. OpCalibrationDataTree Maps quantum operation names to their calibration data. NestedParams Nested dict defining the parameters required by GateImplementation classes. SINGLE_COMPONENTS_WITH_DRIVE_LOCUS_MAPPING Locus mapping name for mapping all components that have the drive operation defined. SINGLE_COMPONENTS_WITH_READOUT_LOCUS_MAPPING Locus mapping name for mapping all components that have the readout operation defined. SINGLE_COMPONENTS_WITH_FLUX_AWG_LOCUS_MAPPING Locus mapping name for mapping all components that have the flux operation defined and the flux controller has an AWG. PROBE_LINES_LOCUS_MAPPING Locus mapping name for mapping all probe lines. Functions get_waveform_parameters (wave[, label_prefix]) Parameters that are required to initialize the given Waveform class. Classes CompositeCache Cache for CompositeGate TimeBoxes. CompositeGate Utility base class for creating gate implementations that are defined in terms of other gate implementations. CustomIQWaveforms Base class for GateImplementations using custom waveform definition with IQPulses. GateImplementation ABC for implementing quantum gates and other quantum operations using instruction schedules. SinglePulseGate Base class for GateImplementations that play a single pulse on a single channel. Inheritance previous CircuitOperationList next iqm.pulse.gate_implementation.Locus © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"Block","url":"/iqm-pulse/api/iqm.pulse.playlist.instructions.Block.html","description":"Bases: Instruction Behave strictly as if outputting zero-valued samples for the duration of the instruction. Used to block a control channel during compilation.\\nA more strict version of Wait , cannot ...","content":"Bases: Instruction Behave strictly as if outputting zero-valued samples for the duration of the instruction. Used to block a control channel during compilation.\\nA more strict version of Wait , cannot be replaced with DD sequences during compilation.\\nConverted to a Wait instruction at the end of compilation process. In “Tetris” scheduling, several Block instructions can overlap in time, whereas Waits cannot. Module: iqm.pulse.playlist.instructions Attributes duration Time duration of the instruction. Methods duration ( int ) – previous AcquisitionMethod next ComplexIntegration © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"waveforms","url":"/iqm-pulse/api/iqm.pulse.playlist.waveforms.html","description":"Waveform definitions. This module defines some waveforms that don’t have special serialization, and reimports\\nwaveforms that do from iqm.models.playlist.waveforms .\\nSee the link for documentation of w...","content":"Waveform definitions. This module defines some waveforms that don’t have special serialization, and reimports\\nwaveforms that do from iqm.models.playlist.waveforms .\\nSee the link for documentation of waveforms that don’t appear here. Full path: iqm.pulse.playlist.waveforms Classes Chirp Linear chirp, defined as ChirpImag Imaginary part of the linear chirp, which sets the phase to $-pi/2$. Cosine Periodic sinusoidal waveform which defaults to cosine. CosineFall Cosine Rise waveform. CosineRise Cosine Rise waveform. CosineRiseFallDerivative Derivative of a waveform that has a sinusoidal rise and fall, and a constant part in between. ModulatedCosineRiseFall Modulated Cosine Rise Fall waveform. Slepian Slepian waveform, which minimizes non-adiabatic errors during a gate. Inheritance previous iqm.pulse.playlist.visualisation.base.inspect_playlist next Chirp © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.gates.get_implementation_class","url":"/iqm-pulse/api/iqm.pulse.gates.get_implementation_class.html","description":"Get gate implementation class by class name. class_name ( str ) – type [ GateImplementation ] | None previous iqm.pulse.gates.expose_implementation next iqm.pulse.gates.register_implementation © Copyr...","content":"Get gate implementation class by class name. class_name ( str ) – type [ GateImplementation ] | None previous iqm.pulse.gates.expose_implementation next iqm.pulse.gates.register_implementation © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"ChannelProperties","url":"/iqm-pulse/api/iqm.pulse.playlist.channel.ChannelProperties.html","description":"Bases: object Defines the properties of a control or measurement channel. All ZI instruments (HDAWG, UHFQA, SHFSG, SHFQA) can handle control pulses and waits where the\\nnumber of samples is 32 + n * 16...","content":"Bases: object Defines the properties of a control or measurement channel. All ZI instruments (HDAWG, UHFQA, SHFSG, SHFQA) can handle control pulses and waits where the\\nnumber of samples is 32 + n * 16 , where n in {0, 1, 2, ...} . Module: iqm.pulse.playlist.channel Attributes blocks_component Whether content in this channel should block the entire component that it is associated with in the scheduling. is_iq HACK, True iff this is an IQ channel. is_virtual Virtual channels are only used on the frontend side during compilation and scheduling. sample_rate sample rate of the instrument responsible for the channel (in Hz) instruction_duration_granularity all instruction durations on this channel must be multiples of this granularity (in samples) instruction_duration_min all instruction durations on this channel must at least this long (in samples) compatible_instructions instruction types that are allowed on this channel Methods duration_to_int_samples Convert a time duration to an integer number of samples at the channel sample rate. duration_to_samples Convert a time duration to number of samples at the channel sample rate. duration_to_seconds Convert a time duration in samples at the channel sample rate to seconds. round_duration_to_granularity Round a time duration to the channel granularity. sample_rate ( float ) – instruction_duration_granularity ( int ) – instruction_duration_min ( int ) – compatible_instructions ( tuple [ type [ Instruction ] , ... ] ) – is_iq ( bool ) – is_virtual ( bool ) – blocks_component ( bool ) – sample rate of the instrument responsible for the channel (in Hz) all instruction durations on this channel must be multiples of this granularity (in samples) all instruction durations on this channel must at least this long (in samples) instruction types that are allowed on this channel HACK, True iff this is an IQ channel. TODO do better Virtual channels are only used on the frontend side during compilation and scheduling.\\nThey are removed from the Schedule before it is sent to Station\\nControl. For example, virtual drive channels of computational resonators. Whether content in this channel should block the entire component that it is associated with in the scheduling.\\nTypically all physical channels should block their components, but certain virtual channels might not\\nrequire this. Convert a time duration to number of samples at the channel sample rate. duration ( float ) – time duration in s duration in samples float Convert a time duration in samples at the channel sample rate to seconds. duration ( float ) – time duration in samples duration in seconds float Convert a time duration to an integer number of samples at the channel sample rate. duration must be sufficiently close to an integer number of samples, and\\nthat number must be something the channel can handle. duration ( float ) – time duration in s message ( str ) – message identifying the duration we are testing check_min_samples ( bool ) – If True, check that the output is at least instruction_duration_min . duration as an integer number of samples ValueError – duration is not close to an integer number of samples, or is\\n    otherwise unacceptable to the channel int Round a time duration to the channel granularity. duration ( float ) – time duration in s round_up ( bool ) – whether to round the durations up, or to the closest granularity force_min_duration ( bool ) – whether to force the duration to be at least instruction_duration_min duration rounded to channel granularity, in s float previous ChannelDescription next IQChannelConfig © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"XYGate","url":"/iqm-pulse/api/iqm.pulse.gates.enums.XYGate.html","description":"Bases: IntEnum Enumerate all single-qubit Clifford gates whose rotation axis is in the XY plane. Members of this enum can be mapped to the corresponding unitary propagator using XYGATE_UNITARIES . Onl...","content":"Bases: IntEnum Enumerate all single-qubit Clifford gates whose rotation axis is in the XY plane. Members of this enum can be mapped to the corresponding unitary propagator using XYGATE_UNITARIES . Only used in the tomography experiments. Module: iqm.pulse.gates.enums Attributes IDENTITY  X_90  X_180  X_M90  Y_90  Y_180  Y_M90  Methods previous TwoQubitGate next flux_multiplexer © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.gates.rz.get_unitary_rz","url":"/iqm-pulse/api/iqm.pulse.gates.rz.get_unitary_rz.html","description":"Unitary for an RZ gate. angle ( float ) – rotation angle (in rad) 2x2 unitary representing rz(angle) . ndarray previous rz next RZ_ACStarkShift © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last...","content":"Unitary for an RZ gate. angle ( float ) – rotation angle (in rad) 2x2 unitary representing rz(angle) . ndarray previous rz next RZ_ACStarkShift © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.gates.flux_multiplexer.TOLERANCE","url":"/iqm-pulse/api/iqm.pulse.gates.flux_multiplexer.TOLERANCE.html","description":"Tolerance for the maximum absolute value in a waveform for considering it to be uniformly zero. previous flux_multiplexer next FluxMultiplexer_SampleLinear © Copyright 2019-2025, IQM Finland Oy, Relea...","content":"Tolerance for the maximum absolute value in a waveform for considering it to be uniformly zero. previous flux_multiplexer next FluxMultiplexer_SampleLinear © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"CircuitOperationList","url":"/iqm-pulse/api/iqm.pulse.circuit_operations.CircuitOperationList.html","description":"Bases: list List of CircuitOperation objects representing a quantum circuit. The class is used to work with CircuitOperations directly. It is mostly meant as\\nconvenience to enable easy creation of cir...","content":"Bases: list List of CircuitOperation objects representing a quantum circuit. The class is used to work with CircuitOperations directly. It is mostly meant as\\nconvenience to enable easy creation of circuits, calculations of their properties, and mapping them onto physical\\nqubits. In addition to the circuit contents, this class has two important attributes: qubits and table . qubits defines the list of qubits which are allowed to be in the loci of all the\\nCircuitOperations present in the list. Think about it as Qiskit’s QuantumRegister. table is a QuantumOpTable , which contains all the QuantumOp s which are allowed in the circuit. In most cases, the table is\\nsimply taken to contain all the default operations defined in iqm.pulse .\\nWhen you use this class with a ScheduleBuilder , it is good practice to set table = builder.op_table . The QuantumOpTable is mutable, so any additional registered\\ngates can automatically be usable in any CircuitOperationList associated with that\\nScheduleBuilder instance. The fundamental use of the class would be to first define a new instance: The num_qubits parameter populates the qubits attribute with qubits QB1-QBn,\\nin this case ['QB1', 'QB2'] . Alternatively, you can provide qubits directly: To add your own QuantumOpTable, initialize like this: Remembering that the table is mutable. If you already have a list of CircuitOperations, you can initialize with it: Calling the find_qubits() method populates the qubits attribute with the qubits found in loci of\\nthe operations in the original circuit. If the list is empty, it will set qubits to an empty list,\\nwhich most of the time is not what you want to do. The class has the __add__ , __mul__ and __getitem__ methods redefined, which means circuit * 3 , circuit1 + circuit2 and circuit[0:4] will produce a CircuitOperationList\\nwith the same qubits and table attributes as the original. To add a prx operation to the list, call: The class also has shortcut methods defined, so the above can be shortened to which is exactly the same syntax as in Qiskit, with the addition of the implementation name\\nwhich usually does not need to be used. The names of the shortcut methods are taken from the\\nattached table at init. All the operations with non-zero arity\\nwill be added as shortcuts. If all the operations in the circuit are unitary, you can calculate the unitary propagator of\\nthe entire circuit by calling: The dimension of the unitary will always be defined by the qubits attribute. In particular, if your circuit\\ncontains 3 qubits, 'QB1', 'QB2', 'QB3' , but you only add gates to the first two, the resulting unitary will\\nstill be an 8x8 matrix, corresponding to the three qubits 'QB1', 'QB2', 'QB3' , in the big endian convention.\\nWith no operations affecting 'QB3' , the action of the unitary on this qubit is identity. To map the circuit onto physical qubits, all you need to do is call: This will create a copy of the circuit, with all the placeholder qubits replaced by the physical qubits, with the\\norder defined by the qubits attribute. For example, if qubits = ['QB1', 'Alice', 'ZZZ'] , and physical_qubits = ['QB2', 'QB5', 'QB10'] , all occurrences of 'QB1' will be mapped to 'QB2' , 'Alice' to 'QB5' and 'ZZZ' to 'QB10' . The original circuit is not modified, so you can create many copies with\\ndifferent physical qubits, which is helpful when running parallel experiments on a large chip. contents ( Iterable [ CircuitOperation ] ) – Circuit operations to initialize the circuit with. Can be left out. qubits ( list [ str ] ) – Qubits allowed to be used in operation loci in the circuit. num_qubits ( int ) – Number of qubits in the circuit, will initialize qubits with ['QB1', 'QB2', ...] .\\nIgnored if qubits is given. table ( QuantumOpTable | None ) – Allowed quantum operations. Module: iqm.pulse.circuit_operations Attributes qubits  Methods add_op Adds a new CircuitOperation to the circuit. add_qubits Adds generic placeholder qubits from 1 to n. barrier Add barrier to the circuit compose A safer way to add circuits together, but will probably take time. count_ops Count each type of operation in the circuit. find_qubits Set attribute qubits to qubits in the loci of operations in the list. get_unitary Calculate the overall unitary implemented by a sequence of CircuitOperations. map_loci Creates a new list of CircuitOperation s with locus mapped onto physical qubits. Set attribute qubits to qubits in the loci of operations in the list. None Adds generic placeholder qubits from 1 to n. n ( int ) – None Calculate the overall unitary implemented by a sequence of CircuitOperations. self – list of CircuitOperations in order qubit_names ( list [ str ] | None ) – Optionally, the ordering of the qubits. Array describing the action of the circuit in big endian convention. ndarray Adds a new CircuitOperation to the circuit. Appends a new CircuitOperation at the end of the list. The CircuitOperation is created using a QuantumOp name from the\\nQuantumOpTable attached to the CircuitOperationList. The locus of that CircuitOperation is built from the qubits stored in qubits , by selecting\\nthe qubits at indices given by locus_indices . For example, if qubits is ['QB1', 'QB2', 'QB4'] , and the locus_indices is [2, 1] , the locus of the new CircuitOperation will be ('QB4', 'QB2') . All arguments for the values of the\\nparams of the requested QuantumOp need to be provided. name ( str ) – Name of the QuantumOp which will generate a new CircuitOperation . locus_indices ( Sequence [ int ] ) – Indices of the qubits in the attribute .qubits which will become the locus of the operation. args – Any arguments the CircuitOperation needs, must correspond to the params of the QuantumOp . impl_name ( str | None ) – Name of the implementation to use when converting the CircuitOperation into\\na Timebox later. None Add barrier to the circuit None A safer way to add circuits together, but will probably take time. All the CircuitOperation s from the 'other' list are appended to the end of\\nthis list. The wire k of the second circuit is connected to wire locus_indices[k] of the first. This\\nis achieved by mapping the locus of each operation in the second circuit onto the qubits of the first. For example, if the qubits of the first list are ['QB1', 'QB2'] , the second list has ['QB3', 'QB4'] , and the locus_indices argument is [1,0] , all the operations in the second list will have\\ntheir 'QB3' mapped to 'QB2' and 'QB4' mapped to 'QB1' . other – Second CircuitOperationList. Must have less or equal qubits than this one. locus_indices ( list [ int ] | None ) – Indices of the qubits in this CircuitOperationList onto which the qubits in the second\\ncircuit ar mapped. Self, with new operations added. Self Count each type of operation in the circuit. Counter mapping operation names to numbers of times they occur in the circuit. Counter Creates a new list of CircuitOperation s with locus mapped onto physical qubits. Creates a fresh list of fresh CircuitOperation s with fresh arguments. If locus is provided, it needs to have the same length as the total number of qubits across the circuit,\\nand the qubits will then be mapped onto the new locus. If it is not provided, this is identical to a deepcopy\\nof the original list. locus ( list [ str ] | None ) – List of new qubits to replace the qubits in the loci of the operations in the circuit. make_circuit ( bool ) – If True, creates a CircuitOperationList . If False, it is just a list. New CircuitOperationList with loci mapped onto new locus. CircuitOperationList | list [ CircuitOperation ] Add the convenience methods for adding new operations, based on the default QuantumOpTable . name ( str ) – None previous iqm.pulse.circuit_operations.reshape_unitary next gate_implementation © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"sx","url":"/iqm-pulse/api/iqm.pulse.gates.sx.html","description":"Single-qubit sqrt(X) gate. The gate is doing pi/2 X gate, with additional Z rotation to correct phase. It rotates the qubit state in XZ plane (or around Y axis) for 90 degree. Full path: iqm.pulse.gat...","content":"Single-qubit sqrt(X) gate. The gate is doing pi/2 X gate, with additional Z rotation to correct phase. It rotates the qubit state in XZ plane (or around Y axis) for 90 degree. Full path: iqm.pulse.gates.sx Classes SXGate SX gate implementation based on PRX gate, by limiting the angle to pi / 2. Inheritance previous RZ_Virtual next SXGate © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.playlist.visualisation.base.inspect_playlist","url":"/iqm-pulse/api/iqm.pulse.playlist.visualisation.base.inspect_playlist.html","description":"Creates an HTML string from the given playlist and segments. The output can be viewed in a browser or in a Jupyter notebook using IPython.core.display.HTML . playlist ( Playlist ) – The Playlist to be...","content":"Creates an HTML string from the given playlist and segments. The output can be viewed in a browser or in a Jupyter notebook using IPython.core.display.HTML . playlist ( Playlist ) – The Playlist to be visualised segments ( Sequence [ int ] ) – Indices of the Playlist segments to inspect. The generated raw HTML string. str previous base next waveforms © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.playlist.hd_drag.solve_cosine_coefs_for_hd_drag","url":"/iqm-pulse/api/iqm.pulse.playlist.hd_drag.solve_cosine_coefs_for_hd_drag.html","description":"Solve cosine coefficients of the basis envelope given the number of suppressed frequencies. The cosine coefficients \\\\(\\\\{d_k\\\\}_{k=1}^{K+1}\\\\) define the basis envelope as \\\\(g(t) = \\\\sum_{k=1}^{K+1} d_k (...","content":"Solve cosine coefficients of the basis envelope given the number of suppressed frequencies. The cosine coefficients \\\\(\\\\{d_k\\\\}_{k=1}^{K+1}\\\\) define the basis envelope as \\\\(g(t) = \\\\sum_{k=1}^{K+1} d_k (1 - \\\\cos(2\\\\pi k t/t_p + k\\\\pi))\\\\) , where the pulse is defined on the\\ninterval \\\\(t \\\\in [-t_p/2, t_p/2]\\\\) . number_of_suppressed_freqs ( int ) – Number of suppressed frequencies Coefficient array of length number_of_suppressed_freqs + 1 ndarray previous iqm.pulse.playlist.hd_drag.evaluate_nth_derivative_of_basis_envelope next iqm.pulse.playlist.hd_drag.solve_hd_drag_coefficients_from_suppressed_frequencies © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.validation.validate_playlist_compatibility","url":"/iqm-pulse/api/iqm.pulse.validation.validate_playlist_compatibility.html","description":"Validates that the given playlist is compatible with the provided AWG data. The following requirements are validated as they are the same for all controllers. Playlist sample rate vs. Actual controlle...","content":"Validates that the given playlist is compatible with the provided AWG data. The following requirements are validated as they are the same for all controllers. Playlist sample rate vs. Actual controller sample rate Instruction granularity with respect to the controllers granularity requirements Checks that no other than supported instructions are used. Checks that instruction length matches waveform length in IQ and RealPulse Checks that all instructions are at least the length of minimum number of samples Checks that Conditional instruction has the same duration in every child instruction playlist ( Playlist ) – instructions used on each channel, as well as the channel configurations device_constraints ( dict [ str , ChannelProperties ] ) – actual hardware limitations of the channels None previous iqm.pulse.validation.validate_instruction_and_wf_length next AWGScheduleValidationData © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"RealChannelConfig","url":"/iqm-pulse/api/iqm.pulse.playlist.channel.RealChannelConfig.html","description":"Bases: ChannelConfiguration Requested configuration of a real channel. Module: iqm.pulse.playlist.channel Attributes sample_rate sample rate of the instrument responsible for the channel (in Hz) Metho...","content":"Bases: ChannelConfiguration Requested configuration of a real channel. Module: iqm.pulse.playlist.channel Attributes sample_rate sample rate of the instrument responsible for the channel (in Hz) Methods sample_rate ( float ) – sample rate of the instrument responsible for the channel (in Hz) previous ProbeChannelProperties next fast_drag © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.circuit_operations.reorder","url":"/iqm-pulse/api/iqm.pulse.circuit_operations.reorder.html","description":"Permutes the order of the qubits in an n-qubit operator matrix. A ( ndarray ) – Matrix of an operator acting on the state space of n qubits, to be reordered. perm ( list [ int ] ) – Permutation vector...","content":"Permutes the order of the qubits in an n-qubit operator matrix. A ( ndarray ) – Matrix of an operator acting on the state space of n qubits, to be reordered. perm ( list [ int ] ) – Permutation vector for the n qubits. perm[k] is the new index for the k:th qubit in the old ordering.\\nFor example, reorder(kron(A, B, C)), [2, 0, 1]) == kron(B, C, A) . Reordered A . ndarray previous iqm.pulse.circuit_operations.get_unitary_from_op next iqm.pulse.circuit_operations.reshape_unitary © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"PRX_ModulatedDRAGCosineRiseFall","url":"/iqm-pulse/api/iqm.pulse.gates.prx.PRX_ModulatedDRAGCosineRiseFall.html","description":"Bases: PRX_ModulatedCustomWaveForms Modulated PRX pulse with cosine rise fall waveform Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depe...","content":"Bases: PRX_ModulatedCustomWaveForms Modulated PRX pulse with cosine rise fall waveform Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). excluded_parameters Parameters names to be excluded from self.parameters . parameters Required calibration data, may be nested Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – If set True , the Q channel waveform is considered to depend on the I channel’s waveform\\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\\nwill be initialised as True . Required calibration data, may be nested alias of CosineRiseFall alias of CosineRiseFallDerivative Parameters names to be excluded from self.parameters . Inheriting classes may override this if certain\\nparameters are not wanted in that class (also parameters defined by the waveforms can be excluded). Return the IQPulse with modulated arbitrary waveform based on the calibration data. IQPulse previous PRX_ModulatedCustomWaveForms next PRX_SinglePulse_GateImplementation © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.quantum_ops.QuantumOpTable","url":"/iqm-pulse/api/iqm.pulse.quantum_ops.QuantumOpTable.html","description":"Type for representing tables of known quantum operations, maps names of the ops to their definitions. alias of dict [ str , QuantumOp ] previous quantum_ops next iqm.pulse.quantum_ops.validate_locus_c...","content":"Type for representing tables of known quantum operations, maps names of the ops to their definitions. alias of dict [ str , QuantumOp ] previous quantum_ops next iqm.pulse.quantum_ops.validate_locus_calibration © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"SXGate","url":"/iqm-pulse/api/iqm.pulse.gates.sx.SXGate.html","description":"Bases: CompositeGate SX gate implementation based on PRX gate, by limiting the angle to pi / 2. Module: iqm.pulse.gates.sx Attributes registered_gates Gates that can be calibrated separately from thei...","content":"Bases: CompositeGate SX gate implementation based on PRX gate, by limiting the angle to pi / 2. Module: iqm.pulse.gates.sx Attributes registered_gates Gates that can be calibrated separately from their common calibration existing in self.builder . Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Gates that can be calibrated separately from their common calibration existing in self.builder . The gate\\nnames should correspond to the keys in self.builder.op_table . Other gates besides the ones given here can\\nalso be constructed via self.builder , but these will always use the common calibration. Call PRX gate with angle equals to pi / 2. TimeBox previous sx next u © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"UGate","url":"/iqm-pulse/api/iqm.pulse.gates.u.UGate.html","description":"Bases: CompositeGate SU(2) gate implemented using PRX. Assumes the chosen PRX implementation uses resonant driving, and that the virtual RZ technique can be used. Module: iqm.pulse.gates.u Attributes ...","content":"Bases: CompositeGate SU(2) gate implemented using PRX. Assumes the chosen PRX implementation uses resonant driving, and that the virtual RZ technique can be used. Module: iqm.pulse.gates.u Attributes registered_gates Gates that can be calibrated separately from their common calibration existing in self.builder . Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Gates that can be calibrated separately from their common calibration existing in self.builder . The gate\\nnames should correspond to the keys in self.builder.op_table . Other gates besides the ones given here can\\nalso be constructed via self.builder , but these will always use the common calibration. Convert pulses into timebox, via Euler decomposition. theta ( float ) – phi ( float ) – lam ( float ) – TimeBox previous iqm.pulse.gates.u.get_unitary_u next playlist © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"quantum_ops","url":"/iqm-pulse/api/iqm.pulse.quantum_ops.html","description":"Quantum operations. Full path: iqm.pulse.quantum_ops Module Attributes QuantumOpTable Type for representing tables of known quantum operations, maps names of the ops to their definitions. Functions va...","content":"Quantum operations. Full path: iqm.pulse.quantum_ops Module Attributes QuantumOpTable Type for representing tables of known quantum operations, maps names of the ops to their definitions. Functions validate_locus_calibration (cal_data, impl, ...) Validates calibration for a particular gate implementation at particular locus. validate_op_calibration (calibration, ops) Validates quantum operation calibration data against the known quantum operations. Classes QuantumOp Describes a native quantum operation type. Inheritance previous Slepian next iqm.pulse.quantum_ops.QuantumOpTable © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"ReadoutTrigger","url":"/iqm-pulse/api/iqm.pulse.playlist.instructions.ReadoutTrigger.html","description":"Bases: Instruction Instruction for playing a probe pulse and acquiring the associated readout results. Module: iqm.pulse.playlist.instructions Attributes probe_pulse Probe pulse to play, usually a Mul...","content":"Bases: Instruction Instruction for playing a probe pulse and acquiring the associated readout results. Module: iqm.pulse.playlist.instructions Attributes probe_pulse Probe pulse to play, usually a MultiplexedIQPulse. acquisitions Active readout acquisition methods associated with this trigger instance. duration Time duration of the instruction. Methods duration ( int ) – probe_pulse ( MultiplexedIQPulse ) – acquisitions ( tuple [ AcquisitionMethod , ... ] ) – Probe pulse to play, usually a MultiplexedIQPulse. Active readout acquisition methods associated with this trigger instance. previous MultiplexedIQPulse next RealPulse © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"barrier","url":"/iqm-pulse/api/iqm.pulse.gates.barrier.html","description":"Barrier metaoperation. The barrier is an n-qubit metaoperation that forces a specific temporal ordering on the quantum\\noperations on different sides of it (the ones preceding the barrier are always ex...","content":"Barrier metaoperation. The barrier is an n-qubit metaoperation that forces a specific temporal ordering on the quantum\\noperations on different sides of it (the ones preceding the barrier are always executed first). Full path: iqm.pulse.gates.barrier Classes Barrier GateImplementation for the n-qudit barrier metaoperation. Inheritance previous iqm.pulse.gates.register_implementation next Barrier © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"default_gates","url":"/iqm-pulse/api/iqm.pulse.gates.default_gates.html","description":"This file defines the default quantum gates and operations for IQM’s pulse control system Full path: iqm.pulse.gates.default_gates previous FluxPulseGate_TGSS_CRF next delay © Copyright 2019-2025, IQM...","content":"This file defines the default quantum gates and operations for IQM’s pulse control system Full path: iqm.pulse.gates.default_gates previous FluxPulseGate_TGSS_CRF next delay © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"enums","url":"/iqm-pulse/api/iqm.pulse.gates.enums.html","description":"Enumerations for representing a set of important one- and two-qubit gates. Full path: iqm.pulse.gates.enums Module Attributes XYGATE_UNITARIES Mapping of XYGates to the corresponding SU(2) matrices TW...","content":"Enumerations for representing a set of important one- and two-qubit gates. Full path: iqm.pulse.gates.enums Module Attributes XYGATE_UNITARIES Mapping of XYGates to the corresponding SU(2) matrices TWO_QUBIT_UNITARIES Mapping of TwoQubitGates to the corresponding U(4) matrices Classes TwoQubitGate Enumerates a subset of two-qubit gates. XYGate Enumerate all single-qubit Clifford gates whose rotation axis is in the XY plane. Inheritance previous Delay next iqm.pulse.gates.enums.XYGATE_UNITARIES © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"Nothing","url":"/iqm-pulse/api/iqm.pulse.playlist.schedule.Nothing.html","description":"Bases: Instruction Used to extend a control channel in time, without blocking it, during scheduling. Can overlap with any other Instruction.\\nConverted to a Wait instruction at the end of scheduling. M...","content":"Bases: Instruction Used to extend a control channel in time, without blocking it, during scheduling. Can overlap with any other Instruction.\\nConverted to a Wait instruction at the end of scheduling. Module: iqm.pulse.playlist.schedule Attributes duration Time duration of the instruction. Methods duration ( int ) – previous iqm.pulse.playlist.schedule.TOLERANCE next Schedule © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"CZ_Slepian","url":"/iqm-pulse/api/iqm.pulse.gates.cz.CZ_Slepian.html","description":"Bases: FluxPulseGate CZ gate using a Slepian flux pulse on the coupler. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested qubit_wave Flux pulse Waveform to be p...","content":"Bases: FluxPulseGate CZ gate using a Slepian flux pulse on the coupler. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested qubit_wave Flux pulse Waveform to be played in the qubit flux AWG. symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of Slepian Required calibration data, may be nested Flux pulse Waveform to be played in the qubit flux AWG. True iff the implementation is symmetric in its locus components.\\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous CZ_GaussianSmoothedSquare next CZ_Slepian_ACStarkCRF © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.playlist.hd_drag.solve_hd_drag_coefficients_from_suppressed_frequencies","url":"/iqm-pulse/api/iqm.pulse.playlist.hd_drag.solve_hd_drag_coefficients_from_suppressed_frequencies.html","description":"Solve coefficients of the derivative terms in a HD DRAG pulse given pulse duration and frequencies to suppress. The coefficients \\\\(\\\\{\\\\beta_{2n}}_{n=0}^{K}\\\\) of the derivative terms are solved using Eq...","content":"Solve coefficients of the derivative terms in a HD DRAG pulse given pulse duration and frequencies to suppress. The coefficients \\\\(\\\\{\\\\beta_{2n}}_{n=0}^{K}\\\\) of the derivative terms are solved using Eq. (B5) of [ 1 ] assuming that \\\\(\\\\beta_0 = 1\\\\) . Here, \\\\(K\\\\) is the number of suppressed frequencies. Note that the duration and frequencies must have matching units, e.g., s and Hz, or ns and GHz. pulse_duration ( float ) – Pulse duration (in s). suppressed_freq_arr ( tuple [ float , ... ] ) – Frequencies to be suppressed relative to the center drive frequency (in Hz). Coefficient array of length len(suppressed_freq_arr) + 1 ndarray previous iqm.pulse.playlist.hd_drag.solve_cosine_coefs_for_hd_drag next HdDrag © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.playlist.fast_drag.fourier_transform_of_cos_basis_functions_as_tensor","url":"/iqm-pulse/api/iqm.pulse.playlist.fast_drag.fourier_transform_of_cos_basis_functions_as_tensor.html","description":"Evaluate Fourier transforms of cosine basis functions for given basis function indices and frequencies. The nth cosine basis function is given by \\\\(g_n(t) = 1 -  \\\\cos(2 \\\\pi n t/t_p)\\\\) defined on the i...","content":"Evaluate Fourier transforms of cosine basis functions for given basis function indices and frequencies. The nth cosine basis function is given by \\\\(g_n(t) = 1 -  \\\\cos(2 \\\\pi n t/t_p)\\\\) defined on the interval \\\\([0, t_p]\\\\) , where \\\\(t_p\\\\) is the pulse duration. The Fourier transform can be analytically evaluated, see\\nEq. (A7) of [ 1 ] . We evaluate the Fourier transform for the basis function indices given by n_arr and for the frequencies given by frequency_arr . We store the Fourier transforms as a tensor of dimension 1+dim(frequency_arr) , such that the first dimension corresponds to the basis function indices, and the following\\ndimensions to those of frequency_arr . Thus, the Fourier transform is evaluated essentially for the cartesian\\nproduct of n_arr and frequency_arr . n_arr ( ndarray ) – 1d array of basis function indices, running typically from 1 to N, where N is the\\nnumber of considered basis functions frequencies ( ndarray ) – N-dimensional array of frequencies (in Hz), at which the Fourier transform is evaluated.\\nFor the computation of FAST DRAG coefficients, N=2 . pulse_duration ( float ) – Pulse duration (in s), without zero padding. Array containing the Fourier transform as a tensor with a shape (len(n_arr), *frequency_arr.shape) ndarray previous iqm.pulse.playlist.fast_drag.evaluate_fast_drag_q_envelope next iqm.pulse.playlist.fast_drag.solve_fast_coefficients_for_given_weights_and_ranges © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"base_utils","url":"/iqm-pulse/api/iqm.pulse.base_utils.html","description":"Base utility functions with no dependencies on other iqm.pulse modules. Full path: iqm.pulse.base_utils Functions merge_dicts (A, B[, path, merge_nones]) Merge two dictionaries recursively, leaving th...","content":"Base utility functions with no dependencies on other iqm.pulse modules. Full path: iqm.pulse.base_utils Functions merge_dicts (A, B[, path, merge_nones]) Merge two dictionaries recursively, leaving the originals unchanged. previous pulse next iqm.pulse.base_utils.merge_dicts © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.playlist.fast_drag.evaluate_fast_drag_i_envelope","url":"/iqm-pulse/api/iqm.pulse.playlist.fast_drag.evaluate_fast_drag_i_envelope.html","description":"Evaluate I-envelope of a FAST DRAG pulse for given coefficients. The I-envelope is defined as \\\\(I(t) = \\\\sum_{n=1}^{N} c_n [1 - (-1)^n \\\\cos(2\\\\pi n t/t_p)]\\\\) , where \\\\(N\\\\) is\\nthe number of cosine terms ...","content":"Evaluate I-envelope of a FAST DRAG pulse for given coefficients. The I-envelope is defined as \\\\(I(t) = \\\\sum_{n=1}^{N} c_n [1 - (-1)^n \\\\cos(2\\\\pi n t/t_p)]\\\\) , where \\\\(N\\\\) is\\nthe number of cosine terms in the series, \\\\(\\\\{c_n\\\\}\\\\) are the coefficients, and the pulse is defined on the\\ninterval \\\\(t \\\\in [-t_p/2, t_p/2]\\\\) . t_arr ( ndarray ) – Array of time points, at which the function is to be evaluated pulse_duration ( float ) – Pulse duration in the same units as t_arr coefficients ( ndarray ) – Coefficients of a FAST DRAG pulse I-envelope of a FAST DRAG pulse evaluated at t_arr ndarray previous iqm.pulse.playlist.fast_drag.compute_matrix_of_summed_fourier_transform_inner_products next iqm.pulse.playlist.fast_drag.evaluate_fast_drag_q_envelope © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"RZ_PRX_Composite","url":"/iqm-pulse/api/iqm.pulse.gates.rz.RZ_PRX_Composite.html","description":"Bases: CompositeGate RZ gate implemented as a sequence of PRX gates. Module: iqm.pulse.gates.rz Attributes registered_gates Gates that can be calibrated separately from their common calibration existi...","content":"Bases: CompositeGate RZ gate implemented as a sequence of PRX gates. Module: iqm.pulse.gates.rz Attributes registered_gates Gates that can be calibrated separately from their common calibration existing in self.builder . Methods Gates that can be calibrated separately from their common calibration existing in self.builder . The gate\\nnames should correspond to the keys in self.builder.op_table . Other gates besides the ones given here can\\nalso be constructed via self.builder , but these will always use the common calibration. previous RZ_ACStarkShift_smoothConstant next RZ_Virtual © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.gate_implementation.Locus","url":"/iqm-pulse/api/iqm.pulse.gate_implementation.Locus.html","description":"Sequence of QPU component physical names a quantum operation is acting on. The order may matter. alias of tuple [ str , …] previous gate_implementation next iqm.pulse.gate_implementation.OILCalibratio...","content":"Sequence of QPU component physical names a quantum operation is acting on. The order may matter. alias of tuple [ str , …] previous gate_implementation next iqm.pulse.gate_implementation.OILCalibrationData © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.playlist.fast_drag.solve_fast_coefficients_for_given_weights_and_ranges","url":"/iqm-pulse/api/iqm.pulse.playlist.fast_drag.solve_fast_coefficients_for_given_weights_and_ranges.html","description":"Solve for optimal coefficients of the basis functions in a FAST DRAG pulse. Computes the optimal coefficients \\\\(\\\\{c_n\\\\}_{n=1}^N\\\\) for a FAST DRAG pulse with \\\\(N\\\\) basis functions\\nsuch that the pulse s...","content":"Solve for optimal coefficients of the basis functions in a FAST DRAG pulse. Computes the optimal coefficients \\\\(\\\\{c_n\\\\}_{n=1}^N\\\\) for a FAST DRAG pulse with \\\\(N\\\\) basis functions\\nsuch that the pulse spectrum is suppressed across the given frequency ranges according to the provided weights.\\nThe computation is based on  Eqs. (A5), (A7), (A12) and (A13) of [ 1 ] . Note that this function essentially computes the mapping from frequency-domain parameters of a FAST DRAG pulse\\nto time-domain parameters. The results must be cached to allow efficient generation of playlists containing a large number of pulses with\\nsame parameters, as in RB. number_of_cosines ( int ) – Number of cosine basis functions used in the FAST DRAG pulse pulse_duration ( float ) – Pulse duration (in s) without zero padding. weights_tuple ( tuple [ float , ... ] ) – 1d tuple of weights for each suppressed frequency interval used in the objective function suppressed_freq_ranges_2d_tuple ( tuple [ tuple [ float , ... ] , ... ] ) – 2d tuple describing the frequency ranges (in Hz), over which we want to\\nsuppress the Fourier transform. Each element of the outer tuple should be a tuple of two floats, the first\\nsetting the starting frequency for the given range and the second setting the ending frequency for the\\ngiven range. n_points_for_integration ( int ) – Number of points at which the integrand is evaluated for each interval. At least 50\\npoints are recommended for the numerical approximation error to be low. Coefficients of the basis functions as a 1d array. ndarray previous iqm.pulse.playlist.fast_drag.fourier_transform_of_cos_basis_functions_as_tensor next FastDrag © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.playlist.schedule.TOLERANCE","url":"/iqm-pulse/api/iqm.pulse.playlist.schedule.TOLERANCE.html","description":"remove when COMP-1281 is done. TODO previous schedule next Nothing © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26....","content":"remove when COMP-1281 is done. TODO previous schedule next Nothing © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"AcquisitionMethod","url":"/iqm-pulse/api/iqm.pulse.playlist.instructions.AcquisitionMethod.html","description":"Bases: object Describes a way to acquire readout data. Module: iqm.pulse.playlist.instructions Attributes label Identifier for the returned data, like QB1__readout.time_trace . delay_samples Delay fro...","content":"Bases: object Describes a way to acquire readout data. Module: iqm.pulse.playlist.instructions Attributes label Identifier for the returned data, like QB1__readout.time_trace . delay_samples Delay from beginning of probe pulse to beginning of acquisition window, in samples. Methods label ( str ) – delay_samples ( int ) – Identifier for the returned data, like QB1__readout.time_trace . Delay from beginning of probe pulse to beginning of acquisition window, in samples. previous instructions next Block © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"playlist","url":"/iqm-pulse/api/iqm.pulse.playlist.html","description":"Control pulses and instruction schedules for quantum computers. Full path: iqm.pulse.playlist Subpackages and modules channel Control channel properties. fast_drag Waveform definitions for Fourier Ans...","content":"Control pulses and instruction schedules for quantum computers. Full path: iqm.pulse.playlist Subpackages and modules channel Control channel properties. fast_drag Waveform definitions for Fourier Ansatz Spectrum Tuning (FAST) DRAG pulse based on [ 1 ] . hd_drag Waveform definitions for a higher-derivative (HD) DRAG pulse based on Appendix B of [ 1 ] . instructions Instructions for control instruments. playlist Sequences of instruction schedules to execute. schedule Instruction schedules for controlling the instruments. visualisation  waveforms Waveform definitions. previous UGate next channel © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"PRX_HdDragSX","url":"/iqm-pulse/api/iqm.pulse.gates.prx.PRX_HdDragSX.html","description":"Bases: PRX_CustomWaveformsSX PRX gate, HD DRAG IQ pulse with VZ-based SX-implementation. See PRX_CustomWaveformsSX . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel ...","content":"Bases: PRX_CustomWaveformsSX PRX gate, HD DRAG IQ pulse with VZ-based SX-implementation. See PRX_CustomWaveformsSX . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). parameters Required calibration data, may be nested Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – If set True , the Q channel waveform is considered to depend on the I channel’s waveform\\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\\nwill be initialised as True . Required calibration data, may be nested alias of HdDragI alias of HdDragQ previous PRX_HdDrag next PRX_ModulatedCustomWaveForms © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"FluxMultiplexer_SampleLinear","url":"/iqm-pulse/api/iqm.pulse.gates.flux_multiplexer.FluxMultiplexer_SampleLinear.html","description":"Bases: GateImplementation Linear flux pulse multiplexed (user for correcting flux crosstalk). The required calibration data is the flux cross-talk correction matrix, where the element \\\\(C_ij\\\\) represe...","content":"Bases: GateImplementation Linear flux pulse multiplexed (user for correcting flux crosstalk). The required calibration data is the flux cross-talk correction matrix, where the element \\\\(C_ij\\\\) represents\\nthe correction needed for flux component i arising from the crosstalk caused by flux component j , so that\\nafter the corrections, the flux pulse played at i is \\\\(f(t) = A_i w_i(t) + \\\\sum_j C_ij A_j w_j(t)\\\\) ,\\nwhere \\\\(A_j\`\\\\) is the flux pulse amplitude for j and \\\\(w_j(t)\\\\) the (normalized) waveform. The flux crosstalk correction matrix is given in a sparse form via two calibration parameters (we do not support\\ndict- or xarray-valued Parameters yet…). Parameter matrix_index lists the relevant (non-zero) elements of the\\nmatrix as a flat np.array of strings of the form <flux component i>__<flux component j> . Parameter matrix_elements lists the corresponding matrix values \\\\(C_ij\\\\) (the lengths of these arrays must match). TODO: this is for now an experimental R&D implementation, and everything here is subject to change still Module: iqm.pulse.gates.flux_multiplexer Attributes parameters Required calibration data, may be nested Methods get_custom_locus_mapping Locus is \\"global\\" (the whole QPU) represented by an empty tuple for now. parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Required calibration data, may be nested Locus is “global” (the whole QPU) represented by an empty tuple for now. chip_topology ( ChipTopology ) – component_to_channels ( dict [ str , Iterable [ str ] ] ) – dict [ tuple [ str , …] | frozenset [ str ], tuple [ str , …]] | None previous iqm.pulse.gates.flux_multiplexer.TOLERANCE next measure © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"channel","url":"/iqm-pulse/api/iqm.pulse.playlist.channel.html","description":"Control channel properties. Full path: iqm.pulse.playlist.channel Functions get_channel_properties (chip_topology, ...) Internal function to get channel properties. get_channel_properties_from_station...","content":"Control channel properties. Full path: iqm.pulse.playlist.channel Functions get_channel_properties (chip_topology, ...) Internal function to get channel properties. get_channel_properties_from_station_settings (...) Get channel properties from Station Control controller settings following the standard convention. round_duration_to_granularity_samples (...[, ...]) Round a time duration to the least common multiple of the granularities of the given channels. Classes ChannelConfiguration Base class for configuring channels. ChannelDescription Channel specific data, including tables for the instructions and waveforms used. ChannelProperties Defines the properties of a control or measurement channel. IQChannelConfig Requested configuration of an IQ channel. ProbeChannelProperties ChannelProperties for probe line channels. RealChannelConfig Requested configuration of a real channel. Inheritance previous playlist next iqm.pulse.playlist.channel.get_channel_properties © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"ProbePulse_CustomWaveforms","url":"/iqm-pulse/api/iqm.pulse.gates.measure.ProbePulse_CustomWaveforms.html","description":"Bases: CustomIQWaveforms Base class for implementing a probe line measurement pulse with custom waveforms in the I and Q channels. With given Waveform waveform definitions Something and SomethingElse ...","content":"Bases: CustomIQWaveforms Base class for implementing a probe line measurement pulse with custom waveforms in the I and Q channels. With given Waveform waveform definitions Something and SomethingElse ,\\nyou may define a measurement implementation that uses them as follows: class MyGate(ProbePulse_CustomWaveforms, i_wave=Something, q_wave=SomethingElse) . Contrary to the Measure_CustomWaveforms class, this implementation acts on proble lines directly (i.e. its locus is a single probe line). The measurement IQPulse instruction will not be automatically modulated\\nby any frequency, so any modulations should be included in the I and Q waveforms themselves. Module: iqm.pulse.gates.measure Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). root_parameters Parameters independent of the of Waveforms. wave_i Waveform for the I channel. wave_q Waveform for the Q channel. Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). get_locus_mapping_name Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Parameters independent of the of Waveforms. Inheriting classes may override this to include parameters common\\nto all such implementations. Builds a probe pulse and acquisition methods using the calibration data. Subclasses may override this method if needed. waveform_params ( dict [ str , Any ] ) – root_params ( dict [ str , Any ] ) – tuple [ IQPulse , tuple [ AcquisitionMethod , AcquisitionMethod ]] Returns a TimeBox containing the probe pulse measurement. In scheduling, the returned TimeBox blocks only the probe line ( self.locus[0] ). key ( str ) – The time trace results generated on this trigger will be used to assigned to f\\"{probe_line}__{key}\\" , where probe_line is the one that handles self.locus[0] . If empty,\\nthe key “readout.time_trace” is used. TimeBox containing the ReadoutTrigger instruction. TimeBox If set True , the Q channel waveform is considered to depend on the I channel’s waveform\\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\\nwill be initialised as True . Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.\\nSubclasses can reimplement this method in case it makes sense in their context. float Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. By default, it is \\"<operation_name>.<implementation_name>\\" . Inheriting classes may\\noverride this for different behaviour. operation_name ( str ) – name of the quantum operation. implementation_name ( str ) – name of the implementation name of the locus mapping str previous Measure_CustomWaveforms next move © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"PRX_DRAGGaussianSX","url":"/iqm-pulse/api/iqm.pulse.gates.prx.PRX_DRAGGaussianSX.html","description":"Bases: PRX_CustomWaveformsSX PRX gate, DRAG / Gaussian IQ pulse with VZ implementation. See PRX_CustomWaveformsVZ . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel w...","content":"Bases: PRX_CustomWaveformsSX PRX gate, DRAG / Gaussian IQ pulse with VZ implementation. See PRX_CustomWaveformsVZ . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). parameters Required calibration data, may be nested Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – If set True , the Q channel waveform is considered to depend on the I channel’s waveform\\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\\nwill be initialised as True . Required calibration data, may be nested alias of TruncatedGaussian alias of TruncatedGaussianDerivative previous PRX_DRAGGaussian next PRX_FastDrag © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"Barrier","url":"/iqm-pulse/api/iqm.pulse.gates.barrier.Barrier.html","description":"Bases: GateImplementation GateImplementation for the n-qudit barrier metaoperation. Returns a schedule with zero-duration Block metainstructions.\\nWhen this is appended to another Schedule ,\\nit causes ...","content":"Bases: GateImplementation GateImplementation for the n-qudit barrier metaoperation. Returns a schedule with zero-duration Block metainstructions.\\nWhen this is appended to another Schedule ,\\nit causes the affected channels to be padded with Wait instructions to the same length,\\nwhich in turn imposes a definite temporal order for the operations on different sides of\\nthe barrier (the ones preceding it are always executed first). Note Assumes that all instructions involve either the drive, flux or probe channels of the locus QPU components. channels – channels related to the locus QPU components, to be blocked parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Module: iqm.pulse.gates.barrier Attributes symmetric True iff the implementation is symmetric in its locus components. Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). True iff the implementation is symmetric in its locus components.\\nOnly meaningful if arity != 1 , and the locus components are of the same type. The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs\\nin the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.\\nSubclasses can reimplement this method in case it makes sense in their context. float previous barrier next conditional © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.validation.validate_instruction_and_wf_length","url":"/iqm-pulse/api/iqm.pulse.validation.validate_instruction_and_wf_length.html","description":"Validate that instruction and waveform lengths match instruction ( Instruction ) – The IQPulse or RealPulse to be validated previous iqm.pulse.validation.validate_channel next iqm.pulse.validation.val...","content":"Validate that instruction and waveform lengths match instruction ( Instruction ) – The IQPulse or RealPulse to be validated previous iqm.pulse.validation.validate_channel next iqm.pulse.validation.validate_playlist_compatibility © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"PRX_ModulatedCustomWaveForms","url":"/iqm-pulse/api/iqm.pulse.gates.prx.PRX_ModulatedCustomWaveForms.html","description":"Bases: PRX_CustomWaveforms ABC for PRX gates with modulated frequency, hot-swappable waveforms. The class takes baseband I and Q waveform as input, and modulates them with frequency in the root_parame...","content":"Bases: PRX_CustomWaveforms ABC for PRX gates with modulated frequency, hot-swappable waveforms. The class takes baseband I and Q waveform as input, and modulates them with frequency in the root_parameters.\\nThe final pulse shape after modulation is: where \\\\(A_I\\\\) is amplitude_i , \\\\(A_Q\\\\) is amplitude_q , \\\\(\\\\Omega\\\\) is arbitrary waveform in\\nbaseband, \\\\(\\\\omega_d/2\\\\pi\\\\) is the drive frequency and \\\\(\\\\delta/2\\\\pi\\\\) is the modulated frequency . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). root_parameters Parameters independent of the of Waveforms. wave_i Waveform for the I channel. wave_q Waveform for the Q channel. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Parameters independent of the of Waveforms. Inheriting classes may override this to include parameters common\\nto all such implementations. Return the IQPulse with modulated arbitrary waveform based on the calibration data. amplitude_i ( float ) – amplitude_q ( float ) – n_samples ( int ) – IQPulse If set True , the Q channel waveform is considered to depend on the I channel’s waveform\\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\\nwill be initialised as True . previous PRX_HdDragSX next PRX_ModulatedDRAGCosineRiseFall © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"IQPulse","url":"/iqm-pulse/api/iqm.pulse.playlist.instructions.IQPulse.html","description":"Bases: Instruction Play an upconverted pulse that contains real in-phase and quadrature waveforms. Module: iqm.pulse.playlist.instructions Attributes modulation_frequency Modulation frequency of the w...","content":"Bases: Instruction Play an upconverted pulse that contains real in-phase and quadrature waveforms. Module: iqm.pulse.playlist.instructions Attributes modulation_frequency Modulation frequency of the waveforms, in units of the sampling rate. phase Phase of the pulse relative to the channel frequency, in radians. phase_increment Relative phase increment to the phase in the carrier frequency of this pulse and all pulses that are played after it. scale_i Scaling factor for the I quadrature. scale_q Scaling factor for the Q quadrature. wave_i I quadrature envelope. wave_q Q quadrature envelope. duration Time duration of the instruction. Methods get_waveforms Returns all the waveforms the Instruction contains. validate Validate the instruction attributes. duration ( int ) – wave_i ( Waveform ) – wave_q ( Waveform ) – scale_i ( float ) – scale_q ( float ) – phase ( float ) – modulation_frequency ( float ) – phase_increment ( float ) – I quadrature envelope. Q quadrature envelope. Scaling factor for the I quadrature. Scaling factor for the Q quadrature. Phase of the pulse relative to the channel frequency, in radians. Modulation frequency of the waveforms, in units of the sampling rate.\\nThis modulation is additional to the channel frequency.\\nThe default value of 0.0 does not modulate.\\nNote that the phase of this modulation resets for every instruction, that is, successive instances of the same\\nmodulated pulse are not phase coherent. Relative phase increment to the phase in the carrier frequency of this pulse and all pulses that\\nare played after it. Unit: rad. Validate the instruction attributes. ValueError – something about the instruction is not ok Returns all the waveforms the Instruction contains. tuple [ Waveform , …] previous FluxPulse next Instruction © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"TwoQubitGate","url":"/iqm-pulse/api/iqm.pulse.gates.enums.TwoQubitGate.html","description":"Bases: Enum Enumerates a subset of two-qubit gates. Members of this enum can be mapped to the corresponding unitary propagator using\\nthe dictionary returned by TWO_QUBIT_UNITARIES . Module: iqm.pulse....","content":"Bases: Enum Enumerates a subset of two-qubit gates. Members of this enum can be mapped to the corresponding unitary propagator using\\nthe dictionary returned by TWO_QUBIT_UNITARIES . Module: iqm.pulse.gates.enums Attributes CZ Controlled-Z gate. ISWAP iSWAP gate. SQRT_ISWAP Square root of the iSWAP gate. Methods Controlled-Z gate. iSWAP gate. Square root of the iSWAP gate. previous iqm.pulse.gates.enums.TWO_QUBIT_UNITARIES next XYGate © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.gates.delay.DELAY_MAX_DURATION_SECONDS","url":"/iqm-pulse/api/iqm.pulse.gates.delay.DELAY_MAX_DURATION_SECONDS.html","description":"Maximum duration for individual Delay operations, in seconds. previous delay next Delay © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26....","content":"Maximum duration for individual Delay operations, in seconds. previous delay next Delay © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"Chirp","url":"/iqm-pulse/api/iqm.pulse.playlist.waveforms.Chirp.html","description":"Bases: Waveform Linear chirp, defined as where \\\\(\\\\omega[\\\\alpha, N]\\\\) is a cosine-tapered window. For \\\\(\\\\alpha = 1\\\\) it becomes rectangular,\\nand for \\\\(\\\\alpha = 0\\\\) it becomes a Hann (or raised cosine) ...","content":"Bases: Waveform Linear chirp, defined as where \\\\(\\\\omega[\\\\alpha, N]\\\\) is a cosine-tapered window. For \\\\(\\\\alpha = 1\\\\) it becomes rectangular,\\nand for \\\\(\\\\alpha = 0\\\\) it becomes a Hann (or raised cosine) window. The chirp pulse is valued inside the Nyquist zone, such that \\\\(f_{0}\\\\) and \\\\(f_{1}\\\\) are constrained\\nin the range \\\\([-0.5, 0.5]\\\\) . freq_start ( float ) – Initial frequency of the chirp waveform in the Nyquist zone. freq_stop ( float ) – Final frequency of the chirp waveform in the Nyquist zone. alpha ( float ) – Alpha parameter of the cosine-tapered window. Defaults to 0.05. phase ( float ) – Phase of the waveform. Defaults to 0 n_samples ( int ) – Module: iqm.pulse.playlist.waveforms Attributes alpha  phase  freq_start  freq_stop  n_samples Requested number of samples for the waveform. Methods non_timelike_attributes Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Actually samples the waveform. sample_coords – coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Used to construct the parameters for the calibration data required by the waveform.\\nBy default all the waveform attributes are “timelike” (the unit for their calibration data is s).\\nHowever, some waveform attributes can be dimensionless, e.g. the relative amplitudes in a sum of\\nconsisting of multiple terms, or frequency-like (calibration data has the unit ‘Hz’).\\nIf a Waveform subclass has non-timelike attributes, it needs to redefine this method. When the Waveform is constructed, all timelike calibration data is converted to units of the\\nsampling window duration, and all frequency-like calibration data into units of inverse sampling\\nwindow duration. dict [ str , str ] previous waveforms next ChirpImag © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"HdDrag","url":"/iqm-pulse/api/iqm.pulse.playlist.hd_drag.HdDrag.html","description":"Bases: SuppressedPulse Base class for higher-derivative DRAG based on Eqs. (B1) and (B2) of [ 1 ] . Base class for IQ components of the higher derivative (HD) drag pulse. Depending on the value of com...","content":"Bases: SuppressedPulse Base class for higher-derivative DRAG based on Eqs. (B1) and (B2) of [ 1 ] . Base class for IQ components of the higher derivative (HD) drag pulse. Depending on the value of compute_coefs_from_frequencies , we compute the coefficients from the suppressed frequencies during the\\npost-initialization or use pre-computed coefficients of the derivative terms (neglecting the suppressed\\nfrequencies). See SuppressedPulse . Module: iqm.pulse.playlist.hd_drag Attributes center_offset  full_width  coefficients  suppressed_frequencies  compute_coefs_from_frequencies  n_samples Requested number of samples for the waveform. Methods non_timelike_attributes Mapping from waveform attributes to the units of their calibration data, unless that unit is second. n_samples ( int ) – full_width ( float ) – coefficients ( ndarray ) – suppressed_frequencies ( ndarray ) – compute_coefs_from_frequencies ( bool ) – center_offset ( float ) – Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Used to construct the parameters for the calibration data required by the waveform.\\nBy default all the waveform attributes are “timelike” (the unit for their calibration data is s).\\nHowever, some waveform attributes can be dimensionless, e.g. the relative amplitudes in a sum of\\nconsisting of multiple terms, or frequency-like (calibration data has the unit ‘Hz’).\\nIf a Waveform subclass has non-timelike attributes, it needs to redefine this method. When the Waveform is constructed, all timelike calibration data is converted to units of the\\nsampling window duration, and all frequency-like calibration data into units of inverse sampling\\nwindow duration. dict [ str , str ] previous iqm.pulse.playlist.hd_drag.solve_hd_drag_coefficients_from_suppressed_frequencies next HdDragI © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"base","url":"/iqm-pulse/api/iqm.pulse.playlist.visualisation.base.html","description":"Function for visualising playlists. Full path: iqm.pulse.playlist.visualisation.base Functions inspect_playlist (playlist[, segments]) Creates an HTML string from the given playlist and segments. prev...","content":"Function for visualising playlists. Full path: iqm.pulse.playlist.visualisation.base Functions inspect_playlist (playlist[, segments]) Creates an HTML string from the given playlist and segments. previous visualisation next iqm.pulse.playlist.visualisation.base.inspect_playlist © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"ChannelConfiguration","url":"/iqm-pulse/api/iqm.pulse.playlist.channel.ChannelConfiguration.html","description":"Bases: object Base class for configuring channels. Module: iqm.pulse.playlist.channel Methods previous iqm.pulse.playlist.channel.round_duration_to_granularity_samples next ChannelDescription © Copyri...","content":"Bases: object Base class for configuring channels. Module: iqm.pulse.playlist.channel Methods previous iqm.pulse.playlist.channel.round_duration_to_granularity_samples next ChannelDescription © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"cz","url":"/iqm-pulse/api/iqm.pulse.gates.cz.html","description":"Two-qubit controlled-Z (CZ) gate. The CZ gate flips the relative phase of the \\\\(|11⟩\\\\) state.\\nIt can be represented by the unitary matrix Full path: iqm.pulse.gates.cz Classes CZ_CRF CZ gate using a C...","content":"Two-qubit controlled-Z (CZ) gate. The CZ gate flips the relative phase of the \\\\(|11⟩\\\\) state.\\nIt can be represented by the unitary matrix Full path: iqm.pulse.gates.cz Classes CZ_CRF CZ gate using a CosineRiseFall flux pulse on the coupler. CZ_CRF_ACStarkCRF Controlled-Z two-qubit gate. CZ_GaussianSmoothedSquare CZ gate using a GaussianSmoothedSquare flux pulse on the coupler. CZ_Slepian CZ gate using a Slepian flux pulse on the coupler. CZ_Slepian_ACStarkCRF Controlled-Z two-qubit gate. CZ_Slepian_CRF CZ gate using a Slepian flux pulse on the coupler and a CosineRiseFall flux pulse on the qubit. CZ_TruncatedGaussianSmoothedSquare CZ gate using a TruncatedGaussianSmoothedSquare flux pulse on the coupler. CouplerFluxPulseQubitACStarkPulseGate Base class for CZ gates with coupler flux pulse and a qubit AC Stark pulse. FluxPulseGate Discrete two locus component gate implemented using flux pulses, virtual RZs, and the interaction mediated by the coupler. FluxPulseGate_CRF_CRF CZ gate using a CosineRiseFall flux pulse on the coupler and on the qubit. FluxPulseGate_TGSS_CRF CZ gate using a TruncatedGaussianSmoothedSquare flux pulse on the coupler and a CosineRiseFall flux pulse on the qubit. Inheritance previous CCPRX_Composite_DRAGGaussian next CZ_CRF © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.circuit_operations.get_unitary_from_circuit","url":"/iqm-pulse/api/iqm.pulse.circuit_operations.get_unitary_from_circuit.html","description":"Calculate the overall unitary implemented by a sequence of CircuitOperations. Iterate through the list of operations, skipping over barrier operations, and calculate the unitary\\nfor each operation, an...","content":"Calculate the overall unitary implemented by a sequence of CircuitOperations. Iterate through the list of operations, skipping over barrier operations, and calculate the unitary\\nfor each operation, and then calculate the matrix product of all of them. The unitary definition must be present\\nin the QuantumOpTable given as the second argument. circuit ( list [ CircuitOperation ] ) – list of CircuitOperations in order table ( dict [ str , QuantumOp ] | None ) – Table of all registered quantum ops. qubit_names ( list [ str ] | None ) – Optionally, the ordering of the qubits. Array describing the action of the circuit in big endian convention. ndarray previous circuit_operations next iqm.pulse.circuit_operations.get_unitary_from_op © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"prx","url":"/iqm-pulse/api/iqm.pulse.gates.prx.html","description":"Single-qubit PRX gate. The phased x rotation (PRX) gate is defined as where the rotation angle \\\\(\\\\theta\\\\) and the phase angle \\\\(\\\\phi\\\\) are in radians. It rotates the qubit state around an axis that li...","content":"Single-qubit PRX gate. The phased x rotation (PRX) gate is defined as where the rotation angle \\\\(\\\\theta\\\\) and the phase angle \\\\(\\\\phi\\\\) are in radians. It rotates the qubit state around an axis that lies in the XY plane of the Bloch sphere. Full path: iqm.pulse.gates.prx Functions get_unitary_prx (angle, phase) Unitary for a PRX gate. Classes ABC_Constant_smooth ABC class for creating gates with an arbitrarily long Constant pulses with smooth rise and fall. Constant_PRX_with_smooth_rise_fall Constant PRX pulse with cosine rise and fall padding. PRX_CustomWaveforms ABC for PRX gates implemented using a single IQ pulse and hot-swappable waveforms. PRX_CustomWaveformsSX ABC for PRX gates implemented using SX gate, hot-swappable waveforms and phase manipulation. PRX_DRAGCosineRiseFall PRX gate, DRAG / CosineRiseFall IQ pulse implementation. PRX_DRAGCosineRiseFallSX PRX gate, DRAG / CosineRiseFall IQ pulse with VZ implementation. PRX_DRAGGaussian PRX gate, DRAG / TruncatedGaussian IQ pulse implementation. PRX_DRAGGaussianSX PRX gate, DRAG / Gaussian IQ pulse with VZ implementation. PRX_FastDrag PRX gate, FAST DRAG IQ pulse based on amplitude scaling. PRX_FastDragSX PRX gate, FAST DRAG IQ pulse with VZ-based SX-implementation. PRX_GateImplementation ABC for different implementations of the PRX gate. PRX_HdDrag PRX gate, HD DRAG IQ pulse based on amplitude scaling PRX_HdDragSX PRX gate, HD DRAG IQ pulse with VZ-based SX-implementation. PRX_ModulatedCustomWaveForms ABC for PRX gates with modulated frequency, hot-swappable waveforms. PRX_ModulatedDRAGCosineRiseFall Modulated PRX pulse with cosine rise fall waveform PRX_SinglePulse_GateImplementation ABC for PRX gates implemented using a single IQ pulse. Inheritance previous MoveMarker next iqm.pulse.gates.prx.get_unitary_prx © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"CompositeCache","url":"/iqm-pulse/api/iqm.pulse.gate_implementation.CompositeCache.html","description":"Bases: object Cache for CompositeGate TimeBoxes. Result from CompositeGate.__call__\`() (or other methods returning a TimeBox) cannot be stored in the normal\\ncache GateImplementation._timebox_cache as ...","content":"Bases: object Cache for CompositeGate TimeBoxes. Result from CompositeGate.__call__\`() (or other methods returning a TimeBox) cannot be stored in the normal\\ncache GateImplementation._timebox_cache as composites can include any gates in their calls, and we cannot trust\\nthat the cache is flushed correctly just based on if the composite itself has its own calibration data changed\\n(we would have to flush also when any of the composite’s members get new calibration, and this cannot consistently\\nbe deduced). For this reason, CompositeCache will be flushed whenever ANY gate implementation gets new calibration\\ndata. Module: iqm.pulse.gate_implementation Methods flush Flush the CompositeCache. get Get a TimeBox from the cache. set Set a TimeBox into the cache. Set a TimeBox into the cache. gate_implementation ( GateImplementation ) – gate implementation that created the TimeBox. cache_key ( tuple [ Any , ... ] ) – hashable key identifying the TimeBox (usually the CompositeGate.__call__() arguments cast\\ninto a tuple). timebox ( TimeBox ) – TimeBox that will be added to the cache. extra_id ( str ) – extra string id for further identifying the result if needed (for example if the TimeBox did not\\ncome from the call method, but some other method, this could be the method’s name). None Get a TimeBox from the cache. gate_implementation ( GateImplementation ) – gate implementation that created the TimeBox. cache_key ( tuple [ Any , ... ] ) – hashable key identifying the TimeBox (usually the CompositeGate.__call__() arguments cast\\ninto a tuple). extra_id ( str ) – extra string id for further identifying the result (for example if the TimeBox did not come\\nfrom the call method, but some other method, this could be the method’s name). The cached TimeBox or None if not fund for this gate_implementation , cache_key , and extra_id . TimeBox | None Flush the CompositeCache. None previous iqm.pulse.gate_implementation.get_waveform_parameters next CompositeGate © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.playlist.hd_drag.evaluate_hd_drag_i_envelope","url":"/iqm-pulse/api/iqm.pulse.playlist.hd_drag.evaluate_hd_drag_i_envelope.html","description":"Evaluate I-envelope of HD DRAG given the coefficients of the derivative terms and the cosine terms. The I-envelope is defined as \\\\(I(t) = \\\\sum_{n=0}^{K} \\\\beta_{2n} g^{(2n)}(t)\\\\) , where \\\\(K\\\\) is the n...","content":"Evaluate I-envelope of HD DRAG given the coefficients of the derivative terms and the cosine terms. The I-envelope is defined as \\\\(I(t) = \\\\sum_{n=0}^{K} \\\\beta_{2n} g^{(2n)}(t)\\\\) , where \\\\(K\\\\) is the number\\nof suppressed frequency ranges, \\\\(\\\\{beta_{2n}\\\\}\\\\) are the coefficients of the derivative terms, and \\\\(g(t)\\\\) is the basis envelope. The pulse is assumed to start at time -pulse_duration/2 ,\\nand end at time pulse_duration/2 . t_arr ( ndarray ) – Array of time points, at which the function is to be evaluated pulse_duration ( float ) – Pulse duration in the same units as t_arr derivative_coefs_arr ( ndarray ) – Coefficients of the even derivatives cosine_coefs_arr ( ndarray ) – Coefficients of the cosine terms in the basis envelope I-envelope of a HD DRAG pulse evaluated at t_arr ndarray previous iqm.pulse.playlist.hd_drag.COSINE_COEFFICIENTS_DICT next iqm.pulse.playlist.hd_drag.evaluate_hd_drag_q_envelope © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.circuit_operations.reshape_unitary","url":"/iqm-pulse/api/iqm.pulse.circuit_operations.reshape_unitary.html","description":"Extend a unitary propagator to act on a larger system. Given a unitary matrix acting on N qubits, indices of N qubits in a larger Hilbert space, and the number\\nof qubits in that Hilbert space, calcula...","content":"Extend a unitary propagator to act on a larger system. Given a unitary matrix acting on N qubits, indices of N qubits in a larger Hilbert space, and the number\\nof qubits in that Hilbert space, calculate a unitary acting on the larger Hilbert space, which acts as\\nthe given unitary on the N selected qubits and as identity on the others. unitary ( tuple [ tuple [ float , ... ] , ... ] ) – original unitary as a nested tuple for hashing & caching purposes. indices ( tuple [ int , ... ] ) – qubit indices in the larger Hilbert space, all in range(num_qubits) n_qubits ( int ) – number of qubits in the larger Hilbert space Unitary matrix acting as unitary on the selected qubits in the larger Hilbert space. ndarray previous iqm.pulse.circuit_operations.reorder next CircuitOperationList © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"FluxPulse","url":"/iqm-pulse/api/iqm.pulse.playlist.instructions.FluxPulse.html","description":"Bases: RealPulse RealPulse representing a flux pulse. Can store RZ angles for correcting local phase shifts from the computational frame due to flux crosstalk. Module: iqm.pulse.playlist.instructions ...","content":"Bases: RealPulse RealPulse representing a flux pulse. Can store RZ angles for correcting local phase shifts from the computational frame due to flux crosstalk. Module: iqm.pulse.playlist.instructions Attributes rzs Collection of (drive) channel names and RZ angles. wave Shape of the pulse. scale Scaling factor for the waveform. duration Time duration of the instruction. Methods duration ( int ) – wave ( Waveform ) – scale ( float ) – rzs ( tuple [ tuple [ str , float ] , ... ] ) – Collection of (drive) channel names and RZ angles. previous ConditionalInstruction next IQPulse © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"timebox","url":"/iqm-pulse/api/iqm.pulse.timebox.html","description":"Reserving QPU resources in instruction scheduling. Full path: iqm.pulse.timebox Classes MultiplexedProbeTimeBox A TimeBox that contains any number of multiplexed readout pulses for probe channels. Sch...","content":"Reserving QPU resources in instruction scheduling. Full path: iqm.pulse.timebox Classes MultiplexedProbeTimeBox A TimeBox that contains any number of multiplexed readout pulses for probe channels. SchedulingAlgorithm Algorithms for resolving composite TimeBoxes into atomic ones. SchedulingStrategy Different scheduling strategies for the contents of composite TimeBoxes. TimeBox Container for one or more instruction schedule fragments, to be scheduled according to a given strategy. Inheritance previous SegmentPointer next MultiplexedProbeTimeBox © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.utils.normalize_angle","url":"/iqm-pulse/api/iqm.pulse.utils.normalize_angle.html","description":"Normalize the given angle to (-pi, pi]. angle ( float ) – angle to normalize (in radians) angle normalized to (-pi, pi] float previous iqm.pulse.utils.map_waveform_param_types next iqm.pulse.utils.pha...","content":"Normalize the given angle to (-pi, pi]. angle ( float ) – angle to normalize (in radians) angle normalized to (-pi, pi] float previous iqm.pulse.utils.map_waveform_param_types next iqm.pulse.utils.phase_transformation © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"SinglePulseGate","url":"/iqm-pulse/api/iqm.pulse.gate_implementation.SinglePulseGate.html","description":"Bases: GateImplementation Base class for GateImplementations that play a single pulse on a single channel. The pulse is created in _get_pulse() and the channel is specified in _get_pulse_channel() .\\nT...","content":"Bases: GateImplementation Base class for GateImplementations that play a single pulse on a single channel. The pulse is created in _get_pulse() and the channel is specified in _get_pulse_channel() .\\nThe base class also implements a basic _call() method that just inserts the specified pulse into the specified\\nchannel, and a method for computing the pulse’s duration. All of these methods can be overridden in subclasses. Module: iqm.pulse.gate_implementation Attributes Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs\\nin the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox Return the channel for the pulse. The default is the drive channel for a single qubit locus. str Return pulse based on the provided calibration data. Instruction Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.\\nSubclasses can reimplement this method in case it makes sense in their context. float previous GateImplementation next gates © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"fast_drag","url":"/iqm-pulse/api/iqm.pulse.playlist.fast_drag.html","description":"Waveform definitions for Fourier Ansatz Spectrum Tuning (FAST) DRAG pulse based on [ 1 ] . Full path: iqm.pulse.playlist.fast_drag Functions compute_matrix_of_summed_fourier_transform_inner_products (...","content":"Waveform definitions for Fourier Ansatz Spectrum Tuning (FAST) DRAG pulse based on [ 1 ] . Full path: iqm.pulse.playlist.fast_drag Functions compute_matrix_of_summed_fourier_transform_inner_products (...) Evaluate matrix \\\\(A\\\\) defined in Eq. evaluate_fast_drag_i_envelope (t_arr, ...) Evaluate I-envelope of a FAST DRAG pulse for given coefficients. evaluate_fast_drag_q_envelope (t_arr, ...) Evaluate Q-envelope of FAST DRAG for given coefficients. fourier_transform_of_cos_basis_functions_as_tensor (...) Evaluate Fourier transforms of cosine basis functions for given basis function indices and frequencies. solve_fast_coefficients_for_given_weights_and_ranges (...) Solve for optimal coefficients of the basis functions in a FAST DRAG pulse. Classes FastDrag Base class for IQ components of the Fourier Ansatz Spectrum Tuning (FAST) DRAG pulse. FastDragI I-component of the Fourier Ansatz Spectrum Tuning (FAST) drag pulse. FastDragQ Q-component of the Fourier Ansatz Spectrum Tuning (FAST) drag pulse. SuppressedPulse Base class for a control pulse using a series expansion to suppress certain frequencies in its envelope spectrum Inheritance previous RealChannelConfig next iqm.pulse.playlist.fast_drag.compute_matrix_of_summed_fourier_transform_inner_products © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"CZ_TruncatedGaussianSmoothedSquare","url":"/iqm-pulse/api/iqm.pulse.gates.cz.CZ_TruncatedGaussianSmoothedSquare.html","description":"Bases: FluxPulseGate CZ gate using a TruncatedGaussianSmoothedSquare flux pulse on the coupler. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested qubit_wave Flu...","content":"Bases: FluxPulseGate CZ gate using a TruncatedGaussianSmoothedSquare flux pulse on the coupler. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested qubit_wave Flux pulse Waveform to be played in the qubit flux AWG. symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – alias of TruncatedGaussianSmoothedSquare Required calibration data, may be nested Flux pulse Waveform to be played in the qubit flux AWG. True iff the implementation is symmetric in its locus components.\\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous CZ_Slepian_CRF next CouplerFluxPulseQubitACStarkPulseGate © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"conditional","url":"/iqm-pulse/api/iqm.pulse.gates.conditional.html","description":"Classically controlled gates. Full path: iqm.pulse.gates.conditional Classes CCPRX_Composite Classically controlled PRX gate. CCPRX_Composite_DRAGCosineRiseFall Conditional drag_crf pulse. CCPRX_Compo...","content":"Classically controlled gates. Full path: iqm.pulse.gates.conditional Classes CCPRX_Composite Classically controlled PRX gate. CCPRX_Composite_DRAGCosineRiseFall Conditional drag_crf pulse. CCPRX_Composite_DRAGGaussian Conditional drag_gaussian pulse. Inheritance previous Barrier next CCPRX_Composite © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.gate_implementation.OILCalibrationData","url":"/iqm-pulse/api/iqm.pulse.gate_implementation.OILCalibrationData.html","description":"Calibration data for a particular implementation of a particular quantum operation at a particular locus. alias of dict [ str , Any ] previous iqm.pulse.gate_implementation.Locus next iqm.pulse.gate_i...","content":"Calibration data for a particular implementation of a particular quantum operation at a particular locus. alias of dict [ str , Any ] previous iqm.pulse.gate_implementation.Locus next iqm.pulse.gate_implementation.OICalibrationData © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"PRX_FastDrag","url":"/iqm-pulse/api/iqm.pulse.gates.prx.PRX_FastDrag.html","description":"Bases: PRX_CustomWaveforms PRX gate, FAST DRAG IQ pulse based on amplitude scaling. See PRX_CustomWaveforms . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel wavefor...","content":"Bases: PRX_CustomWaveforms PRX gate, FAST DRAG IQ pulse based on amplitude scaling. See PRX_CustomWaveforms . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). parameters Required calibration data, may be nested Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – If set True , the Q channel waveform is considered to depend on the I channel’s waveform\\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\\nwill be initialised as True . Required calibration data, may be nested alias of FastDragI alias of FastDragQ previous PRX_DRAGGaussianSX next PRX_FastDragSX © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"PRX_CustomWaveformsSX","url":"/iqm-pulse/api/iqm.pulse.gates.prx.PRX_CustomWaveformsSX.html","description":"Bases: PRX_SinglePulse_GateImplementation , CustomIQWaveforms ABC for PRX gates implemented using SX gate, hot-swappable waveforms and phase manipulation. If the rotation angle \\\\(\\\\theta = \\\\pi/2\\\\) , th...","content":"Bases: PRX_SinglePulse_GateImplementation , CustomIQWaveforms ABC for PRX gates implemented using SX gate, hot-swappable waveforms and phase manipulation. If the rotation angle \\\\(\\\\theta = \\\\pi/2\\\\) , the timebox will consist of just the SX IQ pulse, with phase. If the rotation angle \\\\(\\\\theta = 0.0\\\\) , the timebox will consist of a single zero-amplitude pulse. If not, the timebox will consist of two IQ pulses, with phase. The formula for the PRX gate implemented using SX gates and z rotations is The fusing of z rotations to IQPulses is done inside the _call() method. All parameters in the pulse here is referring to the state of the qubits. Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). root_parameters Parameters independent of the of Waveforms. wave_i Waveform for the I channel. wave_q Waveform for the Q channel. Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Parameters independent of the of Waveforms. Inheriting classes may override this to include parameters common\\nto all such implementations. Convert pulses into timebox, via extra Z rotations. There are exceptions while using 0, pi/2 and pi rotation in angle, for calibration reason. The duration of the\\ntimebox can be different. angle ( float ) – phase ( float ) – TimeBox Builds a single sqrt(X) pulse from the calibration data. amplitude_i ( float ) – amplitude_q ( float ) – n_samples ( int ) – IQPulse If set True , the Q channel waveform is considered to depend on the I channel’s waveform\\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\\nwill be initialised as True . previous PRX_CustomWaveforms next PRX_DRAGCosineRiseFall © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.scheduler.extend_schedule","url":"/iqm-pulse/api/iqm.pulse.scheduler.extend_schedule.html","description":"Extend a Schedule with another Schedule. Extends A with B , modifying both. The extension can add new channels to A . If B has a ragged left side, i.e. some of its channels begin with Nothing instruct...","content":"Extend a Schedule with another Schedule. Extends A with B , modifying both. The extension can add new channels to A . If B has a ragged left side, i.e. some of its channels begin with Nothing instructions,\\nthis algorithm will not always produce an optimally short schedule. A ( Schedule ) – schedule to be extended B ( Schedule ) – schedule to extend A with channels ( dict [ str , ChannelProperties ] ) – properties of the control channels TOL ( float ) – time durations equal or smaller than this are considered zero (in seconds) None previous iqm.pulse.scheduler.extend_hard_boundary_in_seconds next iqm.pulse.scheduler.extend_schedule_new © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"Instruction","url":"/iqm-pulse/api/iqm.pulse.playlist.instructions.Instruction.html","description":"Bases: object Command that can be executed by the quantum computer on a control channel. Has a well-specified time duration. Module: iqm.pulse.playlist.instructions Attributes duration Time duration o...","content":"Bases: object Command that can be executed by the quantum computer on a control channel. Has a well-specified time duration. Module: iqm.pulse.playlist.instructions Attributes duration Time duration of the instruction. Methods copy Make a copy of the Instruction with the given changes applied to its contents. get_child_instructions Returns all the child Instructions the Instruction contains. get_waveforms Returns all the waveforms the Instruction contains. validate Validate the instruction attributes. duration ( int ) – Time duration of the instruction. In samples at the channel sample rate. Validate the instruction attributes. ValueError – something about the instruction is not ok None Make a copy of the Instruction with the given changes applied to its contents. Instruction Returns all the child Instructions the Instruction contains. tuple [ Instruction , …] Returns all the waveforms the Instruction contains. tuple [ Waveform , …] previous IQPulse next MultiplexedIQPulse © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.gate_implementation.get_waveform_parameters","url":"/iqm-pulse/api/iqm.pulse.gate_implementation.get_waveform_parameters.html","description":"Parameters that are required to initialize the given Waveform class. n_samples is handled separately since it is determined by the Instruction duration\\nand channel sample rate, and thus is shared by a...","content":"Parameters that are required to initialize the given Waveform class. n_samples is handled separately since it is determined by the Instruction duration\\nand channel sample rate, and thus is shared by all the waveforms of the Instruction. wave ( type [ Waveform ] ) – waveform class label_prefix ( str ) – optional prefix for the parameter labels for providing additional information parameters of wave , in the format expected by GateImplementation.parameters . Waveform parameters\\nthat have a defined default will be returned as Setting objects and those that do not have default\\nas Parameter objects. dict [ str , Setting | Parameter] previous iqm.pulse.gate_implementation.PROBE_LINES_LOCUS_MAPPING next CompositeCache © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"RZ_ACStarkShift","url":"/iqm-pulse/api/iqm.pulse.gates.rz.RZ_ACStarkShift.html","description":"Bases: GateImplementation Implementation of the RZ gate using an AC Stark pulse. An AC Stark pulse is a strong off-resonant drive on a qubit. This pulse leads to a frequency shift of the qubit due\\nto ...","content":"Bases: GateImplementation Implementation of the RZ gate using an AC Stark pulse. An AC Stark pulse is a strong off-resonant drive on a qubit. This pulse leads to a frequency shift of the qubit due\\nto the AC Stark effect. The qubit frequency shift depends on the AC Stark pulse amplitude and frequency. ac_stark_pulse – AC Stark pulse. channel – Name of the drive channel on which the AC Stark pulse is played. parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – Constructs an instance of the AC Stark pulse for the given locus. Module: iqm.pulse.gates.rz Attributes ac_stark_waveform  Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs\\nin the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.\\nSubclasses can reimplement this method in case it makes sense in their context. float Returns an AC Stark pulse which consists of a modulated I and modulated Q waveform, where the Q quadrature\\nhas an additional phase of -pi/2. n_samples ( int ) – amplitude ( float ) – phase_increment ( float ) – phase ( float ) – IQPulse previous iqm.pulse.gates.rz.get_unitary_rz next RZ_ACStarkShift_CosineRiseFall © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"IQChannelConfig","url":"/iqm-pulse/api/iqm.pulse.playlist.channel.IQChannelConfig.html","description":"Bases: RealChannelConfig Requested configuration of an IQ channel. Module: iqm.pulse.playlist.channel Attributes frequency upconversion frequency for the IQ pulses (in Hz) sample_rate sample rate of t...","content":"Bases: RealChannelConfig Requested configuration of an IQ channel. Module: iqm.pulse.playlist.channel Attributes frequency upconversion frequency for the IQ pulses (in Hz) sample_rate sample rate of the instrument responsible for the channel (in Hz) Methods sample_rate ( float ) – frequency ( float ) – upconversion frequency for the IQ pulses (in Hz) previous ChannelProperties next ProbeChannelProperties © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"rz","url":"/iqm-pulse/api/iqm.pulse.gates.rz.html","description":"Single-qubit RZ gate. The z rotation gate is defined as where the rotation angle \\\\(\\\\phi\\\\) is in radians. Full path: iqm.pulse.gates.rz Functions get_unitary_rz (angle) Unitary for an RZ gate. Classes ...","content":"Single-qubit RZ gate. The z rotation gate is defined as where the rotation angle \\\\(\\\\phi\\\\) is in radians. Full path: iqm.pulse.gates.rz Functions get_unitary_rz (angle) Unitary for an RZ gate. Classes RZ_ACStarkShift Implementation of the RZ gate using an AC Stark pulse. RZ_ACStarkShift_CosineRiseFall AC stark pulse implemented as a modulated cosine rise fall pulse. RZ_ACStarkShift_smoothConstant Constant AC stark pulse with cosine rise and fall padding. RZ_PRX_Composite RZ gate implemented as a sequence of PRX gates. RZ_Virtual Implementation of the RZ gate using the virtual z rotation technique. Inheritance previous Reset_Wait next iqm.pulse.gates.rz.get_unitary_rz © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"Cosine","url":"/iqm-pulse/api/iqm.pulse.playlist.waveforms.Cosine.html","description":"Bases: Waveform Periodic sinusoidal waveform which defaults to cosine. The use case for this waveform is to do manual modulation of other waveforms. where \\\\(f\\\\) is the frequency, and \\\\(\\\\phi\\\\) the phas...","content":"Bases: Waveform Periodic sinusoidal waveform which defaults to cosine. The use case for this waveform is to do manual modulation of other waveforms. where \\\\(f\\\\) is the frequency, and \\\\(\\\\phi\\\\) the phase of the wave. frequency ( float ) – frequency of the wave, in units of inverse sampling window duration phase ( float ) – phase of the wave, in radians n_samples ( int ) – Module: iqm.pulse.playlist.waveforms Attributes phase  frequency  n_samples Requested number of samples for the waveform. Methods non_timelike_attributes Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Actually samples the waveform. sample_coords ( ndarray ) – coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) ndarray Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Used to construct the parameters for the calibration data required by the waveform.\\nBy default all the waveform attributes are “timelike” (the unit for their calibration data is s).\\nHowever, some waveform attributes can be dimensionless, e.g. the relative amplitudes in a sum of\\nconsisting of multiple terms, or frequency-like (calibration data has the unit ‘Hz’).\\nIf a Waveform subclass has non-timelike attributes, it needs to redefine this method. When the Waveform is constructed, all timelike calibration data is converted to units of the\\nsampling window duration, and all frequency-like calibration data into units of inverse sampling\\nwindow duration. dict [ str , str ] previous ChirpImag next CosineFall © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"PRX_FastDragSX","url":"/iqm-pulse/api/iqm.pulse.gates.prx.PRX_FastDragSX.html","description":"Bases: PRX_CustomWaveformsSX PRX gate, FAST DRAG IQ pulse with VZ-based SX-implementation. See PRX_CustomWaveformsSX . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channe...","content":"Bases: PRX_CustomWaveformsSX PRX gate, FAST DRAG IQ pulse with VZ-based SX-implementation. See PRX_CustomWaveformsSX . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). parameters Required calibration data, may be nested Methods parent ( QuantumOp ) – name ( str ) – locus ( Locus ) – calibration_data ( OILCalibrationData ) – builder ( ScheduleBuilder ) – If set True , the Q channel waveform is considered to depend on the I channel’s waveform\\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\\nwill be initialised as True . Required calibration data, may be nested alias of FastDragI alias of FastDragQ previous PRX_FastDrag next PRX_GateImplementation © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.utils.phase_transformation","url":"/iqm-pulse/api/iqm.pulse.utils.phase_transformation.html","description":"Implement an arbitrary (RZ, PRX, RZ) gate sequence by modifying the parameters of the\\nIQ pulse implementing the PRX. By commutation rules we have Hence an arbitrary (RZ, PRX, RZ) gate sequence is equi...","content":"Implement an arbitrary (RZ, PRX, RZ) gate sequence by modifying the parameters of the\\nIQ pulse implementing the PRX. By commutation rules we have Hence an arbitrary (RZ, PRX, RZ) gate sequence is equivalent to (RZ, PRX) with adjusted angles. Use case: with resonant driving, the PRX gate can be implemented using an IQPulse instance,\\nand the preceding RZ can be handled by decrementing the local oscillator phase beforehand (something\\nthe IQPulse instruction can also do), which is equivalent to rotating the local computational frame\\naround the z axis in the opposite direction of the required quantum state rotation. psi_1 ( float ) – RZ angle before the PRX (in rad) psi_2 ( float ) – RZ angle after the PRX (in rad) change to the PRX phase angle (in rad),\\nphase increment for the IQ pulse that implements the remaining RZ (in rad) tuple [ float , float ] previous iqm.pulse.utils.normalize_angle next validation © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-pulse","title":"iqm.pulse.gates.enums.XYGATE_UNITARIES","url":"/iqm-pulse/api/iqm.pulse.gates.enums.XYGATE_UNITARIES.html","description":"Mapping of XYGates to the corresponding SU(2) matrices previous enums next iqm.pulse.gates.enums.TWO_QUBIT_UNITARIES © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26....","content":"Mapping of XYGates to the corresponding SU(2) matrices previous enums next iqm.pulse.gates.enums.TWO_QUBIT_UNITARIES © Copyright 2019-2025, IQM Finland Oy, Release 9.5. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"API documentation: station-control-client","url":"/iqm-station-control-client/index.html","description":"3.16 2025-04-26 This is the documentation of the IQM station-control client library. Index Module Index Search Page next API Reference © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated...","content":"3.16 2025-04-26 This is the documentation of the IQM station-control client library. Index Module Index Search Page next API Reference © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"API Reference","url":"/iqm-station-control-client/API.html","description":"iqm.station_control.client Station control client implementation. iqm.station_control.interface Station control interface. previous API documentation: station-control-client next client © Copyright 20...","content":"iqm.station_control.client Station control client implementation. iqm.station_control.interface Station control interface. previous API documentation: station-control-client next client © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"sweep","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.sweep.html","description":"Sweep related station control interface models. Full path: iqm.station_control.interface.models.sweep Classes SweepBase Abstract base class of the sweep definition and data. SweepData The content of t...","content":"Sweep related station control interface models. Full path: iqm.station_control.interface.models.sweep Classes SweepBase Abstract base class of the sweep definition and data. SweepData The content of the sweep stored in the database. SweepDefinition The content of the sweep object when creating it. SweepStatus Status for sweeps. Inheritance previous SequenceResultDefinition next SweepBase © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"PydanticBase","url":"/iqm-station-control-client/api/iqm.station_control.interface.pydantic_base.PydanticBase.html","description":"Bases: BaseModel Pydantic base model to change the behaviour of pydantic globally.\\nNote that setting model_config in child classes will merge the configs rather than override this one. https://docs.py...","content":"Bases: BaseModel Pydantic base model to change the behaviour of pydantic globally.\\nNote that setting model_config in child classes will merge the configs rather than override this one. https://docs.pydantic.dev/latest/concepts/config/#change-behaviour-globally Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.pydantic_base Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Methods Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous pydantic_base next Changelog © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"DutList","url":"/iqm-station-control-client/api/iqm.station_control.client.list_models.DutList.html","description":"alias of ListModel[list[DutData]] previous DutFieldDataList next ListModel © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26....","content":"alias of ListModel[list[DutData]] previous DutFieldDataList next ListModel © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"ObservationUpdate","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.observation.ObservationUpdate.html","description":"Bases: PydanticBase The observation data to be updated in the database. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.Validat...","content":"Bases: PydanticBase The observation data to be updated in the database. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.observation Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. observation_id Unique identifier of the observation. invalid Flag indicating if the object is invalid. Methods observation_id ( int ) – invalid ( bool ) – Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Unique identifier of the observation. Flag indicating if the object is invalid. Automated systems must not use invalid objects. previous ObservationLite next observation_set © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"meta_class","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.meta_class.html","description":"Full path: iqm.station_control.client.iqm_server.meta_class Classes IqmServerClientMeta Custom metaclass that automatically adds '<feature> not implemented' stub implementations for all StationControl...","content":"Full path: iqm.station_control.client.iqm_server.meta_class Classes IqmServerClientMeta Custom metaclass that automatically adds '<feature> not implemented' stub implementations for all StationControlClient functions that are not overridden by IqmServerClient. Inheritance previous IqmServerClient next IqmServerClientMeta © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"ListWithMeta","url":"/iqm-station-control-client/api/iqm.station_control.interface.list_with_meta.ListWithMeta.html","description":"Bases: list Standard list extension holding optional metadata as well. Module: iqm.station_control.interface.list_with_meta Methods items ( Iterable ) – meta ( Meta ) – previous list_with_meta next Me...","content":"Bases: list Standard list extension holding optional metadata as well. Module: iqm.station_control.interface.list_with_meta Methods items ( Iterable ) – meta ( Meta ) – previous list_with_meta next Meta © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"ObservationLiteList","url":"/iqm-station-control-client/api/iqm.station_control.client.list_models.ObservationLiteList.html","description":"alias of ListModel[list[ObservationLite]] previous ObservationDefinitionList next ObservationSetDataList © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26....","content":"alias of ListModel[list[ObservationLite]] previous ObservationDefinitionList next ObservationSetDataList © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"testing","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.testing.html","description":"Full path: iqm.station_control.client.iqm_server.testing Subpackages and modules iqm_server_mock Internal testing utilities for IqmServerClient previous uuid_pb2_grpc next iqm_server_mock © Copyright ...","content":"Full path: iqm.station_control.client.iqm_server.testing Subpackages and modules iqm_server_mock Internal testing utilities for IqmServerClient previous uuid_pb2_grpc next iqm_server_mock © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"QuantumComputers","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.qc_pb2_grpc.QuantumComputers.html","description":"Bases: object Quantum Computer management APIs. Module: iqm.station_control.client.iqm_server.proto.qc_pb2_grpc Methods GetQuantumComputerResourceV1  GetQuantumComputerV1  ListQuantumComputersV1  prev...","content":"Bases: object Quantum Computer management APIs. Module: iqm.station_control.client.iqm_server.proto.qc_pb2_grpc Methods GetQuantumComputerResourceV1  GetQuantumComputerV1  ListQuantumComputersV1  previous iqm.station_control.client.iqm_server.proto.qc_pb2_grpc.add_QuantumComputersServicer_to_server next QuantumComputersServicer © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.serializers.task_serializers.serialize_sweep_task_request","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.task_serializers.serialize_sweep_task_request.html","description":"Wrap sweep_definition and queue_name into a protobuf message and serialize into a bitstring. sweep_definition ( SweepDefinition ) – The content of the sweep. queue_name ( str ) – Name of the destinati...","content":"Wrap sweep_definition and queue_name into a protobuf message and serialize into a bitstring. sweep_definition ( SweepDefinition ) – The content of the sweep. queue_name ( str ) – Name of the destination queue. SweepTaskRequest encoded into a bitstring. bytes previous iqm.station_control.client.serializers.task_serializers.serialize_run_task_request next station_control © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"calibration_pb2","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.calibration_pb2.html","description":"Generated protocol buffer code. Full path: iqm.station_control.client.iqm_server.proto.calibration_pb2 previous proto next calibration_pb2_grpc © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Las...","content":"Generated protocol buffer code. Full path: iqm.station_control.client.iqm_server.proto.calibration_pb2 previous proto next calibration_pb2_grpc © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"job_pb2","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.job_pb2.html","description":"Generated protocol buffer code. Full path: iqm.station_control.client.iqm_server.proto.job_pb2 previous common_pb2_grpc next job_pb2_grpc © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last upda...","content":"Generated protocol buffer code. Full path: iqm.station_control.client.iqm_server.proto.job_pb2 previous common_pb2_grpc next job_pb2_grpc © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"JobsServicer","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.job_pb2_grpc.JobsServicer.html","description":"Bases: object User job management APIs. Module: iqm.station_control.client.iqm_server.proto.job_pb2_grpc Methods CancelJobV1 Cancel a queued job by JobLookup. GetJobPayloadV1 Get job payload as GRPC d...","content":"Bases: object User job management APIs. Module: iqm.station_control.client.iqm_server.proto.job_pb2_grpc Methods CancelJobV1 Cancel a queued job by JobLookup. GetJobPayloadV1 Get job payload as GRPC data chunk streams by JobLookup . GetJobResultsV1 Get job result as GRPC data chunk streams by JobLookup. GetJobV1 Get job details by JobLookup. SubmitJobV1 Submits a new job to the quantum computer. SubscribeToJobV1 Subscribes to the job changes. Submits a new job to the quantum computer. If the submit succeeds, returns\\nthe handle for the submitted job. ## Errors\\nIn case of an error, a GRPC error status is returned with some optional additional\\ndetails. The possible error cases are described below: ### Invalid payload\\nThis error is returned if the given job payload is not accepted by the\\ntarget quantum computer. Note that different quantum computers might\\naccept different payloads. \` Code = \\"INVALID_ARGUMENT\\" Metadata.error_code = \\"invalid_payload\\" Details = https://protobuf.dev/reference/protobuf/google.protobuf/#value { \\"errors\\": [<list-of-error-messages>] } \` ### Job type not supported\\nThis error is returned if the target quantum computer does not support the\\ngiven job type (circuit, pulse). \` Code = \\"INVALID_ARGUMENT\\" Metadata.error_code = \\"job_type_not_supported\\" \` ### User job quota exceeded\\nThis error is returned if the user has already submitted the maximum allowed\\namount of jobs to the queue. Quota can be freed by either waiting for existing\\njobs to finish or manually cancelling them (either via the API or the web). \` Code = \\"RESOURCE_EXHAUSTED\\" Metadata.error_code = \\"quota_exceeded\\" \` ### Account does not have any active or upcoming timeslots\\nThis error is returned if the job is submitted with the use_timeslot flag enabled,\\nbut the user’s account does not have active or upcoming timeslots booked. \` Code = \\"FAILED_PRECONDITION\\" Metadata.error_code = \\"no_booked_timeslots\\" \` ### Timeslot is required to execute job\\nThis error is returned if the target quantum computer requires timeslot to execute\\njobs but use_timeslot was unset (or set to false ). \` Code = \\"FAILED_PRECONDITION\\" Metadata.error_code = \\"timeslot_required\\" \` ### Quantum computer not found\\nThis error is returned if the qc_id does not match any existing quantum computer. \` Code = \\"NOT_FOUND\\" Metadata.error_code = \\"not_found\\" \` Get job details by JobLookup. Returns the job if the user job exists.\\nUser needs to be authorised to access the job data, i.e. the job must be created by the user. ## Errors\\nIn case of an error, a GRPC error status is returned with some optional additional\\ndetails. The possible error cases are described below: ### Job not found\\nThis error is returned if the JobLookup does not match any existing job. \` Code = \\"NOT_FOUND\\" Metadata.error_code = \\"not_found\\" \` ### Quantum computer not found\\nThis error is returned if quantum computer associated with the job does not match any existing quantum computer. \` Code = \\"NOT_FOUND\\" Metadata.error_code = \\"not_found\\" \` Subscribes to the job changes. Returns a stream that emits the job at subscription\\nmoment and after that the changed job every time when the job state changes. The stream\\nwill end automatically when the job is considered as “final” and won’t be updated\\nanymore in the future (cancelled, interrupted, failed, completed). The stream may also emit empty Keepalive messages to indicate that job is still being\\nprocessed but hasn’t been updated. Clients may ignore these keepalive messages. ## Errors ### Job not found\\nIf the job does not exist with the given lookup, the following error is\\nreturned upon the subscription. \` Code = \\"NOT_FOUND\\" Metadata.error_code = \\"not_found\\" \` ### Job deleted during the subscription\\nIf the job gets deleted during the open subscription, the subscription stream will\\nemit the following error and close immediately after that. \` Code = \\"ABORTED\\" Metadata.error_code = \\"job_deleted\\" \` ### Server cancellation\\nIf server wants to cancel the subscription (e.g. due to restarts or maintenance), the\\nsubscription stream will emit the following error and close immediately after that. \` Code = \\"ABORTED\\" Metadata.error_code = \\"server_cancel\\" \` Get job payload as GRPC data chunk streams by JobLookup . Returns the job input data if the user job exists.\\nUser needs to be authorised to access the job. ## Errors\\nIn case of an error, a GRPC error status is returned with some optional additional\\ndetails. The possible error cases are described below: ### Job not found\\nThis error is returned if the JobLookup does not match any existing job. \` Code = \\"NOT_FOUND\\" Metadata.error_code = \\"not_found\\" \` ### Job payload not found\\nThis error is returned if the job payload is not found. \` Code = \\"NOT_FOUND\\" Metadata.error_code = \\"not_found\\" \` Get job result as GRPC data chunk streams by JobLookup. Returns the job measurements data if the user job exists.\\nUser needs to be authorised to access the job. ## Errors\\nIn case of an error, a GRPC error status is returned with some optional additional\\ndetails. The possible error cases are described below: ### Job not found\\nThis error is returned if the JobLookup does not match any existing job. \` Code = \\"NOT_FOUND\\" Metadata.error_code = \\"not_found\\" \` ### Job results not found\\nThis error is returned if the job results is not found. \` Code = \\"NOT_FOUND\\" Metadata.error_code = \\"not_found\\" \` Cancel a queued job by JobLookup. Returns the updated job when cancelled.\\nUser needs to be authorised to access the job. ## Errors\\nIn case of an error, a GRPC error status is returned with some optional additional\\ndetails. The possible error cases are described below: ### Job not found\\nThis error is returned if the JobLookup does not match any existing user job. \` Code = \\"NOT_FOUND\\" Metadata.error_code = \\"not_found\\" \` ### Can’t cancel job from QC because it’s already in final state\\nThis error is returned if the job measurements is not found. \` Code = \\"FAILED_PRECONDITION\\" Metadata.error_code = \\"job_not_submitted_to_qc\\" \` ### Quantum computer not found\\nThis error is returned if quantum computer associated with the job does not match any existing quantum computer. \` Code = \\"NOT_FOUND\\" Metadata.error_code = \\"not_found\\" \` previous Jobs next JobsStub © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"type_aliases","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.type_aliases.html","description":"Type hint aliases used in the station control interface. Full path: iqm.station_control.interface.models.type_aliases previous SweepStatus next pydantic_base © Copyright 2019-2025, IQM Finland Oy, Rel...","content":"Type hint aliases used in the station control interface. Full path: iqm.station_control.interface.models.type_aliases previous SweepStatus next pydantic_base © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"setting_node_serializer","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.setting_node_serializer.html","description":"Serializers and deserializers for setting node related models. Full path: iqm.station_control.client.serializers.setting_node_serializer Functions deserialize_setting_node (setting_node_str) Convert b...","content":"Serializers and deserializers for setting node related models. Full path: iqm.station_control.client.serializers.setting_node_serializer Functions deserialize_setting_node (setting_node_str) Convert binary string into SettingNode. previous iqm.station_control.client.serializers.run_serializers.serialize_run_definition next iqm.station_control.client.serializers.setting_node_serializer.deserialize_setting_node © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.serializers.struct_serializer.deserialize_struct","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.struct_serializer.deserialize_struct.html","description":"Deserialize a Struct protobuf representation into a free-form dict. proto ( Struct ) – dict previous struct_serializer next iqm.station_control.client.serializers.struct_serializer.serialize_struct © ...","content":"Deserialize a Struct protobuf representation into a free-form dict. proto ( Struct ) – dict previous struct_serializer next iqm.station_control.client.serializers.struct_serializer.serialize_struct © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"ObservationSetDefinition","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.observation_set.ObservationSetDefinition.html","description":"Bases: ObservationSetBase The content of the observation set object when creating it. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydanti...","content":"Bases: ObservationSetBase The content of the observation set object when creating it. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.observation_set Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. observation_set_type Indicates the type (i.e. purpose) of the observation set. observation_ids Database IDs of the observations belonging to the observation set. describes_id Unique identifier of the observation set this observation set describes. invalid Flag indicating if the object is invalid. Methods observation_set_type ( Literal [ 'calibration-set' , 'characterization-set' , 'generic-set' , 'quality-metric-set' ] ) – observation_ids ( list [ int ] ) – describes_id ( UUID | None ) – invalid ( bool ) – Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous ObservationSetData next ObservationSetUpdate © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"playlist_serializers","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.playlist_serializers.html","description":"Serializers and deserializers for Playlist Full path: iqm.station_control.client.serializers.playlist_serializers Functions pack_playlist (playlist) Pack the given playlist into a protobuf format for ...","content":"Serializers and deserializers for Playlist Full path: iqm.station_control.client.serializers.playlist_serializers Functions pack_playlist (playlist) Pack the given playlist into a protobuf format for further serialization. unpack_playlist (proto_playlist) Unpack a protobuf representation of a playlist into its runtime representation. previous iqm.station_control.client.serializers.datetime_serializers.serialize_datetime next iqm.station_control.client.serializers.playlist_serializers.pack_playlist © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.iqm_server.grpc_utils.create_channel","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.grpc_utils.create_channel.html","description":"connection_params ( ConnectionParameters ) – get_token_callback ( Callable [ [ ] , str ] | None ) – enable_compression ( bool ) – Channel previous grpc_utils next iqm.station_control.client.iqm_server...","content":"connection_params ( ConnectionParameters ) – get_token_callback ( Callable [ [ ] , str ] | None ) – enable_compression ( bool ) – Channel previous grpc_utils next iqm.station_control.client.iqm_server.grpc_utils.extract_error © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"proto","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.html","description":"Full path: iqm.station_control.client.iqm_server.proto Subpackages and modules calibration_pb2 Generated protocol buffer code. calibration_pb2_grpc Client and server classes corresponding to protobuf-...","content":"Full path: iqm.station_control.client.iqm_server.proto Subpackages and modules calibration_pb2 Generated protocol buffer code. calibration_pb2_grpc Client and server classes corresponding to protobuf-defined services. common_pb2 Generated protocol buffer code. common_pb2_grpc Client and server classes corresponding to protobuf-defined services. job_pb2 Generated protocol buffer code. job_pb2_grpc Client and server classes corresponding to protobuf-defined services. qc_pb2 Generated protocol buffer code. qc_pb2_grpc Client and server classes corresponding to protobuf-defined services. uuid_pb2 Generated protocol buffer code. uuid_pb2_grpc Client and server classes corresponding to protobuf-defined services. previous IqmServerClientMeta next calibration_pb2 © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"sweep_serializers","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.sweep_serializers.html","description":"Serializers and deserializers for sweep related models. Full path: iqm.station_control.client.serializers.sweep_serializers Functions deserialize_sweep_data (data) Convert JSON serializable dictionary...","content":"Serializers and deserializers for sweep related models. Full path: iqm.station_control.client.serializers.sweep_serializers Functions deserialize_sweep_data (data) Convert JSON serializable dictionary into SweepData. deserialize_sweep_definition (...) Convert sweep proto into SweepDefinition. deserialize_sweep_results (sweep_results_str) Convert binary string into SweepResults. serialize_sweep_data (sweep_data) Convert SweepData into JSON serializable dictionary. serialize_sweep_definition (sweep_definition) Convert SweepDefinition into sweep proto. serialize_sweep_results (sweep_id, sweep_results) Convert SweepResults into binary string. previous iqm.station_control.client.serializers.struct_serializer.serialize_struct next iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_data © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.iqm_server.grpc_utils.parse_connection_params","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.grpc_utils.parse_connection_params.html","description":"qc_url ( str ) – ConnectionParameters previous iqm.station_control.client.iqm_server.grpc_utils.load_all next iqm.station_control.client.iqm_server.grpc_utils.to_datetime © Copyright 2019-2025, IQM Fi...","content":"qc_url ( str ) – ConnectionParameters previous iqm.station_control.client.iqm_server.grpc_utils.load_all next iqm.station_control.client.iqm_server.grpc_utils.to_datetime © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"SweepStatus","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.sweep.SweepStatus.html","description":"Bases: Enum Status for sweeps. Module: iqm.station_control.interface.models.sweep Attributes PENDING Sweep waiting for execution or status unknown PROGRESS Sweep is currently being executed SUCCESS Sw...","content":"Bases: Enum Status for sweeps. Module: iqm.station_control.interface.models.sweep Attributes PENDING Sweep waiting for execution or status unknown PROGRESS Sweep is currently being executed SUCCESS Sweep has succeeded, ready for result retrieval FAILURE Sweep has failed REVOKED Sweep was revoked from execution INTERRUPTED Sweep was interrupted during its execution Methods Sweep waiting for execution or status unknown Sweep is currently being executed Sweep has succeeded, ready for result retrieval Sweep has failed Sweep was revoked from execution Sweep was interrupted during its execution previous SweepDefinition next type_aliases © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"ObservationDefinition","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.observation.ObservationDefinition.html","description":"Bases: ObservationBase The content of the observation definition. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationErr...","content":"Bases: ObservationBase The content of the observation definition. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.observation Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. dut_label DUT label of the device the observation is about. source How the observation was made, e.g. experiment analysis or manual specification. tags Human-readable tags of the observation. dut_field Name of the property the observation is about. value Value of the observation. unit SI unit of the value. uncertainty Uncertainty of the observation value. invalid Flag indicating if the object is invalid. Methods dut_field ( str ) – value ( bool | str | int | float | complex | ndarray ) – unit ( str ) – uncertainty ( int | float | complex | ndarray | None ) – invalid ( bool ) – dut_label ( str ) – source ( dict [ str , Any ] ) – tags ( list [ str ] ) – DUT label of the device the observation is about. How the observation was made, e.g. experiment analysis or manual specification. source always has the key \\"type\\" whose str value determines the other contents of the dict.\\nThe currently supported source types are:\\n- analysis_source\\n- configuration_source\\n- measurement_source\\n- sequence_analysis_source\\n- specification_source Human-readable tags of the observation. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous ObservationData next ObservationLite © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.iqm_server.iqm_server_client.to_task_status","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.iqm_server_client.to_task_status.html","description":"job_status ( <google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x7f38174b1410> ) – str previous iqm.station_control.client.iqm_server.iqm_server_client.to_sweep_status next iqm.sta...","content":"job_status ( <google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x7f38174b1410> ) – str previous iqm.station_control.client.iqm_server.iqm_server_client.to_sweep_status next iqm.station_control.client.iqm_server.iqm_server_client.wrap_error © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.iqm_server.proto.qc_pb2_grpc.add_QuantumComputersServicer_to_server","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.qc_pb2_grpc.add_QuantumComputersServicer_to_server.html","description":"previous qc_pb2_grpc next QuantumComputers © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26....","content":"previous qc_pb2_grpc next QuantumComputers © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"ListModel","url":"/iqm-station-control-client/api/iqm.station_control.client.list_models.ListModel.html","description":"Bases: RootModel A Pydantic BaseModel for a container model of a list of objects. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_co...","content":"Bases: RootModel A Pydantic BaseModel for a container model of a list of objects. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.client.list_models Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. root  Methods root ( RootModelRootType ) – Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous DutList next ObservationDataList © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.iqm_server.iqm_server_client.wrap_error","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.iqm_server_client.wrap_error.html","description":"title ( str ) – previous iqm.station_control.client.iqm_server.iqm_server_client.to_task_status next IqmServerClient © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26....","content":"title ( str ) – previous iqm.station_control.client.iqm_server.iqm_server_client.to_task_status next IqmServerClient © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"common_pb2_grpc","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.common_pb2_grpc.html","description":"Client and server classes corresponding to protobuf-defined services. Full path: iqm.station_control.client.iqm_server.proto.common_pb2_grpc previous common_pb2 next job_pb2 © Copyright 2019-2025, IQM...","content":"Client and server classes corresponding to protobuf-defined services. Full path: iqm.station_control.client.iqm_server.proto.common_pb2_grpc previous common_pb2 next job_pb2 © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"SequenceMetadataDefinition","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.sequence.SequenceMetadataDefinition.html","description":"Bases: SequenceMetadataBase The content of the sequence metadata object when creating it. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pyd...","content":"Bases: SequenceMetadataBase The content of the sequence metadata object when creating it. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.sequence Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. sequence_id Unique identifier of the sequence. origin_id Unique identifier of the creator. origin_uri Uniform resource identifier (weak reference) for the creator. Methods sequence_id ( UUID ) – origin_id ( str ) – origin_uri ( str ) – Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous SequenceMetadataData next SequenceResultBase © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"SequenceResultBase","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.sequence.SequenceResultBase.html","description":"Bases: PydanticBase Abstract base class of the sequence result definition and data. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_...","content":"Bases: PydanticBase Abstract base class of the sequence result definition and data. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.sequence Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. sequence_id Unique identifier of the sequence result. data JSON serializable dict. final Indicates whether this result was marked as final. Methods sequence_id ( UUID ) – data ( dict [ str , Any ] ) – final ( bool ) – Unique identifier of the sequence result. JSON serializable dict. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Indicates whether this result was marked as final. previous SequenceMetadataDefinition next SequenceResultData © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"run_serializers","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.run_serializers.html","description":"Serializers and deserializers for run related models. Full path: iqm.station_control.client.serializers.run_serializers Functions deserialize_run_data (data) Convert a JSON serializable dictionary to ...","content":"Serializers and deserializers for run related models. Full path: iqm.station_control.client.serializers.run_serializers Functions deserialize_run_data (data) Convert a JSON serializable dictionary to RunData object. deserialize_run_definition (run_definition_proto) Convert run proto into RunDefinition. serialize_run_data (run_data) Convert RunData object to a JSON serializable dictionary. serialize_run_definition (run_definition) Convert RunDefinition into run proto. previous iqm.station_control.client.serializers.playlist_serializers.unpack_playlist next iqm.station_control.client.serializers.run_serializers.deserialize_run_data © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.serializers.run_serializers.deserialize_run_data","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.run_serializers.deserialize_run_data.html","description":"Convert a JSON serializable dictionary to RunData object. data ( dict ) – RunData previous run_serializers next iqm.station_control.client.serializers.run_serializers.deserialize_run_definition © Copy...","content":"Convert a JSON serializable dictionary to RunData object. data ( dict ) – RunData previous run_serializers next iqm.station_control.client.serializers.run_serializers.deserialize_run_definition © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"SweepData","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.sweep.SweepData.html","description":"Bases: SweepBase The content of the sweep stored in the database. Module: iqm.station_control.interface.models.sweep Attributes created_timestamp Time when the object was created in the database. modi...","content":"Bases: SweepBase The content of the sweep stored in the database. Module: iqm.station_control.interface.models.sweep Attributes created_timestamp Time when the object was created in the database. modified_timestamp Time when the object was last modified in the database. begin_timestamp Time when the sweep began in the station control. end_timestamp Time when the sweep ended in the station control. sweep_status Status of sweep execution. sweep_id Unique identifier of the sweep. dut_label DUT label of the device being used. settings A tree representation of the initial settings to set before the sweep. sweeps Sweeps that define the swept parameters, i.e. a list of parallel sweeps, where the data values of all sweeps in the tuple are interleaved, and updated simultaneously during the sweep. return_parameters Parameters that will be queried from devices and saved for each spot (variable-tuple) of the N-dimensional sweep. Methods sweep_id ( UUID ) – dut_label ( str ) – settings ( SettingNode ) – sweeps ( list [ tuple [ Sweep , ... ] ] ) – return_parameters ( list [ str ] ) – created_timestamp ( datetime ) – modified_timestamp ( datetime ) – begin_timestamp ( datetime | None ) – end_timestamp ( datetime | None ) – sweep_status ( SweepStatus ) – Time when the object was created in the database. Time when the object was last modified in the database. Time when the sweep began in the station control. Time when the sweep ended in the station control. Status of sweep execution. previous SweepBase next SweepDefinition © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"ObservationUpdateList","url":"/iqm-station-control-client/api/iqm.station_control.client.list_models.ObservationUpdateList.html","description":"alias of ListModel[list[ObservationUpdate]] previous ObservationSetDataList next ResponseWithMeta © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26....","content":"alias of ListModel[list[ObservationUpdate]] previous ObservationSetDataList next ResponseWithMeta © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.serializers.playlist_serializers.unpack_playlist","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.playlist_serializers.unpack_playlist.html","description":"Unpack a protobuf representation of a playlist into its runtime representation. proto_playlist ( Playlist ) – serialized playlist proto_playlist in runtime representation Playlist previous iqm.station...","content":"Unpack a protobuf representation of a playlist into its runtime representation. proto_playlist ( Playlist ) – serialized playlist proto_playlist in runtime representation Playlist previous iqm.station_control.client.serializers.playlist_serializers.pack_playlist next run_serializers © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.serializers.run_serializers.serialize_run_definition","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.run_serializers.serialize_run_definition.html","description":"Convert RunDefinition into run proto. run_definition ( RunDefinition ) – RunDefinition previous iqm.station_control.client.serializers.run_serializers.serialize_run_data next setting_node_serializer ©...","content":"Convert RunDefinition into run proto. run_definition ( RunDefinition ) – RunDefinition previous iqm.station_control.client.serializers.run_serializers.serialize_run_data next setting_node_serializer © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"qc_pb2","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.qc_pb2.html","description":"Generated protocol buffer code. Full path: iqm.station_control.client.iqm_server.proto.qc_pb2 previous JobsStub next qc_pb2_grpc © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 20...","content":"Generated protocol buffer code. Full path: iqm.station_control.client.iqm_server.proto.qc_pb2 previous JobsStub next qc_pb2_grpc © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm_server_mock","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.testing.iqm_server_mock.html","description":"Internal testing utilities for IqmServerClient Full path: iqm.station_control.client.iqm_server.testing.iqm_server_mock Classes IqmServerMockBase Base class for IQM server mocks. Inheritance previous ...","content":"Internal testing utilities for IqmServerClient Full path: iqm.station_control.client.iqm_server.testing.iqm_server_mock Classes IqmServerMockBase Base class for IQM server mocks. Inheritance previous testing next IqmServerMockBase © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.iqm_server.grpc_utils.from_proto_uuid","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.grpc_utils.from_proto_uuid.html","description":"value ( Uuid ) – UUID previous iqm.station_control.client.iqm_server.grpc_utils.extract_error next iqm.station_control.client.iqm_server.grpc_utils.load_all © Copyright 2019-2025, IQM Finland Oy, Rele...","content":"value ( Uuid ) – UUID previous iqm.station_control.client.iqm_server.grpc_utils.extract_error next iqm.station_control.client.iqm_server.grpc_utils.load_all © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"DutFieldDataList","url":"/iqm-station-control-client/api/iqm.station_control.client.list_models.DutFieldDataList.html","description":"alias of ListModel[list[DutFieldData]] previous list_models next DutList © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26....","content":"alias of ListModel[list[DutFieldData]] previous list_models next DutList © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm_server","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.html","description":"StationControlClient implementation for IQM Server Full path: iqm.station_control.client.iqm_server Subpackages and modules error  grpc_utils Internal utility functions used by IqmServerClient. iqm_se...","content":"StationControlClient implementation for IQM Server Full path: iqm.station_control.client.iqm_server Subpackages and modules error  grpc_utils Internal utility functions used by IqmServerClient. iqm_server_client StationControlClient implementation for IQM Server meta_class  proto  testing  previous client next error © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"ObservationSetBase","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.observation_set.ObservationSetBase.html","description":"Bases: PydanticBase Abstract base class of the observation set definition and data. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_...","content":"Bases: PydanticBase Abstract base class of the observation set definition and data. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.observation_set Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. observation_set_type Indicates the type (i.e. purpose) of the observation set. observation_ids Database IDs of the observations belonging to the observation set. describes_id Unique identifier of the observation set this observation set describes. invalid Flag indicating if the object is invalid. Methods observation_set_type ( Literal [ 'calibration-set' , 'characterization-set' , 'generic-set' , 'quality-metric-set' ] ) – observation_ids ( list [ int ] ) – describes_id ( UUID | None ) – invalid ( bool ) – Indicates the type (i.e. purpose) of the observation set. Database IDs of the observations belonging to the observation set. Unique identifier of the observation set this observation set describes. Flag indicating if the object is invalid. Automated systems must not use invalid objects. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous observation_set next ObservationSetData © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_data","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_data.html","description":"Convert JSON serializable dictionary into SweepData. data ( dict ) – SweepData previous sweep_serializers next iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_definition © C...","content":"Convert JSON serializable dictionary into SweepData. data ( dict ) – SweepData previous sweep_serializers next iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_definition © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.utils.calset_from_observations","url":"/iqm-station-control-client/api/iqm.station_control.client.utils.calset_from_observations.html","description":"Create a calibration set from the given observations. calset_observations ( Iterable [ ObservationBase ] ) – observations that form a calibration set calibration set dict [ str , bool | str | int | fl...","content":"Create a calibration set from the given observations. calset_observations ( Iterable [ ObservationBase ] ) – observations that form a calibration set calibration set dict [ str , bool | str | int | float | complex | ndarray ] previous utils next iqm.station_control.client.utils.get_progress_bar_callback © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.serializers.struct_serializer.serialize_struct","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.struct_serializer.serialize_struct.html","description":"Serialize a free-form dict into a Struct protobuf representation. data ( dict ) – Struct previous iqm.station_control.client.serializers.struct_serializer.deserialize_struct next sweep_serializers © C...","content":"Serialize a free-form dict into a Struct protobuf representation. data ( dict ) – Struct previous iqm.station_control.client.serializers.struct_serializer.deserialize_struct next sweep_serializers © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.iqm_server.iqm_server_client.subscribe_to_job_events","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.iqm_server_client.subscribe_to_job_events.html","description":"channel ( Channel ) – job_id ( UUID ) – Iterable [ JobV1 ] previous iqm.station_control.client.iqm_server.iqm_server_client.resolve_current_qc next iqm.station_control.client.iqm_server.iqm_server_cli...","content":"channel ( Channel ) – job_id ( UUID ) – Iterable [ JobV1 ] previous iqm.station_control.client.iqm_server.iqm_server_client.resolve_current_qc next iqm.station_control.client.iqm_server.iqm_server_client.to_sweep_status © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.serializers.channel_property_serializer.deserialize_channel_properties","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.channel_property_serializer.deserialize_channel_properties.html","description":"Convert the given protobuf dictionary of channel properties into a dictionary of ChannelProperties . channel_properties_dictionary – channel property dictionary in protobuf format convert_instructions...","content":"Convert the given protobuf dictionary of channel properties into a dictionary of ChannelProperties . channel_properties_dictionary – channel property dictionary in protobuf format convert_instructions ( bool ) – whether to convert string representation of instruction types to actual\\npython types. channel_property_dictionary ( ChannelPropertyDictionary ) – dictionary of channel properties dict [ str , ChannelProperties ] previous channel_property_serializer next iqm.station_control.client.serializers.channel_property_serializer.deserialize_instructions © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"SequenceMetadataData","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.sequence.SequenceMetadataData.html","description":"Bases: SequenceMetadataBase The content of the sequence metadata stored in the database. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pyda...","content":"Bases: SequenceMetadataBase The content of the sequence metadata stored in the database. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.sequence Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. created_timestamp Time when the object was created in the database. sequence_id Unique identifier of the sequence. origin_id Unique identifier of the creator. origin_uri Uniform resource identifier (weak reference) for the creator. Methods sequence_id ( UUID ) – origin_id ( str ) – origin_uri ( str ) – created_timestamp ( datetime ) – Time when the object was created in the database. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous SequenceMetadataBase next SequenceMetadataDefinition © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"run","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.run.html","description":"Run related station control interface models. Full path: iqm.station_control.interface.models.run Classes RunBase Abstract base class of run data. RunConfigurationBase Abstract base class of the run c...","content":"Run related station control interface models. Full path: iqm.station_control.interface.models.run Classes RunBase Abstract base class of run data. RunConfigurationBase Abstract base class of the run configuration data. RunData The content of the run and its configuration stored in the database. RunDefinition The content of the run object when creating it. RunLite The data of the run stored in the database, excluding run configuration data. RunWithTimestamps Abstract base class of run data including timestamps. Inheritance previous ObservationSetUpdate next RunBase © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"QuantumComputersStub","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.qc_pb2_grpc.QuantumComputersStub.html","description":"Bases: object Quantum Computer management APIs. Constructor. channel – A grpc.Channel. Module: iqm.station_control.client.iqm_server.proto.qc_pb2_grpc Methods previous QuantumComputersServicer next uu...","content":"Bases: object Quantum Computer management APIs. Constructor. channel – A grpc.Channel. Module: iqm.station_control.client.iqm_server.proto.qc_pb2_grpc Methods previous QuantumComputersServicer next uuid_pb2 © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.serializers.setting_node_serializer.deserialize_setting_node","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.setting_node_serializer.deserialize_setting_node.html","description":"Convert binary string into SettingNode. setting_node_str ( bytes ) – SettingNode previous setting_node_serializer next struct_serializer © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updat...","content":"Convert binary string into SettingNode. setting_node_str ( bytes ) – SettingNode previous setting_node_serializer next struct_serializer © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"SweepBase","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.sweep.SweepBase.html","description":"Bases: object Abstract base class of the sweep definition and data. Module: iqm.station_control.interface.models.sweep Attributes sweep_id Unique identifier of the sweep. dut_label DUT label of the de...","content":"Bases: object Abstract base class of the sweep definition and data. Module: iqm.station_control.interface.models.sweep Attributes sweep_id Unique identifier of the sweep. dut_label DUT label of the device being used. settings A tree representation of the initial settings to set before the sweep. sweeps Sweeps that define the swept parameters, i.e. a list of parallel sweeps, where the data values of all sweeps in the tuple are interleaved, and updated simultaneously during the sweep. return_parameters Parameters that will be queried from devices and saved for each spot (variable-tuple) of the N-dimensional sweep. Methods sweep_id ( UUID ) – dut_label ( str ) – settings ( SettingNode ) – sweeps ( list [ tuple [ Sweep , ... ] ] ) – return_parameters ( list [ str ] ) – Unique identifier of the sweep. DUT label of the device being used. A tree representation of the initial settings to set before the sweep. Sweeps that define the swept parameters, i.e. a list of parallel sweeps,\\nwhere the data values of all sweeps in the tuple are interleaved, and updated simultaneously during the sweep. Parameters that will be queried from devices and saved for each spot (variable-tuple)\\nof the N-dimensional sweep. Each item must correspond to a setting name in settings . previous sweep next SweepData © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"error","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.error.html","description":"Full path: iqm.station_control.client.iqm_server.error Exceptions IqmServerError (message, status_code[, ...])  previous iqm_server next iqm.station_control.client.iqm_server.error.IqmServerError © Co...","content":"Full path: iqm.station_control.client.iqm_server.error Exceptions IqmServerError (message, status_code[, ...])  previous iqm_server next iqm.station_control.client.iqm_server.error.IqmServerError © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.iqm_server.grpc_utils.to_proto_uuid","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.grpc_utils.to_proto_uuid.html","description":"value ( UUID ) – Uuid previous iqm.station_control.client.iqm_server.grpc_utils.to_datetime next ApiTokenAuth © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26....","content":"value ( UUID ) – Uuid previous iqm.station_control.client.iqm_server.grpc_utils.to_datetime next ApiTokenAuth © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"ObservationSetUpdate","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.observation_set.ObservationSetUpdate.html","description":"Bases: PydanticBase The observation set data to be updated in the database. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.Val...","content":"Bases: PydanticBase The observation set data to be updated in the database. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.observation_set Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. observation_set_id Unique identifier of the observation set. observation_ids Database IDs of the observations belonging to the observation set. invalid Flag indicating if the object is invalid. Methods observation_set_id ( UUID ) – observation_ids ( list [ int ] | None ) – invalid ( bool ) – Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Unique identifier of the observation set. Database IDs of the observations belonging to the observation set. This will only add new observations to the observation set, deleting existing ones is not possible.\\nSetting this to None or omitting it will leave existing observation_ids as is with no changes. Flag indicating if the object is invalid. Automated systems must not use invalid objects. previous ObservationSetDefinition next run © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_data","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_data.html","description":"Convert SweepData into JSON serializable dictionary. sweep_data ( SweepData ) – dict previous iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_results next iqm.station_contro...","content":"Convert SweepData into JSON serializable dictionary. sweep_data ( SweepData ) – dict previous iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_results next iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_definition © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"ObservationData","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.observation.ObservationData.html","description":"Bases: ObservationLite , ObservationDefinition The content of the observation stored in the database. Create a new model by parsing and validating input data from keyword arguments. Raises [ Validatio...","content":"Bases: ObservationLite , ObservationDefinition The content of the observation stored in the database. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.observation Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. observation_set_ids List of observation set UUIDs this observation belongs to. observation_id Unique identifier of the observation. created_timestamp Time when the object was created in the database. modified_timestamp Time when the object was last modified in the database. dut_label DUT label of the device the observation is about. source How the observation was made, e.g. experiment analysis or manual specification. tags Human-readable tags of the observation. dut_field Name of the property the observation is about. value Value of the observation. unit SI unit of the value. uncertainty Uncertainty of the observation value. invalid Flag indicating if the object is invalid. Methods dut_field ( str ) – value ( bool | str | int | float | complex | ndarray ) – unit ( str ) – uncertainty ( int | float | complex | ndarray | None ) – invalid ( bool ) – dut_label ( str ) – source ( dict [ str , Any ] ) – tags ( list [ str ] ) – observation_id ( int ) – created_timestamp ( datetime ) – modified_timestamp ( datetime ) – observation_set_ids ( list [ UUID ] ) – Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. List of observation set UUIDs this observation belongs to. previous ObservationBase next ObservationDefinition © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.serializers.datetime_serializers.deserialize_datetime","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.datetime_serializers.deserialize_datetime.html","description":"Convert a string formatted according to ISO to a datetime object. timestamp ( str | None ) – datetime | None previous datetime_serializers next iqm.station_control.client.serializers.datetime_serializ...","content":"Convert a string formatted according to ISO to a datetime object. timestamp ( str | None ) – datetime | None previous datetime_serializers next iqm.station_control.client.serializers.datetime_serializers.serialize_datetime © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"DutFieldData","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.dut.DutFieldData.html","description":"Bases: PydanticBase A DUT field or path and its unit. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the i...","content":"Bases: PydanticBase A DUT field or path and its unit. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.dut Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. path DUT field or path. unit SI unit of the value. Methods path ( str ) – unit ( str ) – Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. DUT field or path. SI unit of the value. Empty string means the value is dimensionless. previous DutData next observation © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_results","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_results.html","description":"Convert SweepResults into binary string. sweep_id ( UUID ) – sweep_results ( dict [ str , list [ ndarray ] ] ) – bytes previous iqm.station_control.client.serializers.sweep_serializers.serialize_sweep...","content":"Convert SweepResults into binary string. sweep_id ( UUID ) – sweep_results ( dict [ str , list [ ndarray ] ] ) – bytes previous iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_definition next task_serializers © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"RunLiteList","url":"/iqm-station-control-client/api/iqm.station_control.client.list_models.RunLiteList.html","description":"alias of ListModel[list[RunLite]] previous ResponseWithMeta next SequenceMetadataDataList © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26....","content":"alias of ListModel[list[RunLite]] previous ResponseWithMeta next SequenceMetadataDataList © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.serializers.run_serializers.deserialize_run_definition","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.run_serializers.deserialize_run_definition.html","description":"Convert run proto into RunDefinition. run_definition_proto ( RunDefinition ) – RunDefinition previous iqm.station_control.client.serializers.run_serializers.deserialize_run_data next iqm.station_contr...","content":"Convert run proto into RunDefinition. run_definition_proto ( RunDefinition ) – RunDefinition previous iqm.station_control.client.serializers.run_serializers.deserialize_run_data next iqm.station_control.client.serializers.run_serializers.serialize_run_data © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"utils","url":"/iqm-station-control-client/api/iqm.station_control.client.utils.html","description":"Utility functions for IQM Station Control Client. Full path: iqm.station_control.client.utils Functions calset_from_observations (calset_observations) Create a calibration set from the given observati...","content":"Utility functions for IQM Station Control Client. Full path: iqm.station_control.client.utils Functions calset_from_observations (calset_observations) Create a calibration set from the given observations. get_progress_bar_callback () Returns a callback function that creates or updates existing progressbars when called. previous StationControlClient next iqm.station_control.client.utils.calset_from_observations © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"RunLite","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.run.RunLite.html","description":"Bases: RunWithTimestamps The data of the run stored in the database, excluding run configuration data. Module: iqm.station_control.interface.models.run Attributes sweep_id Unique identifier of the ass...","content":"Bases: RunWithTimestamps The data of the run stored in the database, excluding run configuration data. Module: iqm.station_control.interface.models.run Attributes sweep_id Unique identifier of the associated sweep. created_timestamp Time when the object was created in the database. modified_timestamp Time when the object was last modified in the database. begin_timestamp Time when the run began in the station control. end_timestamp Time when the run ended in the station control. run_id Unique identifier of the run. username User who defined the run. experiment_name Identifier of the Experiment ( Experiment.name ). experiment_label Freeform label of the Experiment. options Experiment-specific options or toggles that generated the run. software_version_set_id Unique identifier of the software version set of the current Python runtime. Methods run_id ( UUID ) – username ( str ) – experiment_name ( str ) – experiment_label ( str ) – options ( dict [ str , Any ] | None ) – software_version_set_id ( int | None ) – created_timestamp ( datetime ) – modified_timestamp ( datetime ) – begin_timestamp ( datetime ) – end_timestamp ( datetime | None ) – sweep_id ( UUID | None ) – Unique identifier of the associated sweep. previous RunDefinition next RunWithTimestamps © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"IqmServerClient","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.iqm_server_client.IqmServerClient.html","description":"Bases: StationControlClient Module: iqm.station_control.client.iqm_server.iqm_server_client Attributes Methods create_observation_set Create an observation set in the database. create_observations Cre...","content":"Bases: StationControlClient Module: iqm.station_control.client.iqm_server.iqm_server_client Attributes Methods create_observation_set Create an observation set in the database. create_observations Create observations in the database. create_sequence_metadata Create sequence metadata in the database. delete_sweep Delete sweep in the database. finalize_observation_set Finalize an observation set in the database. get_about Return information about the station control. get_calibration_set_values Get saved calibration set observations by UUID get_channel_properties Get channel properties from the station. get_chip_design_record Get a raw chip design record matching the given chip label. get_configuration Return the configuration of the station control. get_dut_fields Get DUT fields for the specified DUT label from the database. get_duts Get DUTs of the station control. get_latest_calibration_set_id Get UUID of the latest saved calibration set for the given dut_label. get_observation_set Get an observation set from the database. get_observation_set_observations Get the constituent observations of an observation set from the database. get_observations Get observations from the database. get_or_create_software_version_set Get software version set ID from the database, or create if it doesn't exist. get_run Get run data from the database. get_sequence_result Get sequence result from the database. get_settings Return a tree representation of the default settings as defined in the configuration file. get_sweep Get N-dimensional sweep data from the database. get_sweep_results Get N-dimensional sweep results from the database. get_task Get task data. init Initialize a new station control client instance connected to the given remote. query_observation_sets Query observation sets from the database. query_observations Query observations from the database. query_runs Query runs from the database. query_sequence_metadatas Query sequence metadatas from the database. revoke_sweep Either remove a sweep task from the queue, or abort it gracefully if it's already executing. run Execute an N-dimensional sweep of selected variables and save run, sweep and results. save_sequence_result Save sequence result in the database. sweep Execute an N-dimensional sweep of selected variables and save sweep and results. update_observation_set Update an observation set in the database. update_observations Update observations in the database. root_url ( str ) – get_token_callback ( Callable [ [ ] , str ] | None ) – grpc_channel ( Channel | None ) – Return information about the station control. dict Return the configuration of the station control. dict Return a tree representation of the default settings as defined in the configuration file. SettingNode Get a raw chip design record matching the given chip label. dut_label ( str ) – dict Get channel properties from the station. Channel properties contain information regarding hardware limitations e.g. sampling rate, granularity\\nand supported instructions. Mapping from channel name to AWGProperties or ReadoutProperties dict [ str , ChannelProperties ] Get DUTs of the station control. list [ DutData ] Get DUT fields for the specified DUT label from the database. dut_label ( str ) – list [ DutFieldData ] Execute an N-dimensional sweep of selected variables and save sweep and results. The raw data for each spot in the sweep is saved as numpy arrays,\\nand the complete data for the whole sweep is saved as an x-array dataset\\nwhich has the sweep_definition.sweeps as coordinates and\\ndata of sweep_definition.return_parameters data as DataArrays. The values of sweep_definition.playlist will be uploaded to the controllers given by the keys of sweep_definition.playlist . sweep_definition ( SweepDefinition ) – The content of the sweep to be created. Dict containing the task ID  and sweep ID, and corresponding hrefs, of a successful sweep execution\\nin monolithic mode or successful submission to the task queue in remote mode. ExaError if submitting a sweep failed. – dict Get N-dimensional sweep data from the database. sweep_id ( UUID ) – SweepData Get N-dimensional sweep results from the database. sweep_id ( UUID ) – dict [ str , list [ ndarray ]] Either remove a sweep task from the queue, or abort it gracefully if it’s already executing. If the task was already executing when revoked, the status of the task will be set to \\"INTERRUPTED\\" .\\nIf the task had not started yet, the status will be set to \\"REVOKED\\" .\\nIf the task is not found or is already finished nothing happens. sweep_id ( UUID ) – None Get task data. task_id ( UUID ) – dict Get saved calibration set observations by UUID calibration_set_id ( UUID ) – UUID of the calibration set to retrieve. Dictionary of observations belonging to the given calibration set. dict [ str , bool | str | int | float | complex | ndarray ] Get UUID of the latest saved calibration set for the given dut_label. dut_label ( str ) – Target DUT label UUID of the latest saved calibration set. UUID Create an observation set in the database. observation_set_definition – The content of the observation set to be created. The content of the observation set. ExaError – If creation failed. Create observations in the database. observation_definitions – A sequence of observation definitions,\\neach containing the content of the observation which will be created. Created observations, each including also the database created fields like ID and timestamps. Create sequence metadata in the database. Delete sweep in the database. Finalize an observation set in the database. A finalized set is nearly immutable, allowing to change only invalid flag after finalization. observation_set_id – Observation set to finalize. ExaError – If finalization failed. Get an observation set from the database. observation_set_id – Observation set to retrieve. The content of the observation set. ExaError – If retrieval failed. Get the constituent observations of an observation set from the database. observation_set_id – UUID of the observation set to retrieve. Observations belonging to the given observation set. Get observations from the database. Observations are queried by the given query parameters. mode – The “mode” used to query the observations. Possible values “all_latest”, “tags_and”, or “tags_or”. ”all_latest”:Query all the latest observations for the given dut_label .\\nNo other query parameters are accepted. ”tags_and”: Query observations. Query all the observations that have all the given tags .\\nBy default, only valid observations are included.\\nAll other query parameters can be used to narrow down the query,\\nexpect “run_ids” and “sequence_ids”. ”tags_or”: Query all the latest observations that have at least one of the given tags .\\nAdditionally, dut_label must be given. No other query parameters are used. ”sequence”: Query observations originating from a list of run and/or sequence IDs.\\nNo other query parameters are accepted. The “mode” used to query the observations. Possible values “all_latest”, “tags_and”, or “tags_or”. ”all_latest”:Query all the latest observations for the given dut_label .\\nNo other query parameters are accepted. ”tags_and”: Query observations. Query all the observations that have all the given tags .\\nBy default, only valid observations are included.\\nAll other query parameters can be used to narrow down the query,\\nexpect “run_ids” and “sequence_ids”. ”tags_or”: Query all the latest observations that have at least one of the given tags .\\nAdditionally, dut_label must be given. No other query parameters are used. ”sequence”: Query observations originating from a list of run and/or sequence IDs.\\nNo other query parameters are accepted. dut_label – DUT label of the device the observations pertain to. dut_field – Name of the property the observation is about. tags – Human-readable tags of the observation. invalid – Flag indicating if the object is invalid. Automated systems must not use invalid objects.\\nIf None , both valid and invalid objects are included. run_ids – The run IDs for which to query the observations. sequence_ids – The sequence IDs for which to query the observations. limit – Indicates the maximum number of items to return. Observations, each including also the database created fields like ID and timestamps. Get software version set ID from the database, or create if it doesn’t exist. Get run data from the database. Get sequence result from the database. Initialize a new station control client instance connected to the given remote. Client implementation is selected automatically based on the remote station: if the remote station\\nis running the IQM Server software stack, then the IQM Server client implementation (with a limited\\nfeature set) is chosen. If the remote station is running the SC software stack, then the Station\\nControl client implementation (with the full feature set) is chosen. root_url – Remote station control service URL. For IQM Server remotes, this is the “Quantum Computer URL”\\nvalue from the web dashboard. get_token_callback – A callback function that returns a token (str) which will be passed in Authorization\\nheader in all requests. Query observation sets from the database. observation_set_id: UUID observation_set_id__in: list[UUID] observation_set_type: Literal[“calibration-set”, “generic-set”, “quality-metric-set”] observation_ids__overlap: list[int] observation_ids__contains: list[int] describes_id: UUID describes_id__in: list[UUID] invalid: bool created_timestamp__range: tuple[datetime, datetime] end_timestamp__isnull: bool dut_label: str dut_label__in: list[str] Queried observation sets with some query related metadata Query observations from the database. observation_id: int observation_id__in: list[int] dut_label: str dut_field: str dut_field__in: list[str] tags__overlap: list[str] tags__contains: list[str] invalid: bool source__run_id__in: list[uuid.UUID] source__sequence_id__in: list[uuid.UUID] source__type: str uncertainty__isnull: bool created_timestamp__range: tuple[datetime, datetime] observation_set_ids__overlap: list[uuid.UUID] observation_set_ids__contains: list[uuid.UUID] Queried observations with some query related metadata. Query runs from the database. run_id: uuid.UUID run_id__in: list[uuid.UUID] sweep_id: uuid.UUID sweep_id__in: list[uuid.UUID] username: str username__in: list[str] username__contains: str username__icontains: str experiment_label: str experiment_label__in: list[str] experiment_label__contains: str experiment_label__icontains: str experiment_name: str experiment_name__in: list[str] experiment_name__contains: str experiment_name__icontains: str software_version_set_id: int software_version_set_id__in: list[int] begin_timestamp__range: tuple[datetime, datetime] end_timestamp__range: tuple[datetime, datetime] end_timestamp__isnull: bool Queried runs with some query related metadata. Query sequence metadatas from the database. origin_id: str origin_id__in: list[str] origin_uri: str origin_uri__icontains: str created_timestamp__range: tuple[datetime, datetime] Sequence metadatas with some query related metadata. Execute an N-dimensional sweep of selected variables and save run, sweep and results. Save sequence result in the database. This method creates the object if it doesn’t exist and completely replaces the “data” and “final” if it does.\\nTimestamps are assigned by the database. “modified_timestamp” is not set on initial creation,\\nbut it’s updated on each subsequent call. Update an observation set in the database. observation_set_update – The content of the observation set to be updated. The content of the observation set. ExaError – If updating failed. Update observations in the database. observation_updates – A sequence of observation updates,\\neach containing the content of the observation which will be updated. Updated observations, each including also the database created fields like ID and timestamps. previous iqm.station_control.client.iqm_server.iqm_server_client.wrap_error next meta_class © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.serializers.task_serializers.serialize_run_task_request","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.task_serializers.serialize_run_task_request.html","description":"Wrap run_definition and queue_name into a protobuf message and serialize into a bitstring. run_definition ( RunDefinition ) – The content of the run. queue_name ( str ) – Name of the destination queue...","content":"Wrap run_definition and queue_name into a protobuf message and serialize into a bitstring. run_definition ( RunDefinition ) – The content of the run. queue_name ( str ) – Name of the destination queue. SweepTaskRequest encoded into a bitstring. bytes previous iqm.station_control.client.serializers.task_serializers.deserialize_sweep_task_request next iqm.station_control.client.serializers.task_serializers.serialize_sweep_task_request © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"RunDefinition","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.run.RunDefinition.html","description":"Bases: RunBase , RunConfigurationBase The content of the run object when creating it. Module: iqm.station_control.interface.models.run Attributes sweep_definition The content of the associated sweep s...","content":"Bases: RunBase , RunConfigurationBase The content of the run object when creating it. Module: iqm.station_control.interface.models.run Attributes sweep_definition The content of the associated sweep stored in the database. run_id Unique identifier of the run. username User who defined the run. experiment_name Identifier of the Experiment ( Experiment.name ). experiment_label Freeform label of the Experiment. options Experiment-specific options or toggles that generated the run. software_version_set_id Unique identifier of the software version set of the current Python runtime. additional_run_properties A free-form dictionary of data, used to store information that does not fall into other categories. hard_sweeps Maps SweepBase.return_parameters to \\"hardware sweep specification\\" which specifies how the data measured at each spot should be interpreted and shaped. components Components that participate in this run. default_data_parameters The subset of SweepBase.return_parameters that were added by default, not by the user. default_sweep_parameters The subset of SweepBase.sweeps parameters were added by default, not by the user. Methods additional_run_properties ( dict [ str , Any ] | None ) – hard_sweeps ( dict [ str , list [ tuple [ Sweep , ... ] ] ] | None ) – components ( list [ str ] ) – default_data_parameters ( list [ str ] ) – default_sweep_parameters ( list [ str ] ) – run_id ( UUID ) – username ( str ) – experiment_name ( str ) – experiment_label ( str ) – options ( dict [ str , Any ] | None ) – software_version_set_id ( int | None ) – sweep_definition ( SweepDefinition ) – The content of the associated sweep stored in the database. previous RunData next RunLite © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"DutData","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.dut.DutData.html","description":"Bases: PydanticBase Represents a Device Under Test, or DUT, for short. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.Validati...","content":"Bases: PydanticBase Represents a Device Under Test, or DUT, for short. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.dut Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. label DUT label of the device. dut_type String indicating the DUT type of the device Can be either 'chip' or 'twpa'. Methods label ( str ) – dut_type ( Literal [ 'chip' , 'twpa' ] ) – DUT label of the device. String indicating the DUT type of the device\\nCan be either ‘chip’ or ‘twpa’. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous dut next DutFieldData © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"observation","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.observation.html","description":"Observation related station control interface models. Full path: iqm.station_control.interface.models.observation Classes ObservationBase Abstract base class of the observation models. ObservationData...","content":"Observation related station control interface models. Full path: iqm.station_control.interface.models.observation Classes ObservationBase Abstract base class of the observation models. ObservationData The content of the observation stored in the database. ObservationDefinition The content of the observation definition. ObservationLite The lightweight version of the observation data. ObservationUpdate The observation data to be updated in the database. Inheritance previous DutFieldData next ObservationBase © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.iqm_server.grpc_utils.to_datetime","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.grpc_utils.to_datetime.html","description":"timestamp ( Timestamp ) – datetime previous iqm.station_control.client.iqm_server.grpc_utils.parse_connection_params next iqm.station_control.client.iqm_server.grpc_utils.to_proto_uuid © Copyright 201...","content":"timestamp ( Timestamp ) – datetime previous iqm.station_control.client.iqm_server.grpc_utils.parse_connection_params next iqm.station_control.client.iqm_server.grpc_utils.to_proto_uuid © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.serializers.datetime_serializers.serialize_datetime","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.datetime_serializers.serialize_datetime.html","description":"Convert a datetime object to a string formatted according to ISO. timestamp ( datetime | None ) – str | None previous iqm.station_control.client.serializers.datetime_serializers.deserialize_datetime n...","content":"Convert a datetime object to a string formatted according to ISO. timestamp ( datetime | None ) – str | None previous iqm.station_control.client.serializers.datetime_serializers.deserialize_datetime next playlist_serializers © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.iqm_server.iqm_server_client.resolve_current_qc","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.iqm_server_client.resolve_current_qc.html","description":"channel ( Channel ) – alias ( str ) – QuantumComputerV1 previous iqm.station_control.client.iqm_server.iqm_server_client.payload_to_sweep next iqm.station_control.client.iqm_server.iqm_server_client.s...","content":"channel ( Channel ) – alias ( str ) – QuantumComputerV1 previous iqm.station_control.client.iqm_server.iqm_server_client.payload_to_sweep next iqm.station_control.client.iqm_server.iqm_server_client.subscribe_to_job_events © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.iqm_server.error.IqmServerError","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.error.IqmServerError.html","description":"message ( str ) – status_code ( str ) – error_code ( str | None ) – details ( dict | None ) – previous error next grpc_utils © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-0...","content":"message ( str ) – status_code ( str ) – error_code ( str | None ) – details ( dict | None ) – previous error next grpc_utils © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"ObservationSetDataList","url":"/iqm-station-control-client/api/iqm.station_control.client.list_models.ObservationSetDataList.html","description":"alias of ListModel[list[ObservationSetData]] previous ObservationLiteList next ObservationUpdateList © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26....","content":"alias of ListModel[list[ObservationSetData]] previous ObservationLiteList next ObservationUpdateList © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"calibration_pb2_grpc","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc.html","description":"Client and server classes corresponding to protobuf-defined services. Full path: iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc Functions add_CalibrationsServicer_to_server (servicer...","content":"Client and server classes corresponding to protobuf-defined services. Full path: iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc Functions add_CalibrationsServicer_to_server (servicer, ...)  Classes Calibrations Missing associated documentation comment in .proto file. CalibrationsServicer Missing associated documentation comment in .proto file. CalibrationsStub Missing associated documentation comment in .proto file. Inheritance previous calibration_pb2 next iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc.add_CalibrationsServicer_to_server © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"datetime_serializers","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.datetime_serializers.html","description":"Serializers and deserializers for datetime related models. Full path: iqm.station_control.client.serializers.datetime_serializers Functions deserialize_datetime (timestamp) Convert a string formatted ...","content":"Serializers and deserializers for datetime related models. Full path: iqm.station_control.client.serializers.datetime_serializers Functions deserialize_datetime (timestamp) Convert a string formatted according to ISO to a datetime object. serialize_datetime (timestamp) Convert a datetime object to a string formatted according to ISO. previous iqm.station_control.client.serializers.channel_property_serializer.unpack_channel_properties next iqm.station_control.client.serializers.datetime_serializers.deserialize_datetime © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"CalibrationsServicer","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc.CalibrationsServicer.html","description":"Bases: object Missing associated documentation comment in .proto file. Module: iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc Methods GetCalibrationV1 Missing associated documentatio...","content":"Bases: object Missing associated documentation comment in .proto file. Module: iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc Methods GetCalibrationV1 Missing associated documentation comment in .proto file. GetFullCalibrationDataV1  GetLatestQuantumComputerCalibrationV1 Missing associated documentation comment in .proto file. Missing associated documentation comment in .proto file. Missing associated documentation comment in .proto file. Get the calibration set for a given QC. The calibration set is returned as bytes data that contains the JSON\\nrepresentation of the calibration set data. If the calibration set is\\nnot found, a NOT_FOUND error status is returned. previous Calibrations next CalibrationsStub © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"CalibrationsStub","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc.CalibrationsStub.html","description":"Bases: object Missing associated documentation comment in .proto file. Constructor. channel – A grpc.Channel. Module: iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc Methods previous ...","content":"Bases: object Missing associated documentation comment in .proto file. Constructor. channel – A grpc.Channel. Module: iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc Methods previous CalibrationsServicer next common_pb2 © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"list_with_meta","url":"/iqm-station-control-client/api/iqm.station_control.interface.list_with_meta.html","description":"Models to extend standard list with metadata. Full path: iqm.station_control.interface.list_with_meta Classes ListWithMeta Standard list extension holding optional metadata as well. Meta Class holding...","content":"Models to extend standard list with metadata. Full path: iqm.station_control.interface.list_with_meta Classes ListWithMeta Standard list extension holding optional metadata as well. Meta Class holding metadata for list return values, like pagination related data. Inheritance previous interface next ListWithMeta © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"interface","url":"/iqm-station-control-client/api/iqm.station_control.interface.html","description":"Station control interface. A StationControlInterface administers a set of control and measurement instruments\\nattached to a quantum device, and connects to the database and related external services. ...","content":"Station control interface. A StationControlInterface administers a set of control and measurement instruments\\nattached to a quantum device, and connects to the database and related external services. Full path: iqm.station_control.interface Subpackages and modules list_with_meta Models to extend standard list with metadata. models Station control interface models. pydantic_base Pydantic related models and types. previous iqm.station_control.client.utils.get_progress_bar_callback next list_with_meta © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.iqm_server.iqm_server_client.parse_calibration_set","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.iqm_server_client.parse_calibration_set.html","description":"cal_set_data ( bytes ) – tuple [ UUID , dict [ str , bool | str | int | float | complex | ndarray ]] previous iqm_server_client next iqm.station_control.client.iqm_server.iqm_server_client.parse_json ...","content":"cal_set_data ( bytes ) – tuple [ UUID , dict [ str , bool | str | int | float | complex | ndarray ]] previous iqm_server_client next iqm.station_control.client.iqm_server.iqm_server_client.parse_json © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"StationControlClient","url":"/iqm-station-control-client/api/iqm.station_control.client.station_control.StationControlClient.html","description":"Bases: object Station control client implementation. Current implementation uses HTTP calls to the remote station control service,\\nthat is controlling the station control instance. root_url ( str ) – ...","content":"Bases: object Station control client implementation. Current implementation uses HTTP calls to the remote station control service,\\nthat is controlling the station control instance. root_url ( str ) – Remote station control service URL. get_token_callback ( Callable [ [ ] , str ] | None ) – A callback function that returns a token (str) which will be passed in Authorization header\\nin all requests. Station control client implements generic query methods for certain objects,\\nlike query_observations() , query_observation_sets() , and query_sequence_metadatas() .\\nThese methods accept only keyword arguments as parameters, which are based on the syntax field__lookup=value .\\nNote double-underscore in the name, to separate field names like dut_field from lookup types like in .\\nThe syntax is based on Django implementation, documented here and here . As a convenience, when no lookup type is provided (like in dut_label=\\"foo\\" ),\\nthe lookup type is assumed to be exact ( dut_label__exact=\\"foo\\" ). Other supported lookup types are: For example, created_timestamp__range=(datetime(2023, 10, 12), datetime(2024, 10, 14)) For example, dut_field__in=[\\"QB1.frequency\\", \\"gates.measure.constant.QB2.frequency\\"] For example, origin_uri__icontains=\\"local\\" For example, tags__overlap=[\\"calibration=good\\", \\"2023-12-04\\"] For example, tags__contains=[\\"calibration=good\\", \\"2023-12-04\\"] For example, end_timestamp__isnull=False In addition to model fields (like “dut_label”, “dut_field”, “created_timestamp”, “invalid”, etc.),\\nall of our generic query methods accept also following shared query parameters: For example, latest=\\"invalid\\" would return only one result (latest “created_timestamp”)\\nfor each different “invalid” value in the database. Thus, maximum three results would be returned,\\none for each invalid value of True , False , and None . order_by: str. Prefix with “-” for descending order, for example “-created_timestamp”. limit: int: Default 20. If 0 (or negative number) is given, then pagination is not used, i.e. limit=infinity. offset: int. Default 0. Our generic query methods are not fully generalized yet, thus not all fields and lookup types are supported.\\nCheck query methods own documentation for details about currently supported query parameters. Generic query methods will return a list of objects, but with additional (optional) “meta” attribute,\\nwhich contains metadata, like pagination details. The client can ignore this data,\\nor use it to implement pagination logic for example to fetch all results available. Module: iqm.station_control.client.station_control Attributes version Return the version of the station control API this client is using. Methods create_observation_set Create an observation set in the database. create_observations Create observations in the database. create_sequence_metadata Create sequence metadata in the database. delete_sweep Delete sweep in the database. finalize_observation_set Finalize an observation set in the database. get_about Return information about the station control. get_calibration_set_values Get saved calibration set observations by UUID get_channel_properties Get channel properties from the station. get_chip_design_record Get a raw chip design record matching the given chip label. get_configuration Return the configuration of the station control. get_dut_fields Get DUT fields for the specified DUT label from the database. get_duts Get DUTs of the station control. get_exa_configuration Return the recommended EXA configuration from the server. get_latest_calibration_set_id Get UUID of the latest saved calibration set for the given dut_label. get_observation_set Get an observation set from the database. get_observation_set_observations Get the constituent observations of an observation set from the database. get_observations Get observations from the database. get_or_create_software_version_set Get software version set ID from the database, or create if it doesn't exist. get_run Get run data from the database. get_sequence_result Get sequence result from the database. get_settings Return a tree representation of the default settings as defined in the configuration file. get_sweep Get N-dimensional sweep data from the database. get_sweep_results Get N-dimensional sweep results from the database. get_task Get task data. init Initialize a new station control client instance connected to the given remote. query_observation_sets Query observation sets from the database. query_observations Query observations from the database. query_runs Query runs from the database. query_sequence_metadatas Query sequence metadatas from the database. revoke_sweep Either remove a sweep task from the queue, or abort it gracefully if it's already executing. run Execute an N-dimensional sweep of selected variables and save run, sweep and results. save_sequence_result Save sequence result in the database. sweep Execute an N-dimensional sweep of selected variables and save sweep and results. update_observation_set Update an observation set in the database. update_observations Update observations in the database. Return the version of the station control API this client is using. Initialize a new station control client instance connected to the given remote. Client implementation is selected automatically based on the remote station: if the remote station\\nis running the IQM Server software stack, then the IQM Server client implementation (with a limited\\nfeature set) is chosen. If the remote station is running the SC software stack, then the Station\\nControl client implementation (with the full feature set) is chosen. root_url ( str ) – Remote station control service URL. For IQM Server remotes, this is the “Quantum Computer URL”\\nvalue from the web dashboard. get_token_callback ( Callable [ [ ] , str ] | None ) – A callback function that returns a token (str) which will be passed in Authorization\\nheader in all requests. StationControlClient Return information about the station control. dict Return the configuration of the station control. dict Return the recommended EXA configuration from the server. str Get software version set ID from the database, or create if it doesn’t exist. software_version_set ( dict [ str , str ] ) – int Return a tree representation of the default settings as defined in the configuration file. SettingNode Get a raw chip design record matching the given chip label. dut_label ( str ) – dict Get channel properties from the station. Channel properties contain information regarding hardware limitations e.g. sampling rate, granularity\\nand supported instructions. Mapping from channel name to AWGProperties or ReadoutProperties dict [ str , ChannelProperties ] Execute an N-dimensional sweep of selected variables and save sweep and results. The raw data for each spot in the sweep is saved as numpy arrays,\\nand the complete data for the whole sweep is saved as an x-array dataset\\nwhich has the sweep_definition.sweeps as coordinates and\\ndata of sweep_definition.return_parameters data as DataArrays. The values of sweep_definition.playlist will be uploaded to the controllers given by the keys of sweep_definition.playlist . sweep_definition ( SweepDefinition ) – The content of the sweep to be created. Dict containing the task ID  and sweep ID, and corresponding hrefs, of a successful sweep execution\\nin monolithic mode or successful submission to the task queue in remote mode. ExaError if submitting a sweep failed. – dict Get N-dimensional sweep data from the database. sweep_id ( UUID ) – SweepData Either remove a sweep task from the queue, or abort it gracefully if it’s already executing. If the task was already executing when revoked, the status of the task will be set to \\"INTERRUPTED\\" .\\nIf the task had not started yet, the status will be set to \\"REVOKED\\" .\\nIf the task is not found or is already finished nothing happens. sweep_id ( UUID ) – None Delete sweep in the database. sweep_id ( UUID ) – None Get N-dimensional sweep results from the database. sweep_id ( UUID ) – dict [ str , list [ ndarray ]] Execute an N-dimensional sweep of selected variables and save run, sweep and results. run_definition ( RunDefinition ) – update_progress_callback ( Callable [ [ list [ tuple [ str , int , int ] ] ] , None ] | None ) – wait_task_completion ( bool ) – bool Get run data from the database. run_id ( UUID ) – RunData Query runs from the database. run_id: uuid.UUID run_id__in: list[uuid.UUID] sweep_id: uuid.UUID sweep_id__in: list[uuid.UUID] username: str username__in: list[str] username__contains: str username__icontains: str experiment_label: str experiment_label__in: list[str] experiment_label__contains: str experiment_label__icontains: str experiment_name: str experiment_name__in: list[str] experiment_name__contains: str experiment_name__icontains: str software_version_set_id: int software_version_set_id__in: list[int] begin_timestamp__range: tuple[datetime, datetime] end_timestamp__range: tuple[datetime, datetime] end_timestamp__isnull: bool Queried runs with some query related metadata. ListWithMeta [ RunLite ] Create observations in the database. observation_definitions ( Sequence [ ObservationDefinition ] ) – A sequence of observation definitions,\\neach containing the content of the observation which will be created. Created observations, each including also the database created fields like ID and timestamps. ListWithMeta [ ObservationData ] Get observations from the database. Observations are queried by the given query parameters. mode ( Literal [ 'all_latest' , 'tags_and' , 'tags_or' , 'sequence' ] ) – The “mode” used to query the observations. Possible values “all_latest”, “tags_and”, or “tags_or”. ”all_latest”:Query all the latest observations for the given dut_label .\\nNo other query parameters are accepted. ”tags_and”: Query observations. Query all the observations that have all the given tags .\\nBy default, only valid observations are included.\\nAll other query parameters can be used to narrow down the query,\\nexpect “run_ids” and “sequence_ids”. ”tags_or”: Query all the latest observations that have at least one of the given tags .\\nAdditionally, dut_label must be given. No other query parameters are used. ”sequence”: Query observations originating from a list of run and/or sequence IDs.\\nNo other query parameters are accepted. The “mode” used to query the observations. Possible values “all_latest”, “tags_and”, or “tags_or”. ”all_latest”:Query all the latest observations for the given dut_label .\\nNo other query parameters are accepted. ”tags_and”: Query observations. Query all the observations that have all the given tags .\\nBy default, only valid observations are included.\\nAll other query parameters can be used to narrow down the query,\\nexpect “run_ids” and “sequence_ids”. ”tags_or”: Query all the latest observations that have at least one of the given tags .\\nAdditionally, dut_label must be given. No other query parameters are used. ”sequence”: Query observations originating from a list of run and/or sequence IDs.\\nNo other query parameters are accepted. dut_label ( str | None ) – DUT label of the device the observations pertain to. dut_field ( str | None ) – Name of the property the observation is about. tags ( list [ str ] | None ) – Human-readable tags of the observation. invalid ( bool | None ) – Flag indicating if the object is invalid. Automated systems must not use invalid objects.\\nIf None , both valid and invalid objects are included. run_ids ( list [ UUID ] | None ) – The run IDs for which to query the observations. sequence_ids ( list [ UUID ] | None ) – The sequence IDs for which to query the observations. limit ( int | None ) – Indicates the maximum number of items to return. Observations, each including also the database created fields like ID and timestamps. list [ ObservationData ] Query observations from the database. observation_id: int observation_id__in: list[int] dut_label: str dut_field: str dut_field__in: list[str] tags__overlap: list[str] tags__contains: list[str] invalid: bool source__run_id__in: list[uuid.UUID] source__sequence_id__in: list[uuid.UUID] source__type: str uncertainty__isnull: bool created_timestamp__range: tuple[datetime, datetime] observation_set_ids__overlap: list[uuid.UUID] observation_set_ids__contains: list[uuid.UUID] Queried observations with some query related metadata. ListWithMeta [ ObservationData ] Update observations in the database. observation_updates ( Sequence [ ObservationUpdate ] ) – A sequence of observation updates,\\neach containing the content of the observation which will be updated. Updated observations, each including also the database created fields like ID and timestamps. list [ ObservationData ] Query observation sets from the database. observation_set_id: UUID observation_set_id__in: list[UUID] observation_set_type: Literal[“calibration-set”, “generic-set”, “quality-metric-set”] observation_ids__overlap: list[int] observation_ids__contains: list[int] describes_id: UUID describes_id__in: list[UUID] invalid: bool created_timestamp__range: tuple[datetime, datetime] end_timestamp__isnull: bool dut_label: str dut_label__in: list[str] Queried observation sets with some query related metadata ListWithMeta [ ObservationSetData ] Create an observation set in the database. observation_set_definition ( ObservationSetDefinition ) – The content of the observation set to be created. The content of the observation set. ExaError – If creation failed. ObservationSetData Get an observation set from the database. observation_set_id ( UUID ) – Observation set to retrieve. The content of the observation set. ExaError – If retrieval failed. ObservationSetData Update an observation set in the database. observation_set_update ( ObservationSetUpdate ) – The content of the observation set to be updated. The content of the observation set. ExaError – If updating failed. ObservationSetData Finalize an observation set in the database. A finalized set is nearly immutable, allowing to change only invalid flag after finalization. observation_set_id ( UUID ) – Observation set to finalize. ExaError – If finalization failed. None Get the constituent observations of an observation set from the database. observation_set_id ( UUID ) – UUID of the observation set to retrieve. Observations belonging to the given observation set. list [ ObservationLite ] Get saved calibration set observations by UUID calibration_set_id ( UUID ) – UUID of the calibration set to retrieve. Dictionary of observations belonging to the given calibration set. dict [ str , bool | str | int | float | complex | ndarray ] Get UUID of the latest saved calibration set for the given dut_label. dut_label ( str ) – Target DUT label UUID of the latest saved calibration set. UUID Get DUTs of the station control. list [ DutData ] Get DUT fields for the specified DUT label from the database. dut_label ( str ) – list [ DutFieldData ] Query sequence metadatas from the database. origin_id: str origin_id__in: list[str] origin_uri: str origin_uri__icontains: str created_timestamp__range: tuple[datetime, datetime] Sequence metadatas with some query related metadata. ListWithMeta [ SequenceMetadataData ] Create sequence metadata in the database. sequence_metadata_definition ( SequenceMetadataDefinition ) – SequenceMetadataData Save sequence result in the database. This method creates the object if it doesn’t exist and completely replaces the “data” and “final” if it does.\\nTimestamps are assigned by the database. “modified_timestamp” is not set on initial creation,\\nbut it’s updated on each subsequent call. sequence_result_definition ( SequenceResultDefinition ) – SequenceResultData Get sequence result from the database. sequence_id ( UUID ) – SequenceResultData Get task data. task_id ( UUID ) – dict previous station_control next utils © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"ConnectionParameters","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.grpc_utils.ConnectionParameters.html","description":"Bases: object Module: iqm.station_control.client.iqm_server.grpc_utils Attributes server_address  is_secure  quantum_computer  use_timeslot  Methods server_address ( str ) – is_secure ( bool ) – quant...","content":"Bases: object Module: iqm.station_control.client.iqm_server.grpc_utils Attributes server_address  is_secure  quantum_computer  use_timeslot  Methods server_address ( str ) – is_secure ( bool ) – quantum_computer ( str ) – use_timeslot ( bool ) – previous ClientCallDetails next iqm_server_client © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.iqm_server.grpc_utils.load_all","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.grpc_utils.load_all.html","description":"chunks ( Iterable [ DataChunk ] ) – bytes previous iqm.station_control.client.iqm_server.grpc_utils.from_proto_uuid next iqm.station_control.client.iqm_server.grpc_utils.parse_connection_params © Copy...","content":"chunks ( Iterable [ DataChunk ] ) – bytes previous iqm.station_control.client.iqm_server.grpc_utils.from_proto_uuid next iqm.station_control.client.iqm_server.grpc_utils.parse_connection_params © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"ResponseWithMeta","url":"/iqm-station-control-client/api/iqm.station_control.client.list_models.ResponseWithMeta.html","description":"Bases: PydanticBase , Generic [ T ] Class used for query endpoints to return metadata in addition to the returned items. Create a new model by parsing and validating input data from keyword arguments....","content":"Bases: PydanticBase , Generic [ T ] Class used for query endpoints to return metadata in addition to the returned items. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.client.list_models Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. items  meta  Methods items ( list [ T ] ) – meta ( Meta | None ) – Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous ObservationUpdateList next RunLiteList © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"RunWithTimestamps","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.run.RunWithTimestamps.html","description":"Bases: RunBase Abstract base class of run data including timestamps. Module: iqm.station_control.interface.models.run Attributes created_timestamp Time when the object was created in the database. mod...","content":"Bases: RunBase Abstract base class of run data including timestamps. Module: iqm.station_control.interface.models.run Attributes created_timestamp Time when the object was created in the database. modified_timestamp Time when the object was last modified in the database. begin_timestamp Time when the run began in the station control. end_timestamp Time when the run ended in the station control. run_id Unique identifier of the run. username User who defined the run. experiment_name Identifier of the Experiment ( Experiment.name ). experiment_label Freeform label of the Experiment. options Experiment-specific options or toggles that generated the run. software_version_set_id Unique identifier of the software version set of the current Python runtime. Methods run_id ( UUID ) – username ( str ) – experiment_name ( str ) – experiment_label ( str ) – options ( dict [ str , Any ] | None ) – software_version_set_id ( int | None ) – created_timestamp ( datetime ) – modified_timestamp ( datetime ) – begin_timestamp ( datetime ) – end_timestamp ( datetime | None ) – Time when the object was created in the database. Time when the object was last modified in the database. Time when the run began in the station control. Time when the run ended in the station control. previous RunLite next sequence © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.iqm_server.iqm_server_client.to_sweep_status","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.iqm_server_client.to_sweep_status.html","description":"job_status ( <google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x7f38174b1410> ) – SweepStatus previous iqm.station_control.client.iqm_server.iqm_server_client.subscribe_to_job_eve...","content":"job_status ( <google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x7f38174b1410> ) – SweepStatus previous iqm.station_control.client.iqm_server.iqm_server_client.subscribe_to_job_events next iqm.station_control.client.iqm_server.iqm_server_client.to_task_status © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"ObservationDataList","url":"/iqm-station-control-client/api/iqm.station_control.client.list_models.ObservationDataList.html","description":"alias of ListModel[list[ObservationData]] previous ListModel next ObservationDefinitionList © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26....","content":"alias of ListModel[list[ObservationData]] previous ListModel next ObservationDefinitionList © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"IqmServerClientMeta","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.meta_class.IqmServerClientMeta.html","description":"Bases: type Custom metaclass that automatically adds ‘<feature> not implemented’\\nstub implementations for all StationControlClient functions that are\\nnot overridden by IqmServerClient. Module: iqm.sta...","content":"Bases: type Custom metaclass that automatically adds ‘<feature> not implemented’\\nstub implementations for all StationControlClient functions that are\\nnot overridden by IqmServerClient. Module: iqm.station_control.client.iqm_server.meta_class Methods previous meta_class next proto © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_results","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_results.html","description":"Convert binary string into SweepResults. sweep_results_str ( bytes ) – dict [ str , list [ ndarray ]] previous iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_definition nex...","content":"Convert binary string into SweepResults. sweep_results_str ( bytes ) – dict [ str , list [ ndarray ]] previous iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_definition next iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_data © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"IqmServerMockBase","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.testing.iqm_server_mock.IqmServerMockBase.html","description":"Bases: QuantumComputersServicer , CalibrationsServicer , JobsServicer Base class for IQM server mocks. Only meant for testing IQM library packages, do not use outside of tests! Module: iqm.station_con...","content":"Bases: QuantumComputersServicer , CalibrationsServicer , JobsServicer Base class for IQM server mocks. Only meant for testing IQM library packages, do not use outside of tests! Module: iqm.station_control.client.iqm_server.testing.iqm_server_mock Methods channel Gets a grpc.Channel that connects to this mock server instance. chunk_stream A utility function for converting a binary data blob into a\`(stream DataChunk)\`. parse_uuid Helper function for generating protobuf UUIDs proto_timestamp Helper function for generating protobuf timestamps proto_uuid Helper function for generating protobuf UUIDs Helper function for generating protobuf UUIDs base ( UUID | None ) – Uuid Helper function for generating protobuf UUIDs value ( Uuid ) – UUID Helper function for generating protobuf timestamps base ( datetime | None ) – Timestamp Gets a grpc.Channel that connects to this mock server instance. Can be used to initialize\\na new IqmServerClient that uses this mock server instance as a backend for the\\ninvoked GRPC calls. Channel A utility function for converting a binary data blob into a\`(stream DataChunk)\`. data ( bytes ) – Iterator [ DataChunk ] previous iqm_server_mock next list_models © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"ObservationSetData","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.observation_set.ObservationSetData.html","description":"Bases: ObservationSetBase The content of the observation set stored in the database. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic...","content":"Bases: ObservationSetBase The content of the observation set stored in the database. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.observation_set Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. dut_label String representation of the DUT the observation set is associated with. observation_set_id Unique identifier of the observation set. created_timestamp Time when the object was created in the database. end_timestamp Time when the observation set was finalized. observation_set_type Indicates the type (i.e. purpose) of the observation set. observation_ids Database IDs of the observations belonging to the observation set. describes_id Unique identifier of the observation set this observation set describes. invalid Flag indicating if the object is invalid. Methods observation_set_type ( Literal [ 'calibration-set' , 'characterization-set' , 'generic-set' , 'quality-metric-set' ] ) – observation_ids ( list [ int ] ) – describes_id ( UUID | None ) – invalid ( bool ) – dut_label ( str | None ) – observation_set_id ( UUID ) – created_timestamp ( datetime ) – end_timestamp ( datetime | None ) – String representation of the DUT the observation set is associated with. Can only be None for generic sets. Unique identifier of the observation set. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Time when the object was created in the database. Time when the observation set was finalized. If None , the set is not finalized yet. previous ObservationSetBase next ObservationSetDefinition © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"ClientCallDetails","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.grpc_utils.ClientCallDetails.html","description":"Bases: ClientCallDetails Module: iqm.station_control.client.iqm_server.grpc_utils Methods previous ApiTokenAuth next ConnectionParameters © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last upda...","content":"Bases: ClientCallDetails Module: iqm.station_control.client.iqm_server.grpc_utils Methods previous ApiTokenAuth next ConnectionParameters © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"pydantic_base","url":"/iqm-station-control-client/api/iqm.station_control.interface.pydantic_base.html","description":"Pydantic related models and types. Full path: iqm.station_control.interface.pydantic_base Classes PydanticBase Pydantic base model to change the behaviour of pydantic globally. Inheritance previous ty...","content":"Pydantic related models and types. Full path: iqm.station_control.interface.pydantic_base Classes PydanticBase Pydantic base model to change the behaviour of pydantic globally. Inheritance previous type_aliases next PydanticBase © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"models","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.html","description":"Station control interface models. Full path: iqm.station_control.interface.models Subpackages and modules dut DUT related interface models. observation Observation related station control interface mo...","content":"Station control interface models. Full path: iqm.station_control.interface.models Subpackages and modules dut DUT related interface models. observation Observation related station control interface models. observation_set Observation set related station control interface models. run Run related station control interface models. sequence Sequence related station control interface models. sweep Sweep related station control interface models. type_aliases Type hint aliases used in the station control interface. previous Meta next dut © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.iqm_server.iqm_server_client.payload_to_sweep","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.iqm_server_client.payload_to_sweep.html","description":"job_payload ( bytes ) – SweepDefinition previous iqm.station_control.client.iqm_server.iqm_server_client.parse_json next iqm.station_control.client.iqm_server.iqm_server_client.resolve_current_qc © Co...","content":"job_payload ( bytes ) – SweepDefinition previous iqm.station_control.client.iqm_server.iqm_server_client.parse_json next iqm.station_control.client.iqm_server.iqm_server_client.resolve_current_qc © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"task_serializers","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.task_serializers.html","description":"Serializers and deserializers for task related models. Full path: iqm.station_control.client.serializers.task_serializers Functions deserialize_sweep_task_request (data) Deserializes sweep_definition ...","content":"Serializers and deserializers for task related models. Full path: iqm.station_control.client.serializers.task_serializers Functions deserialize_sweep_task_request (data) Deserializes sweep_definition and queue_name from the serialized bitstring. serialize_run_task_request (run_definition, ...) Wrap run_definition and queue_name into a protobuf message and serialize into a bitstring. serialize_sweep_task_request (...) Wrap sweep_definition and queue_name into a protobuf message and serialize into a bitstring. previous iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_results next iqm.station_control.client.serializers.task_serializers.deserialize_sweep_task_request © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"SweepDefinition","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.sweep.SweepDefinition.html","description":"Bases: SweepBase The content of the sweep object when creating it. Module: iqm.station_control.interface.models.sweep Attributes playlist A Playlist that should be uploaded to the controllers. sweep_i...","content":"Bases: SweepBase The content of the sweep object when creating it. Module: iqm.station_control.interface.models.sweep Attributes playlist A Playlist that should be uploaded to the controllers. sweep_id Unique identifier of the sweep. dut_label DUT label of the device being used. settings A tree representation of the initial settings to set before the sweep. sweeps Sweeps that define the swept parameters, i.e. a list of parallel sweeps, where the data values of all sweeps in the tuple are interleaved, and updated simultaneously during the sweep. return_parameters Parameters that will be queried from devices and saved for each spot (variable-tuple) of the N-dimensional sweep. Methods sweep_id ( UUID ) – dut_label ( str ) – settings ( SettingNode ) – sweeps ( list [ tuple [ Sweep , ... ] ] ) – return_parameters ( list [ str ] ) – playlist ( Playlist | None ) – A Playlist that should be uploaded to the controllers. previous SweepData next SweepStatus © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.serializers.playlist_serializers.pack_playlist","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.playlist_serializers.pack_playlist.html","description":"Pack the given playlist into a protobuf format for further serialization. playlist ( Playlist ) – playlist to pack playlist in protobuf format Playlist previous playlist_serializers next iqm.station_c...","content":"Pack the given playlist into a protobuf format for further serialization. playlist ( Playlist ) – playlist to pack playlist in protobuf format Playlist previous playlist_serializers next iqm.station_control.client.serializers.playlist_serializers.unpack_playlist © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"grpc_utils","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.grpc_utils.html","description":"Internal utility functions used by IqmServerClient. Full path: iqm.station_control.client.iqm_server.grpc_utils Functions create_channel (connection_params[, ...])  extract_error (error[, title])  fro...","content":"Internal utility functions used by IqmServerClient. Full path: iqm.station_control.client.iqm_server.grpc_utils Functions create_channel (connection_params[, ...])  extract_error (error[, title])  from_proto_uuid (value)  load_all (chunks)  parse_connection_params (qc_url)  to_datetime (timestamp)  to_proto_uuid (value)  Classes ApiTokenAuth  ClientCallDetails  ConnectionParameters  Inheritance previous iqm.station_control.client.iqm_server.error.IqmServerError next iqm.station_control.client.iqm_server.grpc_utils.create_channel © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"RunConfigurationBase","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.run.RunConfigurationBase.html","description":"Bases: object Abstract base class of the run configuration data. Module: iqm.station_control.interface.models.run Attributes additional_run_properties A free-form dictionary of data, used to store inf...","content":"Bases: object Abstract base class of the run configuration data. Module: iqm.station_control.interface.models.run Attributes additional_run_properties A free-form dictionary of data, used to store information that does not fall into other categories. hard_sweeps Maps SweepBase.return_parameters to \\"hardware sweep specification\\" which specifies how the data measured at each spot should be interpreted and shaped. components Components that participate in this run. default_data_parameters The subset of SweepBase.return_parameters that were added by default, not by the user. default_sweep_parameters The subset of SweepBase.sweeps parameters were added by default, not by the user. Methods additional_run_properties ( dict [ str , Any ] | None ) – hard_sweeps ( dict [ str , list [ tuple [ Sweep , ... ] ] ] | None ) – components ( list [ str ] ) – default_data_parameters ( list [ str ] ) – default_sweep_parameters ( list [ str ] ) – A free-form dictionary of data, used to store information that does not fall into other categories. Maps SweepBase.return_parameters to “hardware sweep specification” which specifies\\nhow the data measured at each spot should be interpreted and shaped.\\nThe hard sweep specification is in the same format as SweepBase.sweeps ,\\nwhich means that the returned data can be interpreted as an N-dimensional sweep inside the spot.\\nAn empty list is interpreted such that the return parameter is a scalar.\\nThe hard sweep specification can also be None ,\\nin which case the shape will be whatever the instrument returns. Components that participate in this run. The subset of SweepBase.return_parameters that were added by default, not by the user.\\nUsed to select which data to analyze and plot. The subset of SweepBase.sweeps parameters were added by default, not by the user.\\nUsed to select which data to analyze and plot. previous RunBase next RunData © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"uuid_pb2_grpc","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.uuid_pb2_grpc.html","description":"Client and server classes corresponding to protobuf-defined services. Full path: iqm.station_control.client.iqm_server.proto.uuid_pb2_grpc previous uuid_pb2 next testing © Copyright 2019-2025, IQM Fin...","content":"Client and server classes corresponding to protobuf-defined services. Full path: iqm.station_control.client.iqm_server.proto.uuid_pb2_grpc previous uuid_pb2 next testing © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"ObservationDefinitionList","url":"/iqm-station-control-client/api/iqm.station_control.client.list_models.ObservationDefinitionList.html","description":"alias of ListModel[list[ObservationDefinition]] previous ObservationDataList next ObservationLiteList © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26....","content":"alias of ListModel[list[ObservationDefinition]] previous ObservationDataList next ObservationLiteList © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"SequenceMetadataBase","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.sequence.SequenceMetadataBase.html","description":"Bases: PydanticBase Abstract base class of the sequence metadata definition and data. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydanti...","content":"Bases: PydanticBase Abstract base class of the sequence metadata definition and data. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.sequence Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. sequence_id Unique identifier of the sequence. origin_id Unique identifier of the creator. origin_uri Uniform resource identifier (weak reference) for the creator. Methods sequence_id ( UUID ) – origin_id ( str ) – origin_uri ( str ) – Unique identifier of the sequence. Unique identifier of the creator. E.g. notebook researcher username, or calibration service ID. Uniform resource identifier (weak reference) for the creator. E.g. calibration service ID. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous sequence next SequenceMetadataData © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"common_pb2","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.common_pb2.html","description":"Generated protocol buffer code. Full path: iqm.station_control.client.iqm_server.proto.common_pb2 previous CalibrationsStub next common_pb2_grpc © Copyright 2019-2025, IQM Finland Oy, Release 3.16. La...","content":"Generated protocol buffer code. Full path: iqm.station_control.client.iqm_server.proto.common_pb2 previous CalibrationsStub next common_pb2_grpc © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.iqm_server.proto.job_pb2_grpc.add_JobsServicer_to_server","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.job_pb2_grpc.add_JobsServicer_to_server.html","description":"previous job_pb2_grpc next Jobs © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26....","content":"previous job_pb2_grpc next Jobs © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.serializers.channel_property_serializer.deserialize_instructions","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.channel_property_serializer.deserialize_instructions.html","description":"Convert a repeated scalar container of instruction type strings into a tuple of python types. instructions ( Iterable [ str ] ) – tuple [ Operation , …] previous iqm.station_control.client.serializers...","content":"Convert a repeated scalar container of instruction type strings into a tuple of python types. instructions ( Iterable [ str ] ) – tuple [ Operation , …] previous iqm.station_control.client.serializers.channel_property_serializer.deserialize_channel_properties next iqm.station_control.client.serializers.channel_property_serializer.serialize_channel_properties © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"Jobs","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.job_pb2_grpc.Jobs.html","description":"Bases: object User job management APIs. Module: iqm.station_control.client.iqm_server.proto.job_pb2_grpc Methods CancelJobV1  GetJobPayloadV1  GetJobResultsV1  GetJobV1  SubmitJobV1  SubscribeToJobV1 ...","content":"Bases: object User job management APIs. Module: iqm.station_control.client.iqm_server.proto.job_pb2_grpc Methods CancelJobV1  GetJobPayloadV1  GetJobResultsV1  GetJobV1  SubmitJobV1  SubscribeToJobV1  previous iqm.station_control.client.iqm_server.proto.job_pb2_grpc.add_JobsServicer_to_server next JobsServicer © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"JobsStub","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.job_pb2_grpc.JobsStub.html","description":"Bases: object User job management APIs. Constructor. channel – A grpc.Channel. Module: iqm.station_control.client.iqm_server.proto.job_pb2_grpc Methods previous JobsServicer next qc_pb2 © Copyright 20...","content":"Bases: object User job management APIs. Constructor. channel – A grpc.Channel. Module: iqm.station_control.client.iqm_server.proto.job_pb2_grpc Methods previous JobsServicer next qc_pb2 © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"SequenceMetadataDataList","url":"/iqm-station-control-client/api/iqm.station_control.client.list_models.SequenceMetadataDataList.html","description":"alias of ListModel[list[SequenceMetadataData]] previous RunLiteList next serializers © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26....","content":"alias of ListModel[list[SequenceMetadataData]] previous RunLiteList next serializers © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.serializers.run_serializers.serialize_run_data","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.run_serializers.serialize_run_data.html","description":"Convert RunData object to a JSON serializable dictionary. run_data ( RunData ) – dict previous iqm.station_control.client.serializers.run_serializers.deserialize_run_definition next iqm.station_contro...","content":"Convert RunData object to a JSON serializable dictionary. run_data ( RunData ) – dict previous iqm.station_control.client.serializers.run_serializers.deserialize_run_definition next iqm.station_control.client.serializers.run_serializers.serialize_run_definition © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"ApiTokenAuth","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.grpc_utils.ApiTokenAuth.html","description":"Bases: UnaryUnaryClientInterceptor , UnaryStreamClientInterceptor Module: iqm.station_control.client.iqm_server.grpc_utils Methods intercept_unary_stream Intercepts a unary-stream invocation. intercep...","content":"Bases: UnaryUnaryClientInterceptor , UnaryStreamClientInterceptor Module: iqm.station_control.client.iqm_server.grpc_utils Methods intercept_unary_stream Intercepts a unary-stream invocation. intercept_unary_unary Intercepts a unary-unary invocation asynchronously. get_token_callback ( Callable [ [ ] , str ] ) – Intercepts a unary-stream invocation. continuation – A function that proceeds with the invocation by\\nexecuting the next interceptor in chain or invoking the\\nactual RPC on the underlying Channel. It is the interceptor’s\\nresponsibility to call it if it decides to move the RPC forward.\\nThe interceptor can use response_iterator = continuation(client_call_details, request) to continue with the RPC. continuation returns an object that is\\nboth a Call for the RPC and an iterator for response values.\\nDrawing response values from the returned Call-iterator may\\nraise RpcError indicating termination of the RPC with non-OK\\nstatus. client_call_details – A ClientCallDetails object describing the\\noutgoing RPC. request – The request value for the RPC. An object that is both a Call for the RPC and an iterator of\\nresponse values. Drawing response values from the returned\\nCall-iterator may raise RpcError indicating termination of\\nthe RPC with non-OK status. This object should also fulfill the\\nFuture interface, though it may not. Intercepts a unary-unary invocation asynchronously. continuation – A function that proceeds with the invocation by\\nexecuting the next interceptor in chain or invoking the\\nactual RPC on the underlying Channel. It is the interceptor’s\\nresponsibility to call it if it decides to move the RPC forward.\\nThe interceptor can use response_future = continuation(client_call_details, request) to continue with the RPC. continuation returns an object that is\\nboth a Call for the RPC and a Future. In the event of RPC\\ncompletion, the return Call-Future’s result value will be\\nthe response message of the RPC. Should the event terminate\\nwith non-OK status, the returned Call-Future’s exception value\\nwill be an RpcError. client_call_details – A ClientCallDetails object describing the\\noutgoing RPC. request – The request value for the RPC. An object that is both a Call for the RPC and a Future.\\nIn the event of RPC completion, the return Call-Future’s\\nresult value will be the response message of the RPC.\\nShould the event terminate with non-OK status, the returned\\nCall-Future’s exception value will be an RpcError. previous iqm.station_control.client.iqm_server.grpc_utils.to_proto_uuid next ClientCallDetails © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"uuid_pb2","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.uuid_pb2.html","description":"Generated protocol buffer code. Full path: iqm.station_control.client.iqm_server.proto.uuid_pb2 previous QuantumComputersStub next uuid_pb2_grpc © Copyright 2019-2025, IQM Finland Oy, Release 3.16. La...","content":"Generated protocol buffer code. Full path: iqm.station_control.client.iqm_server.proto.uuid_pb2 previous QuantumComputersStub next uuid_pb2_grpc © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"ObservationLite","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.observation.ObservationLite.html","description":"Bases: ObservationBase The lightweight version of the observation data. This model can be used when not all observation data is needed, to speed up retrieval. Create a new model by parsing and validat...","content":"Bases: ObservationBase The lightweight version of the observation data. This model can be used when not all observation data is needed, to speed up retrieval. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.observation Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. observation_id Unique identifier of the observation. created_timestamp Time when the object was created in the database. modified_timestamp Time when the object was last modified in the database. dut_field Name of the property the observation is about. value Value of the observation. unit SI unit of the value. uncertainty Uncertainty of the observation value. invalid Flag indicating if the object is invalid. Methods dut_field ( str ) – value ( bool | str | int | float | complex | ndarray ) – unit ( str ) – uncertainty ( int | float | complex | ndarray | None ) – invalid ( bool ) – observation_id ( int ) – created_timestamp ( datetime ) – modified_timestamp ( datetime ) – Unique identifier of the observation. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Time when the object was created in the database. Time when the object was last modified in the database. previous ObservationDefinition next ObservationUpdate © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.iqm_server.grpc_utils.extract_error","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.grpc_utils.extract_error.html","description":"error ( RpcError ) – title ( str | None ) – IqmServerError previous iqm.station_control.client.iqm_server.grpc_utils.create_channel next iqm.station_control.client.iqm_server.grpc_utils.from_proto_uui...","content":"error ( RpcError ) – title ( str | None ) – IqmServerError previous iqm.station_control.client.iqm_server.grpc_utils.create_channel next iqm.station_control.client.iqm_server.grpc_utils.from_proto_uuid © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"sequence","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.sequence.html","description":"Sequence related station control interface models. Full path: iqm.station_control.interface.models.sequence Classes SequenceMetadataBase Abstract base class of the sequence metadata definition and dat...","content":"Sequence related station control interface models. Full path: iqm.station_control.interface.models.sequence Classes SequenceMetadataBase Abstract base class of the sequence metadata definition and data. SequenceMetadataData The content of the sequence metadata stored in the database. SequenceMetadataDefinition The content of the sequence metadata object when creating it. SequenceResultBase Abstract base class of the sequence result definition and data. SequenceResultData The content of the sequence result stored in the database. SequenceResultDefinition The content of the sequence result object when creating it. Inheritance previous RunWithTimestamps next SequenceMetadataBase © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.utils.get_progress_bar_callback","url":"/iqm-station-control-client/api/iqm.station_control.client.utils.get_progress_bar_callback.html","description":"Returns a callback function that creates or updates existing progressbars when called. Callable [[ list [ tuple [ str , int , int ]]], None ] previous iqm.station_control.client.utils.calset_from_obse...","content":"Returns a callback function that creates or updates existing progressbars when called. Callable [[ list [ tuple [ str , int , int ]]], None ] previous iqm.station_control.client.utils.calset_from_observations next interface © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"ObservationBase","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.observation.ObservationBase.html","description":"Bases: PydanticBase Abstract base class of the observation models. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationEr...","content":"Bases: PydanticBase Abstract base class of the observation models. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.observation Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. dut_field Name of the property the observation is about. value Value of the observation. unit SI unit of the value. uncertainty Uncertainty of the observation value. invalid Flag indicating if the object is invalid. Methods dut_field ( str ) – value ( bool | str | int | float | complex | ndarray ) – unit ( str ) – uncertainty ( int | float | complex | ndarray | None ) – invalid ( bool ) – Name of the property the observation is about. Value of the observation. SI unit of the value. Empty string means the value is dimensionless. Uncertainty of the observation value. None means unknown. Flag indicating if the object is invalid. Automated systems must not use invalid objects. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous observation next ObservationData © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"RunBase","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.run.RunBase.html","description":"Bases: object Abstract base class of run data. Module: iqm.station_control.interface.models.run Attributes run_id Unique identifier of the run. username User who defined the run. experiment_name Ident...","content":"Bases: object Abstract base class of run data. Module: iqm.station_control.interface.models.run Attributes run_id Unique identifier of the run. username User who defined the run. experiment_name Identifier of the Experiment ( Experiment.name ). experiment_label Freeform label of the Experiment. options Experiment-specific options or toggles that generated the run. software_version_set_id Unique identifier of the software version set of the current Python runtime. Methods run_id ( UUID ) – username ( str ) – experiment_name ( str ) – experiment_label ( str ) – options ( dict [ str , Any ] | None ) – software_version_set_id ( int | None ) – Unique identifier of the run. User who defined the run. Identifier of the Experiment ( Experiment.name ). Freeform label of the Experiment. As opposed to experiment_name , no core logic relies on this value. Experiment-specific options or toggles that generated the run. Unique identifier of the software version set of the current Python runtime. previous run next RunConfigurationBase © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"dut","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.dut.html","description":"DUT related interface models. Full path: iqm.station_control.interface.models.dut Classes DutData Represents a Device Under Test, or DUT, for short. DutFieldData A DUT field or path and its unit. Inhe...","content":"DUT related interface models. Full path: iqm.station_control.interface.models.dut Classes DutData Represents a Device Under Test, or DUT, for short. DutFieldData A DUT field or path and its unit. Inheritance previous models next DutData © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"station_control","url":"/iqm-station-control-client/api/iqm.station_control.client.station_control.html","description":"Station control client implementation. Full path: iqm.station_control.client.station_control Classes StationControlClient Station control client implementation. Inheritance previous iqm.station_contro...","content":"Station control client implementation. Full path: iqm.station_control.client.station_control Classes StationControlClient Station control client implementation. Inheritance previous iqm.station_control.client.serializers.task_serializers.serialize_sweep_task_request next StationControlClient © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"SequenceResultDefinition","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.sequence.SequenceResultDefinition.html","description":"Bases: SequenceResultBase The content of the sequence result object when creating it. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydanti...","content":"Bases: SequenceResultBase The content of the sequence result object when creating it. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.sequence Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. sequence_id Unique identifier of the sequence result. data JSON serializable dict. final Indicates whether this result was marked as final. Methods sequence_id ( UUID ) – data ( dict [ str , Any ] ) – final ( bool ) – Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous SequenceResultData next sweep © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"Calibrations","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc.Calibrations.html","description":"Bases: object Missing associated documentation comment in .proto file. Module: iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc Methods GetCalibrationV1  GetFullCalibrationDataV1  GetL...","content":"Bases: object Missing associated documentation comment in .proto file. Module: iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc Methods GetCalibrationV1  GetFullCalibrationDataV1  GetLatestQuantumComputerCalibrationV1  previous iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc.add_CalibrationsServicer_to_server next CalibrationsServicer © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"RunData","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.run.RunData.html","description":"Bases: RunWithTimestamps , RunConfigurationBase The content of the run and its configuration stored in the database. Module: iqm.station_control.interface.models.run Attributes sweep_data The content ...","content":"Bases: RunWithTimestamps , RunConfigurationBase The content of the run and its configuration stored in the database. Module: iqm.station_control.interface.models.run Attributes sweep_data The content of the associated sweep stored in the database. created_timestamp Time when the object was created in the database. modified_timestamp Time when the object was last modified in the database. begin_timestamp Time when the run began in the station control. end_timestamp Time when the run ended in the station control. run_id Unique identifier of the run. username User who defined the run. experiment_name Identifier of the Experiment ( Experiment.name ). experiment_label Freeform label of the Experiment. options Experiment-specific options or toggles that generated the run. software_version_set_id Unique identifier of the software version set of the current Python runtime. additional_run_properties A free-form dictionary of data, used to store information that does not fall into other categories. hard_sweeps Maps SweepBase.return_parameters to \\"hardware sweep specification\\" which specifies how the data measured at each spot should be interpreted and shaped. components Components that participate in this run. default_data_parameters The subset of SweepBase.return_parameters that were added by default, not by the user. default_sweep_parameters The subset of SweepBase.sweeps parameters were added by default, not by the user. Methods additional_run_properties ( dict [ str , Any ] | None ) – hard_sweeps ( dict [ str , list [ tuple [ Sweep , ... ] ] ] | None ) – components ( list [ str ] ) – default_data_parameters ( list [ str ] ) – default_sweep_parameters ( list [ str ] ) – run_id ( UUID ) – username ( str ) – experiment_name ( str ) – experiment_label ( str ) – options ( dict [ str , Any ] | None ) – software_version_set_id ( int | None ) – created_timestamp ( datetime ) – modified_timestamp ( datetime ) – begin_timestamp ( datetime ) – end_timestamp ( datetime | None ) – sweep_data ( SweepData ) – The content of the associated sweep stored in the database. previous RunConfigurationBase next RunDefinition © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.serializers.task_serializers.deserialize_sweep_task_request","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.task_serializers.deserialize_sweep_task_request.html","description":"Deserializes sweep_definition and queue_name from the serialized bitstring. data ( bytes ) – The serialized data class: \` ~iqm.station_control.interface.model.SweepDefinition\\nand queue name (string). ...","content":"Deserializes sweep_definition and queue_name from the serialized bitstring. data ( bytes ) – The serialized data class: \` ~iqm.station_control.interface.model.SweepDefinition\\nand queue name (string). Deserialized tuple previous task_serializers next iqm.station_control.client.serializers.task_serializers.serialize_run_task_request © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm_server_client","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.iqm_server_client.html","description":"StationControlClient implementation for IQM Server Full path: iqm.station_control.client.iqm_server.iqm_server_client Functions parse_calibration_set (cal_set_data)  parse_json (data)  payload_to_swee...","content":"StationControlClient implementation for IQM Server Full path: iqm.station_control.client.iqm_server.iqm_server_client Functions parse_calibration_set (cal_set_data)  parse_json (data)  payload_to_sweep (job_payload)  resolve_current_qc (channel, alias)  subscribe_to_job_events (channel, job_id)  to_sweep_status (job_status)  to_task_status (job_status)  wrap_error (title)  Classes IqmServerClient  Inheritance previous ConnectionParameters next iqm.station_control.client.iqm_server.iqm_server_client.parse_calibration_set © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc.add_CalibrationsServicer_to_server","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc.add_CalibrationsServicer_to_server.html","description":"previous calibration_pb2_grpc next Calibrations © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26....","content":"previous calibration_pb2_grpc next Calibrations © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.iqm_server.iqm_server_client.parse_json","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.iqm_server_client.parse_json.html","description":"data ( bytes ) – Any previous iqm.station_control.client.iqm_server.iqm_server_client.parse_calibration_set next iqm.station_control.client.iqm_server.iqm_server_client.payload_to_sweep © Copyright 20...","content":"data ( bytes ) – Any previous iqm.station_control.client.iqm_server.iqm_server_client.parse_calibration_set next iqm.station_control.client.iqm_server.iqm_server_client.payload_to_sweep © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"SequenceResultData","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.sequence.SequenceResultData.html","description":"Bases: SequenceResultBase The content of the sequence result stored in the database. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic...","content":"Bases: SequenceResultBase The content of the sequence result stored in the database. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.sequence Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. created_timestamp Time when the object was created in the database. modified_timestamp Time when the object was last modified in the database. sequence_id Unique identifier of the sequence result. data JSON serializable dict. final Indicates whether this result was marked as final. Methods sequence_id ( UUID ) – data ( dict [ str , Any ] ) – final ( bool ) – created_timestamp ( datetime ) – modified_timestamp ( datetime | None ) – Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Time when the object was created in the database. Time when the object was last modified in the database. previous SequenceResultBase next SequenceResultDefinition © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"observation_set","url":"/iqm-station-control-client/api/iqm.station_control.interface.models.observation_set.html","description":"Observation set related station control interface models. Full path: iqm.station_control.interface.models.observation_set Classes ObservationSetBase Abstract base class of the observation set definiti...","content":"Observation set related station control interface models. Full path: iqm.station_control.interface.models.observation_set Classes ObservationSetBase Abstract base class of the observation set definition and data. ObservationSetData The content of the observation set stored in the database. ObservationSetDefinition The content of the observation set object when creating it. ObservationSetUpdate The observation set data to be updated in the database. Inheritance previous ObservationUpdate next ObservationSetBase © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"serializers","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.html","description":"Module for station control client serialization and deserialization. Full path: iqm.station_control.client.serializers Subpackages and modules channel_property_serializer Serializers and deserializers...","content":"Module for station control client serialization and deserialization. Full path: iqm.station_control.client.serializers Subpackages and modules channel_property_serializer Serializers and deserializers for ChannelProperties datetime_serializers Serializers and deserializers for datetime related models. playlist_serializers Serializers and deserializers for Playlist run_serializers Serializers and deserializers for run related models. setting_node_serializer Serializers and deserializers for setting node related models. struct_serializer Serializers and deserializers for struct related models. sweep_serializers Serializers and deserializers for sweep related models. task_serializers Serializers and deserializers for task related models. previous SequenceMetadataDataList next channel_property_serializer © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"client","url":"/iqm-station-control-client/api/iqm.station_control.client.html","description":"Station control client implementation. Full path: iqm.station_control.client Subpackages and modules iqm_server StationControlClient implementation for IQM Server list_models Station control client ty...","content":"Station control client implementation. Full path: iqm.station_control.client Subpackages and modules iqm_server StationControlClient implementation for IQM Server list_models Station control client type adapters. serializers Module for station control client serialization and deserialization. station_control Station control client implementation. utils Utility functions for IQM Station Control Client. previous API Reference next iqm_server © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"Meta","url":"/iqm-station-control-client/api/iqm.station_control.interface.list_with_meta.Meta.html","description":"Bases: object Class holding metadata for list return values, like pagination related data. Module: iqm.station_control.interface.list_with_meta Attributes count  errors  limit  offset  order_by  Metho...","content":"Bases: object Class holding metadata for list return values, like pagination related data. Module: iqm.station_control.interface.list_with_meta Attributes count  errors  limit  offset  order_by  Methods count ( int | None ) – order_by ( str | None ) – limit ( int | None ) – offset ( int | None ) – errors ( list [ str ] | None ) – previous ListWithMeta next models © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_definition","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_definition.html","description":"Convert SweepDefinition into sweep proto. sweep_definition ( SweepDefinition ) – SweepRequest previous iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_data next iqm.station_co...","content":"Convert SweepDefinition into sweep proto. sweep_definition ( SweepDefinition ) – SweepRequest previous iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_data next iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_results © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.serializers.channel_property_serializer.serialize_channel_properties","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.channel_property_serializer.serialize_channel_properties.html","description":"Pack the given dictionary of channel properties into a protobuf format for further serialization. channel_properties – channel properties to pack channel_property_dictionary ( dict [ str , ChannelProp...","content":"Pack the given dictionary of channel properties into a protobuf format for further serialization. channel_properties – channel properties to pack channel_property_dictionary ( dict [ str , ChannelProperties ] ) – ChannelPropertyDictionary ChannelPropertyDictionary previous iqm.station_control.client.serializers.channel_property_serializer.deserialize_instructions next iqm.station_control.client.serializers.channel_property_serializer.unpack_channel_properties © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"qc_pb2_grpc","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.qc_pb2_grpc.html","description":"Client and server classes corresponding to protobuf-defined services. Full path: iqm.station_control.client.iqm_server.proto.qc_pb2_grpc Functions add_QuantumComputersServicer_to_server (...)  Classes...","content":"Client and server classes corresponding to protobuf-defined services. Full path: iqm.station_control.client.iqm_server.proto.qc_pb2_grpc Functions add_QuantumComputersServicer_to_server (...)  Classes QuantumComputers Quantum Computer management APIs. QuantumComputersServicer Quantum Computer management APIs. QuantumComputersStub Quantum Computer management APIs. Inheritance previous qc_pb2 next iqm.station_control.client.iqm_server.proto.qc_pb2_grpc.add_QuantumComputersServicer_to_server © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_definition","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_definition.html","description":"Convert sweep proto into SweepDefinition. sweep_definition_proto ( SweepRequest ) – SweepDefinition previous iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_data next iqm.st...","content":"Convert sweep proto into SweepDefinition. sweep_definition_proto ( SweepRequest ) – SweepDefinition previous iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_data next iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_results © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"job_pb2_grpc","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.job_pb2_grpc.html","description":"Client and server classes corresponding to protobuf-defined services. Full path: iqm.station_control.client.iqm_server.proto.job_pb2_grpc Functions add_JobsServicer_to_server (servicer, server)  Class...","content":"Client and server classes corresponding to protobuf-defined services. Full path: iqm.station_control.client.iqm_server.proto.job_pb2_grpc Functions add_JobsServicer_to_server (servicer, server)  Classes Jobs User job management APIs. JobsServicer User job management APIs. JobsStub User job management APIs. Inheritance previous job_pb2 next iqm.station_control.client.iqm_server.proto.job_pb2_grpc.add_JobsServicer_to_server © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"list_models","url":"/iqm-station-control-client/api/iqm.station_control.client.list_models.html","description":"Station control client type adapters. Full path: iqm.station_control.client.list_models Classes DutFieldDataList alias of ListModel[list[DutFieldData]] DutList alias of ListModel[list[DutData]] ListMo...","content":"Station control client type adapters. Full path: iqm.station_control.client.list_models Classes DutFieldDataList alias of ListModel[list[DutFieldData]] DutList alias of ListModel[list[DutData]] ListModel A Pydantic BaseModel for a container model of a list of objects. ListModel[list[DutData]] A Pydantic BaseModel for a container model of a list of objects. ListModel[list[DutFieldData]] A Pydantic BaseModel for a container model of a list of objects. ListModel[list[ObservationData]] A Pydantic BaseModel for a container model of a list of objects. ListModel[list[ObservationDefinition]] A Pydantic BaseModel for a container model of a list of objects. ListModel[list[ObservationLite]] A Pydantic BaseModel for a container model of a list of objects. ListModel[list[ObservationSetData]] A Pydantic BaseModel for a container model of a list of objects. ListModel[list[ObservationUpdate]] A Pydantic BaseModel for a container model of a list of objects. ListModel[list[RunLite]] A Pydantic BaseModel for a container model of a list of objects. ListModel[list[SequenceMetadataData]] A Pydantic BaseModel for a container model of a list of objects. ObservationDataList alias of ListModel[list[ObservationData]] ObservationDefinitionList alias of ListModel[list[ObservationDefinition]] ObservationLiteList alias of ListModel[list[ObservationLite]] ObservationSetDataList alias of ListModel[list[ObservationSetData]] ObservationUpdateList alias of ListModel[list[ObservationUpdate]] ResponseWithMeta Class used for query endpoints to return metadata in addition to the returned items. RunLiteList alias of ListModel[list[RunLite]] SequenceMetadataDataList alias of ListModel[list[SequenceMetadataData]] Inheritance previous IqmServerMockBase next DutFieldDataList © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"QuantumComputersServicer","url":"/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.qc_pb2_grpc.QuantumComputersServicer.html","description":"Bases: object Quantum Computer management APIs. Module: iqm.station_control.client.iqm_server.proto.qc_pb2_grpc Methods GetQuantumComputerResourceV1  GetQuantumComputerV1 Returns the details for the r...","content":"Bases: object Quantum Computer management APIs. Module: iqm.station_control.client.iqm_server.proto.qc_pb2_grpc Methods GetQuantumComputerResourceV1  GetQuantumComputerV1 Returns the details for the requested quantum computer. ListQuantumComputersV1 Returns a list of quantum computers matching the given filters. Returns the details for the requested quantum computer. The quantum computer\\ncan be queried by its id or alias. If the given lookup does not match any\\nexisting quantum computer, the RPC call returns an error with a GRPC status NOT_FOUND . Returns a list of quantum computers matching the given filters. Returns the contents of a given resource by name and QC id (e.g. chip design record, static architecture, etc).\\nSee the full list of available resources at app/backend/lib/iqm-core-client/src/station_control_http_client/resources.rs .\\nEach resource is an opaque binary blob, the interpretation of which is up to the client. previous QuantumComputers next QuantumComputersStub © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"struct_serializer","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.struct_serializer.html","description":"Serializers and deserializers for struct related models. We use custom Struct model instead of standard Struct from protobuf,\\nsince standard Struct doesn’t support integers but instead casts them alwa...","content":"Serializers and deserializers for struct related models. We use custom Struct model instead of standard Struct from protobuf,\\nsince standard Struct doesn’t support integers but instead casts them always to floats. Full path: iqm.station_control.client.serializers.struct_serializer Functions deserialize_struct (proto) Deserialize a Struct protobuf representation into a free-form dict. serialize_struct (data) Serialize a free-form dict into a Struct protobuf representation. previous iqm.station_control.client.serializers.setting_node_serializer.deserialize_setting_node next iqm.station_control.client.serializers.struct_serializer.deserialize_struct © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"iqm.station_control.client.serializers.channel_property_serializer.unpack_channel_properties","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.channel_property_serializer.unpack_channel_properties.html","description":"Parse the Channel Property Dictionary from a string serialised protobuf payload. payload ( bytes ) – protobuf serialised payload of channel property dictionary. convert_instructions ( bool ) – whether...","content":"Parse the Channel Property Dictionary from a string serialised protobuf payload. payload ( bytes ) – protobuf serialised payload of channel property dictionary. convert_instructions ( bool ) – whether to convert string representation of instruction types to actual\\npython types. dict [ str , ChannelProperties ] previous iqm.station_control.client.serializers.channel_property_serializer.serialize_channel_properties next datetime_serializers © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."},{"package":"iqm-station-control-client","title":"channel_property_serializer","url":"/iqm-station-control-client/api/iqm.station_control.client.serializers.channel_property_serializer.html","description":"Serializers and deserializers for ChannelProperties Full path: iqm.station_control.client.serializers.channel_property_serializer Functions deserialize_channel_properties (...[, ...]) Convert the give...","content":"Serializers and deserializers for ChannelProperties Full path: iqm.station_control.client.serializers.channel_property_serializer Functions deserialize_channel_properties (...[, ...]) Convert the given protobuf dictionary of channel properties into a dictionary of ChannelProperties . deserialize_instructions (instructions) Convert a repeated scalar container of instruction type strings into a tuple of python types. serialize_channel_properties (...) Pack the given dictionary of channel properties into a protobuf format for further serialization. unpack_channel_properties (payload[, ...]) Parse the Channel Property Dictionary from a string serialised protobuf payload. previous serializers next iqm.station_control.client.serializers.channel_property_serializer.deserialize_channel_properties © Copyright 2019-2025, IQM Finland Oy, Release 3.16. Last updated on 2025-04-26."}]`);var fm=sc();const mi=({content:c,children:l})=>{const[r,b]=Ue.useState(!1),[_,v]=Ue.useState(null),[q,k]=Ue.useState({x:0,y:0});Ue.useEffect(()=>{const M=document.createElement("div");return document.body.appendChild(M),v(M),()=>{document.body.removeChild(M)}},[]);const I=M=>{k({x:M.clientX,y:M.clientY})};return _?y.jsxs("div",{className:"relative inline-block",onMouseMove:I,children:[l,y.jsx("span",{className:"tooltip-trigger ml-1 cursor-pointer",onMouseEnter:()=>b(!0),onMouseLeave:()=>b(!1),onClick:()=>b(!r),children:"ⓘ"}),r&&fm.createPortal(y.jsx("div",{className:"fixed p-2 bg-gray-700 text-white text-sm rounded shadow-lg z-50",style:{top:q.y+10,left:q.x+10},children:c}),_)]}):null},gm=[{name:"Higher energy states (resonator)",qccsw:"3.1.0",qiskit:{tutorial:"https://www.iqmacademy.com/notebookViewer/?path=/notebooks/iqm/deneb/Deneb_Unlocked_Resonator.ipynb"},cirq:{tutorial:"https://iqm-finland.github.io/iqm-client/api/iqm.iqm_client.models.CircuitCompilationOptions.html#iqm.iqm_client.models.CircuitCompilationOptions.move_gate_validation"}},{name:"Mid-circuit measurements",qccsw:"3.1.0",qiskit:!0,qrisp:!0,cirq:!0,cudaq:!0},{name:"Classically controlled gates",qccsw:"3.1.0",qiskit:{tutorial:"https://docs.meetiqm.com/iqm-client/user_guide_qiskit.html#classically-controlled-gates"},qrisp:!0,cirq:{tutorial:"https://docs.meetiqm.com/cirq-iqm/user_guide.html#classical-control"},cudaq:!1},{name:y.jsx(mi,{content:"Increase throughput by batching circuits that all read out the same qubits.",children:"Batched execution "}),qccsw:"1.0.0",qiskit:!0,cirq:!0,cudaq:!0,qrisp:!0},{name:"Dynamical decoupling",qccsw:"3.3.0",qiskit:{tutorial:"https://iqm-finland.github.io/iqm-client/api/iqm.iqm_client.models.CircuitCompilationOptions.html"},cirq:{tutorial:"https://iqm-finland.github.io/iqm-client/api/iqm.iqm_client.models.CircuitCompilationOptions.html"}},{name:y.jsxs("div",{style:{display:"flex"},children:[" ",y.jsx(mi,{content:"Using a secondary detection event to confirm the successful preparation or measurement of a quantum state.",children:" Heralding"})]}),qccsw:"1.0.0",qiskit:{tutorial:"https://iqm-finland.github.io/iqm-client/api/iqm.iqm_client.models.CircuitCompilationOptions.html#iqm.iqm_client.models.CircuitCompilationOptions.heralding_mode"},cirq:{tutorial:"https://iqm-finland.github.io/iqm-client/api/iqm.iqm_client.models.CircuitCompilationOptions.html#iqm.iqm_client.models.CircuitCompilationOptions.heralding_mode"}},{name:"Benchmarking tools",qccsw:"-",qiskit:{tutorial:"https://docs.meetiqm.com/iqm-benchmarks/"}},{name:"Simulated backend",qccsw:"-",qiskit:!0,cirq:"-",cudaq:"-",qrisp:"-"},{name:"Compilation check",qccsw:"1.0.0",qiskit:{tutorial:"https://www.iqmacademy.com/notebookViewer/?path=/notebooks/iqm/garnet/GarnetAlgorithmsChecker.ipynb"},cirq:!0,cudaq:!0,qrisp:!0},{name:"Resetting qubits",qccsw:"3.2.0",qiskit:{tutorial:"https://docs.meetiqm.com/iqm-client/user_guide_qiskit.html#resetting-qubits"},cirq:!1,cudaq:!1,qrisp:!0},{name:y.jsx(mi,{content:"The qubits are actively reset once more using conditional pulses feedback loops before circuit execution.",children:"Automated active reset"}),qccsw:"3.3.0",qiskit:{tutorial:"https://iqm-finland.github.io/iqm-client/api/iqm.iqm_client.models.CircuitCompilationOptions.html#iqm.iqm_client.models.CircuitCompilationOptions.active_reset_cycles"},cirq:{tutorial:"https://iqm-finland.github.io/iqm-client/api/iqm.iqm_client.models.CircuitCompilationOptions.html#iqm.iqm_client.models.CircuitCompilationOptions.active_reset_cycles"}},{name:"Programmatically retrieve calibration data (Resonance)",qccsw:"-",qiskit:{tutorial:"https://www.iqmacademy.com/notebookViewer/?path=/notebooks/iqm/general/RetrieveCalibrationData.ipynb"},cirq:{tutorial:"https://www.iqmacademy.com/notebookViewer/?path=/notebooks/iqm/general/RetrieveCalibrationData.ipynb"},cudaq:{tutorial:"https://www.iqmacademy.com/notebookViewer/?path=/notebooks/iqm/general/RetrieveCalibrationData.ipynb"},qrisp:{tutorial:"https://www.iqmacademy.com/notebookViewer/?path=/notebooks/iqm/general/RetrieveCalibrationData.ipynb"}},{name:"Programmatically retrieve calibration data",qccsw:"-",qiskit:!0,cirq:!0,cudaq:!0,qrisp:!0},{name:"MOVE operation support",qccsw:"3.0.0",qiskit:{tutorial:"https://www.iqmacademy.com/learn/deneb/01-move/"},cirq:{tutorial:"https://www.iqmacademy.com/learn/deneb/01-move/"}}],_m=[{name:"Ready-made experiments",resonance:!1,onprem:!0},{name:"Custom calibrations",resonance:"Coming soon",onprem:!0},{name:"Custom gates",resonance:"Coming soon",onprem:!0},{name:"Pulse Schedule viewer",resonance:"Coming soon",onprem:!0},{name:"Custom compiler stages",resonance:"Coming soon",onprem:!0},{name:"Calibration workflows",resonance:!1,onprem:!0}],Li=({framework:c})=>y.jsxs("div",{children:[c?y.jsx(y.Fragment,{children:typeof c=="string"?c:y.jsx(y.Fragment,{children:"✅"})}):y.jsx(y.Fragment,{children:"❌"})," ",c&&c.tutorial&&y.jsx(y.Fragment,{children:y.jsx("a",{href:c.tutorial,target:"_blank",rel:"noreferrer",children:"🔍"})})]}),ym=()=>y.jsx(y.Fragment,{children:y.jsx("main",{children:y.jsxs("div",{className:"container mx-auto",children:[y.jsxs("div",{className:"my-4",children:[y.jsx("p",{children:"IQM Quantum Computers support multiple quantum computing frameworks with support for varying features. Below's list provides an overview of the features supported by IQM Quantum Computers."}),y.jsxs("p",{className:"mt-4",children:["If the feature you require is not listed here, it might not mean it is not supported. Please contact us at ",y.jsx("a",{href:"mailto:support@meetiqm.com",children:"IQM Support"}),"."]})]}),y.jsx("h2",{className:"text-2xl font-semibold mt-8",children:"Gate-based access"}),y.jsx("p",{children:"Click on the 🔍 to access more information."}),y.jsx("div",{className:"overflow-x-auto pt-4 pb-4",children:y.jsxs("table",{className:"min-w-full bg-white rounded-xl",children:[y.jsx("thead",{children:y.jsxs("tr",{children:[y.jsx("th",{className:"py-2 px-4 border-b",children:"FEATURE"}),y.jsx("th",{className:"py-2 px-4 border-b",children:y.jsx("div",{className:"flex items-center",children:y.jsx(mi,{content:y.jsx(y.Fragment,{children:"Earliest version of the Quantum Computer Software Stack needed to support this feature."}),children:"QCCSW"})})}),y.jsx("th",{className:"py-2 px-4 border-b",children:y.jsx(mi,{content:"For supported versions check the quantum computer detail page.",children:"Qiskit"})}),y.jsx("th",{className:"py-2 px-4 border-b",children:y.jsx(mi,{content:"Supported in Resonance via Qiskit-on-IQM.",children:"qrisp"})}),y.jsx("th",{className:"py-2 px-4 border-b",children:y.jsx(mi,{content:"For supported versions check the quantum computer detail page.",children:"Cirq"})}),y.jsx("th",{className:"py-2 px-4 border-b",children:"CUDA-Q"})]})}),y.jsx("tbody",{children:gm.sort((c,l)=>l.qccsw.localeCompare(c.qccsw)).map((c,l)=>y.jsxs("tr",{children:[y.jsx("td",{className:"py-2 px-4 border-b",children:c.name}),y.jsxs("td",{className:"py-2 px-4 border-b",children:[typeof c.qccsw=="string"&&/\d/.test(c.qccsw[0])&&y.jsx(y.Fragment,{children:"≥"})," ",c.qccsw]}),y.jsx("td",{className:"py-2 px-4 border-b",children:y.jsx(Li,{framework:c.qiskit})}),y.jsx("td",{className:"py-2 px-4 border-b",children:y.jsx(Li,{framework:c.qrisp})}),y.jsx("td",{className:"py-2 px-4 border-b",children:y.jsx(Li,{framework:c.cirq})}),y.jsx("td",{className:"py-2 px-4 border-b",children:y.jsx(Li,{framework:c.cudaq})})]},l))})]})}),y.jsxs("div",{className:"my-8",children:[y.jsx("h2",{className:"text-2xl font-semibold",children:"Pulse-based access"}),y.jsx("div",{className:"overflow-x-auto",children:y.jsxs("table",{className:"min-w-full bg-white rounded-xl mt-4",children:[y.jsx("thead",{children:y.jsxs("tr",{children:[y.jsx("th",{className:"py-2 px-4 border-b",children:"FEATURE"}),y.jsx("th",{className:"py-2 px-4 border-b",children:"RESONANCE"}),y.jsx("th",{className:"py-2 px-4 border-b",children:"ON-PREMISE DEVICES"})]})}),y.jsx("tbody",{children:_m.sort((c,l)=>{const r=typeof c.name=="string"?c.name:c.name.props.children[0],b=typeof l.name=="string"?l.name:l.name.props.children[0];return r.localeCompare(b)}).map((c,l)=>y.jsxs("tr",{children:[y.jsx("td",{className:"py-2 px-4 border-b",children:c.name}),y.jsx("td",{className:"py-2 px-4 border-b justify-items-center",children:y.jsx(Li,{framework:c.resonance})}),y.jsx("td",{className:"py-2 px-4 border-b justify-items-center",children:y.jsx(Li,{framework:c.onprem})})]},l))})]})})]})]})})});function bm(){const[c,l]=Ue.useState(!1),[r,b]=Ue.useState(""),[_,v]=Ue.useState(Us),q=new Ni(Us,{keys:["title","description","package"],threshold:.4});Ue.useEffect(()=>{const T=O=>{(O.metaKey||O.ctrlKey)&&O.key==="k"&&(O.preventDefault(),l(!0)),O.key==="Escape"&&l(!1)};return window.addEventListener("keydown",T),()=>window.removeEventListener("keydown",T)},[]),Ue.useEffect(()=>{if(r){const T=q.search(r);v(T.map(O=>O.item))}else v(Us)},[r]);const k=()=>{l(!0)},[I,M]=Ue.useState(!0),P=[{href:"./iqm-pulse",title:"IQM Pulse",description:"Interface and implementations for control pulses."},{href:"./iqm-pulla",title:"IQM Pulla",description:"Pulse-level access library for compiling quantum circuits."},{href:"./iqm-benchmarks/",title:"IQM Benchmarks",description:"Quantum Characterization, Verification, and Validation (QCVV) tools for quantum computing."},{href:"./iqm-client/",title:"IQM Client",description:"Python client for remote access to quantum computers for circuit-level access (e.g. via Qiskit, Cirq)."},{href:"./iqm-station-control-client",title:"IQM Station Control Client",description:"Python client for remote access to quantum computers for pulse-level access."},{href:"./iqm-exa-common",title:"IQM EXA Common",description:"Abstract interfaces, helpers, utility classes, etc."},{href:"./iqm-data-definitions",title:"IQM Data Definitions",description:"A common place for data definitions shared inside IQM."}];return y.jsx("div",{className:"min-h-screen px-8 py-3",children:y.jsxs("div",{className:"mx-auto",children:[y.jsxs("div",{className:"flex flex-col sm:flex-row mb-4 sm:gap-2 lg:gap-[8rem]",children:[y.jsx(hm,{}),y.jsxs("div",{className:"flex gap-4",children:[y.jsxs("button",{className:"relative px-4 pt-2",onClick:()=>M(!0),children:["Documentation",y.jsx("span",{className:`block h-[0.2rem] ml-4 mr-4 ${I?"bg-green-500":"bg-transparent"} absolute bottom-0 left-0 right-0`})]}),y.jsxs("button",{className:"relative px-4 pt-2",onClick:()=>M(!1),children:["Features",y.jsx("span",{className:`block h-[0.2rem] ml-4 mr-4 ${I?"bg-transparent":"bg-green-500"} absolute bottom-0 left-0 right-0`})]})]})]}),y.jsxs("div",{className:"max-w-4xl mx-auto",children:[y.jsxs("div",{onClick:k,className:"mt-6 mb-6 flex items-center gap-2 p-3 bg-white border border-gray-200 rounded-lg cursor-pointer hover:border-gray-300 transition-colors",children:[y.jsx(oc,{className:"w-5 h-5 text-gray-400"}),y.jsxs("span",{className:"text-gray-500",children:["Search all documentation... ",navigator.userAgent.includes("Mac")?"Press ⌘K":"Press Ctrl+K"]})]}),I?y.jsxs(y.Fragment,{children:[y.jsxs("p",{children:["Find below the documentation for IQM client-side libraries that can be used to connect to "," ",y.jsx("a",{href:"https://resonance.meetiqm.com",target:"_blank",children:"IQM Resonance"})," and any IQM on-premise quantum computer."]}),y.jsx("div",{className:"grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-6 mt-8",children:P.map((T,O)=>y.jsxs("a",{href:T.href,target:"_blank",className:"p-6 bg-white border border-gray-200 rounded-lg shadow-sm hover:shadow-md transition-shadow",children:[y.jsx("h2",{className:"text-lg font-semibold text-gray-900",children:T.title}),y.jsx("p",{className:"mt-2 text-sm text-gray-600",children:T.description})]},O))})]}):y.jsx(ym,{}),c&&y.jsx("div",{className:"fixed inset-0 bg-black bg-opacity-50 flex items-start justify-center pt-[15vh] z-50",children:y.jsxs("div",{className:"bg-white rounded-xl shadow-2xl w-full max-w-2xl max-h-[70vh] overflow-hidden",children:[y.jsxs("div",{className:"p-4 border-b border-gray-100 flex items-center gap-3",children:[y.jsx(oc,{className:"w-5 h-5 text-gray-400"}),y.jsx("input",{type:"text",autoFocus:!0,placeholder:"Search documentation...",className:"flex-1 outline-none text-gray-900",value:r,onChange:T=>b(T.target.value)}),y.jsx("button",{onClick:()=>l(!1),className:"p-1 hover:bg-gray-100 rounded-md transition-colors",children:y.jsx(lm,{className:"w-5 h-5 text-gray-500"})})]}),y.jsx("div",{className:"overflow-y-auto max-h-[calc(70vh-4rem)]",children:_.map((T,O)=>y.jsxs("a",{href:"."+T.url,target:"_blank",className:"block p-4 hover:bg-gray-50 transition-colors overflow-hidden",children:[y.jsx("h3",{className:"font-medium text-gray-900",children:T.title}),y.jsx("span",{className:"text-sm text-gray-500 block mt-1",children:T.package}),y.jsx("p",{className:"text-sm text-gray-600 mt-1",children:T.description})]},O))})]})})]}),y.jsxs("footer",{className:"mt-8 text-center text-sm text-gray-500 border-gray-300 border-t pt-4",children:[y.jsx("span",{children:"Copyright IQM Quantum Computers 2021-2025."}),y.jsx("br",{}),y.jsxs("span",{children:["Need assistance? Contact us ",y.jsx("a",{href:"mailto:support@meetiqm.com",children:"support@meetiqm.com"})]})]})]})})}vp.createRoot(document.getElementById("root")).render(y.jsx(Ue.StrictMode,{children:y.jsx(bm,{})}));
