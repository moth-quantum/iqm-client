[
  {
    "package": "iqm-exa-common",
    "title": "API documentation: exa-common",
    "url": "/iqm-exa-common/index.html",
    "description": "26.13 2025-04-15 This documentation describes the common library of the Experiment Automation ( EXA ) project. exa-common contains classes and functions that are shared by EXA , Cortex and Station Con...",
    "content": "26.13 2025-04-15 This documentation describes the common library of the Experiment Automation ( EXA ) project. exa-common contains classes and functions that are shared by EXA , Cortex and Station Control . Index Module Index Search Page next API Reference \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "API Reference",
    "url": "/iqm-exa-common/API.html",
    "description": "exa.common Shared errors, helpers, control structures, settings, API models etc. previous API documentation: exa-common next common \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated o...",
    "content": "exa.common Shared errors, helpers, control structures, settings, API models etc. previous API documentation: exa-common next common \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.server_errors.UnauthorizedError",
    "url": "/iqm-exa-common/api/exa.common.errors.server_errors.UnauthorizedError.html",
    "description": "Error raised when the user is not authorized. message ( str ) \u2013 previous exa.common.errors.server_errors.StationControlError next exa.common.errors.server_errors.ValidationError \u00a9 Copyright 2019-2025,...",
    "content": "Error raised when the user is not authorized. message ( str ) \u2013 previous exa.common.errors.server_errors.StationControlError next exa.common.errors.server_errors.ValidationError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "helpers",
    "url": "/iqm-exa-common/api/exa.common.helpers.html",
    "description": "Miscellaneous helper functionality. Full path: exa.common.helpers Subpackages and modules deprecation  software_version_helper  previous exa.common.errors.server_errors.ValidationError next deprecatio...",
    "content": "Miscellaneous helper functionality. Full path: exa.common.helpers Subpackages and modules deprecation  software_version_helper  previous exa.common.errors.server_errors.ValidationError next deprecation \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "CHAD",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.CHAD.html",
    "description": "Bases: ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidate...",
    "content": "Bases: ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes computational_resonator_names Names of all the computational resonators declared in CHAD data. coupler_names Names of all the couplers declared in CHAD data. model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. probe_line_names Names of all the probe lines declared in CHAD data. qubit_names Names of all the qubits declared in CHAD data. mask_set_name  variant  components  Methods filter_qubit_components Filter qubit components from the input components. get_common_coupler_for Convenience method for getting the name of a coupler connecting a pair of components. get_component Get component by component name. get_coupler_mapping_for Get the coupler-component mapping for the couplers that connects to at least two components get_probe_line_mapping_for Get the probe line-component mapping. get_probe_line_names_for Get probe lines for given qubits in CHAD data. group_components_per_default_operations Groups given qubits/couplers based on their defined default operations. mask_set_name ( str ) \u2013 variant ( str ) \u2013 components ( Components ) \u2013 Get component by component name. component_name ( str ) \u2013 Component Names of all the qubits declared in CHAD data. Names of all the couplers declared in CHAD data. Names of all the probe lines declared in CHAD data. Names of all the computational resonators declared in CHAD data. Filter qubit components from the input components. component_names ( Collection [ str ] ) \u2013 list [ str ] Get probe lines for given qubits in CHAD data. component_names ( Collection [ str ] ) \u2013 list [ str ] Groups given qubits/couplers based on their defined default operations. The default operations that can be deducted from a CHAD are readout , drive , and flux . component_names ( Collection [ str ] ) \u2013 The component names to which to do the grouping.\nOther components present in the CHAD will not be included in the returned data. Tuple of qubits and couplers mapped to their connected default operations. The data is in the form of a dict with the keys being readout , drive , and flux ,\nand the values the list of component names having that particular operation. The data is in the form of a dict with the keys being readout , drive , and flux ,\nand the values the list of component names having that particular operation. tuple [ dict [ str , list [ str ]], dict [ str , list [ str ]]] in the given qubits. component_names ( Collection [ str ] ) \u2013 The qubit names. May contain any number of qubits. Coupler names mapped to the components they connect. - ValueError \u2013 If the provided qubit name list contains duplicates. dict [ str , list [ str ]] Get the probe line-component mapping. component_names ( Collection [ str ] ) \u2013 The qubit names. May contain any number of qubits. dict [ str , list [ str ]] Convenience method for getting the name of a coupler connecting a pair of components. first_component ( str ) \u2013 The name of the first component. second_component ( str ) \u2013 The name of the second component.\nThe order of qubits does not matter, i.e. the first_qubit and second_qubit arguments are interchangeable. The name of the coupler that connects the inputted components. The name of the coupler that connects the inputted components. - ValueError \u2013 If there were no couplers or more than one coupler connecting the component pair (the latter\n    should not be possible in a realistic chip). str Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous chad_model next Component \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "chip_topology",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chip_topology.html",
    "description": "Chip topology class for parsing CHAD and other QPU related data into human-usable form. Full path: exa.common.qcm_data.chip_topology Functions sort_components (components) Sort the given components in...",
    "content": "Chip topology class for parsing CHAD and other QPU related data into human-usable form. Full path: exa.common.qcm_data.chip_topology Functions sort_components (components) Sort the given components in a human-readable way. sort_couplers (couplers) Sort the given couplers in a human-readable way. Classes ChipTopology Topology information for a chip (typically a QPU). Inheritance previous Qubit next exa.common.qcm_data.chip_topology.sort_components \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.logger.logger.init_loggers",
    "url": "/iqm-exa-common/api/exa.common.logger.logger.init_loggers.html",
    "description": "Set the log level of given logger names. Logs with INFO or DEBUG logging levels are written into stdout, and logs with other levels are written into stderr. By default, the root logger uses WARNING le...",
    "content": "Set the log level of given logger names. Logs with INFO or DEBUG logging levels are written into stdout, and logs with other levels are written into stderr. By default, the root logger uses WARNING level. See Python\u2019s logging module for possible logging levels. loggers ( dict [ str , str | None ] | None ) \u2013 A mapping from logger name to (case insensitive) logging level. If logging level is None or empty\nstring, default_level will be used for that logger. It is possible to fine tune logging for individual\nmodules, since logger propagation is turned off. Overriding works both ways: a parent logger can have higher\nlogging level than its descendants, and vice versa.\nFor example, {\"sqlalchemy\": None, \"sqlalchemy.engine\": \"debug\"} will put\n\u201csqlalchemy\u201d and its descendants (i.e. \u201csqlalchemy.dialects\u201d, \u201csqlalchemy.dialects.sqlite\u201d, etc.) into default_level , except for \u201csqlalchemy.engine\u201d for which DEBUG level is defined.\nFor the root logger, use empty string key, for example: {\"\": \"INFO\"} .\nIf empty dict or None is given, only the root logger will be initialized to its default WARNING level. default_level ( str ) \u2013 The default level (case insensitive) to be used for logger names given with loggers for which a level is not specified. verbose ( bool ) \u2013 If False, :const: BRIEF format will be used for log messages, otherwise :const: VERBOSE . extra_info_getter ( Callable [ [ ] , str ] | None ) \u2013 Optional callable to convey extra information to log messages. It will get called before\neach log message emission and the output will get appended to the log message. None previous logger next ExtraFormatter \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "Coupler",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.Coupler.html",
    "description": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form...",
    "content": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name  connections  Methods name ( str ) \u2013 connections ( tuple [ str , ... ] ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous ComputationalResonator next Launcher \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "Components",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.Components.html",
    "description": "Bases: ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidate...",
    "content": "Bases: ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes all  model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. qubits  couplers  probe_lines  launchers  computational_resonators  Methods sort_components  qubit ( tuple [ Qubit , ... ] ) \u2013 tunable_coupler ( tuple [ Coupler , ... ] ) \u2013 probe_line ( tuple [ ProbeLine , ... ] ) \u2013 launcher ( tuple [ Launcher , ... ] ) \u2013 computational_resonator ( tuple [ ComputationalResonator , ... ] ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous Component next ComputationalResonator \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "ChipTopology",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chip_topology.ChipTopology.html",
    "description": "Bases: object Topology information for a chip (typically a QPU). Can represent the information found in a CHAD, as well as locus mappings for gates. qubits ( Iterable [ str ] ) \u2013 names of the qubits. ...",
    "content": "Bases: object Topology information for a chip (typically a QPU). Can represent the information found in a CHAD, as well as locus mappings for gates. qubits ( Iterable [ str ] ) \u2013 names of the qubits. computational_resonators ( Iterable [ str ] ) \u2013 names of the computational resonators. couplers ( dict [ str , Iterable [ str ] ] ) \u2013 mapping from coupler name to names of chip components it connects to. probe_lines ( dict [ str , Iterable [ str ] ] ) \u2013 mapping from probe line name to names of chip components it connects to. variant ( str ) \u2013 identifier of the QPU design variant. Module: exa.common.qcm_data.chip_topology Attributes computational_resonators Computational resonators on the chip, in any order. computational_resonators_sorted Computational resonators on the chip, sorted. couplers Tunable couplers on the chip, in any order. couplers_sorted Tunable couplers on the chip, sorted by numerical IDs. probe_lines Probe lines on the chip, in any order. probe_lines_sorted Probe lines on the chip, sorted. all_components All components on the chip. coupler_to_components Map from each coupler to all other components it connects to. component_to_couplers Map from each component to all couplers connected to it. probe_line_to_components Map from each probe line to all components it connects to. component_to_probe_line Map from each component to the probeline connected to it. Methods from_chad Construct a ChipTopology instance from a CHAD. from_chip_design_record Construct a ChipTopology instance from a raw Chip design record. get_all_common_resonators Computational resonators connected to all the given qubits via a coupler. get_common_computational_resonator Convenience method for getting the name of a computational resonator which is connected to both specified qubit components via tunable couplers. get_connected_probe_lines Get probelines that are connected to any of the given components. get_connecting_couplers Couplers that only connect to the given chip components, and connect at least two of them. get_coupler_for Common coupler for the given chip components (e.g. qubit or computational resonator). get_loci Gives all the loci of a given gate. get_neighbor_couplers Couplers that connect to at least one of the given chip components. get_neighbor_locus_components Chip components that are connected to the given components by a coupler, but not included in them. is_computational_resonator True iff the given component is a computational resonator. is_coupler True iff the given component is a coupler. is_probe_line True iff the given component is a probe line. is_qubit True iff the given component is a qubit. limit_values Prunes the given dictionary (e.g. a coupler-to-qubits map) to a subset of values. map_locus Returns the mapped components for the given locus and the given gate. map_to_locus Returns the locus that is mapped to the given components. set_locus_mapping Add a custom mapping from a gate locus to a set of components required for the gate operation. Computational resonators on the chip, in any order. Computational resonators on the chip, sorted. Tunable couplers on the chip, in any order. Tunable couplers on the chip, sorted by numerical IDs. Probe lines on the chip, in any order. Probe lines on the chip, sorted. All components on the chip. Map from each coupler to all other components it connects to. The values are sorted. Map from each component to all couplers connected to it. Map from each probe line to all components it connects to. Map from each component to the probeline connected to it.\nMax 1 connection per component is assumed.\nComponents without connection to a probe line don\u2019t appear. Construct a ChipTopology instance from a raw Chip design record. record ( dict ) \u2013 Record as returned by Station control. Corresponding chip topology ChipTopology Construct a ChipTopology instance from a CHAD. Use from_chip_design_record() if possible. chad ( CHAD ) \u2013 parsed CHAD model corresponding chip topology ChipTopology Couplers that connect to at least one of the given chip components. components ( Iterable [ str ] ) \u2013 some chip components, typically qubits and computational resonators couplers that connect to at least one of components set [ str ] Couplers that only connect to the given chip components, and connect at least two of them. Equivalent to returning the edges in the components -induced\nsubgraph of the coupling topology. components ( Collection [ str ] ) \u2013 some chip components, typically qubits and computational resonators couplers that connect to only members of components , and to at least two of them set [ str ] Common coupler for the given chip components (e.g. qubit or computational resonator). component_1 ( str ) \u2013 first component component_2 ( str ) \u2013 second component the common coupler ValueError \u2013 the given components have zero or more than one connecting coupler str Chip components that are connected to the given components by a coupler, but not included in them. components ( Collection [ str ] ) \u2013 some chip components, typically qubits and computational resonators components that are connected to components by a coupler, but not included in them set [ str ] Get probelines that are connected to any of the given components. components ( Collection [ str ] ) \u2013 set [ str ] Prunes the given dictionary (e.g. a coupler-to-qubits map) to a subset of values. Used to prune e.g. coupler_to_components to a subset of relevant elements. dct ( ComponentMap ) \u2013 Dictionary of collections of values. limit_to ( Collection [ str ] ) \u2013 Components to limit the output to. The input dictionary, but only with key-value pairs where the value intersects with limit_to . ComponentMap True iff the given component is a qubit. component ( str ) \u2013 bool True iff the given component is a coupler. component ( str ) \u2013 bool True iff the given component is a probe line. component ( str ) \u2013 bool True iff the given component is a computational resonator. component ( str ) \u2013 bool Add a custom mapping from a gate locus to a set of components required for the gate operation. The mapping is of the form {<locus>: <components mapped to locus>}, where a locus can be mapped to one or more\ncomponents. The locus itself can be a frozenset (denoting a symmetric gate) or a tuple (non-symmetric gate). Some examples:\n- DEFAULT_2QB_MAPPING (added in __init__() ) maps pairs of qubits to their common coupler symmetrically.\n- Fast flux CZ-gate maps pairs of qubits to their couplers non-symmetrically (first locus qubit can perform flux pulses).\n- A two-qubit gate implementation that includes playing pulses on neighboring components in addition to the connecting coupler. name ( str ) \u2013 The name for the gate & implementation this locus mapping represents (typically in the format \"<gate name>.<implementation name>\" ). mapping ( dict [ tuple [ str , ... ] | frozenset [ str ] , tuple [ str , ... ] ] ) \u2013 The locus mapping to be added. None Validate that the components given in mapping are found in self and the mapping is correctly formed. mapping ( dict [ str | tuple [ str ] , tuple [ str , ... ] | frozenset [ str ] ] | None ) \u2013 None Returns the mapped components for the given locus and the given gate. If the locus or the gate is not found from the locus mappings of self, returns None. locus ( tuple [ str , ... ] | frozenset [ str ] ) \u2013 The locus to map. name ( str | None ) \u2013 The name for the gate & implementation with which to map the locus (typically in the format \"<gate name>.<implementation name>\" ). The components mapped to the given locus or None if locus is not found in the given mapping. str | tuple [ str ] | None Returns the locus that is mapped to the given components. mapped ( str | tuple [ str ] ) \u2013 The mapped components. name ( str ) \u2013 The name for the gate & implementation with which to map the locus (typically in the format \"<gate name>.<implementation name>\" ). The locus mapped to the given components or None if the components are not mapped to any locus. tuple [ str , \u2026] | frozenset [ str ] | None Gives all the loci of a given gate. If no mapping with the given the name nor a default mapping with the given dimensionality is found,\nreturns an empty list. name ( str ) \u2013 The name for the gate & implementation with which to map the locus (typically in the format \"<gate name>.<implementation name>\" ). default_mapping_dimension ( int | None ) \u2013 If provided, will return the loci of the default mapping of the given\ndimensionality in case no mapping for name can be found. The loci associated with the given gate. list [ tuple [ str , \u2026] | frozenset [ str ]] Convenience method for getting the name of a computational resonator which is connected to both specified\nqubit components via tunable couplers. first_qubit ( str ) \u2013 The name of the first qubit. second_qubit ( str ) \u2013 The name of the second qubit. The order of qubits does not matter, i.e. the first_qubit and second_qubit arguments are interchangeable. The name of the second qubit. The order of qubits does not matter, i.e. the first_qubit and second_qubit arguments are interchangeable. The name of the computational resonator that is connected to both inputted qubits via tunable couplers. The name of the computational resonator that is connected to both inputted qubits via tunable couplers. - ValueError \u2013 If no computational resonator was found that is connected to both qubits via tunable couplers. \u2013 str Computational resonators connected to all the given qubits via a coupler. qubits ( list [ str ] ) \u2013 Qubit names. Names of the computational resonators neighboring all of qubits (can be an empty set). set [ str ] previous exa.common.qcm_data.chip_topology.sort_couplers next file_adapter \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "FileAdapter",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.file_adapter.FileAdapter.html",
    "description": "Bases: BaseAdapter Module: exa.common.qcm_data.file_adapter Methods close Cleans up adapter specific items. send Sends PreparedRequest object. Sends PreparedRequest object. Returns Response object. Cl...",
    "content": "Bases: BaseAdapter Module: exa.common.qcm_data.file_adapter Methods close Cleans up adapter specific items. send Sends PreparedRequest object. Sends PreparedRequest object. Returns Response object. Cleans up adapter specific items. previous file_adapter next immutable_base_model \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa_error",
    "url": "/iqm-exa-common/api/exa.common.errors.exa_error.html",
    "description": "Full path: exa.common.errors.exa_error Exceptions EmptyComponentListError (message,\u00a0*args) Error raised when an empty list is given as components for running an experiment. ExaError (message,\u00a0*args) B...",
    "content": "Full path: exa.common.errors.exa_error Exceptions EmptyComponentListError (message,\u00a0*args) Error raised when an empty list is given as components for running an experiment. ExaError (message,\u00a0*args) Base class for exa errors. InvalidSweepOptionsTypeError (**kwargs) The type of sweep options is invalid. UnknownSettingError (message,\u00a0*args) This SettingNode does not have a given key. previous errors next exa.common.errors.exa_error.EmptyComponentListError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.exa_error.InvalidSweepOptionsTypeError",
    "url": "/iqm-exa-common/api/exa.common.errors.exa_error.InvalidSweepOptionsTypeError.html",
    "description": "The type of sweep options is invalid. previous exa.common.errors.exa_error.ExaError next exa.common.errors.exa_error.UnknownSettingError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last upda...",
    "content": "The type of sweep options is invalid. previous exa.common.errors.exa_error.ExaError next exa.common.errors.exa_error.UnknownSettingError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "sweep",
    "url": "/iqm-exa-common/api/exa.common.sweep.html",
    "description": "Sweep utilities. Full path: exa.common.sweep Subpackages and modules previous QCMDataClient next Changelog \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15....",
    "content": "Sweep utilities. Full path: exa.common.sweep Subpackages and modules previous QCMDataClient next Changelog \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "qcm_data_client",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.qcm_data_client.html",
    "description": "QCM (Quantum Computer Management) Data API client implementation. Full path: exa.common.qcm_data.qcm_data_client Classes QCMDataClient Python client for QCM (Quantum Computer Management) Data API. Inh...",
    "content": "QCM (Quantum Computer Management) Data API client implementation. Full path: exa.common.qcm_data.qcm_data_client Classes QCMDataClient Python client for QCM (Quantum Computer Management) Data API. Inheritance previous ImmutableBaseModel next QCMDataClient \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "chad_model",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.html",
    "description": "Pydantic models for CHAD. Full path: exa.common.qcm_data.chad_model Classes CHAD Create a new model by parsing and validating input data from keyword arguments. Component Create a new model by parsing...",
    "content": "Pydantic models for CHAD. Full path: exa.common.qcm_data.chad_model Classes CHAD Create a new model by parsing and validating input data from keyword arguments. Component Create a new model by parsing and validating input data from keyword arguments. Components Create a new model by parsing and validating input data from keyword arguments. ComputationalResonator Create a new model by parsing and validating input data from keyword arguments. Coupler Create a new model by parsing and validating input data from keyword arguments. Launcher Create a new model by parsing and validating input data from keyword arguments. ProbeLine Create a new model by parsing and validating input data from keyword arguments. Qubit Create a new model by parsing and validating input data from keyword arguments. Inheritance previous qcm_data next CHAD \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.server_errors.NotFoundError",
    "url": "/iqm-exa-common/api/exa.common.errors.server_errors.NotFoundError.html",
    "description": "Error raised when nothing was found with the given parameters. This should be used when it\u2019s expected that something is found, for example when trying to find with an exact ID. message ( str ) \u2013 previ...",
    "content": "Error raised when nothing was found with the given parameters. This should be used when it\u2019s expected that something is found, for example when trying to find with an exact ID. message ( str ) \u2013 previous exa.common.errors.server_errors.InternalServerError next exa.common.errors.server_errors.ServiceUnavailableError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "Qubit",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.Qubit.html",
    "description": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form...",
    "content": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name  connections  Methods name ( str ) \u2013 connections ( tuple [ str , ... ] ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous ProbeLine next chip_topology \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "logger",
    "url": "/iqm-exa-common/api/exa.common.logger.html",
    "description": "Helper to initialize loggers to the specified logging level. Full path: exa.common.logger Subpackages and modules logger  previous exa.common.helpers.software_version_helper.get_vcs_description next l...",
    "content": "Helper to initialize loggers to the specified logging level. Full path: exa.common.logger Subpackages and modules logger  previous exa.common.helpers.software_version_helper.get_vcs_description next logger \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.server_errors.StationControlError",
    "url": "/iqm-exa-common/api/exa.common.errors.server_errors.StationControlError.html",
    "description": "Base class for station control errors used in client-server communication. message ( str ) \u2013 previous exa.common.errors.server_errors.ServiceUnavailableError next exa.common.errors.server_errors.Unaut...",
    "content": "Base class for station control errors used in client-server communication. message ( str ) \u2013 previous exa.common.errors.server_errors.ServiceUnavailableError next exa.common.errors.server_errors.UnauthorizedError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "InfoFilter",
    "url": "/iqm-exa-common/api/exa.common.logger.logger.InfoFilter.html",
    "description": "Bases: Filter Helper class to filter log messages above INFO level. Initialize a filter. Initialize with the name of the logger which, together with its\nchildren, will have its events allowed through ...",
    "content": "Bases: Filter Helper class to filter log messages above INFO level. Initialize a filter. Initialize with the name of the logger which, together with its\nchildren, will have its events allowed through the filter. If no\nname is specified, allow every event. Module: exa.common.logger.logger Methods filter Determine if the specified record is to be logged. Determine if the specified record is to be logged. Returns True if the record should be logged, or False otherwise.\nIf deemed appropriate, the record may be modified in-place. record ( LogRecord ) \u2013 bool previous ExtraFormatter next qcm_data \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.server_errors.ForbiddenError",
    "url": "/iqm-exa-common/api/exa.common.errors.server_errors.ForbiddenError.html",
    "description": "Error raised when the operation is forbidden for the user. message ( str ) \u2013 previous exa.common.errors.server_errors.ConflictError next exa.common.errors.server_errors.InternalServerError \u00a9 Copyright...",
    "content": "Error raised when the operation is forbidden for the user. message ( str ) \u2013 previous exa.common.errors.server_errors.ConflictError next exa.common.errors.server_errors.InternalServerError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "data",
    "url": "/iqm-exa-common/api/exa.common.data.html",
    "description": "Classes for representing physical quantities and instrument settings. Full path: exa.common.data Subpackages and modules base_model  previous sweep next base_model \u00a9 Copyright 2019-2025, IQM Finland O...",
    "content": "Classes for representing physical quantities and instrument settings. Full path: exa.common.data Subpackages and modules base_model  previous sweep next base_model \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "software_version_helper",
    "url": "/iqm-exa-common/api/exa.common.helpers.software_version_helper.html",
    "description": "Full path: exa.common.helpers.software_version_helper Functions get_all_software_versions ([reload_module]) Get all available software version information. get_vcs_description (root_directory) Get Ver...",
    "content": "Full path: exa.common.helpers.software_version_helper Functions get_all_software_versions ([reload_module]) Get all available software version information. get_vcs_description (root_directory) Get Version Control System (VCS) description for the caller's current working directory. previous exa.common.helpers.deprecation.format_deprecated next exa.common.helpers.software_version_helper.get_all_software_versions \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "ImmutableBaseModel",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.immutable_base_model.ImmutableBaseModel.html",
    "description": "Bases: BaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form...",
    "content": "Bases: BaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.immutable_base_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Methods Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous immutable_base_model next qcm_data_client \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "common",
    "url": "/iqm-exa-common/api/exa.common.html",
    "description": "Shared errors, helpers, control structures, settings, API models etc. Full path: exa.common Subpackages and modules api API helpers. control Common data structures of abstract instrument control. data...",
    "content": "Shared errors, helpers, control structures, settings, API models etc. Full path: exa.common Subpackages and modules api API helpers. control Common data structures of abstract instrument control. data Classes for representing physical quantities and instrument settings. errors Common error messages. helpers Miscellaneous helper functionality. logger Helper to initialize loggers to the specified logging level. qcm_data  sweep Sweep utilities. previous API Reference next api \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "qcm_data",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.html",
    "description": "Full path: exa.common.qcm_data Subpackages and modules chad_model Pydantic models for CHAD. chip_topology Chip topology class for parsing CHAD and other QPU related data into human-usable form. file_a...",
    "content": "Full path: exa.common.qcm_data Subpackages and modules chad_model Pydantic models for CHAD. chip_topology Chip topology class for parsing CHAD and other QPU related data into human-usable form. file_adapter  immutable_base_model  qcm_data_client QCM (Quantum Computer Management) Data API client implementation. previous InfoFilter next chad_model \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "Launcher",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.Launcher.html",
    "description": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form...",
    "content": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. pin  function  name  connections  Methods name ( str ) \u2013 connections ( tuple [ str , ... ] ) \u2013 pin ( str ) \u2013 function ( str ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous Coupler next ProbeLine \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "base_model",
    "url": "/iqm-exa-common/api/exa.common.data.base_model.html",
    "description": "Full path: exa.common.data.base_model Classes BaseModel Pydantic base model to change the behaviour of pydantic globally. Inheritance previous data next BaseModel \u00a9 Copyright 2019-2025, IQM Finland Oy...",
    "content": "Full path: exa.common.data.base_model Classes BaseModel Pydantic base model to change the behaviour of pydantic globally. Inheritance previous data next BaseModel \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.exa_error.EmptyComponentListError",
    "url": "/iqm-exa-common/api/exa.common.errors.exa_error.EmptyComponentListError.html",
    "description": "Error raised when an empty list is given as components for running an experiment. message ( str ) \u2013 previous exa_error next exa.common.errors.exa_error.ExaError \u00a9 Copyright 2019-2025, IQM Finland Oy, ...",
    "content": "Error raised when an empty list is given as components for running an experiment. message ( str ) \u2013 previous exa_error next exa.common.errors.exa_error.ExaError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "server_errors",
    "url": "/iqm-exa-common/api/exa.common.errors.server_errors.html",
    "description": "Errors used in the client-server communication. Full path: exa.common.errors.server_errors Exceptions BadRequestError (message,\u00a0*args) Error raised when the request syntax is invalid or the method is ...",
    "content": "Errors used in the client-server communication. Full path: exa.common.errors.server_errors Exceptions BadRequestError (message,\u00a0*args) Error raised when the request syntax is invalid or the method is unsupported in general. ConflictError (message,\u00a0*args) This error happens when there is a conflict with the current state of the resource. ForbiddenError (message,\u00a0*args) Error raised when the operation is forbidden for the user. InternalServerError (message,\u00a0*args) Error raised when an unexpected error happened on the server side. NotFoundError (message,\u00a0*args) Error raised when nothing was found with the given parameters. ServiceUnavailableError (message,\u00a0*args) Error raised when the service is unavailable. StationControlError (message,\u00a0*args) Base class for station control errors used in client-server communication. UnauthorizedError (message,\u00a0*args) Error raised when the user is not authorized. ValidationError (message,\u00a0*args) Error raised when something is unprocessable in general, for example if the input value is not acceptable. previous exa.common.errors.exa_error.UnknownSettingError next exa.common.errors.server_errors.BadRequestError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.qcm_data.chip_topology.sort_components",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chip_topology.sort_components.html",
    "description": "Sort the given components in a human-readable way. components ( Iterable [ str ] ) \u2013 list [ str ] previous chip_topology next exa.common.qcm_data.chip_topology.sort_couplers \u00a9 Copyright 2019-2025, IQM...",
    "content": "Sort the given components in a human-readable way. components ( Iterable [ str ] ) \u2013 list [ str ] previous chip_topology next exa.common.qcm_data.chip_topology.sort_couplers \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.helpers.deprecation.format_deprecated",
    "url": "/iqm-exa-common/api/exa.common.helpers.deprecation.format_deprecated.html",
    "description": "old ( str ) \u2013 new ( str | None ) \u2013 since ( str ) \u2013 LiteralString previous deprecation next software_version_helper \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15....",
    "content": "old ( str ) \u2013 new ( str | None ) \u2013 since ( str ) \u2013 LiteralString previous deprecation next software_version_helper \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "control",
    "url": "/iqm-exa-common/api/exa.common.control.html",
    "description": "Common data structures of abstract instrument control. Full path: exa.common.control Subpackages and modules sweep Classes for sweep specification. previous api next sweep \u00a9 Copyright 2019-2025, IQM F...",
    "content": "Common data structures of abstract instrument control. Full path: exa.common.control Subpackages and modules sweep Classes for sweep specification. previous api next sweep \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.helpers.software_version_helper.get_all_software_versions",
    "url": "/iqm-exa-common/api/exa.common.helpers.software_version_helper.get_all_software_versions.html",
    "description": "Get all available software version information. Currently, this function collects all Python package versions and Python interpreter version. reload_module ( bool ) \u2013 Whether to reload the pkg_resourc...",
    "content": "Get all available software version information. Currently, this function collects all Python package versions and Python interpreter version. reload_module ( bool ) \u2013 Whether to reload the pkg_resources module or not. By default,\nit is disabled because reloading the module is not thread safe!\nThis function should be called with reload_module=True when IPython autoreload is in use. dict [ str , str ] Example You have numpy==1.21.0 installed, and in the notebook you have executed the following IPython magic: You install numpy==1.21.1 You call this function with reload_module=False . This will result in some warning printouts and\nthe function will succeed by returning 1.21.0 for numpy, which is wrong because in reality IPython\nautoreload has reloaded the newly installed numpy 1.21.1.\nWith reload_module=True the correct version 1.21.1 is returned and no warnings are printed. information. A package\u2019s version information contains the base version, and the string\n\u201c(local editable)\u201d in the case the package is a local editable installation. previous software_version_helper next exa.common.helpers.software_version_helper.get_vcs_description \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.server_errors.ConflictError",
    "url": "/iqm-exa-common/api/exa.common.errors.server_errors.ConflictError.html",
    "description": "This error happens when there is a conflict with the current state of the resource. For example, when doing duplicate submissions for the same unique data. message ( str ) \u2013 previous exa.common.errors...",
    "content": "This error happens when there is a conflict with the current state of the resource. For example, when doing duplicate submissions for the same unique data. message ( str ) \u2013 previous exa.common.errors.server_errors.BadRequestError next exa.common.errors.server_errors.ForbiddenError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "api",
    "url": "/iqm-exa-common/api/exa.common.api.html",
    "description": "API helpers. Full path: exa.common.api Subpackages and modules previous common next control \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15....",
    "content": "API helpers. Full path: exa.common.api Subpackages and modules previous common next control \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "deprecation",
    "url": "/iqm-exa-common/api/exa.common.helpers.deprecation.html",
    "description": "Full path: exa.common.helpers.deprecation Functions format_deprecated (old,\u00a0new,\u00a0since)  previous helpers next exa.common.helpers.deprecation.format_deprecated \u00a9 Copyright 2019-2025, IQM Finland Oy, R...",
    "content": "Full path: exa.common.helpers.deprecation Functions format_deprecated (old,\u00a0new,\u00a0since)  previous helpers next exa.common.helpers.deprecation.format_deprecated \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "Component",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.Component.html",
    "description": "Bases: ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidate...",
    "content": "Bases: ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name  connections  Methods sort  name ( str ) \u2013 connections ( tuple [ str , ... ] ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous CHAD next Components \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.server_errors.BadRequestError",
    "url": "/iqm-exa-common/api/exa.common.errors.server_errors.BadRequestError.html",
    "description": "Error raised when the request syntax is invalid or the method is unsupported in general. message ( str ) \u2013 previous server_errors next exa.common.errors.server_errors.ConflictError \u00a9 Copyright 2019-20...",
    "content": "Error raised when the request syntax is invalid or the method is unsupported in general. message ( str ) \u2013 previous server_errors next exa.common.errors.server_errors.ConflictError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.helpers.software_version_helper.get_vcs_description",
    "url": "/iqm-exa-common/api/exa.common.helpers.software_version_helper.get_vcs_description.html",
    "description": "Get Version Control System (VCS) description for the caller\u2019s current working directory. The description is used to verify if a directory is installed under VCS and whether changes to the files have\nb...",
    "content": "Get Version Control System (VCS) description for the caller\u2019s current working directory. The description is used to verify if a directory is installed under VCS and whether changes to the files have\nbeen made. First, the existence of .git directory will be checked from root_directory .\nOnly if it exists, a git command is executed in a subprocess with a timeout\nof 1 seconds as the best effort only. The path to the directory where the command will be executed. For instance when called from\nexa-experiment, it can be the exa-experiment root directory or any directory under it. If root_directory is not installed under git, None will be returned. Otherwise, the output of git describe --dirty --tags --long is returned. In case of errors in executing the command, the caught subprocess.CalledProcessError will be converted to string and returned. If the command fails or timeouts , an exception will be raised directly from subprocess.check_output. \u2013 root_directory ( str ) \u2013 str | None previous exa.common.helpers.software_version_helper.get_all_software_versions next logger \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "immutable_base_model",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.immutable_base_model.html",
    "description": "Full path: exa.common.qcm_data.immutable_base_model Classes ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Inheritance previous FileAdapter next Imm...",
    "content": "Full path: exa.common.qcm_data.immutable_base_model Classes ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Inheritance previous FileAdapter next ImmutableBaseModel \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "sweep",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.html",
    "description": "Classes for sweep specification. Full path: exa.common.control.sweep Subpackages and modules previous control next data \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15...",
    "content": "Classes for sweep specification. Full path: exa.common.control.sweep Subpackages and modules previous control next data \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.server_errors.ValidationError",
    "url": "/iqm-exa-common/api/exa.common.errors.server_errors.ValidationError.html",
    "description": "Error raised when something is unprocessable in general, for example if the input value is not acceptable. message ( str ) \u2013 previous exa.common.errors.server_errors.UnauthorizedError next helpers \u00a9 C...",
    "content": "Error raised when something is unprocessable in general, for example if the input value is not acceptable. message ( str ) \u2013 previous exa.common.errors.server_errors.UnauthorizedError next helpers \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.exa_error.UnknownSettingError",
    "url": "/iqm-exa-common/api/exa.common.errors.exa_error.UnknownSettingError.html",
    "description": "This SettingNode does not have a given key. message ( str ) \u2013 previous exa.common.errors.exa_error.InvalidSweepOptionsTypeError next server_errors \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13....",
    "content": "This SettingNode does not have a given key. message ( str ) \u2013 previous exa.common.errors.exa_error.InvalidSweepOptionsTypeError next server_errors \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "BaseModel",
    "url": "/iqm-exa-common/api/exa.common.data.base_model.BaseModel.html",
    "description": "Bases: BaseModel Pydantic base model to change the behaviour of pydantic globally.\nNote that setting model_config in child classes will merge the configs rather than override this one. https://docs.py...",
    "content": "Bases: BaseModel Pydantic base model to change the behaviour of pydantic globally.\nNote that setting model_config in child classes will merge the configs rather than override this one. https://docs.pydantic.dev/latest/concepts/config/#change-behaviour-globally Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.data.base_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Methods copy Returns a copy of the model. model_copy Returns a copy of the model. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Returns a copy of the model. Overrides the Pydantic default \u2018model_copy\u2019 to set \u2018deep=True\u2019 by default. update ( dict [ str , Any ] | None ) \u2013 deep ( bool ) \u2013 Self Returns a copy of the model. Self previous base_model next errors \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "ProbeLine",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.ProbeLine.html",
    "description": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form...",
    "content": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name  connections  Methods name ( str ) \u2013 connections ( tuple [ str , ... ] ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous Launcher next Qubit \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "file_adapter",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.file_adapter.html",
    "description": "Full path: exa.common.qcm_data.file_adapter Classes FileAdapter  Inheritance previous ChipTopology next FileAdapter \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15....",
    "content": "Full path: exa.common.qcm_data.file_adapter Classes FileAdapter  Inheritance previous ChipTopology next FileAdapter \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "QCMDataClient",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.qcm_data_client.QCMDataClient.html",
    "description": "Bases: object Python client for QCM (Quantum Computer Management) Data API. root_url ( str ) \u2013 URL pointing to QCM Data service.\nThis URL can point to a local file storage as well.\nIn that case, the U...",
    "content": "Bases: object Python client for QCM (Quantum Computer Management) Data API. root_url ( str ) \u2013 URL pointing to QCM Data service.\nThis URL can point to a local file storage as well.\nIn that case, the URL should point to a directory which\nhas a directory structure identical to QCM Data service (for example /chip-data-records/),\nand files containing data in identical format returned by QCM Data service.\nFor example, CHAD files should be named {chip_label}.json, like M156_W531_A09_L09.json, and contain\na list instead of a single object. fallback_root_url ( str ) \u2013 Same as root_url , used if a query via root_url returns nothing. Module: exa.common.qcm_data.qcm_data_client Attributes root_url Returns the remote QCM Data service URL. Methods get_chip_design_record Get a raw chip design record matching the given chip label. Returns the remote QCM Data service URL. Get a raw chip design record matching the given chip label. chip_label ( str ) \u2013 Chip label. Data record matching the given chip label. dict previous qcm_data_client next sweep \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.server_errors.InternalServerError",
    "url": "/iqm-exa-common/api/exa.common.errors.server_errors.InternalServerError.html",
    "description": "Error raised when an unexpected error happened on the server side. This error should never be raised when something expected happens,\nand whenever the client encounters this, it should be considered a...",
    "content": "Error raised when an unexpected error happened on the server side. This error should never be raised when something expected happens,\nand whenever the client encounters this, it should be considered as a server bug. message ( str ) \u2013 previous exa.common.errors.server_errors.ForbiddenError next exa.common.errors.server_errors.NotFoundError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "errors",
    "url": "/iqm-exa-common/api/exa.common.errors.html",
    "description": "Common error messages. Full path: exa.common.errors Subpackages and modules exa_error  server_errors Errors used in the client-server communication. previous BaseModel next exa_error \u00a9 Copyright 2019-...",
    "content": "Common error messages. Full path: exa.common.errors Subpackages and modules exa_error  server_errors Errors used in the client-server communication. previous BaseModel next exa_error \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "ExtraFormatter",
    "url": "/iqm-exa-common/api/exa.common.logger.logger.ExtraFormatter.html",
    "description": "Bases: Formatter Helper formatter class to pass in arbitrary extra information to log messages. Initialize the formatter with specified format strings. Initialize the formatter either with the specifi...",
    "content": "Bases: Formatter Helper formatter class to pass in arbitrary extra information to log messages. Initialize the formatter with specified format strings. Initialize the formatter either with the specified format string, or a\ndefault as described above. Allow for specialized date formatting with\nthe optional datefmt argument. If datefmt is omitted, you get an\nISO8601-like (or RFC 3339-like) format. Use a style parameter of \u2018%\u2019, \u2018{\u2019 or \u2018$\u2019 to specify that you want to\nuse one of %-formatting, str.format() ( {} ) formatting or string.Template formatting in your format string. Changed in version 3.2: Added the style parameter. Module: exa.common.logger.logger Attributes Methods format Format the specified record as text. extra_info_getter ( Callable [ [ ] , str ] | None ) \u2013 Format the specified record as text. The record\u2019s attribute dictionary is used as the operand to a\nstring formatting operation which yields the returned string.\nBefore formatting the dictionary, a couple of preparatory steps\nare carried out. The message attribute of the record is computed\nusing LogRecord.getMessage(). If the formatting string uses the\ntime (as determined by a call to usesTime(), formatTime() is\ncalled to format the event time. If there is exception information,\nit is formatted using formatException() and appended to the message. previous exa.common.logger.logger.init_loggers next InfoFilter \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.qcm_data.chip_topology.sort_couplers",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chip_topology.sort_couplers.html",
    "description": "Sort the given couplers in a human-readable way. couplers ( Iterable [ str ] ) \u2013 list [ str ] previous exa.common.qcm_data.chip_topology.sort_components next ChipTopology \u00a9 Copyright 2019-2025, IQM Fi...",
    "content": "Sort the given couplers in a human-readable way. couplers ( Iterable [ str ] ) \u2013 list [ str ] previous exa.common.qcm_data.chip_topology.sort_components next ChipTopology \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "ComputationalResonator",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.ComputationalResonator.html",
    "description": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form...",
    "content": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name  connections  Methods name ( str ) \u2013 connections ( tuple [ str , ... ] ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous Components next Coupler \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.server_errors.ServiceUnavailableError",
    "url": "/iqm-exa-common/api/exa.common.errors.server_errors.ServiceUnavailableError.html",
    "description": "Error raised when the service is unavailable. message ( str ) \u2013 previous exa.common.errors.server_errors.NotFoundError next exa.common.errors.server_errors.StationControlError \u00a9 Copyright 2019-2025, I...",
    "content": "Error raised when the service is unavailable. message ( str ) \u2013 previous exa.common.errors.server_errors.NotFoundError next exa.common.errors.server_errors.StationControlError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.exa_error.ExaError",
    "url": "/iqm-exa-common/api/exa.common.errors.exa_error.ExaError.html",
    "description": "Base class for exa errors. message ( str ) \u2013 Error message. previous exa.common.errors.exa_error.EmptyComponentListError next exa.common.errors.exa_error.InvalidSweepOptionsTypeError \u00a9 Copyright 2019-...",
    "content": "Base class for exa errors. message ( str ) \u2013 Error message. previous exa.common.errors.exa_error.EmptyComponentListError next exa.common.errors.exa_error.InvalidSweepOptionsTypeError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-exa-common",
    "title": "logger",
    "url": "/iqm-exa-common/api/exa.common.logger.logger.html",
    "description": "Full path: exa.common.logger.logger Functions init_loggers ([loggers,\u00a0default_level,\u00a0...]) Set the log level of given logger names. Classes ExtraFormatter Helper formatter class to pass in arbitrary e...",
    "content": "Full path: exa.common.logger.logger Functions init_loggers ([loggers,\u00a0default_level,\u00a0...]) Set the log level of given logger names. Classes ExtraFormatter Helper formatter class to pass in arbitrary extra information to log messages. InfoFilter Helper class to filter log messages above INFO level. Inheritance previous logger next exa.common.logger.logger.init_loggers \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.13. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "Import required packages",
    "url": "/iqm-pulla/Example - Randomized Benchmarking.html",
    "description": "Contact: pedro.romero@meetiqm.com & manish.thapa@meetiqm.com NB: Familiarity with quantum channels, gates and Clifford gates is assumed. The idea behind Clifford Randomized Benchmarking (CRB) is that ...",
    "content": "Contact: pedro.romero@meetiqm.com & manish.thapa@meetiqm.com NB: Familiarity with quantum channels, gates and Clifford gates is assumed. The idea behind Clifford Randomized Benchmarking (CRB) is that under certain (simplified) types of noise, the average survival probability of the initial state of a quantum system under uniformly random sequences of multi-qubit Clifford gates with sequence inversion will decay exponentially in the length of the sequences. From such decay, one can in turn infer the average fidelity of the corresponding Clifford group. CRB sequences are of the form $$\\mathcal{S} m:=\\mathcal{C} {m+1}\\circ\\mathcal{C}_m\\circ\\cdots\\circ\\mathcal{C}_1,$$ for any $m\\geq1$, where $\\mathcal{C} i(\\cdot):=C_i(\\cdot)C_i^\\dagger$ is a unitary channel with $C_i$ being a Clifford gate, and where by definition $$\\mathcal{C} {m+1}=(\\mathcal{C}_m\\circ\\cdots\\circ\\mathcal{C} 1)^{-1}.$$ It is important to notice that $C {m+1}$ is itself a Clifford gate, i.e., one would not implement the sequence $\\mathcal{C}_m\\circ\\cdots\\circ\\mathcal{C} 1$ in practice, but rather compile the corresponding unitary operator $C_mC {m-1}\\cdots{C}_1$ into a single Clifford gate. The main assumption is that the real noisy gates can be approximately modeled independently by a quantum channel $\\mathcal{E}$ (completely positive, trace non-increasing map) as $\\tilde{\\mathcal{C}}_i\\approx\\mathcal{E}\\circ\\mathcal{C}_i$, or (ultimately equivalently) as $\\tilde{\\mathcal{C}}_i\\approx\\mathcal{C}_i\\circ\\mathcal{E}$. This implies that the noise is modeled as Markovian , time-stationary and gate-independent \u2014 while here we will take these for granted, a lot about RB in more general regimes is known, but it is in general more complicated, and often this simplistic scenario goes a long way as a useful first approximation. NB: CRB is not generally intended to work for $n>2$, both because of the scaling of the size of the $n$-qubit Clifford group in $n$, and because such gates have to eventually be transpiled to a native basis of 1Q and 2Q gates! While a high level of optimization in transpile is usually desirable, one must be careful for the optimization not to mess with the Clifford gates, i.e., we want the transformations between barriers in the circuit to implement a Clifford regardless of how it is decomposed. The specific decomposition still matters, however, because the (average) number of 2Q and 1Q gates (i.e., cz and r , respectively) will dictate how noisily we can implement the Cliffords on average, i.e., the average gate fidelity we will ultimately obtain. We will not do this check here, but it is now known that a good decomposition of Clifford gates in our basis will have on average 8.25 cz gates and 1.5 r gates (e.g., see arXiv:1402.4848 ). We can count the number of native 1Q and 2Q gates by using the circuit attribute count_ops() One important reason why CRB works \u2013and why specifically it uses Clifford gates\u2013, is that the uniformly distributed multi-qubit Clifford group forms a unitary 2-design. This essentially means that any quantity that takes two copies of the pair $C, C^\\dagger$ and then averaged over all possible $C$s, will be exactly the same as if $C$ had been any uniformly distributed (so-called Haar) random unitary. This matters because there are plenty of results allowing to easily compute such quantities (i.e., second moments) over the whole uniformly distributed unitary group \u2014 in fact, such second moment simply takes the form of a depolarizing channel (RB precisely extracts the average gate fidelity through the corresponding polarization parameter). The CRB sequences are quantities of this type because of the final inverse at the end (i.e. all sequences will have 2 copies of pairs $C_i,C_i^\\dagger$ for all $i=1,2,\\ldots,m$). This is the reason why the theory behind RB, under the noise assumptions above, can ensure that the decay in average fidelity, i.e., quantities like $$f_0=\\langle0|\\mathcal{S}_m(|0\\rangle!\\langle0|)|0\\rangle$$ take the form of a function $$f_0=Ap^m+B$$ for $0\\leq{A,B,p}\\leq1$. Furthermore, it ensures that $p$ will encode the average gate fidelity of the noisy Clifford gates, whilst $A,B$ will encode (and isolate) errors due to state preparation and measurement. This is what is meant by RB being SPAM-robust. In the modeling with assummptions of noisy gates above, this means $p\\sim\\int{d}\\psi\\langle\\psi|\\mathcal{E}(|\\psi\\rangle!\\langle\\psi|)|\\psi\\rangle$ for all possible uniformly distributed pure states $|\\psi\\rangle$, and $A\\sim\\langle0|\\mathcal{E} \\text{spam}(|0\\rangle!\\langle0|)|0\\rangle$, $B\\sim\\langle0|\\mathcal{E} \\text{spam}(\\mathbb{I}/2^n)|0\\rangle$ for a composition of the state preparation and measurement noise. We may now fix a number of circuit samples and sequence lengths. Despite the Clifford group having a (super) exponential amount of terms (e.g., 24 for 1Q, then 11,520 for 2Q), approximating the average over the whole group with finite samples quickly converges to the Haar average. On the other hand, the sequence lengths can be chosen as exponentially spaced and aiming at long sequences, if possible, serves to better determine the offset constant (often named the nuisance parameter, for obvious reasons) in the decay. Depending on how many circuits we want to execute, we could either generate all circuit samples for all circuit lengths and send all for execution once, or we may, for example, generate a given amount of circuits, send them to execution while meanwhile continuing to generate circuits and sending them. In either case, one may retrieve the results later. Here we will generate all circuits for all sequence lengths, and send them to execute as a single batch on the backend. It is generally a good idea to store (at least at this stage) both the abstract and the transpiled circuits, so that we can inspect them later on. We can inspect the circuits just as a sanity check Task : Count the average number of 1Q and 2Q gates in the circuits for each sequence length. Task : Since the Clifford group is a 2-design, its so-called frame potential (see e.g., arXiv:1610.04903 ) has to satisfy $\\displaystyle{\\sum_{k,,k^\\prime=1}^K}\\left|\\mathrm{tr}\\left(C_{k^\\prime}^{\\dagger}C_k\\right)\\right|^4/K^2 = 2$. Verify this condition for the 1Q Clifford group. warning for the 2Q Clifford group: there are in total $n=11,520^2 = 132,710,400$ values in the sum! It suffices to compute the values in a triangular part of the matrix $U_{k^\\prime}^{\\dagger}U_k$  \u2014 so you can definitely verify this property, however there will still be $n(n-1)/2$ such terms for your computer to sum up! We can now send the transpiled circuits to be run on the hardware. NB: It is generally preferable to use backend.run instead of execute command, since the latter performs a transpilation pass \u201cunder the hood\u201d. We can now inspect the results for a given sequence length (we will use the one defined above). The counts at the ground state relate to the survival probability (or state fidelity) of such state under our random Clifford circuits. Task : Compare the histograms between the outcomes for the narrowest and the deepest circuits NB: You can wrap plot_histogram() with display(*) to show both results in one cell By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "IQM Pulla",
    "url": "/iqm-pulla/readme.html",
    "description": "Pulla (pulse-level access) is a client-side software which allows the user to control the generation and\nexecution of pulse schedules on a quantum computer. Within the existing IQM QCCSW stack, PulLA ...",
    "content": "Pulla (pulse-level access) is a client-side software which allows the user to control the generation and\nexecution of pulse schedules on a quantum computer. Within the existing IQM QCCSW stack, PulLA is somewhere between\ncircuit-level execution and EXA-experiment. An interactive user guide is available as a Jupyter notebook in the docs folder. Create a virtual environment and install dependencies: The [qiskit] option is to enable Qiskit-related features and utilities, like converting Qiskit circuits to Pulla circuits, constructing a compatible compiler instance, or constructing a PullaBackend for running Qiskit jobs. The [qir] option is to enable QIR support, e.g. the qir_to_pulla function. The [notebook] option is to be able to run the example notebooks, using\nand run it in Jupyter Notebook: Install development and testing dependencies: e2e testing is execution of all user guides (Jupyter notebooks). User guides cover the majority of user-level features,\nso we achieve two things: end-to-end-test Pulla as a client library, and make sure the user guides are correct.\n(Server-side use of Pulla is e2e-tested as part of CoCoS.) You have to provide CoCoS and Station Control URLs as environment variables: Notebooks are executed using jupyter execute command. It does not print any output if there are no errors. If you want\nto run a particular notebook and see the output cells printed in the terminal, you can use nbconvert with jq ( https://jqlang.github.io/jq/download/ ) like so: Run unit tests, build docs, build package: Copyright 2025 IQM Licensed under the Apache License, Version 2.0 (the \u201cLicense\u201d);\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \u201cAS IS\u201d BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. previous IQM Pulla next Migration guide By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "IQM Pulla",
    "url": "/iqm-pulla/index.html",
    "description": "7.11 2025-04-15 Client-side library for Pulse-level access to IQM quantum computers. Index Module Index Search Page next IQM Pulla By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Releas...",
    "content": "7.11 2025-04-15 Client-side library for Pulse-level access to IQM quantum computers. Index Module Index Search Page next IQM Pulla By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "Configuration and Usage",
    "url": "/iqm-pulla/Configuration and Usage.html",
    "description": "This notebook describes the basic concepts and configuration of Pulla. Now let\u2019s create a Pulla object. A Pulla object is conceptually an IQM quantum computer client for fetching calibration data and ...",
    "content": "This notebook describes the basic concepts and configuration of Pulla. Now let\u2019s create a Pulla object. A Pulla object is conceptually an IQM quantum computer client for fetching calibration data and constructing a circuit-to-pulse compiler. . It consists of: methods for fetching calibration sets from the server methods for fetching metadata about the QC from the server method for executing pulse-level instruction schedules (e.g. ones created by the compiler) A Compiler object defines a particular circuit-to-pulse compilation logic . It consists of: single calibration set schedule builder based on the calibration set circuit compilation options information about the QC (chip topology, channel properties, etc.) compilation stages set of available circuit-level quantum operations (\u201cnative operations\u201d) (including user-defined operations) set of implementations for each native operation (including user-defined implementations) methods for manipulating the calibration, operations, and implementations Pulla can construct a standard compiler equivalent to the one used by the server side (CoCoS). You can also construct a Compiler manually. To create an instance of Pulla, you need to provide the URL of Station Control. Upon successful initialization, some configuration data is printed (the verbosity of such messages will be controlled by a debug level value). You can access various things like channel properties of the connected station, chip topology, or the current calibration. The initial calibration is the latest calibration of the connected station. Call get_standard_compiler() method to get an instance of Compiler . It will be pre-populated with the latest default calibration set and standard compilation stages. This standard compiler is the same one that CoCoS uses on the server side when processing circuits. get_standard_compiler() fetches the latest calibration set from the server. This network request takes a few moments. You may want to create many Compiler instances without such delay. It may also be possible that, due to human error, the latest calibration set stored on the server is invalid (or incompatible with your version of Pulla or IQM Pulse). In that case get_standard_compiler() will fail. To avoid this, you can pass the calibration set manually, and Pulla will construct the compiler with it instead of getting one from the server. If you want to reuse the calibration of an existing compiler, call Compiler.get_calibration() , e.g.: You can also get a specific calibration set from the server if you know its UUID by calling Pulla.fetch_calibration_set_by_id() , e.g.: The compiler initializes with the following default configuration options: circuit_boundary_mode='all' measurement_mode='all' heralding_mode='none' dd_mode='none' You can change them by changing the corresponding attributes of compiler.options . For the constant implementation of the measure operation, the readout type is controlled by the acquisition_type parameter. By default, it\u2019s set to \"threshold\" . Let\u2019s change it to \"complex\" . The full key in the calibration set dictionary is gates.measure.constant.QUBIT.acquisition_type , where QUBIT is the physical qubit name. Note that we call get_calibration() to get a copy of the compiler\u2019s current calibration set, make changes to the copy, then replace the compiler\u2019s set with the copy. The compiler always contains a single calibration set only. previous Quick Start next Compilation Stages By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "Examples",
    "url": "/iqm-pulla/examples.html",
    "description": "previous Custom Gates and Gate Implementations next Example: Measuring T1 By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15....",
    "content": "previous Custom Gates and Gate Implementations next Example: Measuring T1 By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "References",
    "url": "/iqm-pulla/references.html",
    "description": "Nic Ezzell, Bibek Pokharel, Lina Tewala, Gregory Quiroz, and Daniel\u00a0A. Lidar. Dynamical decoupling for superconducting qubits: a performance survey. Phys. Rev. Appl. , 20:064027, Dec 2023. arXiv:2207....",
    "content": "Nic Ezzell, Bibek Pokharel, Lina Tewala, Gregory Quiroz, and Daniel\u00a0A. Lidar. Dynamical decoupling for superconducting qubits: a performance survey. Phys. Rev. Appl. , 20:064027, Dec 2023. arXiv:2207.03670 , doi:10.1103/PhysRevApplied.20.064027 . previous License By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "Custom Gates and Gate Implementations",
    "url": "/iqm-pulla/Custom Gates and Implementations.html",
    "description": "This notebook demonstrates how to work with user-defined quantum operations and gate implementations that go beyond the standard gate set. Each quantum operation is associated with one or more GateImp...",
    "content": "This notebook demonstrates how to work with user-defined quantum operations and gate implementations that go beyond the standard gate set. Each quantum operation is associated with one or more GateImplementation s which translate the high-level concepts to lower-level instructions accepted by the IQM server. This example shows how the user can Selecting a non-default implementation for a gate Add a custom implementation for an existing gate Add a custom gate and a custom implementation for it by using existing gates as building blocks (composite gates) Defining new pulse waveforms for implementations Please refer to the User Guide.ipynb for basic usage, termninology, and environment setup. Circuits are usually defined without specifying implementations for any of the gates.\nThe implementations available in a given calibration set are listed in the corresponding dynamic quantum architecture, through Cocos. Let\u2019s see a list of available implementations, with their parameters: You can specify a default implementation for each native operation type in the circuit, and then override it for specific loci.\nLet\u2019s change all cz gates to use the slepian implementation, and make an execption for the qubit pair (QB1, QB2) . Note that the default implementations are merely suggestions to the compiler. If the compiler does not have calibration data for a default implementation, it will ignore it and use what it can. If you executed the cell below, you would get an error if the requested implementation 'drag_gaussian' does not have calibration data. You can also force the compiler to use a specific implementation for each circuit instruction separately in the IQM Pulse native format, which describes a circuit as a list of CircuitOperation instances. IQM Pulse allows the user to define composite gates: gates consisting of other registered gates.\nComposite gates are particularly useful because they allow reusing the calibrated of data of the other gates.\nFurthermore, it is possible to use different calibration data for the registered gates inside a composite gate than outside it. Let\u2019s define a prx implementation that acts like a normal prx , except it implements x with 2 pulses with a 100 ns wait between them.\nThe __call__ method produces a TimeBox using IQM Pulse\u2019s ScheduleBuilder.\nIt\u2019s worth mentioning that the composite gate is not restricted to using only registered gates; it could equally well return a TimeBox with lower level instructions. Now we register a new gate custom_x , which StretchedX implements. We want to make it compatible with the circuit-level prx , so we declare that it has the same parameters.\nThen we change the fist prx in the IQM Pulse circuit to use our new implementation. Inspecting the schedule, we can see that the X gate in the circuit is indeed split into two pulses with a wait in between: Finally, let\u2019s change the pulse waveforms of an existing gate. The tricky part of this is that we need to provide the calibration data by hand.\nIQM Pulse provides several \u201cgate with custom waveforms\u201d base classes so that users need only write the waveforms. Let\u2019s define a new implementation of PRX using a raised cosine pulse: The class attributes of the waveforms define the calibration data they require. The PRX_CustomWaveforms class adds some more. We can add the new prx implementation to the compiler, and check what calibration data it needs: Let us then make one of the prx gates in the circuit use our new implementation: Compiling this circuit right now would fail with an error: (The locus (\u2018QB1\u2019,) may differ in your output due to the stochastic nature of routing.) The point is that the compiler does not have necessary calibration data for this new implementation. One way to fix this is to amend the current calibration. The numbers here are arbitrary, in reality you would need to calibrate the gate parameters somehow. Data with gates.prx.raised_cosine.* is now visible in compiler.get_calibration() . Note that we added the same calibration data to all qubits. In practice, this rarely makes sense, because each qubit\nis usually calibrated differently. Now the compilation succeeds and we see that raised_cosine was used once. Using the schedule visualization you could also verify that the pulse shape is indeed different on the first prx instance. previous Compilation Stages next Examples By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "Example: Dynamical decoupling",
    "url": "/iqm-pulla/Example - Simple Dynamical Decoupling.html",
    "description": "There is a standard compilation stage for automatically applying dynamical decoupling (DD) sequences to an instruction schedule,\ncontrolled by the dd_mode compiler option. By default the DD stage is d...",
    "content": "There is a standard compilation stage for automatically applying dynamical decoupling (DD) sequences to an instruction schedule,\ncontrolled by the dd_mode compiler option. By default the DD stage is disabled. The iqm.cpc.compiler.dd module contains various utility functions the DD stage uses, e.g. for locating specific instructions in a schedule, constructing DD sequences, and replacing select instructions with them. For example, we can find locations of Wait instructions on qubit drive channels with a certain minimum duration, and replace them with an arbitrary sequence of Wait and IQPulse instructions that dynamically decouples the qubit, given that the total duration of the sequence is the same as the duration of the original Wait . Let\u2019s create and transpile a quantum circuit that prepares a superposition on one qubit, and then executes a long sequence of gates on other qubits while the first qubit is idling and experiencing decoherence. Finally we reverse the superposition and measure the qubits. Now let us create a pair of Pulla compilers, one with DD and one without. Compiling the circuit using the non-DD compiler produces a schedule with a long wait on QB1__drive.awg. We then execute this schedule and compute the probability of finding QB1 in the |0> state. Ideally this should be one, but due to the decoherence experienced by the superposition state it will be less. Compiling the circuit using the DD compiler instead produces a schedule where the long wait on QB1__drive.awg is replaced by a DD sequence. We execute the DD schedule and again compute the probability of finding QB1 in the |0> state, and will likely see that the probability has gone up, due to the DD sequence partially decoupling the idling QB1 from various decoherence sources and better preserving the superposition state. We can see that the long wait on QB1__drive.awg was indeed replaced by a DD sequence. previous Example: Measuring T1 next Executing QIR programs By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "Compilation Stages",
    "url": "/iqm-pulla/Compilation Stages.html",
    "description": "The generic lifecycle of a Pulla job is a one-way multi-step transformation. The states are as follow: Quantum Circuit in a specific format (e.g. Qiskit, Cirq) Equivalent Quantum Circuit in an IQM Pul...",
    "content": "The generic lifecycle of a Pulla job is a one-way multi-step transformation. The states are as follow: Quantum Circuit in a specific format (e.g. Qiskit, Cirq) Equivalent Quantum Circuit in an IQM Pulse format (list of CircuitOperations) IQM Pulse nested Timebox representation IQM Pulse Schedule representation Measurement results You don\u2019t have to start with a circuit, you can define quantum operations directly (roughly starting from state 2), or define pulse shapes directly (roughly starting from state 3 or 4). The compilation which produces states 3 and 4 is itself multi-step: it consists of multiple stages, and each stage of one or more passes. Let\u2019s go over the generic use case, starting from creating a Qiskit circuit to work on: Pulla has utility functions which accept circuits in different formats (Qiskit, Cirq, IQM JSON) and convert them into Pulla/IQM Pulse format, which is a list of CircuitOperation objects. Let\u2019s do that. Note that none of the operations have an implementation specified ( implementation=None ). The Qiskit conversion utility also gives us a standard compiler with the same calibration set as the one used by backend , in this case the current default one. In order to understand how the compilation stages work, let\u2019s remove the standard stages from the compiler: You can check the readiness of the compiler by calling compiler.ready() . Right now it would return False due to empty stages list. The compiler flow consists of one or more stages, and each stage consists of one or more passes. When the compiler is initialized created by Pulla, it is pre-populated with standard stages. You can define your own stages, with your own passes, grouping them in some meaningful way. Each pass is a function which accepts two arguments: data and context. Data is an iterable of objects of an applicable data type, and context is a dictionary of any additional information. Each pass can transform the data and modify the context, and must return both data and context. This convention allows the compiler to pipe arbitrary amount of passes. A stage is just an ordered collection of passes. The compiler has methods run_stage() and run_pass() allowing you to run particular stages or passes. The compile() method is just calling run_stage() in correct order and passes its initial context to the first pass of the first stage. Let\u2019s write a simple compilation stage to illustrate the concept: Now let\u2019s write two simple passes for that stage. For the first: perhaps we want to add a leading barrier to each circuit. add_leading_barrier below determines the locations of qubits used in the circuit and adds a barrier on those qubits as the first instruction. Note that the function takes data and context and returns data and context. It happens to neither use nor modify the context, but it should still provide it down to the next passes. Ok, let\u2019s define another pass: this one would increase the phase of each prx operation by 0.25 . This may or may\nnot make practical sense, but bear with us for the purposes of illustration: Now let\u2019s add those two passes to our stage, then replace the empty stages property of the compiler with a list consisting of our single stage, and then call show_stages() : The boolean flag full of show_stages() is optional; when True , the doc strings of each pass are printed on the screen. Now that the compiler is ready and we can run compile . The compiler always operates on batches of circuits, so you need to provide an iterable; in our case, it\u2019s a list with a single circuit. Note that it did not really compile the circuits into pulse schedules, because the only passes we\u2019ve defined only modify the circuits, but don\u2019t perform the conversion to pulse schedules. The compilation to pulse schedules usually consists of converting circuits to TimeBox es, then resolving TimeBox es into a single TimeBox , then resolving it into a Schedule , and finally converting a Schedule into a final Schedule ready to be submitted to the server. There might be cases when your compilation stages need additional data. You can provide such data as a custom context dictionary. Get the initial compiler context and modify it, then pass it when calling compile . As mentioned earlier, Pulla comes with a pre-defined \u201cstandard\u201d set of stages which you can use and, if needed, modify. These standard stages are used by CoCoS if you were to submit a circuit to CoCoS (without using Pulla). Thus, if you use the same version of the Pulla library that the remote CoCoS uses, you will be able to produce and inspect the same pulse schedules that CoCoS would (assuming you use the same calibration set). Let\u2019s replace our current single stage with standard stages, and view them: There are 7 standard stages: circuit-level: takes care of validating the circuit, renaming some deprecated names, gathering\ninformation for the next stages circuit resolution: converts circuits to TimeBox es timebox-level: optimizes \u201cmeasure\u201d gates by multiplexing them if possible timebox resolution: converts TimeBox es to Schedule schedule-level: applies dynamical decoupling schedule-level: potentially applies some corrections, then cleans up the schedules schedule resolution: converts Schedule to the final Playlist ready to be executed Variable data now contains the Playlist in its final form, and context contains a dictionary of various things\nwhich were either necessary in some of the passes, or will be necessary for the final execution. It also contains a\ncopy of schedules from before the final playlist resolution. Some of those pieces of data will be needed to build\nStation  Control settings (more on that later). Instead of calling compile() , which runs all the stages, you can run each stage, or even each separate pass, by yourself. In that case you will have to take care of two things: Provide initial context to the first pass of the first stage. Save data and context returned by each pass (or stage) in order to provide it to the next pass (or stage). To help you with 1, the compiler has a method compiler_context() which returns a dictionary of initial context. (Note: to run a pass of any particular stage: compiler.stages[0].passes[0](data, context) ) Let\u2019s create another circuit and compile it manually. We\u2019ll use this example to understand each standard stage: The first stage is circuit-level passes: When defining a circuit in IQM JSON or IQM Pulse format directly, you can specify an implementation for each gate (selecting from implementations provided by the calibration set). If no implementation is specified, the standard circuit-level stage will select the default implementation for each gate automatically. Currently, the choice of the default implementation is global: e.g. prx may have drag_gaussian as the default. In the future, the calibration may yield different implementations for different loci, striving to provide the best quality. Now we can convert the circuit to TimeBox es. TimeBox is a concept of IQM Pulse: a container for one or more instruction schedule fragments, to be scheduled according to a given scheduling strategy. timeboxes is a list of TimeBox objects, and you can edit them manually. A TimeBox can contain multiple children TimeBox es, each containing either more TimeBox es or a Schedule . A TimeBox containing a Schedule rather than children is referred to as \u201catomic\u201d. In our example here the circuit was converted into one TimeBox containing 11 children atomic TimeBox es, which correspond to 11 circuit operations (7 gates + 1 barrier gate + 3 measurement gates). An atomic TimeBox holds its Schedule in an atom property: Next is a timebox-level stage, which only has one pass: multiplexing measurements. The measure_all() we called when\ncreating the circuit adds a single TimeBox with the gate implementation Measure_Constant for each qubit in the\ncircuit.\nWith the measurement_mode='all' option, the first stage has also added a measurement TimeBox for the unused qubits. Multiplexing means executing all of these measurements at once, instead of one after the other.\nThe multiplexing pass does this optimization for us: If you construct a circuit in Qiskit, and want to ensure multiplexing of measurement instructions, you have to \u201cwrap\u201d a group of measurement instructions with barrier s. This would prevent the Qiskit transpiler from putting any other instructions, acting on the same qubits, in between measurements, thus allowing the compiler to multiplex. Next we convert TimeBox es into a single Schedule . This is a recursive process which resolves all nested TimeBox es into atomic TimeBox es, and finally assembles a single Schedule out each of batches of TimeBox es. At this stage, all relative timings between pulses are resolved and fixed. Dynamical decoupling pulse sequences get inserted to replace Wait instructions. The process is controlled by a user-submitted dynamical decoupling strategy. By default, this stage is disabled. Please see other notebooks for examples of how to enable and apply dynamical decoupling. Next is a schedule-level stage. Its first pass applies calibrated phase corrections if MOVE gates are used (only applicable to QCs with computational resonator, i.e. IQM Star Architecture). The second pass removes non-functional instructions from the schedules. Finally, the last stage builds a final schedule from a number of instruction schedules. A playlist is just a compressed Schedule with no duplicate information, ready to be submitted for execution. In order to submit this final schedule for execution, we have to do one more thing: build the Station Control settings. The settings control the behaviour of instruments. At this point everything is ready to be submitted for execution to the server. Namely, these three objects will be used to construct a request to Station Control Service: playlist : sequence of instruction schedules corresponding to the batch of circuits to be executed settings : Station Control settings node context['readout_mappings'] : a mapping from measurement keys to the names of readout controller acquisition labels that will hold the measurement results Now we can convert these raw results into a Qiskit Result object: We can also submit the same circuit to CoCoS for execution. CoCoS is essentially a server-side Pulla with fixed standard stages. Since we started with a normal Qiskit backend and a circuit, execution is as simple as: previous Configuration and Usage next Custom Gates and Gate Implementations By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "Common errors",
    "url": "/iqm-pulla/common_errors.html",
    "description": "This document describes some common errors which you may encounter when using Pulla, and ways to fix them. If you have modified any timing aspect of the schedule, you may encounter an error like this:...",
    "content": "This document describes some common errors which you may encounter when using Pulla, and ways to fix them. If you have modified any timing aspect of the schedule, you may encounter an error like this: The granularity is an instrument limitation. Specifically, the part (e.g. HDAWG) which plays the drive pulses.\nSome instrument may use e.g. a sample rate of 2.4 GHz, and each instruction duration must be an integer multiple of 16\nsamples. Instructions therefore must be a multiple of 6.666ns (16 / 2.4 GHz).\nDurations that are within 0.005 samples of an allowed number of samples are rounded to that\n(the software assumes it is what the user meant), otherwise an error is raised. Different stations have different instruments.\nIQM instruments use a fixed sample rate of 2 GHz, and have a granularity of 8 samples. You can view the granularity information in channel properties, for example Pulla.get_channel_properties()[0]['QB1__drive.awg'] : If you were to turn off the error and use an instruction with a duration that does not fit the granularity, it would\njust silently be extended to the next longest allowed granularity, and would not do what you expect. previous iqm.pulla.utils_dd.generate_phases_of_urn_sequence next Changelog By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "Executing QIR programs",
    "url": "/iqm-pulla/Example - Executing QIR programs.html",
    "description": "If you have a QIR string or bitcode, you can start by creating Pulla-compatible circuits representation. You can also generate a QIR string or bitcode from a qiskit circuit using IQM\u2019s fork of qiskit_...",
    "content": "If you have a QIR string or bitcode, you can start by creating Pulla-compatible circuits representation. You can also generate a QIR string or bitcode from a qiskit circuit using IQM\u2019s fork of qiskit_qir , available as the package iqm-qiskit-qir . previous Example: Dynamical decoupling next API Reference By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "Migration guide",
    "url": "/iqm-pulla/migration_guide.html",
    "description": "This document describes the changes that need to be made to existing code to migrate between major versions of Pulla. The changes in 4.0 are not truly breaking, as your code should still run. However,...",
    "content": "This document describes the changes that need to be made to existing code to migrate between major versions of Pulla. The changes in 4.0 are not truly breaking, as your code should still run. However, there are some changes that\nmight affect the compilation results, and you might want to adjust your code accordingly: New compilation pass prepend_reset added to the (TimeBox-level) standard compiler stage. It adds a reset timebox\nto all circuits. It is the last pass of the TimeBox-level stage. If the calibration lacks reset_wait data, the prepend_reset will have no effect. Optional attribute :attr: .CircuitExecutionOptions.active_reset_cycles added to CircuitExecutionOptions ,\nthat is used to control the reset functionality. By default, it is set to None , which results in delay by wait. :meth`.Pulla.get_standard_compiler` now has an optional argument for overriding default circuit execution options. The function iqm.pulla.utils_qiskit.qiskit_to_cpc was replaced by iqm.pulla.utils_qiskit.qiskit_circuits_to_pulla() and iqm.pulla.utils_qiskit.qiskit_to_pulla() . qiskit_circuits_to_pulla() is a more direct replacement, with the difference that it also requires a\nmapping of qiskit qubit indices to physical qubit names which was not required before.\nThis can be e.g. obtained from an iqm.qiskit_iqm.iqm_provider.IQMBackend instance. qiskit_to_pulla() is a convenience method that in addition to\nconverting the Qiskit circuit(s) also returns a Compiler instance that can be used to compile them\ninto a playlist. It takes as additional parameters a Pulla instance (for building the compiler),\nand an IQMBackend instance (containing the calibration set ID and\nqubit mapping to use). The IQMBackend instance should usually be the same one that was used to transpile\nthe Qiskit circuits. Compiler code is consolidated under the iqm.cpc.compiler.compiler module.\nThere is no more iqm.cpc.compiler.compiler2 . Compiler , CompilationStage are now under iqm.cpc.compiler.compiler . Pulla no longer needs CoCoS URL: Compiler initialization now requires all arguments to be keyword arguments. Pulla no longer retrieves qubit mapping from CoCoS. If your circuit uses same qubits names as physical qubits\n(e.g. QB1 , QB2 , etc.), then you don\u2019t have to do anything. If your circuit uses other qubit names, then you have to\nprovide component_mapping to the Compiler like so: If you use Qiskit, the mapping can be generated with {str(idx): qb for idx, qb in backend._idx_to_qb.items()} . .Compiler.set_default_implementation_for_locus changed to Compiler.set_default_implementation_for_loci() : Compiler.amend_calibration_for_gate_implementation() now accepts a Locus (a tuple of strings)\ninstead of string qubit name, so you can apply the change to multiple loci in a single call: iqm.pulla.utils.qiskit_to_cpc() and iqm.pulla.station_control_result_to_qiskit() , previously marked for\ndeprecation in v. 1.0, are now removed. Use iqm.pulla.utils_qiskit.qiskit_to_cpc() and iqm.pulla.utils_qiskit.station_control_result_to_qiskit() , respectively. The main change in 1.0 is the splitting of Pulla and Compiler , and the move of some compiler-related methods to\nthe more appropriate Compiler class. The Pulla class now only contains methods to retrieve calibration data,\nconstruct a standard compiler instance, and submit pulse schedules to the server. Setting default implementation is now done in the compiler directly, and there is no need to manually refresh the\ncompiler anymore. Same goes for adding implementations, and amending the calibration set with custom data for custom implementations: The calibration is now stored solely in the compiler instance, and can be retrieved using Compiler.get_calibration() : Fetching calibration sets from the server is still done via Pulla.fetch_latest_calibration_set() and Pulla.fetch_calibration_set_by_id() . Standard compilation stages are now available via get_standard_stages() . This ensures the immutability of\nbuilt-in standard stages. previous IQM Pulla next User guides By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "API Reference",
    "url": "/iqm-pulla/API.html",
    "description": "iqm.cpc IQM Circuit to Pulse Compiler. iqm.pulla Client-side library for Pulse-level access to IQM quantum computers. previous Executing QIR programs next iqm.cpc By IQM Pulla developers \u00a9 Copyright 2...",
    "content": "iqm.cpc IQM Circuit to Pulse Compiler. iqm.pulla Client-side library for Pulse-level access to IQM quantum computers. previous Executing QIR programs next iqm.cpc By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "User guides",
    "url": "/iqm-pulla/user_guides.html",
    "description": "previous Migration guide next Quick Start By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15....",
    "content": "previous Migration guide next Quick Start By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "Quick Start",
    "url": "/iqm-pulla/Quick Start.html",
    "description": "IQM PulLA is a client-side software which allows the user to control the generation and execution of pulse-level instruction schedules on a quantum computer. Within the existing IQM QCCSW stack, PulLA...",
    "content": "IQM PulLA is a client-side software which allows the user to control the generation and execution of pulse-level instruction schedules on a quantum computer. Within the existing IQM QCCSW stack, PulLA is somewhere between circuit-level execution and EXA-experiment. Namely, with pulse-level access the user can: compile a quantum circuit (e.g. a Qiskit circuit) into an instruction schedule on the client side access and modify the calibration data to be used for the circuit-to-schedule compilation view and modify the default implementations of quantum gates define custom implementations of quantum gates define new composite gates out of native gates and set their calibration data control the multi-step compilation procedure, and edit the intermediate data use custom pulse shapes This notebook contains a small meaningful example for a \u201cquick start\u201d. Refer to other chapters for more details on various aspects of Pulla. Pulla provides a Qiskit backend, with limited functionality. Its main purpose is to replace the normal execution of run() , which submits circuits to the remote server, with a local compilation and submission of pulse schedules to the remote server. IQMPullaBackend does not provide any new functionality, but rather packs existing features and actions behind an illusion of using a normal Qiskit backend. You can perform all of the actions of IQMPullaBackend manually, but you may choose to use IQMPullaBackend in these cases: You don\u2019t need to control compilation, and want to use Pulla in the same way as a remote circuit-executing IQM Server uses it. You want to run some existing apps written for Qiskit, e.g. benchmarking tools; they often build on top ot the circuit abstraction, and don\u2019t necessarily give you easy access to the circuits, which makes it harder to use Pulla normally. You don\u2019t have access to a remote circuit-executing IQM Server, only to a pulse-executing IQM Server. You don\u2019t have any remote servers at all; all of the quantum control software is running locally (relevant for niche research cases) To initialize an IQMPullaBackend instance, provide 3 arguments: Quantum architecture in QuantumArchitectureSpecification format of IQM Client Instance of Pulla Instance of Compiler When IQMPullaBackend.run() is called, the following steps are performed: Given Qiskit circuits are converted to Pulla format using qiskit_circuits_to_pulla() . Circuits are compiled with the provided compiler using Compiler.compile() . Settings are generated with the provided compiler using Compiler.build_settings() . Circuits are executed on the station associated with the provided Pulla instance. Results are retrieved and converted into a DummyJob , partially compatible with Qiskit Job . Working example below: If the remote station requires authentication: Install IQM Client CLI with pip install iqm-client[cli] Run iqmclient init . The wizard will start and ask questions. Accepting defaults is ok. Wizard will ask for Authentication server URL . Usually, it\u2019s of the form https://STATION_ROOT/auth . E.g. if the Station Control URL is \"https://abc.com/station/\" , then the auth server URL is \"https://abc.com/auth/\" Run iqmclient auth login . You should see info like so: Set the environment variable IQM_TOKENS_FILE accordingly in your Jupyter notebook and pass get_token_callback to the Pulla initialization call like so: Setting IQM_TOKENS_FILE env. variable enables authentication for CoCoS as well, so your Qiskit runs against the same station will work, too. Pulla can also be used with IQM Resonance cloud service. You need to set the station URL to point to Resonance. In addition to that, you must provide a get_token_callback parameter function that returns your Resonance API token. IQM Pulse comes with a schedule visualizer. It takes a Playlist (i.e. a compressed list of instruction schedules) and a list of schedule/segment indices to inspect.\nThe playlist variable below is the one which we derived from the original Qiskit circuit using the Pulla compiler, and it only has one schedule. previous User guides next Configuration and Usage By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "Compilation using a locally created calibration set",
    "url": "/iqm-pulla/Example - Compilation With Local Calibration Set.html",
    "description": "This notebook shows how to construct a calibration set locally and use the local calibration set for compiling circuits. The calibration itself is done using IQM\u2019s Graph Based Calibration (GBC) softwa...",
    "content": "This notebook shows how to construct a calibration set locally and use the local calibration set for compiling circuits. The calibration itself is done using IQM\u2019s Graph Based Calibration (GBC) software. In this notebook we show recalibration based on the latest calibration set. The usage of Pulla with a local calibration set works mostly the same way also for a full calibration from scratch. In that case you would just have to use a different GBC graph, and possibly manually add observations to the observation stash if it does not yet have all observations required for a valid calibration set. Using the principles shown in this notebook, it is possible to use all Pulla functionality as a helpful tool during the calibration process. NOTE: Some of the libraries used in this notebook are only available to on-premise customers and are not currently available publicly. First we prepare a Pulla object, a qiskit-iqm backend, and a circuit as explained in Quick Start.ipynb . Let\u2019s also define a function that compiles and runs the above circuit using the given compiler state. This function will be used to compile and execute the circuit at different points of the calibration process: First we compile and execute the circuit using the compiler obtained above, which uses the current default calibration set on the server. The results of this execution can then be compared to the results after performing (parts of) the recalibration process. Now we will start recalibration using GBC. We need a CalibrationSetWrapper instance for handling calibration sets and a Calibrator for running the calibration: To start with, we run the first node that runs any actual calibration experiments: Then we can create a local calibration set based on the results of the above calibration node, and update the compiler to use this calibration set. We compile and execute a circuit using the updated compiler to see how our updates to the calibration set affect the results. Because many observations of the updated calibration set don\u2019t yet take into account the results of the executed node, the results could even be worse than before updating the calibration set with these intermediate results. We could repeat the above steps multiple times for different nodes of the calibration graph, to see how the results change during the calibration process. Finally, we run the full recalibration, which runs all the remaining nodes that we did not run above: Then we again update the compiler using the results of the calibration in the same way as before. If the full recalibration was successful, the execution results should hopefully be at least as good as before the recalibration. By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "Example: Measuring T1",
    "url": "/iqm-pulla/Example - Measuring T1.html",
    "description": "T1 is an experiment that measures the relaxation time of a qubit. Information stored in a qubit decays exponentially. The time constant of the decay is called the relaxation time $T_1$. The experiment...",
    "content": "T1 is an experiment that measures the relaxation time of a qubit. Information stored in a qubit decays exponentially. The time constant of the decay is called the relaxation time $T_1$. The experiment measures $T_1$ by preparing selected qubits in the  excited state by playing an X gate,\nwaiting some time, and measuring the qubit. The waiting time is swept to reveal the exponential decay of the excited state probability. High-level QuantumOperations like Quantum gates can be implemented using different GateImplementations.\nTo control low-level aspects of the execution, we can create custom operations, the implementation of which we can control. Here we invent a custom operation \"custom\" and write an implementation \"Wait\" , which only inserts a delay of certain duration.\nIn principle, the custom gate implementation could include any number of low-level instructions,\nbut for this task we only need a wait.\nhttps://iqm-finland.github.io/docs/iqm-pulse/using_builder.html for more details about lower level controls. In later cells, we mix the custom gate with other, more familiar gates. We must register the operation, so that the compiler knows what to do with it: We need to select the physical qubits to work on. These are available on the QPU: Out of these, we select a few: Now we create all the circuits. In each circuit, we do a PRX(pi), or X, then our custom operation that waits, then measure all qubits.\nWe create a circuit for each delay time we want on the time axis. Then compile the circuits. We tweak the settings so that the shots are averaged by the server, so that we don\u2019t need to.\nThe results therefore return as sampled probabilities. Extract the results We can also visualise the final playlist. We should see that each circuit is different and the waits at the end are increasing towards the end. previous Examples next Example: Dynamical decoupling By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "Contributors",
    "url": "/iqm-pulla/authors.html",
    "description": "Rakhim Davletkaliyev < rakhim . davletkaliyev @ meetiqm . com > Ville Bergholm < ville @ meetiqm . com > Joni Ikonen < joni @ meetiqm . com > Arianne Meijer < qaremei @ meetiqm . com > Tuukka Hiltunen...",
    "content": "Rakhim Davletkaliyev < rakhim . davletkaliyev @ meetiqm . com > Ville Bergholm < ville @ meetiqm . com > Joni Ikonen < joni @ meetiqm . com > Arianne Meijer < qaremei @ meetiqm . com > Tuukka Hiltunen < tuukka @ meetiqm . com > Jussi Ritvas < jussi . ritvas @ meetiqm . com > Miikka Koistinen < miikka @ meetiqm . com > previous Changelog next License By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils_cirq.cirq_to_cpc",
    "url": "/iqm-pulla/api/iqm.pulla.utils_cirq.cirq_to_cpc.html",
    "description": "Convert a Cirq Circuit to an IQM CPC Circuit. previous iqm.pulla.utils_cirq next iqm.pulla.utils_dd By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04...",
    "content": "Convert a Cirq Circuit to an IQM CPC Circuit. previous iqm.pulla.utils_cirq next iqm.pulla.utils_dd By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.html",
    "description": "Definitions of error classes used to raise issues during circuit compilation. Exceptions CalibrationError A required calibration observation is missing from the calibration set, or an unknown gate cal...",
    "content": "Definitions of error classes used to raise issues during circuit compilation. Exceptions CalibrationError A required calibration observation is missing from the calibration set, or an unknown gate calibration observation is encountered. CircuitError There is something wrong with the quantum circuit. ClientError Client submitted a bad request, and needs to be notified. CompilationPassError There is something wrong with the compilation pass. InsufficientContextError The context provided to the compilation pass does not contain all necessary fields. SettingsConventionError While parsing Station Control settings, something breaks a structural or naming convention. UnknownHardwareComponentError Circuit contains a reference to an unknown hardware component. UnknownLogicalQubitError A logical qubit in the circuit has not been defined in the qubit mapping. previous iqm.cpc.compiler next iqm.cpc.compiler.errors.CalibrationError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils_dd.generate_phases_of_urn_sequence",
    "url": "/iqm-pulla/api/iqm.pulla.utils_dd.generate_phases_of_urn_sequence.html",
    "description": "Generate PRX gate phases for the URn sequence. More information on the URn sequence is available in [ 1 ] , at the end in Appendix A.1. n ( int ) \u2013 Number of single qubit PRX pulses with different pha...",
    "content": "Generate PRX gate phases for the URn sequence. More information on the URn sequence is available in [ 1 ] , at the end in Appendix A.1. n ( int ) \u2013 Number of single qubit PRX pulses with different phases to apply, must be a positive even number. Phases to be used by the URn sequence. list [ float ] previous iqm.pulla.utils_dd next Common errors By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.ClientError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.ClientError.html",
    "description": "Client submitted a bad request, and needs to be notified. Errors inheriting this class will be reported to the client in the message field of the failed job. previous iqm.cpc.compiler.errors.CircuitEr...",
    "content": "Client submitted a bad request, and needs to be notified. Errors inheriting this class will be reported to the client in the message field of the failed job. previous iqm.cpc.compiler.errors.CircuitError next iqm.cpc.compiler.errors.CompilationPassError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla",
    "url": "/iqm-pulla/api/iqm.pulla.html",
    "description": "Client-side library for Pulse-level access to IQM quantum computers. Subpackages and modules utils_cirq Utilities for working with Cirq objects. utils_dd Utilities for working with Dynamical Decouplin...",
    "content": "Client-side library for Pulse-level access to IQM quantum computers. Subpackages and modules utils_cirq Utilities for working with Cirq objects. utils_dd Utilities for working with Dynamical Decoupling. previous iqm.cpc.interface next iqm.pulla.utils_cirq By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.html",
    "description": "Compile quantum circuits into instruction schedules and settings that can be executed on a station. Subpackages and modules errors Definitions of error classes used to raise issues during circuit comp...",
    "content": "Compile quantum circuits into instruction schedules and settings that can be executed on a station. Subpackages and modules errors Definitions of error classes used to raise issues during circuit compilation. previous iqm.cpc next iqm.cpc.compiler.errors By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc",
    "url": "/iqm-pulla/api/iqm.cpc.html",
    "description": "IQM Circuit to Pulse Compiler. IQM Circuit to Pulse Compiler is a Python-based library for converting quantum circuits\ninto instruction schedules (which map Station Control controller names to their p...",
    "content": "IQM Circuit to Pulse Compiler. IQM Circuit to Pulse Compiler is a Python-based library for converting quantum circuits\ninto instruction schedules (which map Station Control controller names to their pulse playlists) and Station Control settings\nrequired for circuit execution, using the calibration data it is given.\nThe generated schedules and settings can be sent to Station Control\nfor execution on real or simulated quantum hardware. CPC is normally only accessed indirectly through Cocos or its reference client IQM client ,\nor a frontend such as Cirq on IQM or Qiskit on IQM . Subpackages and modules compiler Compile quantum circuits into instruction schedules and settings that can be executed on a station. interface Pydantic models used by the API. previous API Reference next iqm.cpc.compiler By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.InsufficientContextError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.InsufficientContextError.html",
    "description": "The context provided to the compilation pass does not contain all necessary fields. previous iqm.cpc.compiler.errors.CompilationPassError next iqm.cpc.compiler.errors.SettingsConventionError By IQM Pu...",
    "content": "The context provided to the compilation pass does not contain all necessary fields. previous iqm.cpc.compiler.errors.CompilationPassError next iqm.cpc.compiler.errors.SettingsConventionError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.SettingsConventionError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.SettingsConventionError.html",
    "description": "While parsing Station Control settings, something breaks a structural or naming convention. previous iqm.cpc.compiler.errors.InsufficientContextError next iqm.cpc.compiler.errors.UnknownHardwareCompon...",
    "content": "While parsing Station Control settings, something breaks a structural or naming convention. previous iqm.cpc.compiler.errors.InsufficientContextError next iqm.cpc.compiler.errors.UnknownHardwareComponentError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.CompilationPassError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.CompilationPassError.html",
    "description": "There is something wrong with the compilation pass. previous iqm.cpc.compiler.errors.ClientError next iqm.cpc.compiler.errors.InsufficientContextError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQ...",
    "content": "There is something wrong with the compilation pass. previous iqm.cpc.compiler.errors.ClientError next iqm.cpc.compiler.errors.InsufficientContextError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.CircuitError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.CircuitError.html",
    "description": "There is something wrong with the quantum circuit. previous iqm.cpc.compiler.errors.CalibrationError next iqm.cpc.compiler.errors.ClientError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland...",
    "content": "There is something wrong with the quantum circuit. previous iqm.cpc.compiler.errors.CalibrationError next iqm.cpc.compiler.errors.ClientError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.UnknownHardwareComponentError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.UnknownHardwareComponentError.html",
    "description": "Circuit contains a reference to an unknown hardware component. previous iqm.cpc.compiler.errors.SettingsConventionError next iqm.cpc.compiler.errors.UnknownLogicalQubitError By IQM Pulla developers \u00a9 ...",
    "content": "Circuit contains a reference to an unknown hardware component. previous iqm.cpc.compiler.errors.SettingsConventionError next iqm.cpc.compiler.errors.UnknownLogicalQubitError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.CalibrationError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.CalibrationError.html",
    "description": "A required calibration observation is missing from the calibration set, or an unknown\ngate calibration observation is encountered. previous iqm.cpc.compiler.errors next iqm.cpc.compiler.errors.Circuit...",
    "content": "A required calibration observation is missing from the calibration set, or an unknown\ngate calibration observation is encountered. previous iqm.cpc.compiler.errors next iqm.cpc.compiler.errors.CircuitError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.interface",
    "url": "/iqm-pulla/api/iqm.cpc.interface.html",
    "description": "Pydantic models used by the API. Subpackages and modules previous iqm.cpc.compiler.errors.UnknownLogicalQubitError next iqm.pulla By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release...",
    "content": "Pydantic models used by the API. Subpackages and modules previous iqm.cpc.compiler.errors.UnknownLogicalQubitError next iqm.pulla By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.UnknownLogicalQubitError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.UnknownLogicalQubitError.html",
    "description": "A logical qubit in the circuit has not been defined in the qubit mapping. previous iqm.cpc.compiler.errors.UnknownHardwareComponentError next iqm.cpc.interface By IQM Pulla developers \u00a9 Copyright 2024...",
    "content": "A logical qubit in the circuit has not been defined in the qubit mapping. previous iqm.cpc.compiler.errors.UnknownHardwareComponentError next iqm.cpc.interface By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils_dd",
    "url": "/iqm-pulla/api/iqm.pulla.utils_dd.html",
    "description": "Utilities for working with Dynamical Decoupling. Functions generate_phases_of_urn_sequence (n) Generate PRX gate phases for the URn sequence. previous iqm.pulla.utils_cirq.cirq_to_cpc next iqm.pulla.u...",
    "content": "Utilities for working with Dynamical Decoupling. Functions generate_phases_of_urn_sequence (n) Generate PRX gate phases for the URn sequence. previous iqm.pulla.utils_cirq.cirq_to_cpc next iqm.pulla.utils_dd.generate_phases_of_urn_sequence By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils_cirq",
    "url": "/iqm-pulla/api/iqm.pulla.utils_cirq.html",
    "description": "Utilities for working with Cirq objects. Functions cirq_to_cpc () Convert a Cirq Circuit to an IQM CPC Circuit. previous iqm.pulla next iqm.pulla.utils_cirq.cirq_to_cpc By IQM Pulla developers \u00a9 Copyr...",
    "content": "Utilities for working with Cirq objects. Functions cirq_to_cpc () Convert a Cirq Circuit to an IQM CPC Circuit. previous iqm.pulla next iqm.pulla.utils_cirq.cirq_to_cpc By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 7.11. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulse",
    "title": "IQM Pulse",
    "url": "/iqm-pulse/index.html",
    "description": "9.2 2025-04-15 IQM Pulse provides an abstraction that transforms high-level quantum circuit operations\nto a unified set of lower-level instructions for IQM quantum computers. A quantum circuit is an a...",
    "content": "9.2 2025-04-15 IQM Pulse provides an abstraction that transforms high-level quantum circuit operations\nto a unified set of lower-level instructions for IQM quantum computers. A quantum circuit is an abstract mathematical construct which conveniently hides all implementation\ndetails such as the timing of microwave pulses, waveform shapes, sampling rates, signal capture, and so on.\nBut in order to execute a circuit you need to convert it into a schedule of hardware instructions which involve\nall of the above. IQM Pulse provides a framework for defining abstract quantum gates/operations, as well as their concrete implementations in terms of hardware instructions machinery to easily construct circuit-level gate sequences, and compile them into instruction schedules. a set of ready-made gates with implementations. IQM Pulse is not a standalone tool, but is used in IQM\u2019s client libraries, IQM Pulla and Exa.\nTo use them effectively, you are encouraged to familiarize yourself with IQM Pulse, especially the most common\nconcepts. Index Module Index Search Page next Concepts and Classes \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.2. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulse",
    "title": "References",
    "url": "/iqm-pulse/references.html",
    "description": "R.\u00a0G. Lyons. Understanding Digital Signal Processing . Prentice Hall, 2nd edition, 2004. ISBN 978-0131089891. Cecilia\u00a0Gisele Jarne. A heuristic approach to obtain signal envelope with a simple softwar...",
    "content": "R.\u00a0G. Lyons. Understanding Digital Signal Processing . Prentice Hall, 2nd edition, 2004. ISBN 978-0131089891. Cecilia\u00a0Gisele Jarne. A heuristic approach to obtain signal envelope with a simple software implementation. ANALES AFA , 29(2):51\u201357, 2018. arXiv:1703.06812 , doi:10.31527/analesafa.2018.29.2.51 . John\u00a0M. Martinis and Michael\u00a0R. Geller. Fast adiabatic qubit gates using only $\\sigma _z$ control. Phys. Rev. A , 90:022307, Aug 2014. arXiv:1402.5467 , doi:10.1103/PhysRevA.90.022307 . Eyob\u00a0A. Sete, Nicolas Didier, Angela\u00a0Q. Chen, Shobhan Kulshreshtha, Riccardo Manenti, and Stefano Poletto. Parametric-resonance entangling gates with a tunable coupler. Phys. Rev. Appl. , 16:024050, Aug 2021. arXiv:2104.03511 , doi:10.1103/PhysRevApplied.16.024050 . Youngkyu Sung, Leon Ding, Jochen Braum\u00fcller, Antti Veps\u00e4l\u00e4inen, Bharath Kannan, Morten Kjaergaard, Ami Greene, Gabriel\u00a0O. Samach, Chris McNally, David Kim, Alexander Melville, Bethany\u00a0M. Niedzielski, Mollie\u00a0E. Schwartz, Jonilyn\u00a0L. Yoder, Terry\u00a0P. Orlando, Simon Gustavsson, and William\u00a0D. Oliver. Realization of high-fidelity CZ and ZZ-free iSWAP gates with a tunable coupler. Phys. Rev. X , 11:021058, Jun 2021. arXiv:2011.01261 , doi:10.1103/PhysRevX.11.021058 . Eric Hyypp\u00e4, Antti Veps\u00e4l\u00e4inen, Miha Papi\u010d, Chun\u00a0Fai Chan, Sinan Inel, Alessandro Landra, Wei Liu, J\u00fcrgen Luus, Fabian Marxer, Caspar Ockeloen-Korppi, and others. Reducing leakage of single-qubit gates for superconducting quantum processors using analytical control pulse envelopes. PRX Quantum , 5(3):030353, 2024. doi:10.1103/PRXQuantum.5.030353 . previous Changelog next License \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.2. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulse",
    "title": "Custom gate implementations",
    "url": "/iqm-pulse/custom_gates.html",
    "description": "Quantum gates are represented by QuantumOp data classes, containing the required\nmetadata to define the gate. A QuantumOp is identified by its name , and arity defines number of locus components the o...",
    "content": "Quantum gates are represented by QuantumOp data classes, containing the required\nmetadata to define the gate. A QuantumOp is identified by its name , and arity defines number of locus components the operation acts on. For example,\nthe PRX operation (Phased X Rotation) is a single-qubit operation, so its arity is 1, whereas the CZ (Controlled-Z) gate\nacts on two qubits, having arity 2. Arity 0 has a special meaning that the operation in question can act on any number\nof components (for example Barrier ). The attribute symmetric defines whether the effect of the quantum operation\nis symmetric with respect to changing the order of its locus components. As an example, the CZ gate is a symmetric\ntwo-qubit gate, whereas CNOT (Controlled-NOT) is not symmetric. Some quantum operations are defined as \u201cfunctions\u201d, taking one or more parameters to define the effect. These\narguments are stored in the attribute params . As an example, the PRX gate\ntakes two arguments, angle (the rotation angle with respect to the z-axis of the Bloch sphere), and phase (the rotation phase in the rotating frame). On the other hand, many operations do not require any parameters, in\nwhich case this field is an empty tuple (e.g. the CZ gate). A QuantumOp has unambiguous definition in terms of its intended effect on the computational subspace of the\nQPU component, but it can be implemented in various ways. Each implementation is represented as a GateImplementation subclass. A QuantumOp stores its known implementations in the\nfield implementations . Note that even though QuantumOp is a frozen data class, the implementations dictionary can be modified, e.g.\nto add new implementations or to change their order (usually programmatically by some client procedure, but nothing as\nsuch prevents the user from manipulating the contents manually). The default implementation is how the user prefers\nto implement the operation unless otherwise specified (in effect, this is what will get called in most cases the\noperation is invoked). In the implementations dict, the default implementation is defined as the first entry.\nQuantumOp contains helpful methods that allow setting and returning the default implementation for specific cases: set_default_implementation() , get_default_implementation_for_locus() , and set_default_implementation_for_locus() . The attribute unitary stores a function that can be used to get the unitary\nmatrix representing the quantum operation in question. The unitary function must have the same arguments\nas defined in params , such that for each collection of these parameters it\ngives the associated unitary matrix. Note that not all QuantumOps necessarily even represent a unitary gate (e.g.\nthe measure operation is not one), or the exact form of the unitary matrix might not be known. In these cases, the\nfield can be left None . The unitary does not need to be defined for most of the basic usage of a QuantumOp, but certain\nalgorithmic methods (e.g. some implementations of Randomized Benchmarking) may require the unitary matrices to be known,\nand such operations that do not define the getter function cannot then be used in these contexts. For more information, see the API docs of QuantumOp for the full list of fields needed\nto define a quantum operation and the available class methods. While QuantumOp represents an abstract quantum operation, its implementations contain\nthe concrete logic of how to make that operation happen using QC hardware. Gate implementations are subclasses of GateImplementation . In this section, the main features of that class are\nintroduced (for a full list of class methods see the API docs), with the emphasis being on how to create your own\ngate implementations. Starting with __init__() , it is important to note that the init\nmethods of all gate implementations must have the exact same signature: Here, parent is the QuantumOp this gate implementation implements, and name is the implementation\u2019s name in\nthe dictionary implementations . locus is the set of (usually logical) components\nthe QuantumOp acts on (the size of the locus must be consistent with the parent \u2019s arity ), while calibration_data gives the required calibration data values\nfor this implementation and locus (can be empty in case the implementation needs no calibration data). Finally,\nThe implementations store a reference to the ScheduleBuilder that created it. This is\nbecause GateImplementations are practically never created manually by calling the init method itself. Instead, one\nneeds a builder and uses get_implementation() . The responsibility of the init method is to (at least) store the calibration_data provided from the builder for\nfurther use, but in many cases, one might want to create some intermediate objects like pulses or instructions from that calibration data already at this point. Note that ScheduleBuilder caches its GateImplementations per each locus and calibration_data , so as long as the calibration is not changed, the code in init will be called just once per locus. GateImplementations are Callables, i.e. they implement the __call__ method. It should take as its arguments at least\nthe QuantumOpt parameters defined for the parent in params , but in\naddition it may have optional extra arguments. The call method should return a TimeBox object\nthat contains the pulses, instructions and other logic required to implement the quantum operation in question. The\ntypical usage of gate implementations then looks like this (See Using ScheduleBuilder and Pulse timing for more\ninfo on scheduling and the ScheduleBuilder): The base class __call__() method does automatic TimeBox caching based\non the unique values of the call arguments, and in many cases, one does not want to reimplement this caching in their own\nimplementations. For this reason, there is the method _call which contains just the pure TimeBox creation logic.\nDevelopers can choose to override that instead of __call__ in cases where the call args are hashable python types,\nand then they can utilize the default caching of TimeBoxes from the base class. When writing a GateImplementation, a developer should consider what parts of the logic should go to the class init and\nwhat to the __call__ or _call method. A general rule of thumb would be that any parts that can be precomputed\nand do not depend on the call arguments can go to init, and the rest to call. As an example, let\u2019s go through a simple PRX _call method (note that the default PRX implementations do not\nuse this exact call method, as this is a simplified example for educational purposes): Here, we first create an IQPulse object which is a low-level Instruction. IQPulse\nmeans a \u201ccomplex pulse\u201d which has two orthogonal components i and q \u2013 this what drive pulses look like in general. In\nthis simplified example, we have hardcoded the pulse waveforms into TruncatedGaussian and TruncatedGaussianDerivative for the i and q components, respectively (this is a DRAG implementation, so the\nq component is the derivative of the i component). The waveforms are parametrized by the calibration_data for the\ngiven locus (see the next subsection for more info on Waveforms and calibration data). The PRX QuantumOp param angle scales the pulse amplitude linearly (the waveforms are normalized to one), and the param phase defines relative\nphase modulation. Then the returned TimeBox is created out of the instruction . Note that\nsince we override _call here, instead of __call__ , so this implementation would utilize the default base class\ncaching such that the TimeBoxes are cached per unique values of (angle, phase) . Another important concept is a the so called locus mapping of a gate implementation. Locus mappings define on which\nloci, i.e. groups of components, a given implementation can be defined. They are used to relay the information which\nloci are supported to a client application (e.g. EXA). In addition, the gate implementation itself can programmatically\nuse this information self.builder.chip_topology . For example, a PRX can be defined on all single components that are connected to a drive line, and CZ can be defined on\nconnected pairs of qubits. Locus mappings live in ScheduleBuilder.chip_topology which is a ChipTopology object. Locus mapping is a dict whose keys are the loci\n( tuple[str, ...] keys denote asymmetric loci where the order of the components matter, and frozenset[str] type\nloci denote symmetric ones), and the values are groups of components, typed tuple[str, ...] , where each locus can be\nmapped with some additional components that are needed for the operation of the implementation. For example, some CZ\nimplementation that tries to correct for crosstalk could map the non-locus components that see this crosstalk here.\nThe values of the dict can be left empty or just replicate the key components in case such extra information is not\nneeded. GateImplementations can define their locus mappings via get_custom_locus_mapping() or if a client application already\nadds the mapping, we can just return its name via get_locus_mapping_name() .\nIf neither of these methods are overridden in a GateImplementation class, the default behaviour will be such that an arity==1 loci will be assumed to use the mapping where all single qubits are the keys, and arity==2 loci the\n(symmetric) mapping where the keys are all pairs of connected qubits. For other arities there is no default behaviour,\nso it is then mandatory to define the mapping explicitly using the aforementioned methods. In order to implement most QuantumOps, one has to physically alter the state of the QPU. This is typically done by playing\nspecified and correctly calibrated pulses via the control electronics (this applies to all typical logical gates such as\ne.g. PRX or CZ \u2013 non-physcial metaoperations such as Barrier are an exception). In defining these pulses, there are two\nlevels of abstractions: Waveform and Instruction . Waveform represents the physical form of the control pulse, typically normalized to the interval [-1.0, 1.0] . The\nEach Waveform subclass can define any number of waveform parameters as class\nattributes, which can be used to programmatically define the waveform. For example, a Gaussian could be defined in terms\nof the average mu and spread sigma . A Waveform class then essentially contains just the parameters\nand a recipe for computing the samples as an np.ndarray . As an example, here is how one writes the Waveform class\nfor Gaussian : The Instructions RealPulse and IQPulse allow handling the amplitudes (via the attribute scale ) without\nhaving to resample the waveform for every different amplitude value. However, one can always choose to include\nthe amplitude into the sampling and then use scale=1 . The waveform parameters (like sigma in the above Gaussian) typically require calibration when the Waveform is used\nin a quantum gate. However, the GateImplementation usually has other calibrated parameters as well defined in the\nimplementation itself. As an example, here are the implementation-level parameters of the default PRX implementation,\ndefined as class attribute: Note the amplitudes are defined here on this level, since the default PRX uses normalized Waveforms and factors in the\namplitudes via scale . In these parameters, the unit is not just metadata. The control electronics understand time\nin terms of samples and their sample rate, while human users typically want to input seconds instead of doing the sample\nconversion manually. For this reason, there is logic that converts anything that has the unit \"s\" into samples.\nSimilarly, parameters with \"Hz\" units are converted to 1/sample . For the Waveform parameters, the same logic\napplies, but by default it is assumed that all parameters are time-like and this converted from seconds to samples.\nIf some Waveform parameters needs to be made unitless or e.g. frequency-like (with \"Hz\" units), it can be achieved\nwith the method non_timelike_attributes() : In the above dict, the keys should be the attribute names and values their units. To make creating new GateImplementations more comfortable, there are additional base classes on top of GateImplementation itself. CompositeGate allows quick implementation of gates in terms of other gates,\nusing a similar syntax as with creating/scheduling several TimeBoxes together (see Using ScheduleBuilder ). At it\nsimplest, a ComposteGate is just the _call method: Here, one could use also builder.get_implementation instead of build() , but the latter allows calibrating the member gates\ncase specifically for this composite if they are first registered via registered_gates (in this case, there is\njust one member, PRX). Creating new implementations for the PRX, CZ and Measure gates often means just coming up with new waveforms for the\ncontrol pulses. If this is the case, there are helpful base classes that make those implementations into oneliners\n(outside of defining the Waveforms themselves): PRX_CustomWaveforms , FluxPulseGate , and Measure_CustomWaveforms . Using these\nbase classes at its simplest looks like this: All of these classes automatically include the associated Waveform parameters into the calibration parameters of\nthe implementation itself. There is also a general base class for any gate that implements a single IQPulse (both PRX_CustomWaveForms and Measure_MyCoolWaveforms actually inherit from it), regardless of the context: CustomIQWaveforms . Gate definitions (i.e. QuantumOps) are stored in ScheduleBuilder \u2019s attribute op_table . When the builder is created, the op_table comes preloaded with the all the basic QuantumOps needed for\ntypical circuit execution and their default implementations. These include e.g. the PRX gate, the CZ gate, the measure\noperation, the conditional prx operation, the reset operation, and the barrier operation. In order to add custom operations, there is a helpful function register_implementation() that\nin addition to adding new implementations allows one to add altogether new quantum operations. As an example here is a snippet that adds the CNOT gate, and its implementation, into an existing builder: Here, the CNOT implementation MyCNotClass needs to be of course defined first (a QuantumOp always needs at least one\nimplementation). Note: The end user cannot modify the canonical mapping (defined in iqm-pulse) between implementation_name and implementation_class . Note that often ScheduleBuilder is created and operated by some client application, and the same application usually\nhas its own interface for adding/manipulating QuantumOps. However, if the user has access to the builder object, the\nabove method will always work. previous Using ScheduleBuilder next Pulse timing \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.2. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulse",
    "title": "Pulse timing",
    "url": "/iqm-pulse/pulse_timing.html",
    "description": "The ReadoutTrigger Instruction responsible of qubit readout has several\ntiming-related attributes.\nThe measure.constant gate implementation produces the lower-level ReadoutTrigger instruction\nfrom a s...",
    "content": "The ReadoutTrigger Instruction responsible of qubit readout has several\ntiming-related attributes.\nThe measure.constant gate implementation produces the lower-level ReadoutTrigger instruction\nfrom a simplified set of settings.\nThe figure below shows how the settings relate to the more flexible attributes of the instruction. With conditional Instructions, we specify how the information from readout operations should affect Instructions at\nruntime.\nUsually, the goal is use the information as soon as possible, but it takes a finite time to propagate from the\nacquisition unit to the drive channels that execute the Instructions conditionally. Note On all hardware supported by IQM QCCSW, ConditionalInstruction reads the signal bit at the time of\nexcution, regardless of when the signal bit was last updated.\nThis means that if the Conditionalinstruction is executed too early, the condition will be executed based on the\nprevious state of the bit. To facilitate efficient timing of the feedback signals, IQM Pulse uses virtual channels between probeline channels\n(the source of the signals) and drive channels (the destinations).\nBlock instructions on the virtual channel represent the travel time of the signals. CCPRX_Composite is GateImplementation of the cc_prx (classically controlled PRX) that outputs two\nTimeBoxes:\nthe first one to represent the travel time, and the second one with the actual ConditionalInstruction .\nIn typical use, both should be scheduled in the same order, to ensure the Conditionalinstrucion starts when the\nsignal bit is available. The following image illustrates how the TimeBoxes are used for qubits QB2 and QB3 .\nFor QB2, this is also how Reset_Conditional implements the reset operation. The equaivalent code would be Instructions are spaced out in time only for visual clarity. When scheduled ASAP, they would be left-aligned\nsuch that the ConditionalInstructions start right after the associated control_delay has passed. The bottom of the image illustrates an alternative use of CCPRX_Composite to have more freedom in the timing.\nThere, the optional delay TimeBox is not used for scheduling the Instructions on QB4.\nInstead, the user has ensured that the other instructions take enough time for the signal to arrive.\nThis could be used to act on the previous feedback signal (not shown). Note This section is not about IQM Pulse itself, but might help in understanding the details of the execution. The image below shows a typical timing of a Playlist segment with 2 AWG devices for driving, and a readout instrument.\nHere, all statements that apply to an AWG apply to readout instruments as well.\nThe AWGs can output an arbitrary sequence of pulses, and the readout instrument can additionally read out\nthe response to the pulses. With readout, the raw signal response from the readout pulse will be integrated to produce a single number, such as a\ncomplex number or a bit, corresponding to a particular qubit in a particular segment. In the figure, one of the AWGs has been selected as the trigger master, which means it sends trigger pulses to\nstart the execution on the slave devices.\nAs shown in the picture, different delays caused by the travel time of signals can be compensated for by\nadjusting the trigger_delay setting of each device. Settings in the figure that can be adjusted by user in the higher level libraries: Setting Explanation <awg>.trigger_delay Wait time between the end of the trigger signal of the AWG master and the beginning of the pulse sequence. <awg>.trigger_delay (slave) Wait time between receiving the trigger signal at the AWG slave and the beginning of the pulse sequence. options.end_delay Wait time between the end of the pulse segment and the next trigger. <gate>.<implementation>.<locus>.duration The duration of the hardware instruction for a gate, possibly rounded to satisfy granularity constraints.\nFor the ReadoutTrigger instruction, the meaning is different, see below. Other notes: The AWG spcecified by options.trigger_master is the only channel that does not wait for a trigger\nat the start of a segment. Slave AWGs may also emit a trigger pulse to allow daisy chaining trigger signals. Systems with IQM Control System are triggered centrally and the channels run independently, and the options.trigger_master has no effect. Pipeline delays are delays between the execution of a command and the pulse actually getting outputted\nfrom a device. This delay is caused by the hardware and cannot be changed.\nIn practice, it can be thought as being part of the cable delays, and thus can be compensated with trigger_delay setting. previous Custom gate implementations next API Reference \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.2. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulse",
    "title": "Using ScheduleBuilder",
    "url": "/iqm-pulse/using_builder.html",
    "description": "This section describes how to use ScheduleBuilder to compose pulse schedules.\nScheduleBuilder encapsulates registered QuantumOps, the calibration information for them, QPU components and their\ntopolog...",
    "content": "This section describes how to use ScheduleBuilder to compose pulse schedules.\nScheduleBuilder encapsulates registered QuantumOps, the calibration information for them, QPU components and their\ntopology, and control channel properties. In the context of IQM Pulla and EXA, an instance of ScheduleBuilder is given by the framework,\nand it contains all the necessary information to execute against a particular quantum computer instance.\nHere, we assume that user has an instance of ScheduleBuilder builder to work with. A typical workflow begins with calling get_implementation() with the name of a desired QuantumOp and the locus\nfor the operation.\nThe locus is the logical target of the operation, usually a sequence of qubits or computational resonators.\nThis outputs a an instance of GateImplementation , which is capable of producing TimeBoxes with the correct\ncalibration for that locus. For example, here we ask for the GateImplementation of prx , cz , and measure , all of which are standard\ngates recognized by IQM Pulse, for qubits QB1 and QB3 .\nAny gate which is registered in the runtime can be requested this way. Notice how the number of qubits matches the operation: CZ acts on 2 qubits, while PRX acts on only one.\nMeasure can act on any number of qubits. There might be several available implementations for an operation. get_implementation gives the implementation that is set as the default, unless a specific implementation is\nrequested with a keyword argument. To instantiate some concrete TimeBoxes, we call time implementation with the logical parameters of the operations, as\ndefined by the QuantumOps.\nPRX has 2 parameters: the 2 angles of a phased rotation.\nCZ does not have any parameters. One important method is the wait() , which blocks the control channels of the given components for a certain time: In all of the examples above, the TimeBoxes are atomic, which can be organized into composite TimeBoxes to decide\ntheir relative order. TimeBoxes can be concatenated with the following rules: Addition ( + ) concatenates the children of the operands into a single TimeBox.\nUse addition to allow gates on disjoint loci to execute simultaneously, for example doing a PRX on all qubits. The pipe operation ( | ) groups two TimeBoxes together without concatenating.\nThis results in composite TimeBox with two children, the operands, which are scheduled separately.\nUse the pipe to ensure that certain operations execute before some others. Iterables of TimeBoxes are treated as the sum of the elements. This would execute 2 PRX gates on QB1 and QB2 simultaneously: If the last operator was | instead, the second gate on QB2 would execute only after the first 3 gates. Together, these rules provide a handy way of defining complex circuits easily: A TimeBox are made atomic by resolving it using ScheduleBuilder.resolve_timebox() .\nWhen using a framework like IQM Pulla or Exa, the framework will take care of the resolving as part of compilation,\nso the user does not need to do it explicitly. TimeBoxes are resolved recursively: The children of a TimeBox are resolved, and resulting (sub-)Schedules are aligned\naccording to the SchedulingStrategy (ASAP or ALAP) of the TimeBox.\nThe time duration of a TimeBox is determined by its contents and the way they are scheduled during the resolution.\nFinally, all channels are padded with Waits so that the total duration of Instructions on every channel is equal.\nIn other words, the Schedule becomes a \u201crectangle\u201d. An important part of the scheduling are the blocking rules, that is, whether the contents of two TimeBoxes block or\nslide past each other.\nThe rules are: An atomic TimeBox is considered to act on a component if it has instructions on any of the non-virtual channels\nrelated to that component. A composite TimeBox acts on the union of its children\u2019s locus components. A TimeBox blocks all channels related to any component it acts on. When scheduling two TimeBoxes, the instructions will not overlap in time if the TimeBoxes block overlapping channels. In addition to blocking the channels actually present in a TimeBox, it is possible to block neighbouring channels\nas well (for example in order to limit cross-talk).\nThe applied neighbourhood is specified in ScheduleBuilder.resolve_timebox() .\nThe neighbourhood is defined as an integer such that 0 means \u201cblock only the involved channels\u201d,\n1 means \u201cblock the involved channels and the channels of any neighbouring couplers\u201d,\n2 means \u201cthe same as in (1) but in addition block all channels connected by those couplers\u201d, and so on.\nThe blocking rules do not add actual Wait or Block instructions are added to the neighbourhood channels, and two\noverlapping neighbourhoods do not block each other.\nThe blocking comes in question only when actual content would be added to those neighbourhood channels. In practice, the rules and default GateImplementations ensure that the user can concatenate arbitrary gates\nwithout worrying that the gates have an adverse effect on each other.\nFor example, the pulse of a PRX gate playing at the same time as a CZ gate or a measurement would ruin both operations.\nIf overlapping of such gates is desired, the best way is to arrange the Instructions on the Schedule level and wrap the\nschedule into an atomic TimeBox. Note Virtual channels are special channels that exist only to aid the scheduling algorithm.\nExamples are tracking the phases of the MOVE gate, and timing of fast feedback.\nThese channels are removed when the Playlist is finalized. You are encouraged to discover the many features of ScheduleBuilder and TimeBox by reading the\nAPI: ScheduleBuilder , TimeBox . A quick reference of selected features is provided in the examples below. Finding information about the target system: Working with TimeBoxes: Some typical errors that are easy to make with the syntax: Not calling the implementation to get a TimeBox. The call is easy to forget especially if there are no parameters\nto give: Giving a single component as locus: previous Concepts and Classes next Custom gate implementations \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.2. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulse",
    "title": "API Reference",
    "url": "/iqm-pulse/API.html",
    "description": "iqm.pulse Control pulses, gates and instruction schedules for quantum computers. previous Pulse timing next pulse \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.2. Last updated on 2025-04-15....",
    "content": "iqm.pulse Control pulses, gates and instruction schedules for quantum computers. previous Pulse timing next pulse \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.2. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulse",
    "title": "Concepts and Classes",
    "url": "/iqm-pulse/concepts.html",
    "description": "This section gives an overview of the main concepts and terminology in IQM Pulse. QPUs contain components : qubits, computational resonators, couplers, and probelines. Each component may have some con...",
    "content": "This section gives an overview of the main concepts and terminology in IQM Pulse. QPUs contain components : qubits, computational resonators, couplers, and probelines. Each component may have some control channels connected to it. Control channels deliver physical control pulses\nto the QPU. Quantum operations have a locus , which is the set of quantum information carrying components\n(qubits and resonators) the operation acts on.\nOne operation may involve sending pulses to multiple control channels. The assembly of a Playlist, or a batch of quantum circuits, can be summarized as follows: A Playlist contains multiple independent segments , to be executed as a batch. A segment is a conceptual unit at a time scale where the quantum information of the QPU can be\nassumed to be preserved. A quantum circuit corresponds to one segment. What is executed during a segment is determined by a Schedule . A Schedule is a set of hardware control channels, each with a strictly timed sequence of Instructions . A Schedule is formed by scheduling a Timebox . A TimeBox can contain other TimeBoxes without precise relative timing,\nor it can be atomic, in which case it contains a single Schedule . The image below illustrates how a Playlist of two segments is formed from TimeBoxes. Hardware instructions are the lowest-level construct visible on the client side.\nInstructions are a set of atomic, real-time execution commands for the control hardware supported by IQM.\nThey work in a time scale where the quantum information of the QPU can be assumed to be preserved.\nExamples of Instructions are IQPulse to play a microwave pulse on a channel, VirtualRZ to adjust the modulation phase, ReadoutTrigger to acquire measurement data,\nand Wait to delay the next Instruction for a given time.\nSee iqm.pulse.playlist.instructions for the complete list. During execution, each hardware control channel executes its own sequence of Instructions.\nEach Instruction blocks the next until it is completed.\nInstructions are as explicit as possible, so that there is no ambiguity on what will be executed when.\nIQM Station control transforms Instructions to machine-specific commands. All Instructions have a duration, measured in samples, though the duration can be zero.\nThe durations are subject to hardware-specific granularity constraints.\nFor example, some hardware might require all instructions to be a multiple of 16 samples long, with a minimum of 32.\nInstructions violating the granularity constraints will raise an error.\nHowever, a typical user does not need to concern themselves about the constraints, as\nthe gate implementations and IQM Pulse\u2019s scheduling ensures the constraints are respected.\nThe philosophy is that Station Control, which is inaccessible to the user, does not attempt to do any smart\n\u201cmagic\u201d to fix inconsistencies in the user\u2019s input, it simply executes the Playlist it is given.\nInstead, the magic happens on the client side so that it is transparent to the user. Note For technical reasons, IQM Pulse mostly uses classes from iqm.pulse.playlist.instructions , but when\nfinalizing the output, the instructions are converted to iqm.models.playlist.instructions .\nThese two class families are semantically equivalent, apart from a few exceptions like Block which\nonly exists on the client side to help with scheduling. Schedule contains a number of control channels, each with a lists of Instructions.\nAll channels in a Schedule start executing at the same instant, and the timing is defined by the duration of the\nindividual Instructions.\nSchedules can be thought of as a fixed block that occupies some interval on a timeline of some channels. Schedules appear in two contexts: gate implementations and as complete segments.\nFor example, when an implementation of a PRX gate is requested,\na small Schedule involving the drive channel of a single qubit is created.\nWhen all the desired gates in a circuit have been scheduled by concatenating the gate-schedules together,\nthe end result, a segment, is a large Schedule occupying all necessary channels.\nA typical segment starts with initializing the qubits and ends with reading out their state. Whereas a Schedule is a container with strict relative timing, a TimeBox is a container with undefined\nrelative timing.\nEach TimeBox can be labeled using a human-readable label describing it, and operates on a number\nof locus components , using some of their control channels.\nA composite TimeBox contains other TimeBoxes as children, whereas atomic TimeBoxes contain a Schedule. TimeBoxes are the main language in which users define the order and relative alignment of execution elements, be it\ngates, Schedules, or larger TimeBoxes. A key process is the scheduling, in which TimeBoxes are resolved recursively into a fixed Schedule.\nWhen resolving, all Schedules inside the TimeBox are concatenated and are either left-aligned (ASAP) or right-aligned\n(ALAP), respecting the hardware constraints.\nImportantly, if some TimeBoxes have content on disjoint channels, the Schedules are allowed to happen simultaneously.\nIf they have content on partly overlapping channels, the Schedules are concatenated while preserving their internal\ntiming.\nAny interval that does not have explicit instructions is filled with Wait Instructions.\nThe figure above demonstrates how TimeBoxes are resolved. The syntax and rules are explained in more detail in Using ScheduleBuilder . A higher-level concept, a QuantumOp can represent a unitary quantum gate,\nor for example a measurement operation (not all QuantumOps necessarily represent a unitary gate).\nQuantumOps are simple, abstract, self-contained actions one can execute on a station as parts of a quantum circuit.\nThey include quantum gates like PRX, CZ, and measurements and resets.\nWhereas Schedules and Instructions act on control channels, QuantumOps act on named components on the QPU, such as\nqubits or computational resonators. A QuantumOp has unambiguous definition in terms of its intended effect on the computational subspace of the\nQPU component, but it can be implemented in various ways.\nEach implementation is represented as a GateImplementation. The list of available QuantumOps at runtime can be obtained with iqm.pulse.builder.build_quantum_ops() .\nA new QuantumOp can be registered at runtime, together with an implementation, with iqm.pulse.gates.register_implementation() . A GateImplementation bridges the gap between QuantumOps and TimeBoxes.\nWhen a user requests a QuantumOp from ScheduleBuilder with specific parameters and locus components, the\nchosen GateImplementation (usually the default) for the operation is used to produce a TimeBox.\nThis TimeBox, usually atomic, contains a Schedule on the appropriate control channels.\nThe Instructions within are constructed following the calibration values from the ScheduleBuilder. All gate implementations are listed in iqm.pulse.gates .\nSection Custom gate implementations explains how to add more implementations. Once all TimeBoxes are scheduled into large Schedules, one for each segment/circuit,\nthe Schedules are collected into a Playlist .\nThe Playlist is the final product that is sent to Station Control.\nIts contents are compressed by indexing all unique Instructions and waveforms on each channel,\nand representing the control channels in each segment as lists of Instruction indices. During execution, the segments in the Playlist are executed in order, and the whole sequence is repeated\na number of times equal to the number of repetitions (shots). Segments are separated in time by end delay , a parameter outside the Playlist.\nA long end delay can be used to prevent quantum information carrying from one segment to the next,\nthus resetting the qubits.\nAlternatively, the reset can be encoded in each segment as a long Wait instruction or using some active reset scheme. Station Control aims to execute all segments together, but sometimes this is not possible due to various memory\nconstraints.\nIn case the whole Playlist does not fit in memory, the segments are split into chunks which are executed separately.\nThe delay between chunks is undefined.\nTherefore, the time between segments is guaranteed to be at least the duration of the end delay, but can be much larger. inspect_playlist() provides a neat visual representation of the playlist, as blocks of instructions on a\ntimeline. previous IQM Pulse next Using ScheduleBuilder \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.2. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-pulse",
    "title": "pulse",
    "url": "/iqm-pulse/api/iqm.pulse.html",
    "description": "Control pulses, gates and instruction schedules for quantum computers. Full path: iqm.pulse Subpackages and modules previous API Reference next Changelog \u00a9 Copyright 2019-2025, IQM Finland Oy, Release...",
    "content": "Control pulses, gates and instruction schedules for quantum computers. Full path: iqm.pulse Subpackages and modules previous API Reference next Changelog \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.2. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-station-control-client",
    "title": "API documentation: station-control-client",
    "url": "/iqm-station-control-client/index.html",
    "description": "3.15 2025-04-15 This is the documentation of the IQM station-control client library. Index Module Index Search Page next API Reference \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 3.15. Last updated...",
    "content": "3.15 2025-04-15 This is the documentation of the IQM station-control client library. Index Module Index Search Page next API Reference \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 3.15. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-station-control-client",
    "title": "API Reference",
    "url": "/iqm-station-control-client/API.html",
    "description": "iqm.station_control.client Station control client implementation. iqm.station_control.interface Station control interface. previous API documentation: station-control-client next client \u00a9 Copyright 20...",
    "content": "iqm.station_control.client Station control client implementation. iqm.station_control.interface Station control interface. previous API documentation: station-control-client next client \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 3.15. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-station-control-client",
    "title": "meta_class",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.meta_class.html",
    "description": "Full path: iqm.station_control.client.iqm_server.meta_class Classes IqmServerClientMeta Custom metaclass that automatically adds '<feature> not implemented' stub implementations for all StationControl...",
    "content": "Full path: iqm.station_control.client.iqm_server.meta_class Classes IqmServerClientMeta Custom metaclass that automatically adds '<feature> not implemented' stub implementations for all StationControlClient functions that are not overridden by IqmServerClient. Inheritance previous iqm_server next IqmServerClientMeta \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 3.15. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-station-control-client",
    "title": "testing",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.testing.html",
    "description": "Full path: iqm.station_control.client.iqm_server.testing Subpackages and modules previous IqmServerClientMeta next interface \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 3.15. Last updated on 2025-0...",
    "content": "Full path: iqm.station_control.client.iqm_server.testing Subpackages and modules previous IqmServerClientMeta next interface \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 3.15. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-station-control-client",
    "title": "ListWithMeta",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.list_with_meta.ListWithMeta.html",
    "description": "Bases: list Standard list extension holding optional metadata as well. Module: iqm.station_control.interface.list_with_meta Methods items ( Iterable ) \u2013 meta ( Meta ) \u2013 previous list_with_meta next Me...",
    "content": "Bases: list Standard list extension holding optional metadata as well. Module: iqm.station_control.interface.list_with_meta Methods items ( Iterable ) \u2013 meta ( Meta ) \u2013 previous list_with_meta next Meta \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 3.15. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-station-control-client",
    "title": "PydanticBase",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.pydantic_base.PydanticBase.html",
    "description": "Bases: BaseModel Pydantic base model to change the behaviour of pydantic globally.\nNote that setting model_config in child classes will merge the configs rather than override this one. https://docs.py...",
    "content": "Bases: BaseModel Pydantic base model to change the behaviour of pydantic globally.\nNote that setting model_config in child classes will merge the configs rather than override this one. https://docs.pydantic.dev/latest/concepts/config/#change-behaviour-globally Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.pydantic_base Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Methods Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous pydantic_base next Changelog \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 3.15. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-station-control-client",
    "title": "interface",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.html",
    "description": "Station control interface. A StationControlInterface administers a set of control and measurement instruments\nattached to a quantum device, and connects to the database and related external services. ...",
    "content": "Station control interface. A StationControlInterface administers a set of control and measurement instruments\nattached to a quantum device, and connects to the database and related external services. Full path: iqm.station_control.interface Subpackages and modules list_with_meta Models to extend standard list with metadata. pydantic_base Pydantic related models and types. previous testing next list_with_meta \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 3.15. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-station-control-client",
    "title": "list_with_meta",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.list_with_meta.html",
    "description": "Models to extend standard list with metadata. Full path: iqm.station_control.interface.list_with_meta Classes ListWithMeta Standard list extension holding optional metadata as well. Meta Class holding...",
    "content": "Models to extend standard list with metadata. Full path: iqm.station_control.interface.list_with_meta Classes ListWithMeta Standard list extension holding optional metadata as well. Meta Class holding metadata for list return values, like pagination related data. Inheritance previous interface next ListWithMeta \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 3.15. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm_server",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.html",
    "description": "StationControlClient implementation for IQM Server Full path: iqm.station_control.client.iqm_server Subpackages and modules meta_class  testing  previous client next meta_class \u00a9 Copyright 2019-2025, ...",
    "content": "StationControlClient implementation for IQM Server Full path: iqm.station_control.client.iqm_server Subpackages and modules meta_class  testing  previous client next meta_class \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 3.15. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-station-control-client",
    "title": "client",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.html",
    "description": "Station control client implementation. Full path: iqm.station_control.client Subpackages and modules iqm_server StationControlClient implementation for IQM Server previous API Reference next iqm_serve...",
    "content": "Station control client implementation. Full path: iqm.station_control.client Subpackages and modules iqm_server StationControlClient implementation for IQM Server previous API Reference next iqm_server \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 3.15. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-station-control-client",
    "title": "IqmServerClientMeta",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.meta_class.IqmServerClientMeta.html",
    "description": "Bases: type Custom metaclass that automatically adds \u2018<feature> not implemented\u2019\nstub implementations for all StationControlClient functions that are\nnot overridden by IqmServerClient. Module: iqm.sta...",
    "content": "Bases: type Custom metaclass that automatically adds \u2018<feature> not implemented\u2019\nstub implementations for all StationControlClient functions that are\nnot overridden by IqmServerClient. Module: iqm.station_control.client.iqm_server.meta_class Methods previous meta_class next testing \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 3.15. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-station-control-client",
    "title": "Meta",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.list_with_meta.Meta.html",
    "description": "Bases: object Class holding metadata for list return values, like pagination related data. Module: iqm.station_control.interface.list_with_meta Attributes count  errors  limit  offset  order_by  Metho...",
    "content": "Bases: object Class holding metadata for list return values, like pagination related data. Module: iqm.station_control.interface.list_with_meta Attributes count  errors  limit  offset  order_by  Methods count ( int | None ) \u2013 order_by ( str | None ) \u2013 limit ( int | None ) \u2013 offset ( int | None ) \u2013 errors ( list [ str ] | None ) \u2013 previous ListWithMeta next pydantic_base \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 3.15. Last updated on 2025-04-15."
  },
  {
    "package": "iqm-station-control-client",
    "title": "pydantic_base",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.pydantic_base.html",
    "description": "Pydantic related models and types. Full path: iqm.station_control.interface.pydantic_base Classes PydanticBase Pydantic base model to change the behaviour of pydantic globally. Inheritance previous Me...",
    "content": "Pydantic related models and types. Full path: iqm.station_control.interface.pydantic_base Classes PydanticBase Pydantic base model to change the behaviour of pydantic globally. Inheritance previous Meta next PydanticBase \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 3.15. Last updated on 2025-04-15."
  }
]