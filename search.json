[
  {
    "package": "iqm-exa-common",
    "title": "API documentation: exa-common",
    "url": "/iqm-exa-common/index.html",
    "description": "26.25.0 2025-06-22 This documentation describes the common library of the Experiment Automation ( EXA ) project. exa-common contains classes and functions that are shared by EXA , Cortex and Station C...",
    "content": "26.25.0 2025-06-22 This documentation describes the common library of the Experiment Automation ( EXA ) project. exa-common contains classes and functions that are shared by EXA , Cortex and Station Control . Index Module Index Search Page next API Reference \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "API Reference",
    "url": "/iqm-exa-common/API.html",
    "description": "exa.common Shared errors, helpers, control structures, settings, API models etc. previous API documentation: exa-common next common \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated...",
    "content": "exa.common Shared errors, helpers, control structures, settings, API models etc. previous API documentation: exa-common next common \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "CHAD",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.CHAD.html",
    "description": "Bases: ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidate...",
    "content": "Bases: ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes computational_resonator_names Names of all the computational resonators declared in CHAD data. coupler_names Names of all the couplers declared in CHAD data. model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. probe_line_names Names of all the probe lines declared in CHAD data. qubit_names Names of all the qubits declared in CHAD data. mask_set_name  variant  components  Methods filter_qubit_components Filter qubit components from the input components. get_common_coupler_for Convenience method for getting the name of a coupler connecting a pair of components. get_component Get component by component name. get_coupler_mapping_for Get the coupler-component mapping for the couplers that connects to at least two components get_probe_line_mapping_for Get the probe line-component mapping. get_probe_line_names_for Get probe lines for given qubits in CHAD data. group_components_per_default_operations Groups given qubits/couplers based on their defined default operations. mask_set_name ( str ) \u2013 variant ( str ) \u2013 components ( Components ) \u2013 Get component by component name. component_name ( str ) \u2013 Component Names of all the qubits declared in CHAD data. Names of all the couplers declared in CHAD data. Names of all the probe lines declared in CHAD data. Names of all the computational resonators declared in CHAD data. Filter qubit components from the input components. component_names ( Collection [ str ] ) \u2013 list [ str ] Get probe lines for given qubits in CHAD data. component_names ( Collection [ str ] ) \u2013 list [ str ] Groups given qubits/couplers based on their defined default operations. The default operations that can be deducted from a CHAD are readout , drive , and flux . component_names ( Collection [ str ] ) \u2013 The component names to which to do the grouping.\nOther components present in the CHAD will not be included in the returned data. Tuple of qubits and couplers mapped to their connected default operations. The data is in the form of a dict with the keys being readout , drive , and flux ,\nand the values the list of component names having that particular operation. The data is in the form of a dict with the keys being readout , drive , and flux ,\nand the values the list of component names having that particular operation. tuple [ dict [ str , list [ str ]], dict [ str , list [ str ]]] in the given qubits. component_names ( Collection [ str ] ) \u2013 The qubit names. May contain any number of qubits. Coupler names mapped to the components they connect. - ValueError \u2013 If the provided qubit name list contains duplicates. dict [ str , list [ str ]] Get the probe line-component mapping. component_names ( Collection [ str ] ) \u2013 The qubit names. May contain any number of qubits. dict [ str , list [ str ]] Convenience method for getting the name of a coupler connecting a pair of components. first_component ( str ) \u2013 The name of the first component. second_component ( str ) \u2013 The name of the second component.\nThe order of qubits does not matter, i.e. the first_qubit and second_qubit arguments are interchangeable. The name of the coupler that connects the inputted components. The name of the coupler that connects the inputted components. - ValueError \u2013 If there were no couplers or more than one coupler connecting the component pair (the latter\n    should not be possible in a realistic chip). str Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous chad_model next Component \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "Components",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.Components.html",
    "description": "Bases: ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidate...",
    "content": "Bases: ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes all  model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. qubits  couplers  probe_lines  launchers  computational_resonators  Methods sort_components  qubit ( tuple [ Qubit , ... ] ) \u2013 tunable_coupler ( tuple [ Coupler , ... ] ) \u2013 probe_line ( tuple [ ProbeLine , ... ] ) \u2013 launcher ( tuple [ Launcher , ... ] ) \u2013 computational_resonator ( tuple [ ComputationalResonator , ... ] ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous Component next ComputationalResonator \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "immutable_base_model",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.immutable_base_model.html",
    "description": "Full path: exa.common.qcm_data.immutable_base_model Classes ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Inheritance previous FileAdapter next Imm...",
    "content": "Full path: exa.common.qcm_data.immutable_base_model Classes ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Inheritance previous FileAdapter next ImmutableBaseModel \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "Qubit",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.Qubit.html",
    "description": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form...",
    "content": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name  connections  Methods name ( str ) \u2013 connections ( tuple [ str , ... ] ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous ProbeLine next chip_topology \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.UnauthorizedError",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.UnauthorizedError.html",
    "description": "Error raised when the user is not authorized. message ( str ) \u2013 previous exa.common.errors.station_control_errors.StationControlError next exa.common.errors.station_control_errors.ValidationError \u00a9 Co...",
    "content": "Error raised when the user is not authorized. message ( str ) \u2013 previous exa.common.errors.station_control_errors.StationControlError next exa.common.errors.station_control_errors.ValidationError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "api",
    "url": "/iqm-exa-common/api/exa.common.api.html",
    "description": "API helpers. Full path: exa.common.api Subpackages and modules previous common next control \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22....",
    "content": "API helpers. Full path: exa.common.api Subpackages and modules previous common next control \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "sweep",
    "url": "/iqm-exa-common/api/exa.common.sweep.html",
    "description": "Sweep utilities. Full path: exa.common.sweep Subpackages and modules previous QCMDataClient next Changelog \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22....",
    "content": "Sweep utilities. Full path: exa.common.sweep Subpackages and modules previous QCMDataClient next Changelog \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.helpers.deprecation.format_deprecated",
    "url": "/iqm-exa-common/api/exa.common.helpers.deprecation.format_deprecated.html",
    "description": "old ( str ) \u2013 new ( str | None ) \u2013 since ( str ) \u2013 LiteralString previous deprecation next software_version_helper \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22....",
    "content": "old ( str ) \u2013 new ( str | None ) \u2013 since ( str ) \u2013 LiteralString previous deprecation next software_version_helper \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "logger",
    "url": "/iqm-exa-common/api/exa.common.logger.html",
    "description": "Helper to initialize loggers to the specified logging level. Full path: exa.common.logger Subpackages and modules logger  previous exa.common.helpers.software_version_helper.get_vcs_description next l...",
    "content": "Helper to initialize loggers to the specified logging level. Full path: exa.common.logger Subpackages and modules logger  previous exa.common.helpers.software_version_helper.get_vcs_description next logger \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.BadRequestError",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.BadRequestError.html",
    "description": "Error raised when the request syntax is invalid or the method is unsupported in general. message ( str ) \u2013 previous exa.common.errors.station_control_errors.BadGatewayError next exa.common.errors.stat...",
    "content": "Error raised when the request syntax is invalid or the method is unsupported in general. message ( str ) \u2013 previous exa.common.errors.station_control_errors.BadGatewayError next exa.common.errors.station_control_errors.ConflictError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "station_control_errors",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.html",
    "description": "Errors used in the station control client-server communication. Full path: exa.common.errors.station_control_errors Functions map_from_error_to_status_code (error) Map a StationControlError to an HTTP...",
    "content": "Errors used in the station control client-server communication. Full path: exa.common.errors.station_control_errors Functions map_from_error_to_status_code (error) Map a StationControlError to an HTTPStatus code. map_from_status_code_to_error (status_code) Map an HTTPStatus code to a StationControlError. Exceptions BadGatewayError (message,\u00a0*args) Error raised when there are invalid responses from another server/proxy. BadRequestError (message,\u00a0*args) Error raised when the request syntax is invalid or the method is unsupported in general. ConflictError (message,\u00a0*args) This error happens when there is a conflict with the current state of the resource. ForbiddenError (message,\u00a0*args) Error raised when the operation is forbidden for the user. GatewayTimeoutError (message,\u00a0*args) Error raised when the gateway server did not receive a timely response. InternalServerError (message,\u00a0*args) Error raised when an unexpected error happened on the server side. NotFoundError (message,\u00a0*args) Error raised when nothing was found with the given parameters. ServiceUnavailableError (message,\u00a0*args) Error raised when the service is unavailable. StationControlError (message,\u00a0*args) Base class for station control errors. UnauthorizedError (message,\u00a0*args) Error raised when the user is not authorized. ValidationError (message,\u00a0*args) Error raised when something is unprocessable in general, for example if the input value is not acceptable. previous exa.common.errors.exa_error.UnknownSettingError next exa.common.errors.station_control_errors.map_from_error_to_status_code \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa_error",
    "url": "/iqm-exa-common/api/exa.common.errors.exa_error.html",
    "description": "Full path: exa.common.errors.exa_error Exceptions EmptyComponentListError (message,\u00a0*args) Error raised when an empty list is given as components for running an experiment. ExaError (message,\u00a0*args) B...",
    "content": "Full path: exa.common.errors.exa_error Exceptions EmptyComponentListError (message,\u00a0*args) Error raised when an empty list is given as components for running an experiment. ExaError (message,\u00a0*args) Base class for exa errors. InvalidSweepOptionsTypeError (**kwargs) The type of sweep options is invalid. UnknownSettingError (message,\u00a0*args) This SettingNode does not have a given key. previous errors next exa.common.errors.exa_error.EmptyComponentListError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.qcm_data.chip_topology.sort_components",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chip_topology.sort_components.html",
    "description": "Sort the given components in a human-readable way. components ( Iterable [ str ] ) \u2013 list [ str ] previous chip_topology next exa.common.qcm_data.chip_topology.sort_couplers \u00a9 Copyright 2019-2025, IQM...",
    "content": "Sort the given components in a human-readable way. components ( Iterable [ str ] ) \u2013 list [ str ] previous chip_topology next exa.common.qcm_data.chip_topology.sort_couplers \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.logger.logger.init_loggers",
    "url": "/iqm-exa-common/api/exa.common.logger.logger.init_loggers.html",
    "description": "Set the log level of given logger names. Logs with INFO or DEBUG logging levels are written into stdout, and logs with other levels are written into stderr. By default, the root logger uses WARNING le...",
    "content": "Set the log level of given logger names. Logs with INFO or DEBUG logging levels are written into stdout, and logs with other levels are written into stderr. By default, the root logger uses WARNING level. See Python\u2019s logging module for possible logging levels. loggers ( dict [ str , str | None ] | None ) \u2013 A mapping from logger name to (case insensitive) logging level. If logging level is None or empty\nstring, default_level will be used for that logger. It is possible to fine tune logging for individual\nmodules, since logger propagation is turned off. Overriding works both ways: a parent logger can have higher\nlogging level than its descendants, and vice versa.\nFor example, {\"sqlalchemy\": None, \"sqlalchemy.engine\": \"debug\"} will put\n\u201csqlalchemy\u201d and its descendants (i.e. \u201csqlalchemy.dialects\u201d, \u201csqlalchemy.dialects.sqlite\u201d, etc.) into default_level , except for \u201csqlalchemy.engine\u201d for which DEBUG level is defined.\nFor the root logger, use empty string key, for example: {\"\": \"INFO\"} .\nIf empty dict or None is given, only the root logger will be initialized to its default WARNING level. default_level ( str ) \u2013 The default level (case insensitive) to be used for logger names given with loggers for which a level is not specified. verbose ( bool ) \u2013 If False, :const: BRIEF format will be used for log messages, otherwise :const: VERBOSE . extra_info_getter ( Callable [ [ ] , str ] | None ) \u2013 Optional callable to convey extra information to log messages. It will get called before\neach log message emission and the output will get appended to the log message. None previous logger next ExtraFormatter \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "chad_model",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.html",
    "description": "Pydantic models for CHAD. Full path: exa.common.qcm_data.chad_model Classes CHAD Create a new model by parsing and validating input data from keyword arguments. Component Create a new model by parsing...",
    "content": "Pydantic models for CHAD. Full path: exa.common.qcm_data.chad_model Classes CHAD Create a new model by parsing and validating input data from keyword arguments. Component Create a new model by parsing and validating input data from keyword arguments. Components Create a new model by parsing and validating input data from keyword arguments. ComputationalResonator Create a new model by parsing and validating input data from keyword arguments. Coupler Create a new model by parsing and validating input data from keyword arguments. Launcher Create a new model by parsing and validating input data from keyword arguments. ProbeLine Create a new model by parsing and validating input data from keyword arguments. Qubit Create a new model by parsing and validating input data from keyword arguments. Inheritance previous qcm_data next CHAD \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.map_from_status_code_to_error",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.map_from_status_code_to_error.html",
    "description": "Map an HTTPStatus code to a StationControlError. status_code ( HTTPStatus ) \u2013 type [ StationControlError ] previous exa.common.errors.station_control_errors.map_from_error_to_status_code next exa.comm...",
    "content": "Map an HTTPStatus code to a StationControlError. status_code ( HTTPStatus ) \u2013 type [ StationControlError ] previous exa.common.errors.station_control_errors.map_from_error_to_status_code next exa.common.errors.station_control_errors.BadGatewayError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "BaseModel",
    "url": "/iqm-exa-common/api/exa.common.data.base_model.BaseModel.html",
    "description": "Bases: BaseModel Pydantic base model to change the behaviour of pydantic globally.\nNote that setting model_config in child classes will merge the configs rather than override this one. https://docs.py...",
    "content": "Bases: BaseModel Pydantic base model to change the behaviour of pydantic globally.\nNote that setting model_config in child classes will merge the configs rather than override this one. https://docs.pydantic.dev/latest/concepts/config/#change-behaviour-globally Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.data.base_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Methods copy Returns a copy of the model. model_copy Returns a copy of the model. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Returns a copy of the model. Overrides the Pydantic default \u2018model_copy\u2019 to set \u2018deep=True\u2019 by default. update ( dict [ str , Any ] | None ) \u2013 deep ( bool ) \u2013 Self Returns a copy of the model. Self previous base_model next errors \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "sweep",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.html",
    "description": "Classes for sweep specification. Full path: exa.common.control.sweep Subpackages and modules previous control next data \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-...",
    "content": "Classes for sweep specification. Full path: exa.common.control.sweep Subpackages and modules previous control next data \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.qcm_data.chip_topology.sort_couplers",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chip_topology.sort_couplers.html",
    "description": "Sort the given couplers in a human-readable way. couplers ( Iterable [ str ] ) \u2013 list [ str ] previous exa.common.qcm_data.chip_topology.sort_components next ChipTopology \u00a9 Copyright 2019-2025, IQM Fi...",
    "content": "Sort the given couplers in a human-readable way. couplers ( Iterable [ str ] ) \u2013 list [ str ] previous exa.common.qcm_data.chip_topology.sort_components next ChipTopology \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "Launcher",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.Launcher.html",
    "description": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form...",
    "content": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. pin  function  name  connections  Methods name ( str ) \u2013 connections ( tuple [ str , ... ] ) \u2013 pin ( str ) \u2013 function ( str ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous Coupler next ProbeLine \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.InternalServerError",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.InternalServerError.html",
    "description": "Error raised when an unexpected error happened on the server side. This error should never be raised when something expected happens,\nand whenever the client encounters this, it should be considered a...",
    "content": "Error raised when an unexpected error happened on the server side. This error should never be raised when something expected happens,\nand whenever the client encounters this, it should be considered as a server bug. message ( str ) \u2013 previous exa.common.errors.station_control_errors.GatewayTimeoutError next exa.common.errors.station_control_errors.NotFoundError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "errors",
    "url": "/iqm-exa-common/api/exa.common.errors.html",
    "description": "Common error messages. Full path: exa.common.errors Subpackages and modules exa_error  station_control_errors Errors used in the station control client-server communication. previous BaseModel next ex...",
    "content": "Common error messages. Full path: exa.common.errors Subpackages and modules exa_error  station_control_errors Errors used in the station control client-server communication. previous BaseModel next exa_error \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "QCMDataClient",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.qcm_data_client.QCMDataClient.html",
    "description": "Bases: object Python client for QCM (Quantum Computer Management) Data API. root_url ( str ) \u2013 URL pointing to QCM Data service.\nThis URL can point to a local file storage as well.\nIn that case, the U...",
    "content": "Bases: object Python client for QCM (Quantum Computer Management) Data API. root_url ( str ) \u2013 URL pointing to QCM Data service.\nThis URL can point to a local file storage as well.\nIn that case, the URL should point to a directory which\nhas a directory structure identical to QCM Data service (for example /chip-data-records/),\nand files containing data in identical format returned by QCM Data service.\nFor example, CHAD files should be named {chip_label}.json, like M156_W531_A09_L09.json, and contain\na list instead of a single object. fallback_root_url ( str ) \u2013 Same as root_url , used if a query via root_url returns nothing. Module: exa.common.qcm_data.qcm_data_client Attributes root_url Returns the remote QCM Data service URL. Methods get_chip_design_record Get a raw chip design record matching the given chip label. Returns the remote QCM Data service URL. Get a raw chip design record matching the given chip label. chip_label ( str ) \u2013 Chip label. Data record matching the given chip label. dict previous qcm_data_client next sweep \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "base_model",
    "url": "/iqm-exa-common/api/exa.common.data.base_model.html",
    "description": "Full path: exa.common.data.base_model Classes BaseModel Pydantic base model to change the behaviour of pydantic globally. Inheritance previous data next BaseModel \u00a9 Copyright 2019-2025, IQM Finland Oy...",
    "content": "Full path: exa.common.data.base_model Classes BaseModel Pydantic base model to change the behaviour of pydantic globally. Inheritance previous data next BaseModel \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "common",
    "url": "/iqm-exa-common/api/exa.common.html",
    "description": "Shared errors, helpers, control structures, settings, API models etc. Full path: exa.common Subpackages and modules api API helpers. control Common data structures of abstract instrument control. data...",
    "content": "Shared errors, helpers, control structures, settings, API models etc. Full path: exa.common Subpackages and modules api API helpers. control Common data structures of abstract instrument control. data Classes for representing physical quantities and instrument settings. errors Common error messages. helpers Miscellaneous helper functionality. logger Helper to initialize loggers to the specified logging level. qcm_data  sweep Sweep utilities. previous API Reference next api \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "control",
    "url": "/iqm-exa-common/api/exa.common.control.html",
    "description": "Common data structures of abstract instrument control. Full path: exa.common.control Subpackages and modules sweep Classes for sweep specification. previous api next sweep \u00a9 Copyright 2019-2025, IQM F...",
    "content": "Common data structures of abstract instrument control. Full path: exa.common.control Subpackages and modules sweep Classes for sweep specification. previous api next sweep \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.ValidationError",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.ValidationError.html",
    "description": "Error raised when something is unprocessable in general, for example if the input value is not acceptable. message ( str ) \u2013 previous exa.common.errors.station_control_errors.UnauthorizedError next he...",
    "content": "Error raised when something is unprocessable in general, for example if the input value is not acceptable. message ( str ) \u2013 previous exa.common.errors.station_control_errors.UnauthorizedError next helpers \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.BadGatewayError",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.BadGatewayError.html",
    "description": "Error raised when there are invalid responses from another server/proxy. message ( str ) \u2013 previous exa.common.errors.station_control_errors.map_from_status_code_to_error next exa.common.errors.statio...",
    "content": "Error raised when there are invalid responses from another server/proxy. message ( str ) \u2013 previous exa.common.errors.station_control_errors.map_from_status_code_to_error next exa.common.errors.station_control_errors.BadRequestError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "helpers",
    "url": "/iqm-exa-common/api/exa.common.helpers.html",
    "description": "Miscellaneous helper functionality. Full path: exa.common.helpers Subpackages and modules deprecation  software_version_helper  previous exa.common.errors.station_control_errors.ValidationError next d...",
    "content": "Miscellaneous helper functionality. Full path: exa.common.helpers Subpackages and modules deprecation  software_version_helper  previous exa.common.errors.station_control_errors.ValidationError next deprecation \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "ImmutableBaseModel",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.immutable_base_model.ImmutableBaseModel.html",
    "description": "Bases: BaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form...",
    "content": "Bases: BaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.immutable_base_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Methods Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous immutable_base_model next qcm_data_client \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "deprecation",
    "url": "/iqm-exa-common/api/exa.common.helpers.deprecation.html",
    "description": "Full path: exa.common.helpers.deprecation Functions format_deprecated (old,\u00a0new,\u00a0since)  previous helpers next exa.common.helpers.deprecation.format_deprecated \u00a9 Copyright 2019-2025, IQM Finland Oy, R...",
    "content": "Full path: exa.common.helpers.deprecation Functions format_deprecated (old,\u00a0new,\u00a0since)  previous helpers next exa.common.helpers.deprecation.format_deprecated \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.helpers.software_version_helper.get_all_software_versions",
    "url": "/iqm-exa-common/api/exa.common.helpers.software_version_helper.get_all_software_versions.html",
    "description": "Get all available software version information. Currently, this function collects all Python package versions and Python interpreter version. reload_module ( bool ) \u2013 Whether to reload the pkg_resourc...",
    "content": "Get all available software version information. Currently, this function collects all Python package versions and Python interpreter version. reload_module ( bool ) \u2013 Whether to reload the pkg_resources module or not. By default,\nit is disabled because reloading the module is not thread safe!\nThis function should be called with reload_module=True when IPython autoreload is in use. dict [ str , str ] Example You have numpy==1.21.0 installed, and in the notebook you have executed the following IPython magic: You install numpy==1.21.1 You call this function with reload_module=False . This will result in some warning printouts and\nthe function will succeed by returning 1.21.0 for numpy, which is wrong because in reality IPython\nautoreload has reloaded the newly installed numpy 1.21.1.\nWith reload_module=True the correct version 1.21.1 is returned and no warnings are printed. information. A package\u2019s version information contains the base version, and the string\n\u201c(local editable)\u201d in the case the package is a local editable installation. previous software_version_helper next exa.common.helpers.software_version_helper.get_vcs_description \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.helpers.software_version_helper.get_vcs_description",
    "url": "/iqm-exa-common/api/exa.common.helpers.software_version_helper.get_vcs_description.html",
    "description": "Get Version Control System (VCS) description for the caller\u2019s current working directory. The description is used to verify if a directory is installed under VCS and whether changes to the files have\nb...",
    "content": "Get Version Control System (VCS) description for the caller\u2019s current working directory. The description is used to verify if a directory is installed under VCS and whether changes to the files have\nbeen made. First, the existence of .git directory will be checked from root_directory .\nOnly if it exists, a git command is executed in a subprocess with a timeout\nof 1 seconds as the best effort only. The path to the directory where the command will be executed. For instance when called from\nexa-experiment, it can be the exa-experiment root directory or any directory under it. If root_directory is not installed under git, None will be returned. Otherwise, the output of git describe --dirty --tags --long is returned. In case of errors in executing the command, the caught subprocess.CalledProcessError will be converted to string and returned. If the command fails or timeouts , an exception will be raised directly from subprocess.check_output. \u2013 root_directory ( str ) \u2013 str | None previous exa.common.helpers.software_version_helper.get_all_software_versions next logger \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "chip_topology",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chip_topology.html",
    "description": "Chip topology class for parsing CHAD and other QPU related data into human-usable form. Full path: exa.common.qcm_data.chip_topology Functions sort_components (components) Sort the given components in...",
    "content": "Chip topology class for parsing CHAD and other QPU related data into human-usable form. Full path: exa.common.qcm_data.chip_topology Functions sort_components (components) Sort the given components in a human-readable way. sort_couplers (couplers) Sort the given couplers in a human-readable way. Classes ChipTopology Topology information for a chip (typically a QPU). Inheritance previous Qubit next exa.common.qcm_data.chip_topology.sort_components \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "ExtraFormatter",
    "url": "/iqm-exa-common/api/exa.common.logger.logger.ExtraFormatter.html",
    "description": "Bases: Formatter Helper formatter class to pass in arbitrary extra information to log messages. Initialize the formatter with specified format strings. Initialize the formatter either with the specifi...",
    "content": "Bases: Formatter Helper formatter class to pass in arbitrary extra information to log messages. Initialize the formatter with specified format strings. Initialize the formatter either with the specified format string, or a\ndefault as described above. Allow for specialized date formatting with\nthe optional datefmt argument. If datefmt is omitted, you get an\nISO8601-like (or RFC 3339-like) format. Use a style parameter of \u2018%\u2019, \u2018{\u2019 or \u2018$\u2019 to specify that you want to\nuse one of %-formatting, str.format() ( {} ) formatting or string.Template formatting in your format string. Changed in version 3.2: Added the style parameter. Module: exa.common.logger.logger Attributes Methods format Format the specified record as text. extra_info_getter ( Callable [ [ ] , str ] | None ) \u2013 Format the specified record as text. The record\u2019s attribute dictionary is used as the operand to a\nstring formatting operation which yields the returned string.\nBefore formatting the dictionary, a couple of preparatory steps\nare carried out. The message attribute of the record is computed\nusing LogRecord.getMessage(). If the formatting string uses the\ntime (as determined by a call to usesTime(), formatTime() is\ncalled to format the event time. If there is exception information,\nit is formatted using formatException() and appended to the message. previous exa.common.logger.logger.init_loggers next InfoFilter \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "data",
    "url": "/iqm-exa-common/api/exa.common.data.html",
    "description": "Classes for representing physical quantities and instrument settings. Full path: exa.common.data Subpackages and modules base_model  previous sweep next base_model \u00a9 Copyright 2019-2025, IQM Finland O...",
    "content": "Classes for representing physical quantities and instrument settings. Full path: exa.common.data Subpackages and modules base_model  previous sweep next base_model \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "qcm_data",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.html",
    "description": "Full path: exa.common.qcm_data Subpackages and modules chad_model Pydantic models for CHAD. chip_topology Chip topology class for parsing CHAD and other QPU related data into human-usable form. file_a...",
    "content": "Full path: exa.common.qcm_data Subpackages and modules chad_model Pydantic models for CHAD. chip_topology Chip topology class for parsing CHAD and other QPU related data into human-usable form. file_adapter  immutable_base_model  qcm_data_client QCM (Quantum Computer Management) Data API client implementation. previous InfoFilter next chad_model \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.NotFoundError",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.NotFoundError.html",
    "description": "Error raised when nothing was found with the given parameters. This should be used when it\u2019s expected that something is found, for example when trying to find with an exact ID. message ( str ) \u2013 previ...",
    "content": "Error raised when nothing was found with the given parameters. This should be used when it\u2019s expected that something is found, for example when trying to find with an exact ID. message ( str ) \u2013 previous exa.common.errors.station_control_errors.InternalServerError next exa.common.errors.station_control_errors.ServiceUnavailableError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "qcm_data_client",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.qcm_data_client.html",
    "description": "QCM (Quantum Computer Management) Data API client implementation. Full path: exa.common.qcm_data.qcm_data_client Classes QCMDataClient Python client for QCM (Quantum Computer Management) Data API. Inh...",
    "content": "QCM (Quantum Computer Management) Data API client implementation. Full path: exa.common.qcm_data.qcm_data_client Classes QCMDataClient Python client for QCM (Quantum Computer Management) Data API. Inheritance previous ImmutableBaseModel next QCMDataClient \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "logger",
    "url": "/iqm-exa-common/api/exa.common.logger.logger.html",
    "description": "Full path: exa.common.logger.logger Functions init_loggers ([loggers,\u00a0default_level,\u00a0...]) Set the log level of given logger names. Classes ExtraFormatter Helper formatter class to pass in arbitrary e...",
    "content": "Full path: exa.common.logger.logger Functions init_loggers ([loggers,\u00a0default_level,\u00a0...]) Set the log level of given logger names. Classes ExtraFormatter Helper formatter class to pass in arbitrary extra information to log messages. InfoFilter Helper class to filter log messages above INFO level. Inheritance previous logger next exa.common.logger.logger.init_loggers \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.GatewayTimeoutError",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.GatewayTimeoutError.html",
    "description": "Error raised when the gateway server did not receive a timely response. message ( str ) \u2013 previous exa.common.errors.station_control_errors.ForbiddenError next exa.common.errors.station_control_errors...",
    "content": "Error raised when the gateway server did not receive a timely response. message ( str ) \u2013 previous exa.common.errors.station_control_errors.ForbiddenError next exa.common.errors.station_control_errors.InternalServerError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "InfoFilter",
    "url": "/iqm-exa-common/api/exa.common.logger.logger.InfoFilter.html",
    "description": "Bases: Filter Helper class to filter log messages above INFO level. Initialize a filter. Initialize with the name of the logger which, together with its\nchildren, will have its events allowed through ...",
    "content": "Bases: Filter Helper class to filter log messages above INFO level. Initialize a filter. Initialize with the name of the logger which, together with its\nchildren, will have its events allowed through the filter. If no\nname is specified, allow every event. Module: exa.common.logger.logger Methods filter Determine if the specified record is to be logged. Determine if the specified record is to be logged. Returns True if the record should be logged, or False otherwise.\nIf deemed appropriate, the record may be modified in-place. record ( LogRecord ) \u2013 bool previous ExtraFormatter next qcm_data \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "file_adapter",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.file_adapter.html",
    "description": "Full path: exa.common.qcm_data.file_adapter Classes FileAdapter  Inheritance previous ChipTopology next FileAdapter \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22....",
    "content": "Full path: exa.common.qcm_data.file_adapter Classes FileAdapter  Inheritance previous ChipTopology next FileAdapter \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "ComputationalResonator",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.ComputationalResonator.html",
    "description": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form...",
    "content": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name  connections  Methods name ( str ) \u2013 connections ( tuple [ str , ... ] ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous Components next Coupler \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "Coupler",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.Coupler.html",
    "description": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form...",
    "content": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name  connections  Methods name ( str ) \u2013 connections ( tuple [ str , ... ] ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous ComputationalResonator next Launcher \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "Component",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.Component.html",
    "description": "Bases: ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidate...",
    "content": "Bases: ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name  connections  Methods sort  name ( str ) \u2013 connections ( tuple [ str , ... ] ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous CHAD next Components \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.exa_error.InvalidSweepOptionsTypeError",
    "url": "/iqm-exa-common/api/exa.common.errors.exa_error.InvalidSweepOptionsTypeError.html",
    "description": "The type of sweep options is invalid. previous exa.common.errors.exa_error.ExaError next exa.common.errors.exa_error.UnknownSettingError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last up...",
    "content": "The type of sweep options is invalid. previous exa.common.errors.exa_error.ExaError next exa.common.errors.exa_error.UnknownSettingError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.ForbiddenError",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.ForbiddenError.html",
    "description": "Error raised when the operation is forbidden for the user. message ( str ) \u2013 previous exa.common.errors.station_control_errors.ConflictError next exa.common.errors.station_control_errors.GatewayTimeou...",
    "content": "Error raised when the operation is forbidden for the user. message ( str ) \u2013 previous exa.common.errors.station_control_errors.ConflictError next exa.common.errors.station_control_errors.GatewayTimeoutError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.StationControlError",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.StationControlError.html",
    "description": "Base class for station control errors. message ( str ) \u2013 previous exa.common.errors.station_control_errors.ServiceUnavailableError next exa.common.errors.station_control_errors.UnauthorizedError \u00a9 Cop...",
    "content": "Base class for station control errors. message ( str ) \u2013 previous exa.common.errors.station_control_errors.ServiceUnavailableError next exa.common.errors.station_control_errors.UnauthorizedError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.exa_error.ExaError",
    "url": "/iqm-exa-common/api/exa.common.errors.exa_error.ExaError.html",
    "description": "Base class for exa errors. message ( str ) \u2013 Error message. previous exa.common.errors.exa_error.EmptyComponentListError next exa.common.errors.exa_error.InvalidSweepOptionsTypeError \u00a9 Copyright 2019-...",
    "content": "Base class for exa errors. message ( str ) \u2013 Error message. previous exa.common.errors.exa_error.EmptyComponentListError next exa.common.errors.exa_error.InvalidSweepOptionsTypeError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.ConflictError",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.ConflictError.html",
    "description": "This error happens when there is a conflict with the current state of the resource. For example, when doing duplicate submissions for the same unique data. message ( str ) \u2013 previous exa.common.errors...",
    "content": "This error happens when there is a conflict with the current state of the resource. For example, when doing duplicate submissions for the same unique data. message ( str ) \u2013 previous exa.common.errors.station_control_errors.BadRequestError next exa.common.errors.station_control_errors.ForbiddenError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "software_version_helper",
    "url": "/iqm-exa-common/api/exa.common.helpers.software_version_helper.html",
    "description": "Full path: exa.common.helpers.software_version_helper Functions get_all_software_versions ([reload_module]) Get all available software version information. get_vcs_description (root_directory) Get Ver...",
    "content": "Full path: exa.common.helpers.software_version_helper Functions get_all_software_versions ([reload_module]) Get all available software version information. get_vcs_description (root_directory) Get Version Control System (VCS) description for the caller's current working directory. previous exa.common.helpers.deprecation.format_deprecated next exa.common.helpers.software_version_helper.get_all_software_versions \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.ServiceUnavailableError",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.ServiceUnavailableError.html",
    "description": "Error raised when the service is unavailable. message ( str ) \u2013 previous exa.common.errors.station_control_errors.NotFoundError next exa.common.errors.station_control_errors.StationControlError \u00a9 Copy...",
    "content": "Error raised when the service is unavailable. message ( str ) \u2013 previous exa.common.errors.station_control_errors.NotFoundError next exa.common.errors.station_control_errors.StationControlError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "ChipTopology",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chip_topology.ChipTopology.html",
    "description": "Bases: object Topology information for a chip (typically a QPU). Can represent the information found in a CHAD, as well as locus mappings for gates. qubits ( Iterable [ str ] ) \u2013 names of the qubits. ...",
    "content": "Bases: object Topology information for a chip (typically a QPU). Can represent the information found in a CHAD, as well as locus mappings for gates. qubits ( Iterable [ str ] ) \u2013 names of the qubits. computational_resonators ( Iterable [ str ] ) \u2013 names of the computational resonators. couplers ( dict [ str , Iterable [ str ] ] ) \u2013 mapping from coupler name to names of chip components it connects to. probe_lines ( dict [ str , Iterable [ str ] ] ) \u2013 mapping from probe line name to names of chip components it connects to. variant ( str ) \u2013 identifier of the QPU design variant. Module: exa.common.qcm_data.chip_topology Attributes computational_resonators Computational resonators on the chip, in any order. computational_resonators_sorted Computational resonators on the chip, sorted. couplers Tunable couplers on the chip, in any order. couplers_sorted Tunable couplers on the chip, sorted by numerical IDs. probe_lines Probe lines on the chip, in any order. probe_lines_sorted Probe lines on the chip, sorted. all_components All components on the chip. coupler_to_components Map from each coupler to all other components it connects to. component_to_couplers Map from each component to all couplers connected to it. probe_line_to_components Map from each probe line to all components it connects to. component_to_probe_line Map from each component to the probeline connected to it. Methods from_chad Construct a ChipTopology instance from a CHAD. from_chip_design_record Construct a ChipTopology instance from a raw Chip design record. get_all_common_resonators Computational resonators connected to all the given qubits via a coupler. get_common_computational_resonator Convenience method for getting the name of a computational resonator which is connected to both specified qubit components via tunable couplers. get_connected_coupler_map Returns a ComponentMap , including only the couplers between components that both are in the given subset. get_connected_probe_lines Get probelines that are connected to any of the given components. get_connecting_couplers Couplers that only connect to the given chip components, and connect at least two of them. get_coupler_for Common coupler for the given chip components (e.g. qubit or computational resonator). get_loci Gives all the loci of a given gate. get_neighbor_couplers Couplers that connect to at least one of the given chip components. get_neighbor_locus_components Chip components that are connected to the given components by a coupler, but not included in them. is_computational_resonator True iff the given component is a computational resonator. is_coupler True iff the given component is a coupler. is_probe_line True iff the given component is a probe line. is_qubit True iff the given component is a qubit. limit_values Prunes the given dictionary (e.g. a coupler-to-qubits map) to a subset of values. map_locus Returns the mapped components for the given locus and the given gate. map_to_locus Returns the locus that is mapped to the given components. set_locus_mapping Add a custom mapping from a gate locus to a set of components required for the gate operation. Computational resonators on the chip, in any order. Computational resonators on the chip, sorted. Tunable couplers on the chip, in any order. Tunable couplers on the chip, sorted by numerical IDs. Probe lines on the chip, in any order. Probe lines on the chip, sorted. All components on the chip. Map from each coupler to all other components it connects to. The values are sorted. Map from each component to all couplers connected to it. Map from each probe line to all components it connects to. Map from each component to the probeline connected to it.\nMax 1 connection per component is assumed.\nComponents without connection to a probe line don\u2019t appear. Construct a ChipTopology instance from a raw Chip design record. record ( dict ) \u2013 Record as returned by Station control. Corresponding chip topology ChipTopology Construct a ChipTopology instance from a CHAD. Use from_chip_design_record() if possible. chad ( CHAD ) \u2013 parsed CHAD model corresponding chip topology ChipTopology Couplers that connect to at least one of the given chip components. components ( Iterable [ str ] ) \u2013 some chip components, typically qubits and computational resonators couplers that connect to at least one of components set [ str ] Couplers that only connect to the given chip components, and connect at least two of them. Equivalent to returning the edges in the components -induced\nsubgraph of the coupling topology. components ( Collection [ str ] ) \u2013 some chip components, typically qubits and computational resonators couplers that connect to only members of components , and to at least two of them set [ str ] Common coupler for the given chip components (e.g. qubit or computational resonator). component_1 ( str ) \u2013 first component component_2 ( str ) \u2013 second component the common coupler ValueError \u2013 the given components have zero or more than one connecting coupler str Chip components that are connected to the given components by a coupler, but not included in them. components ( Collection [ str ] ) \u2013 some chip components, typically qubits and computational resonators components that are connected to components by a coupler, but not included in them set [ str ] Get probelines that are connected to any of the given components. components ( Collection [ str ] ) \u2013 set [ str ] Returns a ComponentMap , including only the couplers between components that both are in the given subset. components ( Collection [ str ] ) \u2013 Collection of coupled components to restrict the returned couplers. A ComponentMap , a dict mapping coupler names to the names of the coupled components. ComponentMap Prunes the given dictionary (e.g. a coupler-to-qubits map) to a subset of values. Used to prune e.g. coupler_to_components to a subset of relevant elements. dct ( ComponentMap ) \u2013 Dictionary of collections of values. limit_to ( Collection [ str ] ) \u2013 Components to limit the output to. The input dictionary, but only with key-value pairs where the value intersects with limit_to . ComponentMap True iff the given component is a qubit. component ( str ) \u2013 bool True iff the given component is a coupler. component ( str ) \u2013 bool True iff the given component is a probe line. component ( str ) \u2013 bool True iff the given component is a computational resonator. component ( str ) \u2013 bool Add a custom mapping from a gate locus to a set of components required for the gate operation. The mapping is of the form {<locus>: <components mapped to locus>}, where a locus can be mapped to one or more\ncomponents. The locus itself can be a frozenset (denoting a symmetric gate) or a tuple (non-symmetric gate). Some examples:\n- DEFAULT_2QB_MAPPING (added in __init__() ) maps pairs of qubits to their common coupler symmetrically.\n- Fast flux CZ-gate maps pairs of qubits to their couplers non-symmetrically (first locus qubit can perform flux pulses).\n- A two-qubit gate implementation that includes playing pulses on neighboring components in addition to the connecting coupler. name ( str ) \u2013 The name for the gate & implementation this locus mapping represents (typically in the format \"<gate name>.<implementation name>\" ). mapping ( dict [ tuple [ str , ... ] | frozenset [ str ] , tuple [ str , ... ] ] ) \u2013 The locus mapping to be added. None Validate that the components given in mapping are found in self and the mapping is correctly formed. mapping ( dict [ str | tuple [ str ] , tuple [ str , ... ] | frozenset [ str ] ] | None ) \u2013 None Returns the mapped components for the given locus and the given gate. If the locus or the gate is not found from the locus mappings of self, returns None. locus ( tuple [ str , ... ] | frozenset [ str ] ) \u2013 The locus to map. name ( str | None ) \u2013 The name for the gate & implementation with which to map the locus (typically in the format \"<gate name>.<implementation name>\" ). The components mapped to the given locus or None if locus is not found in the given mapping. str | tuple [ str ] | None Returns the locus that is mapped to the given components. mapped ( str | tuple [ str ] ) \u2013 The mapped components. name ( str ) \u2013 The name for the gate & implementation with which to map the locus (typically in the format \"<gate name>.<implementation name>\" ). The locus mapped to the given components or None if the components are not mapped to any locus. tuple [ str , \u2026] | frozenset [ str ] | None Gives all the loci of a given gate. If no mapping with the given the name nor a default mapping with the given dimensionality is found,\nreturns an empty list. name ( str ) \u2013 The name for the gate & implementation with which to map the locus (typically in the format \"<gate name>.<implementation name>\" ). default_mapping_dimension ( int | None ) \u2013 If provided, will return the loci of the default mapping of the given\ndimensionality in case no mapping for name can be found. The loci associated with the given gate. list [ tuple [ str , \u2026] | frozenset [ str ]] Convenience method for getting the name of a computational resonator which is connected to both specified\nqubit components via tunable couplers. first_qubit ( str ) \u2013 The name of the first qubit. second_qubit ( str ) \u2013 The name of the second qubit. The order of qubits does not matter, i.e. the first_qubit and second_qubit arguments are interchangeable. The name of the second qubit. The order of qubits does not matter, i.e. the first_qubit and second_qubit arguments are interchangeable. The name of the computational resonator that is connected to both inputted qubits via tunable couplers. The name of the computational resonator that is connected to both inputted qubits via tunable couplers. - ValueError \u2013 If no computational resonator was found that is connected to both qubits via tunable couplers. \u2013 str Computational resonators connected to all the given qubits via a coupler. qubits ( list [ str ] ) \u2013 Qubit names. Names of the computational resonators neighboring all of qubits (can be an empty set). set [ str ] previous exa.common.qcm_data.chip_topology.sort_couplers next file_adapter \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.map_from_error_to_status_code",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.map_from_error_to_status_code.html",
    "description": "Map a StationControlError to an HTTPStatus code. error ( StationControlError ) \u2013 HTTPStatus previous station_control_errors next exa.common.errors.station_control_errors.map_from_status_code_to_error ...",
    "content": "Map a StationControlError to an HTTPStatus code. error ( StationControlError ) \u2013 HTTPStatus previous station_control_errors next exa.common.errors.station_control_errors.map_from_status_code_to_error \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "ProbeLine",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.ProbeLine.html",
    "description": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form...",
    "content": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name  connections  Methods name ( str ) \u2013 connections ( tuple [ str , ... ] ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous Launcher next Qubit \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.exa_error.UnknownSettingError",
    "url": "/iqm-exa-common/api/exa.common.errors.exa_error.UnknownSettingError.html",
    "description": "This SettingNode does not have a given key. message ( str ) \u2013 previous exa.common.errors.exa_error.InvalidSweepOptionsTypeError next station_control_errors \u00a9 Copyright 2019-2025, IQM Finland Oy, Relea...",
    "content": "This SettingNode does not have a given key. message ( str ) \u2013 previous exa.common.errors.exa_error.InvalidSweepOptionsTypeError next station_control_errors \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.exa_error.EmptyComponentListError",
    "url": "/iqm-exa-common/api/exa.common.errors.exa_error.EmptyComponentListError.html",
    "description": "Error raised when an empty list is given as components for running an experiment. message ( str ) \u2013 previous exa_error next exa.common.errors.exa_error.ExaError \u00a9 Copyright 2019-2025, IQM Finland Oy, ...",
    "content": "Error raised when an empty list is given as components for running an experiment. message ( str ) \u2013 previous exa_error next exa.common.errors.exa_error.ExaError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-exa-common",
    "title": "FileAdapter",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.file_adapter.FileAdapter.html",
    "description": "Bases: BaseAdapter Module: exa.common.qcm_data.file_adapter Methods close Cleans up adapter specific items. send Sends PreparedRequest object. Sends PreparedRequest object. Returns Response object. Cl...",
    "content": "Bases: BaseAdapter Module: exa.common.qcm_data.file_adapter Methods close Cleans up adapter specific items. send Sends PreparedRequest object. Sends PreparedRequest object. Returns Response object. Cleans up adapter specific items. previous file_adapter next immutable_base_model \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.25.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "Common errors",
    "url": "/iqm-pulla/common_errors.html",
    "description": "This document describes some common errors which you may encounter when using Pulla, and ways to fix them. If you have modified any timing aspect of the schedule, you may encounter an error like this:...",
    "content": "This document describes some common errors which you may encounter when using Pulla, and ways to fix them. If you have modified any timing aspect of the schedule, you may encounter an error like this: The granularity is an instrument limitation. Specifically, the part (e.g. HDAWG) which plays the drive pulses.\nSome instrument may use e.g. a sample rate of 2.4 GHz, and each instruction duration must be an integer multiple of 16\nsamples. Instructions therefore must be a multiple of 6.666ns (16 / 2.4 GHz).\nDurations that are within 0.005 samples of an allowed number of samples are rounded to that\n(the software assumes it is what the user meant), otherwise an error is raised. Different stations have different instruments.\nIQM instruments use a fixed sample rate of 2 GHz, and have a granularity of 8 samples. You can view the granularity information in channel properties, for example Pulla.get_channel_properties()[0]['QB1__drive.awg'] : If you were to turn off the error and use an instruction with a duration that does not fit the granularity, it would\njust silently be extended to the next longest allowed granularity, and would not do what you expect. previous iqm.pulla.utils_dd.generate_phases_of_urn_sequence next Changelog By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "Quick Start",
    "url": "/iqm-pulla/Quick Start.html",
    "description": "IQM PulLA is a client-side software which allows the user to control the generation and execution of pulse-level instruction schedules on a quantum computer. Within the existing IQM QCCSW stack, PulLA...",
    "content": "IQM PulLA is a client-side software which allows the user to control the generation and execution of pulse-level instruction schedules on a quantum computer. Within the existing IQM QCCSW stack, PulLA is somewhere between circuit-level execution and EXA-experiment. Namely, with pulse-level access the user can: compile a quantum circuit (e.g. a Qiskit circuit) into an instruction schedule on the client side access and modify the calibration data to be used for the circuit-to-schedule compilation view and modify the default implementations of quantum gates define custom implementations of quantum gates define new composite gates out of native gates and set their calibration data control the multi-step compilation procedure, and edit the intermediate data use custom pulse shapes This notebook contains a small meaningful example for a \u201cquick start\u201d. Refer to other chapters for more details on various aspects of Pulla. Pulla provides a Qiskit backend, with limited functionality. Its main purpose is to replace the normal execution of run() , which submits circuits to the remote server, with a local compilation and submission of pulse schedules to the remote server. IQMPullaBackend does not provide any new functionality, but rather packs existing features and actions behind an illusion of using a normal Qiskit backend. You can perform all of the actions of IQMPullaBackend manually, but you may choose to use IQMPullaBackend in these cases: You don\u2019t need to control compilation, and want to use Pulla in the same way as a remote circuit-executing IQM Server uses it. You want to run some existing apps written for Qiskit, e.g. benchmarking tools; they often build on top ot the circuit abstraction, and don\u2019t necessarily give you easy access to the circuits, which makes it harder to use Pulla normally. You don\u2019t have access to a remote circuit-executing IQM Server, only to a pulse-executing IQM Server. You don\u2019t have any remote servers at all; all of the quantum control software is running locally (relevant for niche research cases) To initialize an IQMPullaBackend instance, provide 3 arguments: Quantum architecture in QuantumArchitectureSpecification format of IQM Client Instance of Pulla Instance of Compiler When IQMPullaBackend.run() is called, the following steps are performed: Given Qiskit circuits are converted to Pulla format using qiskit_circuits_to_pulla() . Circuits are compiled with the provided compiler using Compiler.compile() . Settings are generated with the provided compiler using Compiler.build_settings() . Circuits are executed on the station associated with the provided Pulla instance. Results are retrieved and converted into a DummyJob , partially compatible with Qiskit Job . Working example below: If the remote station requires authentication: Install IQM Client CLI with pip install iqm-client[cli] Run iqmclient init . The wizard will start and ask questions. Accepting defaults is ok. Wizard will ask for Authentication server URL . Usually, it\u2019s of the form https://STATION_ROOT/auth . E.g. if the Station Control URL is \"https://abc.com/station/\" , then the auth server URL is \"https://abc.com/auth/\" Run iqmclient auth login . You should see info like so: Set the environment variable IQM_TOKENS_FILE accordingly in your Jupyter notebook and pass get_token_callback to the Pulla initialization call like so: Setting IQM_TOKENS_FILE env. variable enables authentication for CoCoS as well, so your Qiskit runs against the same station will work, too. Pulla can also be used with IQM Resonance cloud service. You need to set the station URL to point to Resonance. In addition to that, you must provide a get_token_callback parameter function that returns your Resonance API token. IQM Pulse comes with a schedule visualizer. It takes a Playlist (i.e. a compressed list of instruction schedules) and a list of schedule/segment indices to inspect.\nThe playlist variable below is the one which we derived from the original Qiskit circuit using the Pulla compiler, and it only has one schedule. previous User guides next Configuration and Usage By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "Custom Gates and Gate Implementations",
    "url": "/iqm-pulla/Custom Gates and Implementations.html",
    "description": "This notebook demonstrates how to work with user-defined quantum operations and gate implementations that go beyond the standard gate set. Each quantum operation is associated with one or more GateImp...",
    "content": "This notebook demonstrates how to work with user-defined quantum operations and gate implementations that go beyond the standard gate set. Each quantum operation is associated with one or more GateImplementation s which translate the high-level concepts to lower-level instructions accepted by the IQM server. This example shows how the user can Selecting a non-default implementation for a gate Add a custom implementation for an existing gate Add a custom gate and a custom implementation for it by using existing gates as building blocks (composite gates) Defining new pulse waveforms for implementations Please refer to the User Guide.ipynb for basic usage, termninology, and environment setup. Circuits are usually defined without specifying implementations for any of the gates.\nThe implementations available in a given calibration set are listed in the corresponding dynamic quantum architecture, through Cocos. Let\u2019s see a list of available implementations, with their parameters: You can specify a default implementation for each native operation type in the circuit, and then override it for specific loci.\nLet\u2019s change all cz gates to use the slepian implementation, and make an execption for the qubit pair (QB1, QB2) . Note that the default implementations are merely suggestions to the compiler. If the compiler does not have calibration data for a default implementation, it will ignore it and use what it can. If you executed the cell below, you would get an error if the requested implementation 'drag_gaussian' does not have calibration data. You can also force the compiler to use a specific implementation for each circuit instruction separately in the IQM Pulse native format, which describes a circuit as a list of CircuitOperation instances. IQM Pulse allows the user to define composite gates: gates consisting of other registered gates.\nComposite gates are particularly useful because they allow reusing the calibrated of data of the other gates.\nFurthermore, it is possible to use different calibration data for the registered gates inside a composite gate than outside it. Let\u2019s define a prx implementation that acts like a normal prx , except it implements x with 2 pulses with a 100 ns wait between them.\nThe __call__ method produces a TimeBox using IQM Pulse\u2019s ScheduleBuilder.\nIt\u2019s worth mentioning that the composite gate is not restricted to using only registered gates; it could equally well return a TimeBox with lower level instructions. Now we register a new gate custom_x , which StretchedX implements. We want to make it compatible with the circuit-level prx , so we declare that it has the same parameters.\nThen we change the fist prx in the IQM Pulse circuit to use our new implementation. Inspecting the schedule, we can see that the X gate in the circuit is indeed split into two pulses with a wait in between: Finally, let\u2019s change the pulse waveforms of an existing gate. The tricky part of this is that we need to provide the calibration data by hand.\nIQM Pulse provides several \u201cgate with custom waveforms\u201d base classes so that users need only write the waveforms. Let\u2019s define a new implementation of PRX using a raised cosine pulse: The class attributes of the waveforms define the calibration data they require. The PRX_CustomWaveforms class adds some more. We can add the new prx implementation to the compiler, and check what calibration data it needs: Let us then make one of the prx gates in the circuit use our new implementation: Compiling this circuit right now would fail with an error: (The locus (\u2018QB1\u2019,) may differ in your output due to the stochastic nature of routing.) The point is that the compiler does not have necessary calibration data for this new implementation. One way to fix this is to amend the current calibration. The numbers here are arbitrary, in reality you would need to calibrate the gate parameters somehow. Data with gates.prx.raised_cosine.* is now visible in compiler.get_calibration() . Note that we added the same calibration data to all qubits. In practice, this rarely makes sense, because each qubit\nis usually calibrated differently. Now the compilation succeeds and we see that raised_cosine was used once. Using the schedule visualization you could also verify that the pulse shape is indeed different on the first prx instance. previous Compilation Stages next Examples By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "IQM Pulla",
    "url": "/iqm-pulla/readme.html",
    "description": "Pulla (pulse-level access) is a client-side software which allows the user to control the generation and\nexecution of pulse schedules on a quantum computer. Within the existing IQM QCCSW stack, PulLA ...",
    "content": "Pulla (pulse-level access) is a client-side software which allows the user to control the generation and\nexecution of pulse schedules on a quantum computer. Within the existing IQM QCCSW stack, PulLA is somewhere between\ncircuit-level execution and EXA-experiment. An interactive user guide is available as a Jupyter notebook in the docs folder. Create a virtual environment and install dependencies: The [qiskit] option is to enable Qiskit-related features and utilities, like converting Qiskit circuits to Pulla circuits, constructing a compatible compiler instance, or constructing a PullaBackend for running Qiskit jobs. The [qir] option is to enable QIR support, e.g. the qir_to_pulla function. The [notebook] option is to be able to run the example notebooks, using\nand run it in Jupyter Notebook: Install development and testing dependencies: e2e testing is execution of all user guides (Jupyter notebooks). User guides cover the majority of user-level features,\nso we achieve two things: end-to-end-test Pulla as a client library, and make sure the user guides are correct.\n(Server-side use of Pulla is e2e-tested as part of CoCoS.) You have to provide CoCoS and Station Control URLs as environment variables: Notebooks are executed using jupyter execute command. It does not print any output if there are no errors. If you want\nto run a particular notebook and see the output cells printed in the terminal, you can use nbconvert with jq ( https://jqlang.github.io/jq/download/ ) like so: Run unit tests, build docs, build package: Copyright 2025 IQM Licensed under the Apache License, Version 2.0 (the \u201cLicense\u201d);\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \u201cAS IS\u201d BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. previous IQM Pulla next Migration guide By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "Configuration and Usage",
    "url": "/iqm-pulla/Configuration and Usage.html",
    "description": "This notebook describes the basic concepts and configuration of Pulla. Now let\u2019s create a Pulla object. A Pulla object is conceptually an IQM quantum computer client for fetching calibration data and ...",
    "content": "This notebook describes the basic concepts and configuration of Pulla. Now let\u2019s create a Pulla object. A Pulla object is conceptually an IQM quantum computer client for fetching calibration data and constructing a circuit-to-pulse compiler. . It consists of: methods for fetching calibration sets from the server methods for fetching metadata about the QC from the server method for executing pulse-level instruction schedules (e.g. ones created by the compiler) A Compiler object defines a particular circuit-to-pulse compilation logic . It consists of: single calibration set schedule builder based on the calibration set circuit compilation options information about the QC (chip topology, channel properties, etc.) compilation stages set of available circuit-level quantum operations (\u201cnative operations\u201d) (including user-defined operations) set of implementations for each native operation (including user-defined implementations) methods for manipulating the calibration, operations, and implementations Pulla can construct a standard compiler equivalent to the one used by the server side (CoCoS). You can also construct a Compiler manually. To create an instance of Pulla, you need to provide the URL of Station Control. Upon successful initialization, some configuration data is printed (the verbosity of such messages will be controlled by a debug level value). You can access various things like channel properties of the connected station, chip topology, or the current calibration. The initial calibration is the latest calibration of the connected station. Call get_standard_compiler() method to get an instance of Compiler . It will be pre-populated with the latest default calibration set and standard compilation stages. This standard compiler is the same one that CoCoS uses on the server side when processing circuits. get_standard_compiler() fetches the latest calibration set from the server. This network request takes a few moments. You may want to create many Compiler instances without such delay. It may also be possible that, due to human error, the latest calibration set stored on the server is invalid (or incompatible with your version of Pulla or IQM Pulse). In that case get_standard_compiler() will fail. To avoid this, you can pass the calibration set manually, and Pulla will construct the compiler with it instead of getting one from the server. If you want to reuse the calibration of an existing compiler, call Compiler.get_calibration() , e.g.: You can also get a specific calibration set from the server if you know its UUID by calling Pulla.fetch_calibration_set_by_id() , e.g.: The compiler initializes with the following default configuration options: circuit_boundary_mode='all' measurement_mode='all' heralding_mode='none' dd_mode='none' You can change them by changing the corresponding attributes of compiler.options . For the constant implementation of the measure operation, the readout type is controlled by the acquisition_type parameter. By default, it\u2019s set to \"threshold\" . Let\u2019s change it to \"complex\" . The full key in the calibration set dictionary is gates.measure.constant.QUBIT.acquisition_type , where QUBIT is the physical qubit name. Note that we call get_calibration() to get a copy of the compiler\u2019s current calibration set, make changes to the copy, then replace the compiler\u2019s set with the copy. The compiler always contains a single calibration set only. previous Quick Start next Compilation Stages By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "Executing QIR programs",
    "url": "/iqm-pulla/Example - Executing QIR programs.html",
    "description": "If you have a QIR string or bitcode, you can start by creating Pulla-compatible circuits representation. You can also generate a QIR string or bitcode from a qiskit circuit using IQM\u2019s fork of qiskit_...",
    "content": "If you have a QIR string or bitcode, you can start by creating Pulla-compatible circuits representation. You can also generate a QIR string or bitcode from a qiskit circuit using IQM\u2019s fork of qiskit_qir , available as the package iqm-qiskit-qir . previous Example: Dynamical decoupling next API Reference By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "Example: Measuring T1",
    "url": "/iqm-pulla/Example - Measuring T1.html",
    "description": "T1 is an experiment that measures the relaxation time of a qubit. Information stored in a qubit decays exponentially. The time constant of the decay is called the relaxation time $T_1$. The experiment...",
    "content": "T1 is an experiment that measures the relaxation time of a qubit. Information stored in a qubit decays exponentially. The time constant of the decay is called the relaxation time $T_1$. The experiment measures $T_1$ by preparing selected qubits in the  excited state by playing an X gate,\nwaiting some time, and measuring the qubit. The waiting time is swept to reveal the exponential decay of the excited state probability. High-level QuantumOperations like Quantum gates can be implemented using different GateImplementations.\nTo control low-level aspects of the execution, we can create custom operations, the implementation of which we can control. Here we invent a custom operation \"custom\" and write an implementation \"Wait\" , which only inserts a delay of certain duration.\nIn principle, the custom gate implementation could include any number of low-level instructions,\nbut for this task we only need a wait.\nhttps://iqm-finland.github.io/docs/iqm-pulse/using_builder.html for more details about lower level controls. In later cells, we mix the custom gate with other, more familiar gates. We must register the operation, so that the compiler knows what to do with it: We need to select the physical qubits to work on. These are available on the QPU: Out of these, we select a few: Now we create all the circuits. In each circuit, we do a PRX(pi), or X, then our custom operation that waits, then measure all qubits.\nWe create a circuit for each delay time we want on the time axis. Then compile the circuits. We tweak the settings so that the shots are averaged by the server, so that we don\u2019t need to.\nThe results therefore return as sampled probabilities. Extract the results We can also visualise the final playlist. We should see that each circuit is different and the waits at the end are increasing towards the end. previous Examples next Example: Dynamical decoupling By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "User guides",
    "url": "/iqm-pulla/user_guides.html",
    "description": "previous Migration guide next Quick Start By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22....",
    "content": "previous Migration guide next Quick Start By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "Examples",
    "url": "/iqm-pulla/examples.html",
    "description": "previous Custom Gates and Gate Implementations next Example: Measuring T1 By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22....",
    "content": "previous Custom Gates and Gate Implementations next Example: Measuring T1 By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "IQM Pulla",
    "url": "/iqm-pulla/index.html",
    "description": "8.1.0 2025-06-22 Client-side library for Pulse-level access to IQM quantum computers. Index Module Index Search Page next IQM Pulla By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Relea...",
    "content": "8.1.0 2025-06-22 Client-side library for Pulse-level access to IQM quantum computers. Index Module Index Search Page next IQM Pulla By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "References",
    "url": "/iqm-pulla/references.html",
    "description": "Nic Ezzell, Bibek Pokharel, Lina Tewala, Gregory Quiroz, and Daniel\u00a0A. Lidar. Dynamical decoupling for superconducting qubits: a performance survey. Phys. Rev. Appl. , 20:064027, Dec 2023. arXiv:2207....",
    "content": "Nic Ezzell, Bibek Pokharel, Lina Tewala, Gregory Quiroz, and Daniel\u00a0A. Lidar. Dynamical decoupling for superconducting qubits: a performance survey. Phys. Rev. Appl. , 20:064027, Dec 2023. arXiv:2207.03670 , doi:10.1103/PhysRevApplied.20.064027 . previous License By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "Example: Dynamical decoupling",
    "url": "/iqm-pulla/Example - Simple Dynamical Decoupling.html",
    "description": "There is a standard compilation stage for automatically applying dynamical decoupling (DD) sequences to an instruction schedule,\ncontrolled by the dd_mode compiler option. By default the DD stage is d...",
    "content": "There is a standard compilation stage for automatically applying dynamical decoupling (DD) sequences to an instruction schedule,\ncontrolled by the dd_mode compiler option. By default the DD stage is disabled. The iqm.cpc.compiler.dd module contains various utility functions the DD stage uses, e.g. for locating specific instructions in a schedule, constructing DD sequences, and replacing select instructions with them. For example, we can find locations of Wait instructions on qubit drive channels with a certain minimum duration, and replace them with an arbitrary sequence of Wait and IQPulse instructions that dynamically decouples the qubit, given that the total duration of the sequence is the same as the duration of the original Wait . Let\u2019s create and transpile a quantum circuit that prepares a superposition on one qubit, and then executes a long sequence of gates on other qubits while the first qubit is idling and experiencing decoherence. Finally we reverse the superposition and measure the qubits. Now let us create a pair of Pulla compilers, one with DD and one without. Compiling the circuit using the non-DD compiler produces a schedule with a long wait on QB1__drive.awg. We then execute this schedule and compute the probability of finding QB1 in the |0> state. Ideally this should be one, but due to the decoherence experienced by the superposition state it will be less. Compiling the circuit using the DD compiler instead produces a schedule where the long wait on QB1__drive.awg is replaced by a DD sequence. We execute the DD schedule and again compute the probability of finding QB1 in the |0> state, and will likely see that the probability has gone up, due to the DD sequence partially decoupling the idling QB1 from various decoherence sources and better preserving the superposition state. We can see that the long wait on QB1__drive.awg was indeed replaced by a DD sequence. previous Example: Measuring T1 next Executing QIR programs By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "API Reference",
    "url": "/iqm-pulla/API.html",
    "description": "iqm.cpc IQM Circuit to Pulse Compiler. iqm.pulla Client-side library for Pulse-level access to IQM quantum computers. previous Executing QIR programs next iqm.cpc By IQM Pulla developers \u00a9 Copyright 2...",
    "content": "iqm.cpc IQM Circuit to Pulse Compiler. iqm.pulla Client-side library for Pulse-level access to IQM quantum computers. previous Executing QIR programs next iqm.cpc By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "Import required packages",
    "url": "/iqm-pulla/Example - Randomized Benchmarking.html",
    "description": "Contact: pedro.romero@meetiqm.com & manish.thapa@meetiqm.com NB: Familiarity with quantum channels, gates and Clifford gates is assumed. The idea behind Clifford Randomized Benchmarking (CRB) is that ...",
    "content": "Contact: pedro.romero@meetiqm.com & manish.thapa@meetiqm.com NB: Familiarity with quantum channels, gates and Clifford gates is assumed. The idea behind Clifford Randomized Benchmarking (CRB) is that under certain (simplified) types of noise, the average survival probability of the initial state of a quantum system under uniformly random sequences of multi-qubit Clifford gates with sequence inversion will decay exponentially in the length of the sequences. From such decay, one can in turn infer the average fidelity of the corresponding Clifford group. CRB sequences are of the form $$\\mathcal{S} m:=\\mathcal{C} {m+1}\\circ\\mathcal{C}_m\\circ\\cdots\\circ\\mathcal{C}_1,$$ for any $m\\geq1$, where $\\mathcal{C} i(\\cdot):=C_i(\\cdot)C_i^\\dagger$ is a unitary channel with $C_i$ being a Clifford gate, and where by definition $$\\mathcal{C} {m+1}=(\\mathcal{C}_m\\circ\\cdots\\circ\\mathcal{C} 1)^{-1}.$$ It is important to notice that $C {m+1}$ is itself a Clifford gate, i.e., one would not implement the sequence $\\mathcal{C}_m\\circ\\cdots\\circ\\mathcal{C} 1$ in practice, but rather compile the corresponding unitary operator $C_mC {m-1}\\cdots{C}_1$ into a single Clifford gate. The main assumption is that the real noisy gates can be approximately modeled independently by a quantum channel $\\mathcal{E}$ (completely positive, trace non-increasing map) as $\\tilde{\\mathcal{C}}_i\\approx\\mathcal{E}\\circ\\mathcal{C}_i$, or (ultimately equivalently) as $\\tilde{\\mathcal{C}}_i\\approx\\mathcal{C}_i\\circ\\mathcal{E}$. This implies that the noise is modeled as Markovian , time-stationary and gate-independent \u2014 while here we will take these for granted, a lot about RB in more general regimes is known, but it is in general more complicated, and often this simplistic scenario goes a long way as a useful first approximation. NB: CRB is not generally intended to work for $n>2$, both because of the scaling of the size of the $n$-qubit Clifford group in $n$, and because such gates have to eventually be transpiled to a native basis of 1Q and 2Q gates! While a high level of optimization in transpile is usually desirable, one must be careful for the optimization not to mess with the Clifford gates, i.e., we want the transformations between barriers in the circuit to implement a Clifford regardless of how it is decomposed. The specific decomposition still matters, however, because the (average) number of 2Q and 1Q gates (i.e., cz and r , respectively) will dictate how noisily we can implement the Cliffords on average, i.e., the average gate fidelity we will ultimately obtain. We will not do this check here, but it is now known that a good decomposition of Clifford gates in our basis will have on average 8.25 cz gates and 1.5 r gates (e.g., see arXiv:1402.4848 ). We can count the number of native 1Q and 2Q gates by using the circuit attribute count_ops() One important reason why CRB works \u2013and why specifically it uses Clifford gates\u2013, is that the uniformly distributed multi-qubit Clifford group forms a unitary 2-design. This essentially means that any quantity that takes two copies of the pair $C, C^\\dagger$ and then averaged over all possible $C$s, will be exactly the same as if $C$ had been any uniformly distributed (so-called Haar) random unitary. This matters because there are plenty of results allowing to easily compute such quantities (i.e., second moments) over the whole uniformly distributed unitary group \u2014 in fact, such second moment simply takes the form of a depolarizing channel (RB precisely extracts the average gate fidelity through the corresponding polarization parameter). The CRB sequences are quantities of this type because of the final inverse at the end (i.e. all sequences will have 2 copies of pairs $C_i,C_i^\\dagger$ for all $i=1,2,\\ldots,m$). This is the reason why the theory behind RB, under the noise assumptions above, can ensure that the decay in average fidelity, i.e., quantities like $$f_0=\\langle0|\\mathcal{S}_m(|0\\rangle!\\langle0|)|0\\rangle$$ take the form of a function $$f_0=Ap^m+B$$ for $0\\leq{A,B,p}\\leq1$. Furthermore, it ensures that $p$ will encode the average gate fidelity of the noisy Clifford gates, whilst $A,B$ will encode (and isolate) errors due to state preparation and measurement. This is what is meant by RB being SPAM-robust. In the modeling with assummptions of noisy gates above, this means $p\\sim\\int{d}\\psi\\langle\\psi|\\mathcal{E}(|\\psi\\rangle!\\langle\\psi|)|\\psi\\rangle$ for all possible uniformly distributed pure states $|\\psi\\rangle$, and $A\\sim\\langle0|\\mathcal{E} \\text{spam}(|0\\rangle!\\langle0|)|0\\rangle$, $B\\sim\\langle0|\\mathcal{E} \\text{spam}(\\mathbb{I}/2^n)|0\\rangle$ for a composition of the state preparation and measurement noise. We may now fix a number of circuit samples and sequence lengths. Despite the Clifford group having a (super) exponential amount of terms (e.g., 24 for 1Q, then 11,520 for 2Q), approximating the average over the whole group with finite samples quickly converges to the Haar average. On the other hand, the sequence lengths can be chosen as exponentially spaced and aiming at long sequences, if possible, serves to better determine the offset constant (often named the nuisance parameter, for obvious reasons) in the decay. Depending on how many circuits we want to execute, we could either generate all circuit samples for all circuit lengths and send all for execution once, or we may, for example, generate a given amount of circuits, send them to execution while meanwhile continuing to generate circuits and sending them. In either case, one may retrieve the results later. Here we will generate all circuits for all sequence lengths, and send them to execute as a single batch on the backend. It is generally a good idea to store (at least at this stage) both the abstract and the transpiled circuits, so that we can inspect them later on. We can inspect the circuits just as a sanity check Task : Count the average number of 1Q and 2Q gates in the circuits for each sequence length. Task : Since the Clifford group is a 2-design, its so-called frame potential (see e.g., arXiv:1610.04903 ) has to satisfy $\\displaystyle{\\sum_{k,,k^\\prime=1}^K}\\left|\\mathrm{tr}\\left(C_{k^\\prime}^{\\dagger}C_k\\right)\\right|^4/K^2 = 2$. Verify this condition for the 1Q Clifford group. warning for the 2Q Clifford group: there are in total $n=11,520^2 = 132,710,400$ values in the sum! It suffices to compute the values in a triangular part of the matrix $U_{k^\\prime}^{\\dagger}U_k$  \u2014 so you can definitely verify this property, however there will still be $n(n-1)/2$ such terms for your computer to sum up! We can now send the transpiled circuits to be run on the hardware. NB: It is generally preferable to use backend.run instead of execute command, since the latter performs a transpilation pass \u201cunder the hood\u201d. We can now inspect the results for a given sequence length (we will use the one defined above). The counts at the ground state relate to the survival probability (or state fidelity) of such state under our random Clifford circuits. Task : Compare the histograms between the outcomes for the narrowest and the deepest circuits NB: You can wrap plot_histogram() with display(*) to show both results in one cell By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "Compilation Stages",
    "url": "/iqm-pulla/Compilation Stages.html",
    "description": "The generic lifecycle of a Pulla job is a one-way multi-step transformation. The states are as follow: Quantum Circuit in a specific format (e.g. Qiskit, Cirq) Equivalent Quantum Circuit in an IQM Pul...",
    "content": "The generic lifecycle of a Pulla job is a one-way multi-step transformation. The states are as follow: Quantum Circuit in a specific format (e.g. Qiskit, Cirq) Equivalent Quantum Circuit in an IQM Pulse format (list of CircuitOperations) IQM Pulse nested Timebox representation IQM Pulse Schedule representation Measurement results You don\u2019t have to start with a circuit, you can define quantum operations directly (roughly starting from state 2), or define pulse shapes directly (roughly starting from state 3 or 4). The compilation which produces states 3 and 4 is itself multi-step: it consists of multiple stages, and each stage of one or more passes. Let\u2019s go over the generic use case, starting from creating a Qiskit circuit to work on: Pulla has utility functions which accept circuits in different formats (Qiskit, Cirq, IQM JSON) and convert them into Pulla/IQM Pulse format, which is a list of CircuitOperation objects. Let\u2019s do that. Note that none of the operations have an implementation specified ( implementation=None ). The Qiskit conversion utility also gives us a standard compiler with the same calibration set as the one used by backend , in this case the current default one. In order to understand how the compilation stages work, let\u2019s remove the standard stages from the compiler: You can check the readiness of the compiler by calling compiler.ready() . Right now it would return False due to empty stages list. The compiler flow consists of one or more stages, and each stage consists of one or more passes. When the compiler is initialized created by Pulla, it is pre-populated with standard stages. You can define your own stages, with your own passes, grouping them in some meaningful way. Each pass is a function which accepts two arguments: data and context. Data is an iterable of objects of an applicable data type, and context is a dictionary of any additional information. Each pass can transform the data and modify the context, and must return both data and context. This convention allows the compiler to pipe arbitrary amount of passes. A stage is just an ordered collection of passes. The compiler has methods run_stage() and run_pass() allowing you to run particular stages or passes. The compile() method is just calling run_stage() in correct order and passes its initial context to the first pass of the first stage. Let\u2019s write a simple compilation stage to illustrate the concept: Now let\u2019s write two simple passes for that stage. For the first: perhaps we want to add a leading barrier to each circuit. add_leading_barrier below determines the locations of qubits used in the circuit and adds a barrier on those qubits as the first instruction. Note that the function takes data and context and returns data and context. It happens to neither use nor modify the context, but it should still provide it down to the next passes. Ok, let\u2019s define another pass: this one would increase the phase of each prx operation by 0.25 . This may or may\nnot make practical sense, but bear with us for the purposes of illustration: Now let\u2019s add those two passes to our stage, then replace the empty stages property of the compiler with a list consisting of our single stage, and then call show_stages() : The boolean flag full of show_stages() is optional; when True , the doc strings of each pass are printed on the screen. Now that the compiler is ready and we can run compile . The compiler always operates on batches of circuits, so you need to provide an iterable; in our case, it\u2019s a list with a single circuit. Note that it did not really compile the circuits into pulse schedules, because the only passes we\u2019ve defined only modify the circuits, but don\u2019t perform the conversion to pulse schedules. The compilation to pulse schedules usually consists of converting circuits to TimeBox es, then resolving TimeBox es into a single TimeBox , then resolving it into a Schedule , and finally converting a Schedule into a final Schedule ready to be submitted to the server. There might be cases when your compilation stages need additional data. You can provide such data as a custom context dictionary. Get the initial compiler context and modify it, then pass it when calling compile . As mentioned earlier, Pulla comes with a pre-defined \u201cstandard\u201d set of stages which you can use and, if needed, modify. These standard stages are used by CoCoS if you were to submit a circuit to CoCoS (without using Pulla). Thus, if you use the same version of the Pulla library that the remote CoCoS uses, you will be able to produce and inspect the same pulse schedules that CoCoS would (assuming you use the same calibration set). Let\u2019s replace our current single stage with standard stages, and view them: There are 7 standard stages: circuit-level: takes care of validating the circuit, renaming some deprecated names, gathering\ninformation for the next stages circuit resolution: converts circuits to TimeBox es timebox-level: optimizes \u201cmeasure\u201d gates by multiplexing them if possible timebox resolution: converts TimeBox es to Schedule schedule-level: applies dynamical decoupling schedule-level: potentially applies some corrections, then cleans up the schedules schedule resolution: converts Schedule to the final Playlist ready to be executed Variable data now contains the Playlist in its final form, and context contains a dictionary of various things\nwhich were either necessary in some of the passes, or will be necessary for the final execution. It also contains a\ncopy of schedules from before the final playlist resolution. Some of those pieces of data will be needed to build\nStation  Control settings (more on that later). Instead of calling compile() , which runs all the stages, you can run each stage, or even each separate pass, by yourself. In that case you will have to take care of two things: Provide initial context to the first pass of the first stage. Save data and context returned by each pass (or stage) in order to provide it to the next pass (or stage). To help you with 1, the compiler has a method compiler_context() which returns a dictionary of initial context. (Note: to run a pass of any particular stage: compiler.stages[0].passes[0](data, context) ) Let\u2019s create another circuit and compile it manually. We\u2019ll use this example to understand each standard stage: The first stage is circuit-level passes: When defining a circuit in IQM JSON or IQM Pulse format directly, you can specify an implementation for each gate (selecting from implementations provided by the calibration set). If no implementation is specified, the standard circuit-level stage will select the default implementation for each gate automatically. Currently, the choice of the default implementation is global: e.g. prx may have drag_gaussian as the default. In the future, the calibration may yield different implementations for different loci, striving to provide the best quality. Now we can convert the circuit to TimeBox es. TimeBox is a concept of IQM Pulse: a container for one or more instruction schedule fragments, to be scheduled according to a given scheduling strategy. timeboxes is a list of TimeBox objects, and you can edit them manually. A TimeBox can contain multiple children TimeBox es, each containing either more TimeBox es or a Schedule . A TimeBox containing a Schedule rather than children is referred to as \u201catomic\u201d. In our example here the circuit was converted into one TimeBox containing 11 children atomic TimeBox es, which correspond to 11 circuit operations (7 gates + 1 barrier gate + 3 measurement gates). An atomic TimeBox holds its Schedule in an atom property: Next is a timebox-level stage, which only has one pass: multiplexing measurements. The measure_all() we called when\ncreating the circuit adds a single TimeBox with the gate implementation Measure_Constant for each qubit in the\ncircuit.\nWith the measurement_mode='all' option, the first stage has also added a measurement TimeBox for the unused qubits. Multiplexing means executing all of these measurements at once, instead of one after the other.\nThe multiplexing pass does this optimization for us: If you construct a circuit in Qiskit, and want to ensure multiplexing of measurement instructions, you have to \u201cwrap\u201d a group of measurement instructions with barrier s. This would prevent the Qiskit transpiler from putting any other instructions, acting on the same qubits, in between measurements, thus allowing the compiler to multiplex. Next we convert TimeBox es into a single Schedule . This is a recursive process which resolves all nested TimeBox es into atomic TimeBox es, and finally assembles a single Schedule out each of batches of TimeBox es. At this stage, all relative timings between pulses are resolved and fixed. Dynamical decoupling pulse sequences get inserted to replace Wait instructions. The process is controlled by a user-submitted dynamical decoupling strategy. By default, this stage is disabled. Please see other notebooks for examples of how to enable and apply dynamical decoupling. Next is a schedule-level stage. Its first pass applies calibrated phase corrections if MOVE gates are used (only applicable to QCs with computational resonator, i.e. IQM Star Architecture). The second pass removes non-functional instructions from the schedules. Finally, the last stage builds a final schedule from a number of instruction schedules. A playlist is just a compressed Schedule with no duplicate information, ready to be submitted for execution. In order to submit this final schedule for execution, we have to do one more thing: build the Station Control settings. The settings control the behaviour of instruments. At this point everything is ready to be submitted for execution to the server. Namely, these three objects will be used to construct a request to Station Control Service: playlist : sequence of instruction schedules corresponding to the batch of circuits to be executed settings : Station Control settings node context['readout_mappings'] : a mapping from measurement keys to the names of readout controller acquisition labels that will hold the measurement results Now we can convert these raw results into a Qiskit Result object: We can also submit the same circuit to CoCoS for execution. CoCoS is essentially a server-side Pulla with fixed standard stages. Since we started with a normal Qiskit backend and a circuit, execution is as simple as: previous Configuration and Usage next Custom Gates and Gate Implementations By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "Compilation using a locally created calibration set",
    "url": "/iqm-pulla/Example - Compilation With Local Calibration Set.html",
    "description": "This notebook shows how to construct a calibration set locally and use the local calibration set for compiling circuits. The calibration itself is done using IQM\u2019s Graph Based Calibration (GBC) softwa...",
    "content": "This notebook shows how to construct a calibration set locally and use the local calibration set for compiling circuits. The calibration itself is done using IQM\u2019s Graph Based Calibration (GBC) software. In this notebook we show recalibration based on the latest calibration set. The usage of Pulla with a local calibration set works mostly the same way also for a full calibration from scratch. In that case you would just have to use a different GBC graph, and possibly manually add observations to the observation stash if it does not yet have all observations required for a valid calibration set. Using the principles shown in this notebook, it is possible to use all Pulla functionality as a helpful tool during the calibration process. NOTE: Some of the libraries used in this notebook are only available to on-premise customers and are not currently available publicly. First we prepare a Pulla object, a qiskit-iqm backend, and a circuit as explained in Quick Start.ipynb . Let\u2019s also define a function that compiles and runs the above circuit using the given compiler state. This function will be used to compile and execute the circuit at different points of the calibration process: First we compile and execute the circuit using the compiler obtained above, which uses the current default calibration set on the server. The results of this execution can then be compared to the results after performing (parts of) the recalibration process. Now we will start recalibration using GBC. We need a CalibrationSetWrapper instance for handling calibration sets and a Calibrator for running the calibration: To start with, we run the first node that runs any actual calibration experiments: Then we can create a local calibration set based on the results of the above calibration node, and update the compiler to use this calibration set. We compile and execute a circuit using the updated compiler to see how our updates to the calibration set affect the results. Because many observations of the updated calibration set don\u2019t yet take into account the results of the executed node, the results could even be worse than before updating the calibration set with these intermediate results. We could repeat the above steps multiple times for different nodes of the calibration graph, to see how the results change during the calibration process. Finally, we run the full recalibration, which runs all the remaining nodes that we did not run above: Then we again update the compiler using the results of the calibration in the same way as before. If the full recalibration was successful, the execution results should hopefully be at least as good as before the recalibration. By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "Migration guide",
    "url": "/iqm-pulla/migration_guide.html",
    "description": "This document describes the changes that need to be made to existing code to migrate between major versions of Pulla. The changes in 4.0 are not truly breaking, as your code should still run. However,...",
    "content": "This document describes the changes that need to be made to existing code to migrate between major versions of Pulla. The changes in 4.0 are not truly breaking, as your code should still run. However, there are some changes that\nmight affect the compilation results, and you might want to adjust your code accordingly: New compilation pass prepend_reset added to the (TimeBox-level) standard compiler stage. It adds a reset timebox\nto all circuits. It is the last pass of the TimeBox-level stage. If the calibration lacks reset_wait data, the prepend_reset will have no effect. Optional attribute :attr: .CircuitExecutionOptions.active_reset_cycles added to CircuitExecutionOptions ,\nthat is used to control the reset functionality. By default, it is set to None , which results in delay by wait. :meth`.Pulla.get_standard_compiler` now has an optional argument for overriding default circuit execution options. The function iqm.pulla.utils_qiskit.qiskit_to_cpc was replaced by iqm.pulla.utils_qiskit.qiskit_circuits_to_pulla() and iqm.pulla.utils_qiskit.qiskit_to_pulla() . qiskit_circuits_to_pulla() is a more direct replacement, with the difference that it also requires a\nmapping of qiskit qubit indices to physical qubit names which was not required before.\nThis can be e.g. obtained from an iqm.qiskit_iqm.iqm_provider.IQMBackend instance. qiskit_to_pulla() is a convenience method that in addition to\nconverting the Qiskit circuit(s) also returns a Compiler instance that can be used to compile them\ninto a playlist. It takes as additional parameters a Pulla instance (for building the compiler),\nand an IQMBackend instance (containing the calibration set ID and\nqubit mapping to use). The IQMBackend instance should usually be the same one that was used to transpile\nthe Qiskit circuits. Compiler code is consolidated under the iqm.cpc.compiler.compiler module.\nThere is no more iqm.cpc.compiler.compiler2 . Compiler , CompilationStage are now under iqm.cpc.compiler.compiler . Pulla no longer needs CoCoS URL: Compiler initialization now requires all arguments to be keyword arguments. Pulla no longer retrieves qubit mapping from CoCoS. If your circuit uses same qubits names as physical qubits\n(e.g. QB1 , QB2 , etc.), then you don\u2019t have to do anything. If your circuit uses other qubit names, then you have to\nprovide component_mapping to the Compiler like so: If you use Qiskit, the mapping can be generated with {str(idx): qb for idx, qb in backend._idx_to_qb.items()} . .Compiler.set_default_implementation_for_locus changed to Compiler.set_default_implementation_for_loci() : Compiler.amend_calibration_for_gate_implementation() now accepts a Locus (a tuple of strings)\ninstead of string qubit name, so you can apply the change to multiple loci in a single call: iqm.pulla.utils.qiskit_to_cpc() and iqm.pulla.station_control_result_to_qiskit() , previously marked for\ndeprecation in v. 1.0, are now removed. Use iqm.pulla.utils_qiskit.qiskit_to_cpc() and iqm.pulla.utils_qiskit.station_control_result_to_qiskit() , respectively. The main change in 1.0 is the splitting of Pulla and Compiler , and the move of some compiler-related methods to\nthe more appropriate Compiler class. The Pulla class now only contains methods to retrieve calibration data,\nconstruct a standard compiler instance, and submit pulse schedules to the server. Setting default implementation is now done in the compiler directly, and there is no need to manually refresh the\ncompiler anymore. Same goes for adding implementations, and amending the calibration set with custom data for custom implementations: The calibration is now stored solely in the compiler instance, and can be retrieved using Compiler.get_calibration() : Fetching calibration sets from the server is still done via Pulla.fetch_latest_calibration_set() and Pulla.fetch_calibration_set_by_id() . Standard compilation stages are now available via get_standard_stages() . This ensures the immutability of\nbuilt-in standard stages. previous IQM Pulla next User guides By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "Contributors",
    "url": "/iqm-pulla/authors.html",
    "description": "Rakhim Davletkaliyev < rakhim . davletkaliyev @ meetiqm . com > Ville Bergholm < ville @ meetiqm . com > Joni Ikonen < joni @ meetiqm . com > Arianne Meijer < qaremei @ meetiqm . com > Tuukka Hiltunen...",
    "content": "Rakhim Davletkaliyev < rakhim . davletkaliyev @ meetiqm . com > Ville Bergholm < ville @ meetiqm . com > Joni Ikonen < joni @ meetiqm . com > Arianne Meijer < qaremei @ meetiqm . com > Tuukka Hiltunen < tuukka @ meetiqm . com > Jussi Ritvas < jussi . ritvas @ meetiqm . com > Miikka Koistinen < miikka @ meetiqm . com > previous Changelog next License By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils_dd.generate_phases_of_urn_sequence",
    "url": "/iqm-pulla/api/iqm.pulla.utils_dd.generate_phases_of_urn_sequence.html",
    "description": "Generate PRX gate phases for the URn sequence. More information on the URn sequence is available in [ 1 ] , at the end in Appendix A.1. n ( int ) \u2013 Number of single qubit PRX pulses with different pha...",
    "content": "Generate PRX gate phases for the URn sequence. More information on the URn sequence is available in [ 1 ] , at the end in Appendix A.1. n ( int ) \u2013 Number of single qubit PRX pulses with different phases to apply, must be a positive even number. Phases to be used by the URn sequence. list [ float ] previous iqm.pulla.utils_dd next Common errors By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla",
    "url": "/iqm-pulla/api/iqm.pulla.html",
    "description": "Client-side library for Pulse-level access to IQM quantum computers. Subpackages and modules utils_cirq Utilities for working with Cirq objects. utils_dd Utilities for working with Dynamical Decouplin...",
    "content": "Client-side library for Pulse-level access to IQM quantum computers. Subpackages and modules utils_cirq Utilities for working with Cirq objects. utils_dd Utilities for working with Dynamical Decoupling. previous iqm.cpc.interface next iqm.pulla.utils_cirq By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.UnknownHardwareComponentError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.UnknownHardwareComponentError.html",
    "description": "Circuit contains a reference to an unknown hardware component. previous iqm.cpc.compiler.errors.UnknownCircuitExecutionOptionError next iqm.cpc.compiler.errors.UnknownLogicalQubitError By IQM Pulla de...",
    "content": "Circuit contains a reference to an unknown hardware component. previous iqm.cpc.compiler.errors.UnknownCircuitExecutionOptionError next iqm.cpc.compiler.errors.UnknownLogicalQubitError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.interface",
    "url": "/iqm-pulla/api/iqm.cpc.interface.html",
    "description": "Pydantic models used by the API. Subpackages and modules previous iqm.cpc.compiler.errors.UnknownLogicalQubitError next iqm.pulla By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release...",
    "content": "Pydantic models used by the API. Subpackages and modules previous iqm.cpc.compiler.errors.UnknownLogicalQubitError next iqm.pulla By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.CompilationPassError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.CompilationPassError.html",
    "description": "There is something wrong with the compilation pass. previous iqm.cpc.compiler.errors.ClientError next iqm.cpc.compiler.errors.InsufficientContextError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQ...",
    "content": "There is something wrong with the compilation pass. previous iqm.cpc.compiler.errors.ClientError next iqm.cpc.compiler.errors.InsufficientContextError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc",
    "url": "/iqm-pulla/api/iqm.cpc.html",
    "description": "IQM Circuit to Pulse Compiler. IQM Circuit to Pulse Compiler is a Python-based library for converting quantum circuits\ninto instruction schedules (which map Station Control controller names to their p...",
    "content": "IQM Circuit to Pulse Compiler. IQM Circuit to Pulse Compiler is a Python-based library for converting quantum circuits\ninto instruction schedules (which map Station Control controller names to their pulse playlists) and Station Control settings\nrequired for circuit execution, using the calibration data it is given.\nThe generated schedules and settings can be sent to Station Control\nfor execution on real or simulated quantum hardware. CPC is normally only accessed indirectly through Cocos or its reference client IQM client ,\nor a frontend such as Cirq on IQM or Qiskit on IQM . Subpackages and modules compiler Compile quantum circuits into instruction schedules and settings that can be executed on a station. interface Pydantic models used by the API. previous API Reference next iqm.cpc.compiler By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.ClientError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.ClientError.html",
    "description": "Client submitted a bad request, and needs to be notified. Errors inheriting this class will be reported to the client in the message field of the failed job. previous iqm.cpc.compiler.errors.CircuitEr...",
    "content": "Client submitted a bad request, and needs to be notified. Errors inheriting this class will be reported to the client in the message field of the failed job. previous iqm.cpc.compiler.errors.CircuitError next iqm.cpc.compiler.errors.CompilationPassError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.CircuitError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.CircuitError.html",
    "description": "There is something wrong with the quantum circuit. previous iqm.cpc.compiler.errors.CalibrationError next iqm.cpc.compiler.errors.ClientError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland...",
    "content": "There is something wrong with the quantum circuit. previous iqm.cpc.compiler.errors.CalibrationError next iqm.cpc.compiler.errors.ClientError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils_cirq",
    "url": "/iqm-pulla/api/iqm.pulla.utils_cirq.html",
    "description": "Utilities for working with Cirq objects. Functions cirq_to_cpc () Convert a Cirq Circuit to an IQM CPC Circuit. previous iqm.pulla next iqm.pulla.utils_cirq.cirq_to_cpc By IQM Pulla developers \u00a9 Copyr...",
    "content": "Utilities for working with Cirq objects. Functions cirq_to_cpc () Convert a Cirq Circuit to an IQM CPC Circuit. previous iqm.pulla next iqm.pulla.utils_cirq.cirq_to_cpc By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils_cirq.cirq_to_cpc",
    "url": "/iqm-pulla/api/iqm.pulla.utils_cirq.cirq_to_cpc.html",
    "description": "Convert a Cirq Circuit to an IQM CPC Circuit. previous iqm.pulla.utils_cirq next iqm.pulla.utils_dd By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-0...",
    "content": "Convert a Cirq Circuit to an IQM CPC Circuit. previous iqm.pulla.utils_cirq next iqm.pulla.utils_dd By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.UnknownLogicalQubitError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.UnknownLogicalQubitError.html",
    "description": "A logical qubit in the circuit has not been defined in the qubit mapping. previous iqm.cpc.compiler.errors.UnknownHardwareComponentError next iqm.cpc.interface By IQM Pulla developers \u00a9 Copyright 2024...",
    "content": "A logical qubit in the circuit has not been defined in the qubit mapping. previous iqm.cpc.compiler.errors.UnknownHardwareComponentError next iqm.cpc.interface By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.InsufficientContextError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.InsufficientContextError.html",
    "description": "The context provided to the compilation pass does not contain all necessary fields. previous iqm.cpc.compiler.errors.CompilationPassError next iqm.cpc.compiler.errors.SettingsConventionError By IQM Pu...",
    "content": "The context provided to the compilation pass does not contain all necessary fields. previous iqm.cpc.compiler.errors.CompilationPassError next iqm.cpc.compiler.errors.SettingsConventionError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils_dd",
    "url": "/iqm-pulla/api/iqm.pulla.utils_dd.html",
    "description": "Utilities for working with Dynamical Decoupling. Functions generate_phases_of_urn_sequence (n) Generate PRX gate phases for the URn sequence. previous iqm.pulla.utils_cirq.cirq_to_cpc next iqm.pulla.u...",
    "content": "Utilities for working with Dynamical Decoupling. Functions generate_phases_of_urn_sequence (n) Generate PRX gate phases for the URn sequence. previous iqm.pulla.utils_cirq.cirq_to_cpc next iqm.pulla.utils_dd.generate_phases_of_urn_sequence By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.html",
    "description": "Compile quantum circuits into instruction schedules and settings that can be executed on a station. Subpackages and modules errors Definitions of error classes used to raise issues during circuit comp...",
    "content": "Compile quantum circuits into instruction schedules and settings that can be executed on a station. Subpackages and modules errors Definitions of error classes used to raise issues during circuit compilation. previous iqm.cpc next iqm.cpc.compiler.errors By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.html",
    "description": "Definitions of error classes used to raise issues during circuit compilation. Exceptions CalibrationError A required calibration observation is missing from the calibration set, or an unknown gate cal...",
    "content": "Definitions of error classes used to raise issues during circuit compilation. Exceptions CalibrationError A required calibration observation is missing from the calibration set, or an unknown gate calibration observation is encountered. CircuitError There is something wrong with the quantum circuit. ClientError Client submitted a bad request, and needs to be notified. CompilationPassError There is something wrong with the compilation pass. InsufficientContextError The context provided to the compilation pass does not contain all necessary fields. SettingsConventionError While parsing Station Control settings, something breaks a structural or naming convention. UnknownCircuitExecutionOptionError An unsupported value was used in circuit execution options. UnknownHardwareComponentError Circuit contains a reference to an unknown hardware component. UnknownLogicalQubitError A logical qubit in the circuit has not been defined in the qubit mapping. previous iqm.cpc.compiler next iqm.cpc.compiler.errors.CalibrationError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.CalibrationError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.CalibrationError.html",
    "description": "A required calibration observation is missing from the calibration set, or an unknown\ngate calibration observation is encountered. previous iqm.cpc.compiler.errors next iqm.cpc.compiler.errors.Circuit...",
    "content": "A required calibration observation is missing from the calibration set, or an unknown\ngate calibration observation is encountered. previous iqm.cpc.compiler.errors next iqm.cpc.compiler.errors.CircuitError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.UnknownCircuitExecutionOptionError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.UnknownCircuitExecutionOptionError.html",
    "description": "An unsupported value was used in circuit execution options. previous iqm.cpc.compiler.errors.SettingsConventionError next iqm.cpc.compiler.errors.UnknownHardwareComponentError By IQM Pulla developers ...",
    "content": "An unsupported value was used in circuit execution options. previous iqm.cpc.compiler.errors.SettingsConventionError next iqm.cpc.compiler.errors.UnknownHardwareComponentError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.SettingsConventionError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.SettingsConventionError.html",
    "description": "While parsing Station Control settings, something breaks a structural or naming convention. previous iqm.cpc.compiler.errors.InsufficientContextError next iqm.cpc.compiler.errors.UnknownCircuitExecuti...",
    "content": "While parsing Station Control settings, something breaks a structural or naming convention. previous iqm.cpc.compiler.errors.InsufficientContextError next iqm.cpc.compiler.errors.UnknownCircuitExecutionOptionError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.1.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulse",
    "title": "Using ScheduleBuilder",
    "url": "/iqm-pulse/using_builder.html",
    "description": "This section describes how to use ScheduleBuilder to compose pulse schedules.\nScheduleBuilder encapsulates registered QuantumOps, the calibration information for them, QPU components and their\ntopolog...",
    "content": "This section describes how to use ScheduleBuilder to compose pulse schedules.\nScheduleBuilder encapsulates registered QuantumOps, the calibration information for them, QPU components and their\ntopology, and control channel properties. In the context of IQM Pulla and EXA, an instance of ScheduleBuilder is given by the framework,\nand it contains all the necessary information to execute against a particular quantum computer instance.\nHere, we assume that user has an instance of ScheduleBuilder builder to work with. A typical workflow begins with calling get_implementation() with the name of a desired QuantumOp and the locus\nfor the operation.\nThe locus is the logical target of the operation, usually a sequence of qubits or computational resonators.\nThis outputs a an instance of GateImplementation , which is capable of producing TimeBoxes with the correct\ncalibration for that locus. For example, here we ask for the GateImplementation of prx , cz , and measure , all of which are standard\ngates recognized by IQM Pulse, for qubits QB1 and QB3 .\nAny gate which is registered in the runtime can be requested this way. Notice how the number of qubits matches the operation: CZ acts on 2 qubits, while PRX acts on only one.\nMeasure can act on any number of qubits. There might be several available implementations for an operation. get_implementation gives the implementation that is set as the default, unless a specific implementation is\nrequested with a keyword argument. To instantiate some concrete TimeBoxes, we call time implementation with the logical parameters of the operations, as\ndefined by the QuantumOps.\nPRX has 2 parameters: the 2 angles of a phased rotation.\nCZ does not have any parameters. One important method is the wait() , which blocks the control channels of the given components for a certain time: In all of the examples above, the TimeBoxes are atomic, which can be organized into composite TimeBoxes to decide\ntheir relative order. TimeBoxes can be concatenated with the following rules: Addition ( + ) concatenates the children of the operands into a single TimeBox.\nUse addition to allow gates on disjoint loci to execute simultaneously, for example doing a PRX on all qubits. The pipe operation ( | ) groups two TimeBoxes together without concatenating.\nThis results in composite TimeBox with two children, the operands, which are scheduled separately.\nUse the pipe to ensure that certain operations execute before some others. Iterables of TimeBoxes are treated as the sum of the elements. This would execute 2 PRX gates on QB1 and QB2 simultaneously: If the last operator was | instead, the second gate on QB2 would execute only after the first 3 gates. Together, these rules provide a handy way of defining complex circuits easily: A TimeBox are made atomic by resolving it using ScheduleBuilder.resolve_timebox() .\nWhen using a framework like IQM Pulla or Exa, the framework will take care of the resolving as part of compilation,\nso the user does not need to do it explicitly. TimeBoxes are resolved recursively: The children of a TimeBox are resolved, and resulting (sub-)Schedules are aligned\naccording to the SchedulingStrategy (ASAP or ALAP) of the TimeBox.\nThe time duration of a TimeBox is determined by its contents and the way they are scheduled during the resolution.\nFinally, all channels are padded with Waits so that the total duration of Instructions on every channel is equal.\nIn other words, the Schedule becomes a \u201crectangle\u201d. An important part of the scheduling are the blocking rules, that is, whether the contents of two TimeBoxes block or\nslide past each other.\nThe rules are: An atomic TimeBox is considered to act on a component if it has instructions on any of the non-virtual channels\nrelated to that component. A composite TimeBox acts on the union of its children\u2019s locus components. A TimeBox blocks all channels related to any component it acts on. When scheduling two TimeBoxes, the instructions will not overlap in time if the TimeBoxes block overlapping channels. In addition to blocking the channels actually present in a TimeBox, it is possible to block neighbouring channels\nas well (for example in order to limit cross-talk).\nThe applied neighbourhood is specified in ScheduleBuilder.resolve_timebox() .\nThe neighbourhood is defined as an integer such that 0 means \u201cblock only the involved channels\u201d,\n1 means \u201cblock the involved channels and the channels of any neighbouring couplers\u201d,\n2 means \u201cthe same as in (1) but in addition block all channels connected by those couplers\u201d, and so on.\nThe blocking rules do not add actual Wait or Block instructions are added to the neighbourhood channels, and two\noverlapping neighbourhoods do not block each other.\nThe blocking comes in question only when actual content would be added to those neighbourhood channels. In practice, the rules and default GateImplementations ensure that the user can concatenate arbitrary gates\nwithout worrying that the gates have an adverse effect on each other.\nFor example, the pulse of a PRX gate playing at the same time as a CZ gate or a measurement would ruin both operations.\nIf overlapping of such gates is desired, the best way is to arrange the Instructions on the Schedule level and wrap the\nschedule into an atomic TimeBox. Note Virtual channels are special channels that exist only to aid the scheduling algorithm.\nExamples are tracking the phases of the MOVE gate, and timing of fast feedback.\nThese channels are removed when the Playlist is finalized. You are encouraged to discover the many features of ScheduleBuilder and TimeBox by reading the\nAPI: ScheduleBuilder , TimeBox . A quick reference of selected features is provided in the examples below. Finding information about the target system: Working with TimeBoxes: Some typical errors that are easy to make with the syntax: Not calling the implementation to get a TimeBox. The call is easy to forget especially if there are no parameters\nto give: Giving a single component as locus: previous Concepts and Classes next Custom gate implementations \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.15.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulse",
    "title": "IQM Pulse",
    "url": "/iqm-pulse/index.html",
    "description": "9.15.0 2025-06-22 IQM Pulse provides an abstraction that transforms high-level quantum circuit operations\nto a unified set of lower-level instructions for IQM quantum computers. A quantum circuit is a...",
    "content": "9.15.0 2025-06-22 IQM Pulse provides an abstraction that transforms high-level quantum circuit operations\nto a unified set of lower-level instructions for IQM quantum computers. A quantum circuit is an abstract mathematical construct which conveniently hides all implementation\ndetails such as the timing of microwave pulses, waveform shapes, sampling rates, signal capture, and so on.\nBut in order to execute a circuit you need to convert it into a schedule of hardware instructions which involve\nall of the above. IQM Pulse provides a framework for defining abstract quantum gates/operations, as well as their concrete implementations in terms of hardware instructions machinery to easily construct circuit-level gate sequences, and compile them into instruction schedules. a set of ready-made gates with implementations. IQM Pulse is not a standalone tool, but is used in IQM\u2019s client libraries, IQM Pulla and Exa.\nTo use them effectively, you are encouraged to familiarize yourself with IQM Pulse, especially the most common\nconcepts. Index Module Index Search Page next Concepts and Classes \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.15.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulse",
    "title": "Concepts and Classes",
    "url": "/iqm-pulse/concepts.html",
    "description": "This section gives an overview of the main concepts and terminology in IQM Pulse. QPUs contain components : qubits, computational resonators, couplers, and probelines. Each component may have some con...",
    "content": "This section gives an overview of the main concepts and terminology in IQM Pulse. QPUs contain components : qubits, computational resonators, couplers, and probelines. Each component may have some control channels connected to it. Control channels deliver physical control pulses\nto the QPU. Quantum operations have a locus , which is the set of quantum information carrying components\n(qubits and resonators) the operation acts on.\nOne operation may involve sending pulses to multiple control channels. The assembly of a Playlist, or a batch of quantum circuits, can be summarized as follows: A Playlist contains multiple independent segments , to be executed as a batch. A segment is a conceptual unit at a time scale where the quantum information of the QPU can be\nassumed to be preserved. A quantum circuit corresponds to one segment. What is executed during a segment is determined by a Schedule . A Schedule is a set of hardware control channels, each with a strictly timed sequence of Instructions . A Schedule is formed by scheduling a Timebox . A TimeBox can contain other TimeBoxes without precise relative timing,\nor it can be atomic, in which case it contains a single Schedule . The image below illustrates how a Playlist of two segments is formed from TimeBoxes. Hardware instructions are the lowest-level construct visible on the client side.\nInstructions are a set of atomic, real-time execution commands for the control hardware supported by IQM.\nThey work in a time scale where the quantum information of the QPU can be assumed to be preserved.\nExamples of Instructions are IQPulse to play a microwave pulse on a channel, VirtualRZ to adjust the modulation phase, ReadoutTrigger to acquire measurement data,\nand Wait to delay the next Instruction for a given time.\nSee iqm.pulse.playlist.instructions for the complete list. During execution, each hardware control channel executes its own sequence of Instructions.\nEach Instruction blocks the next until it is completed.\nInstructions are as explicit as possible, so that there is no ambiguity on what will be executed when.\nIQM Station control transforms Instructions to machine-specific commands. All Instructions have a duration, measured in samples, though the duration can be zero.\nThe durations are subject to hardware-specific granularity constraints.\nFor example, some hardware might require all instructions to be a multiple of 16 samples long, with a minimum of 32.\nInstructions violating the granularity constraints will raise an error.\nHowever, a typical user does not need to concern themselves about the constraints, as\nthe gate implementations and IQM Pulse\u2019s scheduling ensures the constraints are respected.\nThe philosophy is that Station Control, which is inaccessible to the user, does not attempt to do any smart\n\u201cmagic\u201d to fix inconsistencies in the user\u2019s input, it simply executes the Playlist it is given.\nInstead, the magic happens on the client side so that it is transparent to the user. Note For technical reasons, IQM Pulse mostly uses classes from iqm.pulse.playlist.instructions , but when\nfinalizing the output, the instructions are converted to iqm.models.playlist.instructions .\nThese two class families are semantically equivalent, apart from a few exceptions like Block which\nonly exists on the client side to help with scheduling. Schedule contains a number of control channels, each with a lists of Instructions.\nAll channels in a Schedule start executing at the same instant, and the timing is defined by the duration of the\nindividual Instructions.\nSchedules can be thought of as a fixed block that occupies some interval on a timeline of some channels. Schedules appear in two contexts: gate implementations and as complete segments.\nFor example, when an implementation of a PRX gate is requested,\na small Schedule involving the drive channel of a single qubit is created.\nWhen all the desired gates in a circuit have been scheduled by concatenating the gate-schedules together,\nthe end result, a segment, is a large Schedule occupying all necessary channels.\nA typical segment starts with initializing the qubits and ends with reading out their state. Whereas a Schedule is a container with strict relative timing, a TimeBox is a container with undefined\nrelative timing.\nEach TimeBox can be labeled using a human-readable label describing it, and operates on a number\nof locus components , using some of their control channels.\nA composite TimeBox contains other TimeBoxes as children, whereas atomic TimeBoxes contain a Schedule. TimeBoxes are the main language in which users define the order and relative alignment of execution elements, be it\ngates, Schedules, or larger TimeBoxes. A key process is the scheduling, in which TimeBoxes are resolved recursively into a fixed Schedule.\nWhen resolving, all Schedules inside the TimeBox are concatenated and are either left-aligned (ASAP) or right-aligned\n(ALAP), respecting the hardware constraints.\nImportantly, if some TimeBoxes have content on disjoint channels, the Schedules are allowed to happen simultaneously.\nIf they have content on partly overlapping channels, the Schedules are concatenated while preserving their internal\ntiming.\nAny interval that does not have explicit instructions is filled with Wait Instructions.\nThe figure above demonstrates how TimeBoxes are resolved. The syntax and rules are explained in more detail in Using ScheduleBuilder . A higher-level concept, a QuantumOp can represent a unitary quantum gate,\nor for example a measurement operation (not all QuantumOps necessarily represent a unitary gate).\nQuantumOps are simple, abstract, self-contained actions one can execute on a station as parts of a quantum circuit.\nThey include quantum gates like PRX, CZ, and measurements and resets.\nWhereas Schedules and Instructions act on control channels, QuantumOps act on named components on the QPU, such as\nqubits or computational resonators. A QuantumOp has unambiguous definition in terms of its intended effect on the computational subspace of the\nQPU component, but it can be implemented in various ways.\nEach implementation is represented as a GateImplementation. The list of available QuantumOps at runtime can be obtained with iqm.pulse.builder.build_quantum_ops() .\nA new QuantumOp can be registered at runtime, together with an implementation, with iqm.pulse.gates.register_implementation() . A GateImplementation bridges the gap between QuantumOps and TimeBoxes.\nWhen a user requests a QuantumOp from ScheduleBuilder with specific parameters and locus components, the\nchosen GateImplementation (usually the default) for the operation is used to produce a TimeBox.\nThis TimeBox, usually atomic, contains a Schedule on the appropriate control channels.\nThe Instructions within are constructed following the calibration values from the ScheduleBuilder. All gate implementations are listed in iqm.pulse.gates .\nSection Custom gate implementations explains how to add more implementations. Once all TimeBoxes are scheduled into large Schedules, one for each segment/circuit,\nthe Schedules are collected into a Playlist .\nThe Playlist is the final product that is sent to Station Control.\nIts contents are compressed by indexing all unique Instructions and waveforms on each channel,\nand representing the control channels in each segment as lists of Instruction indices. During execution, the segments in the Playlist are executed in order, and the whole sequence is repeated\na number of times equal to the number of repetitions (shots). Segments are separated in time by end delay , a parameter outside the Playlist.\nA long end delay can be used to prevent quantum information carrying from one segment to the next,\nthus resetting the qubits.\nAlternatively, the reset can be encoded in each segment as a long Wait instruction or using some active reset scheme. Station Control aims to execute all segments together, but sometimes this is not possible due to various memory\nconstraints.\nIn case the whole Playlist does not fit in memory, the segments are split into chunks which are executed separately.\nThe delay between chunks is undefined.\nTherefore, the time between segments is guaranteed to be at least the duration of the end delay, but can be much larger. inspect_playlist() provides a neat visual representation of the playlist, as blocks of instructions on a\ntimeline. previous IQM Pulse next Using ScheduleBuilder \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.15.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulse",
    "title": "References",
    "url": "/iqm-pulse/references.html",
    "description": "R.\u00a0G. Lyons. Understanding Digital Signal Processing . Prentice Hall, 2nd edition, 2004. ISBN 978-0131089891. Cecilia\u00a0Gisele Jarne. A heuristic approach to obtain signal envelope with a simple softwar...",
    "content": "R.\u00a0G. Lyons. Understanding Digital Signal Processing . Prentice Hall, 2nd edition, 2004. ISBN 978-0131089891. Cecilia\u00a0Gisele Jarne. A heuristic approach to obtain signal envelope with a simple software implementation. ANALES AFA , 29(2):51\u201357, 2018. arXiv:1703.06812 , doi:10.31527/analesafa.2018.29.2.51 . John\u00a0M. Martinis and Michael\u00a0R. Geller. Fast adiabatic qubit gates using only $\\sigma _z$ control. Phys. Rev. A , 90:022307, Aug 2014. arXiv:1402.5467 , doi:10.1103/PhysRevA.90.022307 . Eyob\u00a0A. Sete, Nicolas Didier, Angela\u00a0Q. Chen, Shobhan Kulshreshtha, Riccardo Manenti, and Stefano Poletto. Parametric-resonance entangling gates with a tunable coupler. Phys. Rev. Appl. , 16:024050, Aug 2021. arXiv:2104.03511 , doi:10.1103/PhysRevApplied.16.024050 . Youngkyu Sung, Leon Ding, Jochen Braum\u00fcller, Antti Veps\u00e4l\u00e4inen, Bharath Kannan, Morten Kjaergaard, Ami Greene, Gabriel\u00a0O. Samach, Chris McNally, David Kim, Alexander Melville, Bethany\u00a0M. Niedzielski, Mollie\u00a0E. Schwartz, Jonilyn\u00a0L. Yoder, Terry\u00a0P. Orlando, Simon Gustavsson, and William\u00a0D. Oliver. Realization of high-fidelity CZ and ZZ-free iSWAP gates with a tunable coupler. Phys. Rev. X , 11:021058, Jun 2021. arXiv:2011.01261 , doi:10.1103/PhysRevX.11.021058 . Eric Hyypp\u00e4, Antti Veps\u00e4l\u00e4inen, Miha Papi\u010d, Chun\u00a0Fai Chan, Sinan Inel, Alessandro Landra, Wei Liu, J\u00fcrgen Luus, Fabian Marxer, Caspar Ockeloen-Korppi, and others. Reducing leakage of single-qubit gates for superconducting quantum processors using analytical control pulse envelopes. PRX Quantum , 5(3):030353, 2024. doi:10.1103/PRXQuantum.5.030353 . previous Changelog next License \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.15.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulse",
    "title": "API Reference",
    "url": "/iqm-pulse/API.html",
    "description": "iqm.pulse Control pulses, gates and instruction schedules for quantum computers. previous Pulse timing next pulse \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.15.0. Last updated on 2025-06-22....",
    "content": "iqm.pulse Control pulses, gates and instruction schedules for quantum computers. previous Pulse timing next pulse \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.15.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulse",
    "title": "Pulse timing",
    "url": "/iqm-pulse/pulse_timing.html",
    "description": "The ReadoutTrigger Instruction responsible of qubit readout has several\ntiming-related attributes.\nThe measure.constant gate implementation produces the lower-level ReadoutTrigger instruction\nfrom a s...",
    "content": "The ReadoutTrigger Instruction responsible of qubit readout has several\ntiming-related attributes.\nThe measure.constant gate implementation produces the lower-level ReadoutTrigger instruction\nfrom a simplified set of settings.\nThe figure below shows how the settings relate to the more flexible attributes of the instruction. With conditional Instructions, we specify how the information from readout operations should affect Instructions at\nruntime.\nUsually, the goal is use the information as soon as possible, but it takes a finite time to propagate from the\nacquisition unit to the drive channels that execute the Instructions conditionally. Note On all hardware supported by IQM QCCSW, ConditionalInstruction reads the signal bit at the time of\nexcution, regardless of when the signal bit was last updated.\nThis means that if the Conditionalinstruction is executed too early, the condition will be executed based on the\nprevious state of the bit. To facilitate efficient timing of the feedback signals, IQM Pulse uses virtual channels between probeline channels\n(the source of the signals) and drive channels (the destinations).\nBlock instructions on the virtual channel represent the travel time of the signals. CCPRX_Composite is GateImplementation of the cc_prx (classically controlled PRX) that outputs two\nTimeBoxes:\nthe first one to represent the travel time, and the second one with the actual ConditionalInstruction .\nIn typical use, both should be scheduled in the same order, to ensure the Conditionalinstrucion starts when the\nsignal bit is available. The following image illustrates how the TimeBoxes are used for qubits QB2 and QB3 .\nFor QB2, this is also how Reset_Conditional implements the reset operation. The equaivalent code would be Instructions are spaced out in time only for visual clarity. When scheduled ASAP, they would be left-aligned\nsuch that the ConditionalInstructions start right after the associated control_delay has passed. The bottom of the image illustrates an alternative use of CCPRX_Composite to have more freedom in the timing.\nThere, the optional delay TimeBox is not used for scheduling the Instructions on QB4.\nInstead, the user has ensured that the other instructions take enough time for the signal to arrive.\nThis could be used to act on the previous feedback signal (not shown). Note This section is not about IQM Pulse itself, but might help in understanding the details of the execution. The image below shows a typical timing of a Playlist segment with 2 AWG devices for driving, and a readout instrument.\nHere, all statements that apply to an AWG apply to readout instruments as well.\nThe AWGs can output an arbitrary sequence of pulses, and the readout instrument can additionally read out\nthe response to the pulses. With readout, the raw signal response from the readout pulse will be integrated to produce a single number, such as a\ncomplex number or a bit, corresponding to a particular qubit in a particular segment. In the figure, one of the AWGs has been selected as the trigger master, which means it sends trigger pulses to\nstart the execution on the slave devices.\nAs shown in the picture, different delays caused by the travel time of signals can be compensated for by\nadjusting the trigger_delay setting of each device. Settings in the figure that can be adjusted by user in the higher level libraries: Setting Explanation <awg>.trigger_delay Wait time between the end of the trigger signal of the AWG master and the beginning of the pulse sequence. <awg>.trigger_delay (slave) Wait time between receiving the trigger signal at the AWG slave and the beginning of the pulse sequence. options.end_delay Wait time between the end of the pulse segment and the next trigger. <gate>.<implementation>.<locus>.duration The duration of the hardware instruction for a gate, possibly rounded to satisfy granularity constraints.\nFor the ReadoutTrigger instruction, the meaning is different, see below. Other notes: The AWG spcecified by options.trigger_master is the only channel that does not wait for a trigger\nat the start of a segment. Slave AWGs may also emit a trigger pulse to allow daisy chaining trigger signals. Systems with IQM Control System are triggered centrally and the channels run independently, and the options.trigger_master has no effect. Pipeline delays are delays between the execution of a command and the pulse actually getting outputted\nfrom a device. This delay is caused by the hardware and cannot be changed.\nIn practice, it can be thought as being part of the cable delays, and thus can be compensated with trigger_delay setting. previous Custom gate implementations next API Reference \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.15.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulse",
    "title": "Custom gate implementations",
    "url": "/iqm-pulse/custom_gates.html",
    "description": "Quantum gates are represented by QuantumOp data classes, containing the required\nmetadata to define the gate. A QuantumOp is identified by its name , and arity defines number of locus components the o...",
    "content": "Quantum gates are represented by QuantumOp data classes, containing the required\nmetadata to define the gate. A QuantumOp is identified by its name , and arity defines number of locus components the operation acts on. For example,\nthe PRX operation (Phased X Rotation) is a single-qubit operation, so its arity is 1, whereas the CZ (Controlled-Z) gate\nacts on two qubits, having arity 2. Arity 0 has a special meaning that the operation in question can act on any number\nof components (for example Barrier ). The attribute symmetric defines whether the effect of the quantum operation\nis symmetric with respect to changing the order of its locus components. As an example, the CZ gate is a symmetric\ntwo-qubit gate, whereas CNOT (Controlled-NOT) is not symmetric. Some quantum operations are defined as \u201cfunctions\u201d, taking one or more parameters to define the effect. These\narguments are stored in the attribute params . As an example, the PRX gate\ntakes two arguments, angle (the rotation angle with respect to the z-axis of the Bloch sphere), and phase (the rotation phase in the rotating frame). On the other hand, many operations do not require any parameters, in\nwhich case this field is an empty tuple (e.g. the CZ gate). A QuantumOp has unambiguous definition in terms of its intended effect on the computational subspace of the\nQPU component, but it can be implemented in various ways. Each implementation is represented as a GateImplementation subclass. A QuantumOp stores its known implementations in the\nfield implementations . Note that even though QuantumOp is a frozen data class, the implementations dictionary can be modified, e.g.\nto add new implementations or to change their order (usually programmatically by some client procedure, but nothing as\nsuch prevents the user from manipulating the contents manually). The default implementation is how the user prefers\nto implement the operation unless otherwise specified (in effect, this is what will get called in most cases the\noperation is invoked). In the implementations dict, the default implementation is defined as the first entry.\nQuantumOp contains helpful methods that allow setting and returning the default implementation for specific cases: set_default_implementation() , get_default_implementation_for_locus() , and set_default_implementation_for_locus() . The attribute unitary stores a function that can be used to get the unitary\nmatrix representing the quantum operation in question. The unitary function must have the same arguments\nas defined in params , such that for each collection of these parameters it\ngives the associated unitary matrix. Note that not all QuantumOps necessarily even represent a unitary gate (e.g.\nthe measure operation is not one), or the exact form of the unitary matrix might not be known. In these cases, the\nfield can be left None . The unitary does not need to be defined for most of the basic usage of a QuantumOp, but certain\nalgorithmic methods (e.g. some implementations of Randomized Benchmarking) may require the unitary matrices to be known,\nand such operations that do not define the getter function cannot then be used in these contexts. For more information, see the API docs of QuantumOp for the full list of fields needed\nto define a quantum operation and the available class methods. While QuantumOp represents an abstract quantum operation, its implementations contain\nthe concrete logic of how to make that operation happen using QC hardware. Gate implementations are subclasses of GateImplementation . In this section, the main features of that class are\nintroduced (for a full list of class methods see the API docs), with the emphasis being on how to create your own\ngate implementations. Starting with __init__() , it is important to note that the init\nmethods of all gate implementations must have the exact same signature: Here, parent is the QuantumOp this gate implementation implements, and name is the implementation\u2019s name in\nthe dictionary implementations . locus is the set of (usually logical) components\nthe QuantumOp acts on (the size of the locus must be consistent with the parent \u2019s arity ), while calibration_data gives the required calibration data values\nfor this implementation and locus (can be empty in case the implementation needs no calibration data). Finally,\nThe implementations store a reference to the ScheduleBuilder that created it. This is\nbecause GateImplementations are practically never created manually by calling the init method itself. Instead, one\nneeds a builder and uses get_implementation() . The responsibility of the init method is to (at least) store the calibration_data provided from the builder for\nfurther use, but in many cases, one might want to create some intermediate objects like pulses or instructions from that calibration data already at this point. Note that ScheduleBuilder caches its GateImplementations per each locus and calibration_data , so as long as the calibration is not changed, the code in init will be called just once per locus. GateImplementations are Callables, i.e. they implement the __call__ method. It should take as its arguments at least\nthe QuantumOpt parameters defined for the parent in params , but in\naddition it may have optional extra arguments. The call method should return a TimeBox object\nthat contains the pulses, instructions and other logic required to implement the quantum operation in question. The\ntypical usage of gate implementations then looks like this (See Using ScheduleBuilder and Pulse timing for more\ninfo on scheduling and the ScheduleBuilder): The base class __call__() method does automatic TimeBox caching based\non the unique values of the call arguments, and in many cases, one does not want to reimplement this caching in their own\nimplementations. For this reason, there is the method _call which contains just the pure TimeBox creation logic.\nDevelopers can choose to override that instead of __call__ in cases where the call args are hashable python types,\nand then they can utilize the default caching of TimeBoxes from the base class. When writing a GateImplementation, a developer should consider what parts of the logic should go to the class init and\nwhat to the __call__ or _call method. A general rule of thumb would be that any parts that can be precomputed\nand do not depend on the call arguments can go to init, and the rest to call. As an example, let\u2019s go through a simple PRX _call method (note that the default PRX implementations do not\nuse this exact call method, as this is a simplified example for educational purposes): Here, we first create an IQPulse object which is a low-level Instruction. IQPulse\nmeans a \u201ccomplex pulse\u201d which has two orthogonal components i and q \u2013 this what drive pulses look like in general. In\nthis simplified example, we have hardcoded the pulse waveforms into TruncatedGaussian and TruncatedGaussianDerivative for the i and q components, respectively (this is a DRAG implementation, so the\nq component is the derivative of the i component). The waveforms are parametrized by the calibration_data for the\ngiven locus (see the next subsection for more info on Waveforms and calibration data). The PRX QuantumOp param angle scales the pulse amplitude linearly (the waveforms are normalized to one), and the param phase defines relative\nphase modulation. Then the returned TimeBox is created out of the instruction . Note that\nsince we override _call here, instead of __call__ , so this implementation would utilize the default base class\ncaching such that the TimeBoxes are cached per unique values of (angle, phase) . Another important concept is a the so called locus mapping of a gate implementation. Locus mappings define on which\nloci, i.e. groups of components, a given implementation can be defined. They are used to relay the information which\nloci are supported to a client application (e.g. EXA). In addition, the gate implementation itself can programmatically\nuse this information self.builder.chip_topology . For example, a PRX can be defined on all single components that are connected to a drive line, and CZ can be defined on\nconnected pairs of qubits. Locus mappings live in ScheduleBuilder.chip_topology which is a ChipTopology object. Locus mapping is a dict whose keys are the loci\n( tuple[str, ...] keys denote asymmetric loci where the order of the components matter, and frozenset[str] type\nloci denote symmetric ones), and the values are groups of components, typed tuple[str, ...] , where each locus can be\nmapped with some additional components that are needed for the operation of the implementation. For example, some CZ\nimplementation that tries to correct for crosstalk could map the non-locus components that see this crosstalk here.\nThe values of the dict can be left empty or just replicate the key components in case such extra information is not\nneeded. GateImplementations can define their locus mappings via get_custom_locus_mapping() or if a client application already\nadds the mapping, we can just return its name via get_locus_mapping_name() .\nIf neither of these methods are overridden in a GateImplementation class, the default behaviour will be such that an arity==1 loci will be assumed to use the mapping where all single qubits are the keys, and arity==2 loci the\n(symmetric) mapping where the keys are all pairs of connected qubits. For other arities there is no default behaviour,\nso it is then mandatory to define the mapping explicitly using the aforementioned methods. In order to implement most QuantumOps, one has to physically alter the state of the QPU. This is typically done by playing\nspecified and correctly calibrated pulses via the control electronics (this applies to all typical logical gates such as\ne.g. PRX or CZ \u2013 non-physcial metaoperations such as Barrier are an exception). In defining these pulses, there are two\nlevels of abstractions: Waveform and Instruction . Waveform represents the physical form of the control pulse, typically normalized to the interval [-1.0, 1.0] . The\nEach Waveform subclass can define any number of waveform parameters as class\nattributes, which can be used to programmatically define the waveform. For example, a Gaussian could be defined in terms\nof the average mu and spread sigma . A Waveform class then essentially contains just the parameters\nand a recipe for computing the samples as an np.ndarray . As an example, here is how one writes the Waveform class\nfor Gaussian : The Instructions RealPulse and IQPulse allow handling the amplitudes (via the attribute scale ) without\nhaving to resample the waveform for every different amplitude value. However, one can always choose to include\nthe amplitude into the sampling and then use scale=1 . The waveform parameters (like sigma in the above Gaussian) typically require calibration when the Waveform is used\nin a quantum gate. However, the GateImplementation usually has other calibrated parameters as well defined in the\nimplementation itself. As an example, here are the implementation-level parameters of the default PRX implementation,\ndefined as class attribute: Note the amplitudes are defined here on this level, since the default PRX uses normalized Waveforms and factors in the\namplitudes via scale . In these parameters, the unit is not just metadata. The control electronics understand time\nin terms of samples and their sample rate, while human users typically want to input seconds instead of doing the sample\nconversion manually. For this reason, there is logic that converts anything that has the unit \"s\" into samples.\nSimilarly, parameters with \"Hz\" units are converted to 1/sample . For the Waveform parameters, the same logic\napplies, but by default it is assumed that all parameters are time-like and this converted from seconds to samples.\nIf some Waveform parameters needs to be made unitless or e.g. frequency-like (with \"Hz\" units), it can be achieved\nwith the method non_timelike_attributes() : In the above dict, the keys should be the attribute names and values their units. To make creating new GateImplementations more comfortable, there are additional base classes on top of GateImplementation itself. CompositeGate allows quick implementation of gates in terms of other gates,\nusing a similar syntax as with creating/scheduling several TimeBoxes together (see Using ScheduleBuilder ). At it\nsimplest, a ComposteGate is just the _call method: Here, one could use also builder.get_implementation instead of build() , but the latter allows calibrating the member gates\ncase specifically for this composite if they are first registered via registered_gates (in this case, there is\njust one member, PRX). Creating new implementations for the PRX, CZ and Measure gates often means just coming up with new waveforms for the\ncontrol pulses. If this is the case, there are helpful base classes that make those implementations into oneliners\n(outside of defining the Waveforms themselves): PRX_CustomWaveforms , FluxPulseGate , and Measure_CustomWaveforms . Using these\nbase classes at its simplest looks like this: All of these classes automatically include the associated Waveform parameters into the calibration parameters of\nthe implementation itself. There is also a general base class for any gate that implements a single IQPulse (both PRX_CustomWaveForms and Measure_MyCoolWaveforms actually inherit from it), regardless of the context: CustomIQWaveforms . Gate definitions (i.e. QuantumOps) are stored in ScheduleBuilder \u2019s attribute op_table . When the builder is created, the op_table comes preloaded with the all the basic QuantumOps needed for\ntypical circuit execution and their default implementations. These include e.g. the PRX gate, the CZ gate, the measure\noperation, the conditional prx operation, the reset operation, and the barrier operation. In order to add custom operations, there is a helpful function register_implementation() that\nin addition to adding new implementations allows one to add altogether new quantum operations. As an example here is a snippet that adds the CNOT gate, and its implementation, into an existing builder: Here, the CNOT implementation MyCNotClass needs to be of course defined first (a QuantumOp always needs at least one\nimplementation). Note: The end user cannot modify the canonical mapping (defined in iqm-pulse) between implementation_name and implementation_class . Note that often ScheduleBuilder is created and operated by some client application, and the same application usually\nhas its own interface for adding/manipulating QuantumOps. However, if the user has access to the builder object, the\nabove method will always work. previous Using ScheduleBuilder next Pulse timing \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.15.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-pulse",
    "title": "pulse",
    "url": "/iqm-pulse/api/iqm.pulse.html",
    "description": "Control pulses, gates and instruction schedules for quantum computers. Full path: iqm.pulse Subpackages and modules previous API Reference next Changelog \u00a9 Copyright 2019-2025, IQM Finland Oy, Release...",
    "content": "Control pulses, gates and instruction schedules for quantum computers. Full path: iqm.pulse Subpackages and modules previous API Reference next Changelog \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.15.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-station-control-client",
    "title": "API documentation: station-control-client",
    "url": "/iqm-station-control-client/index.html",
    "description": "9.0.0 2025-06-22 This is the documentation of the IQM station-control client library. Index Module Index Search Page next API Reference \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.0.0. Last updat...",
    "content": "9.0.0 2025-06-22 This is the documentation of the IQM station-control client library. Index Module Index Search Page next API Reference \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.0.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-station-control-client",
    "title": "API Reference",
    "url": "/iqm-station-control-client/API.html",
    "description": "iqm.station_control.client Station control client implementation. iqm.station_control.interface Station control interface. previous API documentation: station-control-client next client \u00a9 Copyright 20...",
    "content": "iqm.station_control.client Station control client implementation. iqm.station_control.interface Station control interface. previous API documentation: station-control-client next client \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.0.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-station-control-client",
    "title": "testing",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.testing.html",
    "description": "Full path: iqm.station_control.client.iqm_server.testing Subpackages and modules previous iqm_server next interface \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.0.0. Last updated on 2025-06-22....",
    "content": "Full path: iqm.station_control.client.iqm_server.testing Subpackages and modules previous iqm_server next interface \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.0.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-station-control-client",
    "title": "list_with_meta",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.list_with_meta.html",
    "description": "Models to extend standard list with metadata. Full path: iqm.station_control.interface.list_with_meta Classes ListWithMeta Standard list extension holding optional metadata as well. Meta Class holding...",
    "content": "Models to extend standard list with metadata. Full path: iqm.station_control.interface.list_with_meta Classes ListWithMeta Standard list extension holding optional metadata as well. Meta Class holding metadata for list return values, like pagination related data. Inheritance previous interface next ListWithMeta \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.0.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-station-control-client",
    "title": "pydantic_base",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.pydantic_base.html",
    "description": "Pydantic related models and types. Full path: iqm.station_control.interface.pydantic_base Classes PydanticBase Pydantic base model to change the behaviour of pydantic globally. Inheritance previous Me...",
    "content": "Pydantic related models and types. Full path: iqm.station_control.interface.pydantic_base Classes PydanticBase Pydantic base model to change the behaviour of pydantic globally. Inheritance previous Meta next PydanticBase \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.0.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm_server",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.html",
    "description": "StationControlClient implementation for IQM Server Full path: iqm.station_control.client.iqm_server Subpackages and modules testing  previous client next testing \u00a9 Copyright 2019-2025, IQM Finland Oy,...",
    "content": "StationControlClient implementation for IQM Server Full path: iqm.station_control.client.iqm_server Subpackages and modules testing  previous client next testing \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.0.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-station-control-client",
    "title": "interface",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.html",
    "description": "Station control interface. A StationControlInterface administers a set of control and measurement instruments\nattached to a quantum device, and connects to the database and related external services. ...",
    "content": "Station control interface. A StationControlInterface administers a set of control and measurement instruments\nattached to a quantum device, and connects to the database and related external services. Full path: iqm.station_control.interface Subpackages and modules list_with_meta Models to extend standard list with metadata. pydantic_base Pydantic related models and types. previous testing next list_with_meta \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.0.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-station-control-client",
    "title": "PydanticBase",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.pydantic_base.PydanticBase.html",
    "description": "Bases: BaseModel Pydantic base model to change the behaviour of pydantic globally.\nNote that setting model_config in child classes will merge the configs rather than override this one. https://docs.py...",
    "content": "Bases: BaseModel Pydantic base model to change the behaviour of pydantic globally.\nNote that setting model_config in child classes will merge the configs rather than override this one. https://docs.pydantic.dev/latest/concepts/config/#change-behaviour-globally Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.pydantic_base Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Methods Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous pydantic_base next Changelog \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.0.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-station-control-client",
    "title": "ListWithMeta",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.list_with_meta.ListWithMeta.html",
    "description": "Bases: list Standard list extension holding optional metadata as well. Module: iqm.station_control.interface.list_with_meta Methods items ( Iterable ) \u2013 meta ( Meta ) \u2013 previous list_with_meta next Me...",
    "content": "Bases: list Standard list extension holding optional metadata as well. Module: iqm.station_control.interface.list_with_meta Methods items ( Iterable ) \u2013 meta ( Meta ) \u2013 previous list_with_meta next Meta \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.0.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-station-control-client",
    "title": "client",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.html",
    "description": "Station control client implementation. Full path: iqm.station_control.client Subpackages and modules iqm_server StationControlClient implementation for IQM Server previous API Reference next iqm_serve...",
    "content": "Station control client implementation. Full path: iqm.station_control.client Subpackages and modules iqm_server StationControlClient implementation for IQM Server previous API Reference next iqm_server \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.0.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-station-control-client",
    "title": "Meta",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.list_with_meta.Meta.html",
    "description": "Bases: object Class holding metadata for list return values, like pagination related data. Module: iqm.station_control.interface.list_with_meta Attributes count  errors  limit  offset  order_by  Metho...",
    "content": "Bases: object Class holding metadata for list return values, like pagination related data. Module: iqm.station_control.interface.list_with_meta Attributes count  errors  limit  offset  order_by  Methods count ( int | None ) \u2013 order_by ( str | None ) \u2013 limit ( int | None ) \u2013 offset ( int | None ) \u2013 errors ( list [ str ] | None ) \u2013 previous ListWithMeta next pydantic_base \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.0.0. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-qaoa",
    "title": "SK Model and Transpilation",
    "url": "/iqm-qaoa/SK Model and Transpilation.html",
    "description": "The purpose of this notebook is to showcase the QAOA library working from the problem definition all the way to execution on a real hardware. In particular, here we use QAOA to solve an instance of th...",
    "content": "The purpose of this notebook is to showcase the QAOA library working from the problem definition all the way to execution on a real hardware. In particular, here we use QAOA to solve an instance of the Sherrington-Kirkpatrick (SK) model, a very densely connected problem, to illustrate the advantage of using our custom transpiler over the Qiskit default transpiler. The SK model describes a number of binary variables, every pair of which interacts with a random interaction strength. We will solve a problem of size problem_size , i.e., this will be the number of binary variables and also the number of qubits that we use. The number of shots is set to default maximum on Resonance. We create an instance of the SK model of size problem_size . We specify the random distribution of the interactions between the variables to be \u201cgaussian\u201d (with mean 0 and variance 1). A few other distributions are possible (e.g., \u201cuniform\u201d or \u201crademacher\u201d). We print out the largest, lowest and average energy of the model, calculated by brute-forcing over all possible bitstrings of length problem_size . This may be slow if problem_size has been set higher than ~30. In the following, we set up the connection to Resonance and define a simulator backend of the Garnet QPU. Note: in general, you also need to specify the \u2018usage mode\u2019. For running on a real machine (in pay-as-you-go usage mode), the url would change to https://cocos.resonance.meetiqm.com/garnet. For a specific timeslot the url would change to https://cocos.resonance.meetiqm.com/garnet:timeslot Create the QUBO QAOA instance from the problem instance, train it and then construct the QAOA circuits using 4 different methods: The perfect circuit without any transpilation. The circuit transpiled for IQM hardware, using Qiskit default transpilation function. The circuit transpiled for IQM hardware, using our custom transpiler. The circuit transpiled for IQM hardware, using the swap network strategy. The train method has several possible parameters, but here the default setting is used (which uses analytical formulas since the QAOA has one layer). Run the perfect circuit on perfect (noiseless simulator), print out the average energy of the samples. Run the Qiskit-transpiled circuit on our hardware, print out the average energy of the samples and the number of gates used. Run the custom-transpiled circuit on our hardware, print out the average energy of the samples and the number of gates used. Run the swap-network-transpiled circuit on our hardware, print out the average energy of the samples and the number of gates used. If everything went as expected, the hardwired transpiler and the swap network transpiler should perform better than the qiskit default transpiler. The hardwired transpiler minimizes the number of 2QB gates used whereas the swap network transpiler minimizes the overall depth of the circuit. Based on the average energy obtained with the two approaches, we can judge which is better for our hardware (and this particular problem size). previous Usage Examples next Sparse Maxcut By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-qaoa",
    "title": "IQM QAOA",
    "url": "/iqm-qaoa/readme.html",
    "description": "Usually it makes sense to use a new Python environment, to isolate your setup from the global Python installation. That way, you can play around without messing the rest of your system. Using uv in te...",
    "content": "Usually it makes sense to use a new Python environment, to isolate your setup from the global Python installation. That way, you can play around without messing the rest of your system. Using uv in terminal: Using Conda in terminal: In Visual Studio Code: Open the list of commands Ctrl + Shift + p . Select Python: Create Environment . Select Venv . Select the correct Python version. Then run If you have already installed the QAOA library and want to get the latest release you can add the --upgrade flag Documentation for the latest version is available online . previous IQM QAOA next Usage Examples By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-qaoa",
    "title": "Training the QAOA",
    "url": "/iqm-qaoa/Training the QAOA.html",
    "description": "In this notebook we showcase (and compare) various strategies of training the QAOA, that is finding the optimal values for the variational parameters (also known as QAOA angles ). We start by generati...",
    "content": "In this notebook we showcase (and compare) various strategies of training the QAOA, that is finding the optimal values for the variational parameters (also known as QAOA angles ). We start by generating a quasi-random instance of the maxcut problem (with 10 nodes). Generate a QAOA instance from the problem instance. We use the TreeQAOA class, which is identical to the QUBOQAOA class, but it contains one extra way to \u201ctrain\u201d the QAOA parameters. For training the QAOA, we will use various estimators . An estimator is a function (technically a class with a method) which takes a QAOA object and calculates/estimates the expectation value of the Hamiltonian. Similarly, a sampler takes a QAOA object and generates samples (measurement results) of possible solutions. Here we also set up a variable results to store the results of our experiments, for comparison. It\u2019s a dictionary of dictionaries, keyed first by the training method and then by the QAOA number of layers. We start with EstimatorSingleLayer . For single-layer QAOA, the expectation values of 1- and 2-qubit operators can be calculated analytically. This estimator does the calculation. Next, we train using EstimatorStateVector . This estimator runs the statevector simulation of the QAOA circuit to calculate the expectation value of the Hamiltonian. Next, we train using EstimatorFromSampler together with SamplerSimulation . This estimator calls a given sampler and uses the obtained samples to estimate the expectation value (by calculating the energy of each of the samples and averaging them out). The SamplerSimulation runs the simulation of the QAOA circuit, including the measurements. Next, we again use EstimatorFromSampler together with SamplerSimulation . But this time we calculate not the expectation value , but the conditional value at risk at 0.1 level. We use this value in training the QAOA, possibly changing the performance. Next, we train using EstimatorFromSampler again, but this time together with SamplerResonance . This sampler actually runs the circuit via Resonance, IQM\u2019s cloud quantum computing platform. WARNING When running training using this estimator, Resonance is used for every training cycle, potentially taking a lot of time (even when using a mock QC)! The if clause surrounding the cell makes sure that it\u2019s skipped during testing (because it\u2019s too slow). Now we \u201ctrain\u201d the angles by setting them to the Tree QAOA angles. The Tree QAOA angles are the optimal angles for problems on regular infinite random graphs, where the neighborhood of each node is a tree graph. These angles are pre-calculated for various values of graph regularity and parameters of the Hamiltonian. The method set_tree_angles looks at the parameters of our problem and sets the QAOA angles to the corresponding Tree QAOA angles. While these angles aren\u2019t likely the most optimal angles for our problem, they are likely to produce good results and it allows us to skip conventional QAOA training completely. More reading on Tree QAOA For comparison we now repeat all of the above (except for EstimatorSingleLayer ) for QAOA with 2 layers and summarize the data in a table. We expect the Statevector , Simulated Samples and the Single Layer methods to perform the best (although none of them is scalable). Using CVaR instead of the mean gives better results, but this is expected, given that we\u2019re looking at a tail of a distribution. Whether it actually helps in training the QAOA is not clear. We expect all methods to improve with increasing p . previous Portfolio Optimization next API Reference By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-qaoa",
    "title": "Portfolio Optimization",
    "url": "/iqm-qaoa/Portfolio Optimization.html",
    "description": "The purpose of this notebook is to showcase the QAOA library working from the problem definition all the way to execution on a real hardware. In particular, here we use QAOA to solve a particular inst...",
    "content": "The purpose of this notebook is to showcase the QAOA library working from the problem definition all the way to execution on a real hardware. In particular, here we use QAOA to solve a particular instance of portfolio optimization. First, we describe the problem: we have n_assets assets, each with an expected_return . The variable containing the covariances and variances is called cov_mat . The goal is to choose a set of assets which maximize the yield, while minimizing the covariance, weighted by the investor\u2019s risk_aversion (the higher, the more likely the investor is to avoid risk). The budget says how many assets we can buy. Within the QAOA library, quadratic binary optimization problems are represented as objects of BinaryQuadraticModel or ConstrainedQuadraticModel from the dimod package ( read more about the models here ). In order to define a custom constrained problem in our QAOA library ( ConstrainedQuadraticInstance ), we need to create a custom object of ConstrainedQuadraticModel , by defining the objective and the constraint. The objective is the expected return minus the variance of the portfolio weighted by the risk aversion. The constraint has the identity matrix on the left-hand side (i.e., the number of selected assets) and the budget on the right-hand side. In the following, we set up the connection to Resonance and define a simulator backend of the Garnet QPU. Note: in general, you also need to specify the \u2018usage mode\u2019. For running on a real machine (in pay-as-you-go usage mode), the url would change to https://cocos.resonance.meetiqm.com/garnet. For a specific timeslot the url would change to https://cocos.resonance.meetiqm.com/garnet:timeslot Create the QUBO QAOA instance from the problem instance and train it. The train method has several possible parameters, but here the default setting is used (which uses analytical formulas since the QAOA has one layer). Sample for a solution from the QAOA and post-process the result (removing the samples violating the constraint). The sample method of my_qaoa typically expects a number of shots. By omitting this parameter, it defaults to 20 000, the default maximum number on Resonance. The format of the samples is a dictionary whose keys are bitstrings (the individual samples that were taken) and whose values are integers (the number of times each sample was taken). We may now examine the found solutions. previous Sparse Maxcut next Training the QAOA By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-qaoa",
    "title": "Usage Examples",
    "url": "/iqm-qaoa/examples.html",
    "description": "previous IQM QAOA next SK Model and Transpilation By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22....",
    "content": "previous IQM QAOA next SK Model and Transpilation By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-qaoa",
    "title": "IQM QAOA",
    "url": "/iqm-qaoa/index.html",
    "description": "1.3.0 2025-06-22 Python implementation of the Quantum Approximate Optimization Algorithm (QAOA), compatible with IQM quantum computers. Index Module Index Search Page next IQM QAOA By IQM QAOA develop...",
    "content": "1.3.0 2025-06-22 Python implementation of the Quantum Approximate Optimization Algorithm (QAOA), compatible with IQM quantum computers. Index Module Index Search Page next IQM QAOA By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-qaoa",
    "title": "References",
    "url": "/iqm-qaoa/references.html",
    "description": "J.\u00a0A. Montanez-Barrera and Kristel Michielsen. Towards a universal QAOA protocol: evidence of a scaling advantage in solving some combinatorial optimization problems. https://arxiv.org/abs/2405.09169 ...",
    "content": "J.\u00a0A. Montanez-Barrera and Kristel Michielsen. Towards a universal QAOA protocol: evidence of a scaling advantage in solving some combinatorial optimization problems. https://arxiv.org/abs/2405.09169 , May 2024. Asier Ozaeta, Wim van Dam, and Peter\u00a0L McMahon. Expectation values from the single-layer quantum approximate optimization algorithm on ising problems. Quantum Science and Technology , Dec 2020. arXiv:2012.03421 . Ayse Kotil, Fedor Simkovic, and Martin Leib. Improved qubit routing for QAOA circuits. https://arxiv.org/abs/2312.15982 , Dec 2023. Michel\u00a0X. Goemans and David\u00a0P. Williamson. Improved approximation algorithms for maximum cut and satisfiability problems using semidefinite programming. J. ACM , 42(6):1115\u20131145, November 1995. URL: https://doi.org/10.1145/227683.227684 , doi:10.1145/227683.227684 . J.\u00a0Misra and David Gries. A constructive proof of vizing's theorem. Information Processing Letters , 41(3):131\u2013133, 1992. URL: https://www.sciencedirect.com/science/article/pii/002001909290041S , doi:https://doi.org/10.1016/0020-0190(92)90041-S . Johannes Weidenfeller, Lucia\u00a0C. Valor, Julien Gacon, Caroline Tornow, Luciano Bello, Stefan Woerner, and Daniel\u00a0J. Egger. Scaling of the quantum approximate optimization algorithm on superconducting qubit based hardware. Quantum , 6:870, Dec 2022. URL: http://dx.doi.org/10.22331/q-2022-12-07-870 , doi:10.22331/q-2022-12-07-870 . previous Changelog By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-qaoa",
    "title": "Sparse Maxcut",
    "url": "/iqm-qaoa/Sparse Maxcut.html",
    "description": "The purpose of this notebook is to showcase the QAOA library working from the problem definition all the way to execution on a real hardware. In particular, here we use QAOA to solve an instance of a ...",
    "content": "The purpose of this notebook is to showcase the QAOA library working from the problem definition all the way to execution on a real hardware. In particular, here we use QAOA to solve an instance of a random sparsely-connected max-cut problem. Maxcut is a graph problem, but internally the QAOA library converts it to a quadratic binary optimization problem (QUBO). We will solve a problem of size problem_size , i.e., this will be the size of the graph, the number of binary variables and also the number of qubits that we use. The number of shots is set to default maximum on Resonance. We create an instance of the max-cut problem of size problem_size , on a 3-regular random graph.\nWe print out the largest, lowest and average energy of the model, calculated by brute-forcing over all possible bitstrings of length problem_size . This may be slow if problem_size has been set higher than ~30. In the following, we set up the connection to Resonance and define a simulator backend of the Garnet and Sirius QPUs. We will run the QAOA on both and compare the results. Note: in general, you also need to specify the \u2018usage mode\u2019. For running on a real machine (in pay-as-you-go usage mode), the url would change to https://cocos.resonance.meetiqm.com/garnet. For a specific timeslot the url would change to https://cocos.resonance.meetiqm.com/garnet:timeslot Create the QUBO QAOA instance from the problem instance and train it. The train method has several possible parameters, but here the default setting is used (which uses analytical formulas since the QAOA has one layer). Once the QAOA is trained, we can use the QPU to sample from it and to use the samples for estimating the expected value of the Hamiltonian. For that we need to define a sampler and an estimator . There are several other samplers and estimators available in the QAOA library. Here we use the sampler which samples from a given QPU (via Resonance) and the estimator which uses this sampler to provide samples from which the expected value of the Hamiltonian is calculated. We don\u2019t need the samples here for anything, so we\u2019ll discard them. Same as the above, except on the star QPU. Running circuits on the star uses fewer 2QB gates, but requires considerably larger circuit depth (because only one 2QB gate can be done at a time). previous SK Model and Transpilation next Portfolio Optimization By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-qaoa",
    "title": "API Reference",
    "url": "/iqm-qaoa/API.html",
    "description": "iqm.applications Classes and tools for defining problem instances. iqm.qaoa IQM QAOA previous Training the QAOA next iqm.applications By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on...",
    "content": "iqm.applications Classes and tools for defining problem instances. iqm.qaoa IQM QAOA previous Training the QAOA next iqm.applications By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-qaoa",
    "title": "Contributors",
    "url": "/iqm-qaoa/authors.html",
    "description": "Jiri Guth Jarkovsky < jiri . guthjarkovsky @ meetiqm . com > Elisabeth Wybo < elisabeth . wybo @ meetiqm . com > Martin Leib < martin . leib @ meetiqm . com > Jalil Khatibi Moqadam < jalil . khatibi @...",
    "content": "Jiri Guth Jarkovsky < jiri . guthjarkovsky @ meetiqm . com > Elisabeth Wybo < elisabeth . wybo @ meetiqm . com > Martin Leib < martin . leib @ meetiqm . com > Jalil Khatibi Moqadam < jalil . khatibi @ meetiqm . com > Ricardas Brazinkas < ricardas . brazinkas @ meetiqm . com > Jami R\u00f6nkk\u00f6 < jami @ meetiqm . com > previous License next Changelog By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.applications",
    "url": "/iqm-qaoa/api/iqm.applications.html",
    "description": "Classes and tools for defining problem instances. Subpackages and modules previous API Reference next iqm.qaoa By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22....",
    "content": "Classes and tools for defining problem instances. Subpackages and modules previous API Reference next iqm.qaoa By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa.transpiler.sparse",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.sparse.html",
    "description": "The submodule for greedy transpilation for sparse QAOA circuits. Subpackages and modules previous iqm.qaoa.transpiler.sn next iqm.qaoa.transpiler.star By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM...",
    "content": "The submodule for greedy transpilation for sparse QAOA circuits. Subpackages and modules previous iqm.qaoa.transpiler.sn next iqm.qaoa.transpiler.star By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa.transpiler",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.html",
    "description": "A folder for modules related to the transpilation (routing) of the QAOA circuit on a QPU. Subpackages and modules hardwired The submodule for hard-wired transpilation of dense QAOA circuits. sn The su...",
    "content": "A folder for modules related to the transpilation (routing) of the QAOA circuit on a QPU. Subpackages and modules hardwired The submodule for hard-wired transpilation of dense QAOA circuits. sn The submodule for swap-network-based transpilation of dense QAOA circuits. sparse The submodule for greedy transpilation for sparse QAOA circuits. star The submodule for star-network-based transpilation of dense QAOA circuits. previous iqm.qaoa next iqm.qaoa.transpiler.hardwired By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa",
    "url": "/iqm-qaoa/api/iqm.qaoa.html",
    "description": "IQM QAOA Subpackages and modules transpiler A folder for modules related to the transpilation (routing) of the QAOA circuit on a QPU. previous iqm.applications next iqm.qaoa.transpiler By IQM QAOA dev...",
    "content": "IQM QAOA Subpackages and modules transpiler A folder for modules related to the transpilation (routing) of the QAOA circuit on a QPU. previous iqm.applications next iqm.qaoa.transpiler By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa.transpiler.star",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.star.html",
    "description": "The submodule for star-network-based transpilation of dense QAOA circuits. Subpackages and modules previous iqm.qaoa.transpiler.sparse next License By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. L...",
    "content": "The submodule for star-network-based transpilation of dense QAOA circuits. Subpackages and modules previous iqm.qaoa.transpiler.sparse next License By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa.transpiler.hardwired",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.hardwired.html",
    "description": "The submodule for hard-wired transpilation of dense QAOA circuits. Subpackages and modules previous iqm.qaoa.transpiler next iqm.qaoa.transpiler.sn By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. L...",
    "content": "The submodule for hard-wired transpilation of dense QAOA circuits. Subpackages and modules previous iqm.qaoa.transpiler next iqm.qaoa.transpiler.sn By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa.transpiler.sn",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.sn.html",
    "description": "The submodule for swap-network-based transpilation of dense QAOA circuits. Subpackages and modules previous iqm.qaoa.transpiler.hardwired next iqm.qaoa.transpiler.sparse By IQM QAOA developers \u00a9 Copyr...",
    "content": "The submodule for swap-network-based transpilation of dense QAOA circuits. Subpackages and modules previous iqm.qaoa.transpiler.hardwired next iqm.qaoa.transpiler.sparse By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-data-definitions",
    "title": "IQM Data Definitions",
    "url": "/iqm-data-definitions/index.html",
    "description": "2.13 2025-06-22 Low-level data prototypes shared across the control software of IQM quantum computers. Index Module Index Search Page next API Reference By IQM \u00a9 Copyright 2021-2025, IQM. Last updated...",
    "content": "2.13 2025-06-22 Low-level data prototypes shared across the control software of IQM quantum computers. Index Module Index Search Page next API Reference By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-data-definitions",
    "title": "API Reference",
    "url": "/iqm-data-definitions/API.html",
    "description": "The module iqm.data_definitions contains autogenerated Python code for Protobuf prototypes.\nThe prototypes are used in client\u2013server communication between IQM Station Control and it\u2019s clients.\nUsers a...",
    "content": "The module iqm.data_definitions contains autogenerated Python code for Protobuf prototypes.\nThe prototypes are used in client\u2013server communication between IQM Station Control and it\u2019s clients.\nUsers are not expected to interact with this module directly, except when integrating custom client libraries against\nIQM\u2019s QCCSW. The module iqm.models contains the Python-native representations of the some of the prototypes.\nUsers of iqm-pulse might encounter these. iqm.models Python-native representation of the protos in iqm.data_definitions , recognized by IQM Station Control. iqm.data_definitions  Note The API documentation of iqm.data_definitions is generated automatically based on the raw .proto files\nthat define the cross-platform communication protocols.\nAs such, the minimal HTML documentation is missing the typical docstrings.\nHowever, the Python module iqm.data_definitions includes Python stub files ( .pyi ), which include\nproper type hints and docstrings, so they are displayed in IDEs.\nFurthermore, the HTML documentation of the _pb2 modules include the .proto source files,\nincluding docstrings, so that low-level integrators can use them generate compatible code for their chosen language. previous IQM Data Definitions next models By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-data-definitions",
    "title": "v2",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.station_control.v2.html",
    "description": "Full path: iqm.data_definitions.station_control.v2 Subpackages and modules previous v1 next Changelog By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22....",
    "content": "Full path: iqm.data_definitions.station_control.v2 Subpackages and modules previous v1 next Changelog By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-data-definitions",
    "title": "common",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.html",
    "description": "Full path: iqm.data_definitions.common Subpackages and modules v1  previous data_definitions next v1 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22....",
    "content": "Full path: iqm.data_definitions.common Subpackages and modules v1  previous data_definitions next v1 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-data-definitions",
    "title": "v1",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.html",
    "description": "Full path: iqm.data_definitions.common.v1 Subpackages and modules previous common next station_control By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22....",
    "content": "Full path: iqm.data_definitions.common.v1 Subpackages and modules previous common next station_control By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-data-definitions",
    "title": "data_definitions",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.html",
    "description": "Full path: iqm.data_definitions Subpackages and modules common  station_control  previous models next common By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22....",
    "content": "Full path: iqm.data_definitions Subpackages and modules common  station_control  previous models next common By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-data-definitions",
    "title": "v1",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.station_control.v1.html",
    "description": "Full path: iqm.data_definitions.station_control.v1 Subpackages and modules previous station_control next v2 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22....",
    "content": "Full path: iqm.data_definitions.station_control.v1 Subpackages and modules previous station_control next v2 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-data-definitions",
    "title": "models",
    "url": "/iqm-data-definitions/api/iqm.models.html",
    "description": "Python-native representation of the protos in iqm.data_definitions , recognized by IQM Station Control. Full path: iqm.models Subpackages and modules previous API Reference next data_definitions By IQ...",
    "content": "Python-native representation of the protos in iqm.data_definitions , recognized by IQM Station Control. Full path: iqm.models Subpackages and modules previous API Reference next data_definitions By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-data-definitions",
    "title": "station_control",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.station_control.html",
    "description": "Full path: iqm.data_definitions.station_control Subpackages and modules v1  v2  previous v1 next v1 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22....",
    "content": "Full path: iqm.data_definitions.station_control Subpackages and modules v1  v2  previous v1 next v1 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-benchmarks",
    "title": "IQM Benchmarks",
    "url": "/iqm-benchmarks/readme.html",
    "description": "IQM Benchmarks is a suite of Quantum Characterization, Verification, and Validation (QCVV) tools for quantum computing. It is designed to be a comprehensive tool for benchmarking quantum hardware. The...",
    "content": "IQM Benchmarks is a suite of Quantum Characterization, Verification, and Validation (QCVV) tools for quantum computing. It is designed to be a comprehensive tool for benchmarking quantum hardware. The suite is designed to be modular, allowing users to easily add new benchmarks and customize existing ones. The suite is designed to be easy to use, with a simple API that allows users to run benchmarks with a single command. Below is a list of the benchmarks currently available in the suite: Gates / Layers: Standard Clifford Randomized Benchmarking [ Phys. Rev. A 85, 042311 (2012)] Interleaved Randomized Benchmarking [ Phys. Rev. Lett. 109, 080505 (2012)] Compressive Gate Set Tomography [ PRX Quantum 4, 010325 (2023)] Mirror Randomized Benchmarking [ Phys. Rev. Lett. 129, 150502 (2022)] Error Per Layered Gate [ arXiv:2311.05933 [quant-ph] (2023)] Holistic: Quantum Volume [ Phys. Rev. A 100, 032328 (2019)] CLOPS [ arXiv:2110.14108 [quant-ph] (2021)] Entanglement: GHZ State Fidelity [ arXiv:0712.0921 [quant-ph] (2007)] Graph State Bipartite Entanglement [ Adv. Quantum Technol., 2100061 (2021)] Optimization: Q-Score [ IEEE Trans. Quantum Eng., 2 (2021)] The project is split into different benchmarks, all sharing the Benchmark class or the legacy BenchmarkBase class. Each individual benchmark takes as an argument their own BenchmarkConfigurationBase class. All the (legacy) benchmarks executed at once are wrapped by the BenchmarkExperiment class, which handles dependencies among the benchmarks, storing the results, producing the plots\u2026 uv is highly recommended for practical Python environment and package management.\nWith uv installed in your system, start a terminal in your machine and create a new Python environment Note: refer to uv\u2019s documentation if there are problems setting up a Python environment. After the command has run, read the output and make sure to use the prompt to activate the environment.\nThen, you can install the latest release of the IQM Benchmarks by running: Supplied within the Python package there is an additional requirements.txt file containing locked, security scanned\ndependencies. The file can be used to constrain installed dependencies either directly from the repo or by\nextracting it from the PyPI package. Optional dependencies like compressive gate set tomography and jupyter notebooks can be installed as follows: Current optional dependencies are: examples : Jupyter notebooks mgst : Compressive gate set tomography test : Code testing and Linting docs : Documentation building cicd : CICD tools To install in development mode with all required dependencies, you can instead clone the repository and from the project directory run To run the tests, you can use the following command: To build the API documentation as HTML: Update the requirements. This is necessary when you add a new dependency or update an existing one in pyproject.toml .\nAfter this, any changes in the lockfile requirements.txt have to be committed.\nThe script upgrades locked dependencies defined in pyproject.toml within the given version ranges. However, transitive\ndependencies are deliberately not upgraded automatically. The IQM Benchmarks suite is designed to be used with real quantum hardware. To use the suite, you will need to have access to a quantum computer. The suite is designed to work with both IQM Resonance (IQM\u2019s quantum cloud service) and on-prem devices, but can be easily adapted to work with other quantum computing platforms. To use the suite with IQM Resonance, you will need to set up an account and obtain an API token. You can then set the IQM_TOKEN environment variable to your API token. The suite will automatically use this token to authenticate with IQM Resonance. You can easily set up one or more benchmarks by defining a configuration for them. For example, for Randomized, Interleaved and Mirror Benchmarking, or Quantum Volume: In order to execute them, you must specify a backend. for IQM Resonance this can be given as a simple string, such as \u201cgarnet\u201d (together with your IQM Token environment variable) and for an on-prem device and IQM Resonance this can be defined using the URL of the quantum computer. Also, you need to reference the benchmark configuration you want to run: Full examples on how to run benchmarks and analyze the results can be found in the examples folder. This repository can be setup to perform a scheduled (weekly, daily\u2026) benchmark from a Gitlab/Github pipeline, executed on a real device. An example configuration is given in the scheduled_experiments folder. previous IQM Benchmarks next Examples By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-benchmarks",
    "title": "IQM Benchmarks",
    "url": "/iqm-benchmarks/index.html",
    "description": " 2025-06-22 iqm-finland/iqm-benchmarks Quantum Characterization, Verification, and Validation (QCVV) tools for quantum computing.\nDeveloped by IQM . Index Module Index Search Page next IQM Benchmarks ...",
    "content": " 2025-06-22 iqm-finland/iqm-benchmarks Quantum Characterization, Verification, and Validation (QCVV) tools for quantum computing.\nDeveloped by IQM . Index Module Index Search Page next IQM Benchmarks By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-benchmarks",
    "title": "API Reference",
    "url": "/iqm-benchmarks/API.html",
    "description": "previous 2-Qubit Clifford Group Decomposition next License By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-22....",
    "content": "previous 2-Qubit Clifford Group Decomposition next License By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-benchmarks",
    "title": "2-Qubit Clifford Group Decomposition",
    "url": "/iqm-benchmarks/development/generate_2qubit_cliffords.html",
    "description": "Generate the decomposition of the 2-qubit Clifford group according to: https://arxiv.org/abs/1402.4848 Verify the condition \\(\\displaystyle{\\sum_{k,\\,k^\\prime=1}^K}\\left|\\mathrm{tr}\\left(U_{k^\\prime}^...",
    "content": "Generate the decomposition of the 2-qubit Clifford group according to: https://arxiv.org/abs/1402.4848 Verify the condition \\(\\displaystyle{\\sum_{k,\\,k^\\prime=1}^K}\\left|\\mathrm{tr}\\left(U_{k^\\prime}^{\\dagger}U_k\\right)\\right|^4/K^2 = 2\\) (Eq. S2) Verify the condition \\(\\displaystyle{\\sum_{k,\\,k^\\prime=1}^K}\\left|\\mathrm{tr}\\left(U_{k^\\prime}^{\\dagger}U_k\\right)\\right|^4/K^2 = 2\\) (Eq. S2) WARNING : in total there are \\(n=11,520^2 = 132,710,400\\) values in the sum ! It suffices to compute the values in a triangular part of the matrix \\(U_{k^\\prime}^{\\dagger}U_k\\) \u2014 however there are still \\(n(n-1)/2\\) such terms ! previous How to make your own benchmark? next API Reference By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-benchmarks",
    "title": "How to make your own benchmark?",
    "url": "/iqm-benchmarks/development/how_to_make_your_own_benchmark.html",
    "description": "This notebook shows an example of how to use the benchmark defition to write a new benchmark class. Here we make a simple benchmark that creates two circuits, one that prepares all the qubits in the g...",
    "content": "This notebook shows an example of how to use the benchmark defition to write a new benchmark class. Here we make a simple benchmark that creates two circuits, one that prepares all the qubits in the ground state and another one that prepares them in the excited state. previous Development next 2-Qubit Clifford Group Decomposition By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Development",
    "url": "/iqm-benchmarks/development/development.html",
    "description": "This section provides examples and guidance on how to create benchmarks based on the IQM Benchmarks package. previous Benchmarking IQM Star next How to make your own benchmark? By IQM Benchmarks devel...",
    "content": "This section provides examples and guidance on how to create benchmarks based on the IQM Benchmarks package. previous Benchmarking IQM Star next How to make your own benchmark? By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Mirror Randomized Benchmarking (MRB)",
    "url": "/iqm-benchmarks/examples/example_mirror_rb.html",
    "description": "previous Error Per Layered Gate (EPLG) next Graph State Bipartite Entanglement By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-22....",
    "content": "previous Error Per Layered Gate (EPLG) next Graph State Bipartite Entanglement By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Error Per Layered Gate (EPLG)",
    "url": "/iqm-benchmarks/examples/example_eplg.html",
    "description": "In order to be able to use calibration fidelities as a proxy for selecting a linear chain, we need to specify the calibration URL of the station. If specifying qubit pairs manually (not necessarily fo...",
    "content": "In order to be able to use calibration fidelities as a proxy for selecting a linear chain, we need to specify the calibration URL of the station. If specifying qubit pairs manually (not necessarily forming a linear chain), this is not needed: you can simply pass the backend as a string name. Display all the attributes in the dataset previous Interleaved Randomized Benchmarking (IRB) next Mirror Randomized Benchmarking (MRB) By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Interleaved Randomized Benchmarking (IRB)",
    "url": "/iqm-benchmarks/examples/example_interleaved_rb.html",
    "description": "Set IQM Token if using Resonance. previous Clifford Randomized Benchmarking (CRB) next Error Per Layered Gate (EPLG) By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-22....",
    "content": "Set IQM Token if using Resonance. previous Clifford Randomized Benchmarking (CRB) next Error Per Layered Gate (EPLG) By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Greenberger\u2013Horne\u2013Zeilinger (GHZ) State Fidelity",
    "url": "/iqm-benchmarks/examples/example_ghz.html",
    "description": "The aim of this benchmark is to show whether a GHZ state with high enough fidelity can be prepared such that the state is genuinely multipartite entangled. One can show that a fidelity larger than 0.5...",
    "content": "The aim of this benchmark is to show whether a GHZ state with high enough fidelity can be prepared such that the state is genuinely multipartite entangled. One can show that a fidelity larger than 0.5 is a sufficient condition (see Leibfried, D. et al., Creation of a six-atom \u2018Schr\u00f6dinger cat\u2019 state. Nature 438, 639\u2013642 (2005)) The benchmark currently offers two methods to estimate the fidelity: Multiple quantum coherences (G. J. Mooney et al., Generation and verification of 27-qubit Greenberger-Horne-Zeilinger states in a superconducting quantum computer, J. Phys. Commun. 5, 095004 (2021)) Randomized measurements (Elben, A. et al., Statistical correlations between locally randomized measurements: A toolbox for probing entanglement in many-body quantum states, Phys. Rev. A 99, 052323 (2019)) Additionally, for a given set of \\(n\\) qubits, different circuits can be applied which lead to the same GHZ state. Currently there are the following implementations: \u201cnaive\u201d: The textbook ciruit of depth \\(n\\) , which starts from a Hadamrd gate on one qubit and entangles each additional qubit with a CNOT operation from the first. \u201clog_depth\u201d: A logarithmic depth circuit utilizing parallel CNOT applications. Either the method in Cruz et al. https://arxiv.org/abs/1807.05572 or the method in Mooney et al. https://arxiv.org/abs/2101.08946 is used, depending on which yields the lower depth or the lower number of 2-qubit gates. \u201ctree\u201d: An in-house logarithmic depth circuit utilizing calibration data of the CZ-fidelities and a tree-graph algorithm to find a circuit with minimal depth and high fidelity 2-qubit gates. Note that the first two methods will always give the same circuit for the same qubit layout (and the same coupling map), while the \u201ctree\u201d method relies on the latest calibration fidelities and can give different circuits on different days.\nThus for consistent comparisons one of the first two methods should be chosen, while for the best results, i.e. the largest possible GME entangled GHZ state, the tree-method is preferable. The important parameters are: custom_qubits_array : A list[list[int]] which includes all qubit layouts on which the benchmark is run. shots : The number of shots for the fidelity measurement fidelity_routine : Either \u201ccoherences\u201d or \u201crandomized_measurements\u201d rem : Boolean value that controls whether readout error mitigation is used mit_shots : Whenever rem=True, this parameter controls the total number of shots used to calibrate readout error mitgation num_RMs : The number of randomized measurement settings (only necessary when choosing fidelity_routine=randomized_measurements ) For thinking about which qubit layouts to use, the following visualization of the connectivity and CZ fidelities is helpful. Requirements: Access to the backend, in this example IQM Garnet. An access token environment variable needs to be set via os.environ[\"IQM_TOKEN\"] = <your_token> . Use of the plot: If the qubit_layouts argument is provided, the selected qubits are marked in orange. CZ errors are indicated with edge width, thinner is better , where the edge width is given by \\(w_{ij} = - \\mathrm{log}(\\mathcal{F}_{\\mathrm{CZ}}^{ij})\\) . Each edge is also labeled with the width value. Some graph layouts are predefined to match the layout as shown in IQM-Resonance. If the layout is not predefined, a graph in grid or star layout will be automatically generated, dependeing on the backend. Automatically generated graphs might need to be rerun a few times until a nice node layout is found. To see individual fidelitiy and uncertainty values of a given qubit layout, one can filter the result.observations -list by layout as shown below. The plot allows a comparison of all layout results with and without REM, where the data point description labels \u201cL0\u201d, \u201cL1\u201d, \u2026 enumerate the layouts in the order defined in the configuration. previous Circuit Layer Operations Per Second (CLOPS) next Q-Score By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Q-Score",
    "url": "/iqm-benchmarks/examples/example_qscore.html",
    "description": "previous Greenberger\u2013Horne\u2013Zeilinger (GHZ) State Fidelity next Devices By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-22....",
    "content": "previous Greenberger\u2013Horne\u2013Zeilinger (GHZ) State Fidelity next Devices By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Clifford Randomized Benchmarking (CRB)",
    "url": "/iqm-benchmarks/examples/example_clifford_rb.html",
    "description": "NB: Clifford RB is executed by default with Interleaved RB ! previous IQM Benchmarks: Summary Notebook next Interleaved Randomized Benchmarking (IRB) By IQM Benchmarks developers \u00a9 Copyright 2024, IQM...",
    "content": "NB: Clifford RB is executed by default with Interleaved RB ! previous IQM Benchmarks: Summary Notebook next Interleaved Randomized Benchmarking (IRB) By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Compressive Gate Set Tomography (GST)",
    "url": "/iqm-benchmarks/examples/example_gst.html",
    "description": "This notebook gives an introduction on how to run compressive gate set tomography, what the input parameters mean and how to display different observations and plots. This notebook and the compressive...",
    "content": "This notebook gives an introduction on how to run compressive gate set tomography, what the input parameters mean and how to display different observations and plots. This notebook and the compressive GST functionality requires the optional dependency \u201cmgst\u201d to be installed. For background, see the journal reference at https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.4.010325 The most important parameters are the following: qubits ( List[int] ): The qubits on the backend where the experiment is performed. gate_set ( Union[str, List[Type[QuantumCircuit]]] ): Either one of the currently predefined gate sets \"1QXYI\" , \"2QXYCZ\" , \"2QXYCZ_extended\" , \"3QXYCZ\" , or a list of quantum circuits. num_circuits ( int ): The number of circuits for the experiment. Recommended are at least 50 for single qubit GST, at least 300 for two-qubit GST and at least 2000 for 3-qubit GST. shots ( int ): The number of shots per circuit. rank ( int ): The Kraus rank of the reconstruction, i.e. the number of Kraus operators for each gate.\n$ \\( G(\\rho) = \\sum_{i = 1}^{\\text{rank}} K_i \\rho K_i^{\\dagger}\\) $\nSetting rank=1 will trigger a unitary gate fit, leading to a gate parametrization output in terms Hamiltonian parameters.\nThe maximum rank is given by the physical dimension squared. For fully rigorous performance computation of metrics such as the average gate fidelity or the diamond distance it is recommended to choose full rank.\nA low rank has the benefit of needing less circuits and less computing time, while still capturing the dominant error sources. bootstrap_samples ( int ): If bootstrapping error bars are to be generated, this variable sets the number of bootstrap runs. Recommended for trustworthy error bars are 50 samples. The default is 0, since computing bootstrap error bars is very time consuming. Be prepared that the first execution on a new system will take an extra 1-2 minutes to compile the lower level optimization code. To get a unitary model of the gate set from the same data, the rank parameter of the benchmark object can be set to 1.\nThe analysis will give a Hamiltonian parametrization of the gate set and produce different plots. For uncertaintites on the observations set bootstrap_samples \\(\\geq 10\\) . The high level results are stored in a list of Observations under restult.observations .\nTo access only those observations corresponding to a specific qubit layout, one can use the identifier attribute: In addition to the high level observations above, the full process matrices for each gate and the full parametrizations for initial state and measurement are stored. They can be accessed under result.dataset.attrs[f\"results_layout_{qubit_layout}\"] as follows. Two gate sets are saved, the raw gate set and the gauge-optimized gate set.\nIn most instances the gauge-optimized gate set should be used for further processing, since it gives the gate set in the reference frame in which the target gates are defined. The \"raw_gates\" and \"gauge_opt_gates\" keys in the outcome dictionary contain a 3D numpy array, where i.e. gate #1 is accessed with raw_results[\"gauge_opt_state\"][0] , and so on. The plots can be accessed in the notebook via result.plots, a dictionary containing all figure objects. These can then be diplayed as shown below, or saved to disc from the notebook.\nCurrently all gauge optimized gate superoperators are shown as matrix plots in their Pauli basis representation, while the state preparation and measurement outcomes are shown as matrix plots in standard basis.\nFor reference, a sinlge qubit superoperator for gate \\(G\\) in the Pauli-basis has entries \\(G_{ij}\\) defined via\n$ \\(\nG(\\rho) = \\frac{1}{2} \\sum_{i,j = 1}^4 G_{ij} P_i Tr(P_j \\rho),\n\\) \\(\nwhere \\) P_i, P_j$ are Pauli matrices. In addition to gate plots, selections of gate error measures and gate parameters are also stored in figure objects. Stored plot names can be displayed and individually plotted as follows. Rank 1 results (for example the gate Hamiltonians in the Pauli basis) Alternatively, all plots (of all layouts) can be displayed via result.plot_all() . In this example we define a gate set ourselves as a list of quantum circuits. The example gate set chosen here is the \u201cXYI\u201d gate set with the addition of \\(\\pi\\) -rotations around the X- and Y-axis.\nNote that we also increased the number of random GST sequences in the GST configuration from 50 to 100 to account for the larger gate set. previous Graph State Bipartite Entanglement next Quantum Volume (QV) By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Circuit Layer Operations Per Second (CLOPS)",
    "url": "/iqm-benchmarks/examples/example_clops.html",
    "description": "The plot generated by the CLOPS analysis is a bar plot that shows a breakdown of elapsed times in the experiment in units of seconds. The bars labeled as \u201cRemote\u201d refer to time spent in the remote com...",
    "content": "The plot generated by the CLOPS analysis is a bar plot that shows a breakdown of elapsed times in the experiment in units of seconds. The bars labeled as \u201cRemote\u201d refer to time spent in the remote components of the experiment, as reported by the backend. Remote (components) shows the values of the time spent in compilation, submission and execution of the jobs. Remote (total) shows the total time spent in the remote components of the experiment. NB: the difference between the Remote \u201ctotal\u201d and \u201ccomponents\u201d elapsed times may be due to other aspects like loading and storing jobs and IDs, etc. The \u201cWall-time\u201d bars show time spent in the experiment as experienced by the user. NB: The time spent in assigning parameters is not included in the CLOPS value, since this is done offline in your (the user\u2019s) hardware. Wall-time (CLOPS) encompasses the time related to the CLOPS value, i.e., comprising only of submitting jobs per template and retrieving the results, without time spent in transpilation or parameter assignment, which are both done offline. Wall-time (total) shows a breakdown of the total wall-time of the experiment, with the added offline times of transpilation of circuit templates and assignment of parameters. NB: The difference between the \u201cuser retrieve\u201d time and the Remote \u201ctotal\u201d time can be assigned as a latency time, and may vary significantly depending on external circumstances. This latency is the aggregated time between when a job is finished and when the results are received (which may be due to several external factors). previous Quantum Volume (QV) next Greenberger\u2013Horne\u2013Zeilinger (GHZ) State Fidelity By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Quantum Volume (QV)",
    "url": "/iqm-benchmarks/examples/example_quantum_volume.html",
    "description": "One can perform a separate run of the benchmark (also possible with a different configuration) List all the keys in the attributes of the dataset The data for specific experiments is indexed by 0,1,\u2026,...",
    "content": "One can perform a separate run of the benchmark (also possible with a different configuration) List all the keys in the attributes of the dataset The data for specific experiments is indexed by 0,1,\u2026, e.g., for the first experiment: The observation object contains the benchmark results Print a specific output Or print all the plots at once previous Compressive Gate Set Tomography (GST) next Circuit Layer Operations Per Second (CLOPS) By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Examples",
    "url": "/iqm-benchmarks/examples/examples.html",
    "description": "This section contains a collection of examples that demonstrate how to use the IQM Benchmarks package to perform various benchmarks. The first run all experiments in the package, and the rest are spec...",
    "content": "This section contains a collection of examples that demonstrate how to use the IQM Benchmarks package to perform various benchmarks. The first run all experiments in the package, and the rest are specific examples of different benchmarking protocols. previous IQM Benchmarks next IQM Benchmarks: Summary Notebook By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-benchmarks",
    "title": "IQM Benchmarks: Summary Notebook",
    "url": "/iqm-benchmarks/examples/example_experiment_all.html",
    "description": "NB: Clifford RB is executed by default with Interleaved RB ! previous Examples next Clifford Randomized Benchmarking (CRB) By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-2...",
    "content": "NB: Clifford RB is executed by default with Interleaved RB ! previous Examples next Clifford Randomized Benchmarking (CRB) By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Graph State Bipartite Entanglement",
    "url": "/iqm-benchmarks/examples/example_graphstate.html",
    "description": "Set IQM Token if using Resonance. The negativity is shown as a percentage of the ideal maximum value of 0.5 (which would be achieved on a noiseless backend). Plot the lowest and highest negativity res...",
    "content": "Set IQM Token if using Resonance. The negativity is shown as a percentage of the ideal maximum value of 0.5 (which would be achieved on a noiseless backend). Plot the lowest and highest negativity resconstructed density matrices Display max negativities in the backend graph All the qubit pair groups generated during execution previous Mirror Randomized Benchmarking (MRB) next Compressive Gate Set Tomography (GST) By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Benchmarking IQM Star",
    "url": "/iqm-benchmarks/devices/star.html",
    "description": "This notebook allows you to run some useful benchmarks for the Star system. We can access the Star backend and plot its connectivity graph to check that everything is working properly. We run the cell...",
    "content": "This notebook allows you to run some useful benchmarks for the Star system. We can access the Star backend and plot its connectivity graph to check that everything is working properly. We run the cell below to ignore those warnings that are not critical for the correct run of the benchmarks. The GHZ (Greenberger-Horne-Zeilinger) state is a maximally entangled quantum state that involves three or more qubits, \\(n\\) . It is an equal superposition of all qubits being in state 0 and all qubits being in state 1, i.e., \\(| GHZ \\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle^{\\otimes n}+|1\\rangle^{\\otimes n})\\) . The GHZ state fidelity acts as a witness for genuine multi-qubit entanglement if found to be above \\(0.5\\) . This means that the measurement results cannot be explained without entanglement involving all qubits, so it is a great way to evaluate the \u201cquantumness\u201d of the computer. The state \\(\\rho_{\\text{ideal}}= |GHZ\\rangle\\langle GHZ|\\) is a pure state, so in this case the fidelity can be computed as: where \\(\\rho_{\\text{measured}}\\) is the density matrix given by the actual results of the quantum computer. The ideal GHZ state density matrix entries can be written as \\(\\rho_{i,j}=\\langle i| \\rho_{\\text{ideal}} | j \\rangle\\) where \\(i,j\\) are the \\(n\\) basis states \\(\\{|00..0\\rangle, ..., |11..1\\rangle\\}\\) ; only the corner entries \\(\\rho_{0,0},\\rho_{0,n},\\rho_{n,0}\\) and \\(\\rho_{n,n} \\) are non-zero. This simplifies the process since we only need to measure these four components. In the fidelity formula, all other entries are effectively nullified by the zero entries in the ideal state matrix. To measure the coherences (off-diagonal entries) we use the method of multiple quantum coherences Mooney, 2021 . Quantum volume is a single-number metric that was introduced in Cross, 2019 . It evaluates the quality of a quantum processor via the largest random square circuit, i.e., with the same number of layers of parallel random 2-qubit unitaries as number of qubits, that it can run successfully. The success of a run is based on the heavy output probability, which corresponds to the probability of observing heavy outputs , i.e. the measurement outputs that occcur with a probability greater than the median of the distribution. The heavy output generation problem asks if the generated distribution of the random circuit we run contains heavy outputs at least 2/3 of the time (on average) with a high confidence level, typically higher than 97.5%. It can be shown that the heavy output probability for an ideal device is at around 0.85 asymptotically.\nThe quantum volume is then defined as where \\(n \\leq N\\) is a number of qubits and \\(d(n)\\) is the achievable depth , i.e. the largest depth such that we are confident the probability of observing a heavy output is greater than 2/3. We define a combination of qubits to test quantum volume on. If you want to modify the settings above, please refer to the documentation here . Warning: The following code cell may take few minutes to run since it will compute the benchmark on all the qubit layouts specified above. CLOPS is a metric that estimates the speed at which a quantum computer can execute Quantum Volume (QV) layers of a quantum circuit. That is, the circuits to calculate this benchmark have the same structure as the ones used for QV. Here we follow the definition introduced in ( Wack, 2021 ), but other versions of this benchmark exist. CLOPS is measured by means of a quantum variational-like protocol, where templates of parametrized QV circuits are assigned random parameters, executed, and outcomes are used as a seed to assign new parameters and repeat the process. The ratio of number of templates ( \\(M\\) ), parameter updates ( \\(K\\) ), measurement shots ( \\(S\\) ) and QV layers ( \\(\\log_2\\mathrm{QV}\\) ) with the time taken to run all, constitutes the CLOPS value: Notice that the total CLOPS time includes that of assignment of parameters, submission of circuits and retrieval of results. If you want to modify the settings above, please refer to the documentation here . The Q-score measures the maximum number of qubits that can be used\neffectively to solve the MaxCut combinatorial optimization problem with the Quantum Approximate\nOptimization Algorithm - Martiel,2021 The graphs chosen for the benchmark are random Erd\u0151s-R\u00e9nyi graphs with 50% edge-probability between nodes.\nThe obtained cost of the solution, i.e. the average number of cut edges, must be above a certain threshold. Specifically, one has to find the cost of a graph to be above \\(\\beta\\geq 0.2\\) on a scale where \\(\\beta = 0\\) corresponds to a random solution and \\(\\beta = 1\\) to an ideal solution. If you want to modify the settings above, please refer to the documentation here . Warning: The following code cell may take several minutes to run. previous Benchmarking IQM Spark next Development By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Devices",
    "url": "/iqm-benchmarks/devices/devices.html",
    "description": "This section provides examples and guidance on how to benchmark specific IQM devices. previous Q-Score next Benchmarking IQM Spark By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2...",
    "content": "This section provides examples and guidance on how to benchmark specific IQM devices. previous Q-Score next Benchmarking IQM Spark By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Benchmarking IQM Spark",
    "url": "/iqm-benchmarks/devices/spark.html",
    "description": "This notebook allows you to run some useful benchmarks for the Spark system. Before starting, make sure you have installed all the necessary packages: We can access the Spark backend and plot its conn...",
    "content": "This notebook allows you to run some useful benchmarks for the Spark system. Before starting, make sure you have installed all the necessary packages: We can access the Spark backend and plot its connectivity graph to check that everything is working properly. We run the cell below to ignore those warnings that are not critical for the correct run of the benchmarks. The GHZ (Greenberger-Horne-Zeilinger) state is a maximally entangled quantum state that involves three or more qubits, \\(n\\) . It is an equal superposition of all qubits being in state 0 and all qubits being in state 1, i.e., \\(| GHZ \\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle^{\\otimes n}+|1\\rangle^{\\otimes n})\\) . The GHZ state fidelity acts as a witness for genuine multi-qubit entanglement if found to be above \\(0.5\\) . This means that the measurement results cannot be explained without entanglement involving all qubits, so it is a great way to evaluate the \u201cquantumness\u201d of the computer. The state \\(\\rho_{\\text{ideal}}= |GHZ\\rangle\\langle GHZ|\\) is a pure state, so in this case the fidelity can be computed as: where \\(\\rho_{\\text{measured}}\\) is the density matrix given by the actual results of the quantum computer. The ideal GHZ state density matrix entries can be written as \\(\\rho_{i,j}=\\langle i| \\rho_{\\text{ideal}} | j \\rangle\\) where \\(i,j\\) are the \\(n\\) basis states \\(\\{|00..0\\rangle, ..., |11..1\\rangle\\}\\) ; only the corner entries \\(\\rho_{0,0},\\rho_{0,n},\\rho_{n,0}\\) and \\(\\rho_{n,n} \\) are non-zero. This simplifies the process since we only need to measure these four components. In the fidelity formula, all other entries are effectively nullified by the zero entries in the ideal state matrix. To measure the coherences (off-diagonal entries) we use the method of multiple quantum coherences Mooney, 2021 . If you want to modify the settings above, please refer to the documentation here . Before running the benchmark analysis, we can visualize the histogram of counts obtained from measuring a GHZ state on 5 qubits: Quantum volume is a single-number metric that was introduced in Cross, 2019 . It evaluates the quality of a quantum processor via the largest random square circuit, i.e., with the same number of layers of parallel random 2-qubit unitaries as number of qubits, that it can run successfully. The success of a run is based on the heavy output probability, which corresponds to the probability of observing heavy outputs , i.e. the measurement outputs that occcur with a probability greater than the median of the distribution. The heavy output generation problem asks if the generated distribution of the random circuit we run contains heavy outputs at least 2/3 of the time (on average) with a high confidence level, typically higher than 97.5%. It can be shown that the heavy output probability for an ideal device is at around 0.85 asymptotically.\nThe quantum volume is then defined as where \\(n \\leq N\\) is a number of qubits and \\(d(n)\\) is the achievable depth , i.e. the largest depth such that we are confident the probability of observing a heavy output is greater than 2/3. We define a combination of qubits to test quantum volume on. Due to the star topology, the combinations must contain at least qubit #2 (see topmost graph). If you want to modify the settings above, please refer to the documentation here . Warning: The following code cell may take few minutes to run since it will compute the benchmark on all the qubit layouts specified above. CLOPS is a metric that estimates the speed at which a quantum computer can execute Quantum Volume (QV) layers of a quantum circuit. That is, the circuits to calculate this benchmark have the same structure as the ones used for QV. Here we follow the definition introduced in ( Wack, 2021 ), but other versions of this benchmark exist. CLOPS is measured by means of a quantum variational-like protocol, where templates of parametrized QV circuits are assigned random parameters, executed, and outcomes are used as a seed to assign new parameters and repeat the process. The ratio of number of templates ( \\(M\\) ), parameter updates ( \\(K\\) ), measurement shots ( \\(S\\) ) and QV layers ( \\(\\log_2\\mathrm{QV}\\) ) with the time taken to run all, constitutes the CLOPS value: Notice that the total CLOPS time includes that of assignment of parameters, submission of circuits and retrieval of results. If you want to modify the settings above, please refer to the documentation here . The idea behind Clifford Randomized Benchmarking (CRB) is that under certain (simplified) types of noise, the average survival probability of an initial state \\(|0\\rangle\\) under random sequences of Clifford gates and a final sequence inverse will decay exponentially in the length of the sequences. This can be written as where \\(C_1, C_2, \\ldots, C_m\\) is the random sequences of Clifford gates, \\(C_\\text{inv}=(C_1C_2\\cdots{C}_m)^{-1}\\) , \\(0\\leq{p}\\leq{1}\\) and \\(0\\leq{A,B}\\leq1\\) are constants isolating the effects of state-preparation and measurement (SPAM) errors ( Magesan,2012 ). From such decay, one can in turn infer the average fidelity of the corresponding Clifford group. The main assumption we will make here is that the noise can be modeled as Markovian, time-stationary and gate-independent. The theory of CRB under these approximations, and the fact that the multi-qubit Clifford group is a unitary 2-design (i.e., uniformly averaging with two pairs of \\(C\\) , \\(C^{\\dagger}\\) Clifford operators gives the same result as using fully random unitaries), ensures that the average fidelity of our gate set is given by CRB is not generally intended to work for \\(n>2\\) , both because of the scaling of the size of the \\(n\\) -qubit Clifford group in \\(n\\) , and because such gates have to eventually be transpiled to a native basis of 1Q and 2Q gates! It is important to mention that the average Clifford fidelity is related to the average fidelity of IQM\u2019s native gate set for single-qubit gates as ( Barends, 2014 ) This is because all the single-qubit Clifford gates can be decomposed using on average 1.875 gates from IQM\u2019s native set. This formula shows that the value of \\(\\overline{F}_\\text{GATE}\\) will always be slightly higher than \\(\\overline{F}_\\text{CRB}\\) , so one must be careful when comparing with average fidelities reported in the specs of a QPU. If you want to modify the settings above, please refer to the documentation here . Warning: The following code cell may take few minutes to run since it will compute the average fidelities for all the qubits in the QPU (and we set parallel_execution=False ). Differently from the previous protocol, this benchmark aims at estimating the average fidelity of an individual quantum gate. This can be achieved interleaving random Clifford gates between the gate of interest. This method was introduced in Magesan, 2012 , and just as CRB, it is robust with respect to SPAM errors. The protocol runs two sets of sequences, one solely made up of random Clifford gates, as in CRB, and one made up of random Clifford sequences but interleaving the gate of interest among these (and compiling the corresponding sequence inverse). IRB then extracts the corresponding decay parameters (where we expect the decay rate for IRB to be smaller than the CRB one, because the sequence is longer), and the average fidelity of the gate we wish to characterize is then calculated with a simple formula using the two decay parameters. If you want to modify the settings above, please refer to the documentation here . NB: Clifford RB is executed by default when running Interleaved RB! Warning: The following code cells may take several minutes to run. The Q-score measures the maximum number of qubits that can be used\neffectively to solve the MaxCut combinatorial optimization problem with the Quantum Approximate\nOptimization Algorithm - Martiel,2021 The graphs chosen for the benchmark are random Erd\u0151s-R\u00e9nyi graphs with 50% edge-probability between nodes.\nThe obtained cost of the solution, i.e. the average number of cut edges, must be above a certain threshold. Specifically, one has to find the cost of a graph to be above \\(\\beta\\geq 0.2\\) on a scale where \\(\\beta = 0\\) corresponds to a random solution and \\(\\beta = 1\\) to an ideal solution. If you want to modify the settings above, please refer to the documentation here . Warning: The following code cell may take several minutes to run. Typical performance for IQM Spark is summarized in the table below and compared to the values obtained with your device. The typical single- and two-qubit gate fidelities reported below refer to the median over the 5 qubits and 4 couplings of the system, respectively. previous Devices next Benchmarking IQM Star By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-06-22."
  },
  {
    "package": "iqm-client",
    "title": "Integration Guide",
    "url": "/iqm-client/integration_guide.html",
    "description": "IQM client is designed to be the Python adapter to IQM\u2019s quantum computers for application-level\nquantum computing frameworks.  For example integrations maintained by IQM, please refer to the Qiskit a...",
    "content": "IQM client is designed to be the Python adapter to IQM\u2019s quantum computers for application-level\nquantum computing frameworks.  For example integrations maintained by IQM, please refer to the Qiskit and Cirq packages. IQM client offers the functionality to submit quantum circuits to an IQM quantum computer, query a\njob or a job status, and retrieve the quantum architecture of the quantum computer. The following sections illustrate how to integrate IQM quantum computers into your quantum computing\nframework. Initialising the IQM client is simple, and in case you perform authentication as described below,\nrequires only the URL of the IQM quantum computer. To submit a quantum circuit for execution, it has to be specified using the Circuit class.\nThe available native instructions are documented in the Instruction class. Then the circuit can be submitted, and its status and result can be queried with the job id. A dict containing arbitrary metadata can be attached to the circuit before submitting it for\nexecution. The attached metadata should consist only of values of JSON serializable datatypes.\nA utility function to_json_dict() can be used to convert supported datatypes,\ne.g. numpy.ndarray , to equivalent JSON serializable types. The progress of the job can be followed with IQMClient.get_run_status() . Once the job is ready,\nthe results can be read with IQMClient.get_run() . Both of these actions are combined in IQMClient.wait_for_results() which waits until the job is ready and then returns the result. In addition to the actual results, job result contains also metadata of the job execution.\nThe metadata includes the original request, ID of the calibration set used in the execution, and\na collection of timestamps describing the duration of the execution. The timestamps returned with job results are stored as an optional dict called timestamps in the metadata of RunResult of the job. Each timestamp is stored in the dict with a key describing the point in job processing where\nthe timestamp was stored. For example, the timestamp stored at the start of circuit compilation step is stored with\nkey compile_start . Other timestamps are stored in the same way, with keys containing the step name, compile , submit or execution , and either a _start or _end suffix. In addition, there are\nalso timestamps for starting and ending the job itself, job_start and job_end . If the job processing is\nterminated before it is complete the timestamps of steps not processed will not be present in the dict. The first timestamp stored is the job_start timestamp. It is stored when the server receives the job request. The job processing starts with compilation step where the circuits are converted to pulse schedules that can be\nsent for execution. Compilation step produces timestamps compile_start and compile_end . The pulse schedules are then submitted for execution. This step produces timestamps submit_start and submit_end . After submitting the pulse schedules the server waits for the execution results.\nThis step produces timestamps execution_start and execution_end . Finally, when job processing is complete, regardless whether the job was successful or not, the timestamp job_end is stored. IQM uses bearer token authentication to manage access to quantum computers.\nCurrently, there are three mutually exclusive ways of providing an authentication\ntoken to IQM client: The recommended way is to use IQM Client CLI to manage the authentication tokens and store them into a file. IQM client can then read\nthe token from the file and use it for authentication. The file path can be provided to\nIQM client in environment variable IQM_TOKENS_FILE .\nAlternatively, the tokens file path can be provided as argument tokens_file to IQMClient constructor. It is also possible to use plaintext token obtained from a server dashboard. These\ntokens may have longer lifespan than access tokens generated by IQM Client CLI, and thus\nIQM client won\u2019t attempt to refresh them. The generated token can be provided to IQM\nclient in environment variable IQM_TOKEN .\nAlternatively, the token can be provided as argument token to IQMClient constructor. The third way is to provide server URL, username and password for obtaining the\ntoken from an authentication server. IQM client will maintain a login session with\nthe authentication server and read and refresh the token as needed. The server URL,\nusername and password can be provided to IQM client in environment variables IQM_AUTH_SERVER , IQM_AUTH_USERNAME and IQM_AUTH_PASSWORD .\nAlternatively, the values can be provided as arguments auth_server_url , username and password to IQMClient constructor.\nNote, that all the values must be provided as either environment variables or\nas constructor arguments, not mixed. IQM does not provide an open source circuit transpilation library, so this will have to be supplied\nby the quantum computing framework or a third party library.  To obtain the necessary information\nfor circuit transpilation, IQMClient.get_dynamic_quantum_architecture() returns the names of the\nQPU components (qubits and computational resonators), and the native operations available\nin the given calibration set. This information should enable circuit transpilation for the\nIQM Crystal quantum architectures. The notable exception is the transpilation for the IQM Star quantum architectures, which have\ncomputational resonators in addition to qubits. Some specialized transpilation logic involving\nthe MOVE gates specific to these architectures is provided, in the form of the functions transpile_insert_moves() and transpile_remove_moves() .\nSee iqm.iqm_client.transpile for the details. A typical Star architecture use case would look something like this: We encourage to transpile circuits to use the physical IQM qubit names before submitting them to IQM\nquantum computers.  In case the quantum computing framework does not allow for this, providing a\nqubit mapping can do the translation from the framework qubit names to IQM qubit names.  Note, that\nqubit mapping is not supposed to be associated with individual circuits, but rather with the entire\njob request to IQM server.  Typically, you would have some local representation of the QPU and\ntranspile the circuits against that representation, then use qubit mapping along with the generated\ncircuits to map from the local representation to the IQM representation of qubit names.  We\ndiscourage exposing this feature to end users of the quantum computing framework. Before performing circuit execution, IQM server checks how long it would take to run each circuit.\nIf any circuit in a job would take too long to execute compared to the T2 time of the qubits,\nthe server will disqualify the job, not execute any circuits, and return a detailed error message.\nIn some special cases, it makes sense to adjust or disable this check using\nthe max_circuit_duration_over_t2 attribute of CircuitCompilationOptions ,\nand then passing the options to IQMClient.submit_circuits() . Set IQM_CLIENT_REQUESTS_TIMEOUT environment variable to override the network requests default\ntimeout value. The default value is 60 seconds and might not be sufficient when fetching run results\nof larger circuits via slow network connections. On Linux: On Windows: Once set, this environment variable will control network request timeouts for IQMClient methods abort_job , get_quantum_architecture , get_dynamic_quantum_architecture , get_run , and get_run_status . Set IQM_CLIENT_SECONDS_BETWEEN_CALLS to control the polling frequency when waiting for\ncompilation and run results with the IQMClient.wait_for_compilation() and IQMClient.wait_for_results() methods. The default value is set to 1 second. Set IQM_CLIENT_DEBUG=1 to print the run request when it is submitted for execution in IQMClient.submit_circuits() or IQMClient.submit_run_request() . To inspect the run request without sending\nit for execution, use IQMClient.create_run_request() . IQM provides a demo environment to test the integration against a mock quantum computer. If you\u2019d\nlike to request access to that environment, please contact IQM . previous API Reference next IQM Client CLI User Guide By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release . Last updated on 2025-06-22."
  },
  {
    "package": "iqm-client",
    "title": "IQM Client",
    "url": "/iqm-client/readme.html",
    "description": "Client-side Python library for connecting to an IQM quantum computer. Includes as an optional feature Qiskit and Cirq adapters for IQM\u2019s quantum computers, which allow you to: Transpile arbitrary quan...",
    "content": "Client-side Python library for connecting to an IQM quantum computer. Includes as an optional feature Qiskit and Cirq adapters for IQM\u2019s quantum computers, which allow you to: Transpile arbitrary quantum circuits for IQM quantum architectures Simulate execution on IQM quantum architectures with IQM-specific noise models\n(currently only the Qiskit adapter contains IQM noise models) Run quantum circuits on an IQM quantum computer Also includes a CLI utility for managing user\nauthentication when using IQM quantum computers. For executing code on an IQM quantum computer, you can use for example Qiskit on IQM or Cirq on IQM , which can be installed as optional\nfeatures of IQM Client from the Python Package Index (PyPI), e.g.: Note If you have previously installed the (now deprecated) qiskit-iqm or cirq-iqm packages in your\nPython environment, you should first uninstall them with $ pip uninstall qiskit-iqm cirq-iqm .\nIn this case, you should also include the --force-reinstall option in the iqm-client installation command. The CLI utility for managing user authentication can also\nbe installed as an optional feature: IQM Client by itself is not intended to be used directly by human users. If you want just the base IQM Client library,\nthough, you can install it with Note uv is highly recommended for practical Python environment and package management. Documentation for the latest version is available online .\nYou can build documentation for any older version locally by downloading the corresponding package from PyPI,\nand running the docs builder. For versions 20.12 and later this is done by running ./docbuild in the iqm-client root directory, and for earlier versions by running tox run -e docs . ./docbuild or tox run -e docs will build the documentation at ./build/sphinx/html .\nThese commands require installing the sphinx and sphinx-book-theme Python packages and graphviz . IQM Client is free software, released under the Apache License, version 2.0. Copyright 2021-2025 IQM Client developers. previous IQM client next API Reference By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release . Last updated on 2025-06-22."
  },
  {
    "package": "iqm-client",
    "title": "Cirq on IQM User Guide",
    "url": "/iqm-client/user_guide_cirq.html",
    "description": "This guide serves as an introduction to the main features of Cirq on IQM, the Cirq adapter for IQM Client.\nYou are encouraged to run the demonstrated code snippets and check the output yourself. Note ...",
    "content": "This guide serves as an introduction to the main features of Cirq on IQM, the Cirq adapter for IQM Client.\nYou are encouraged to run the demonstrated code snippets and check the output yourself. Note If you have previously installed the (now deprecated) cirq-iqm package in your Python environment,\nyou should first uninstall it with $ pip uninstall cirq-iqm . In this case, you should also include\nthe --force-reinstall option in the iqm-client installation command. The recommended way is to install the optional cirq feature of the iqm-client distribution package directly\nfrom the Python Package Index (PyPI): After installation, Cirq on IQM can be imported in your Python code as follows: Cirq on IQM provides descriptions of IQM\u2019s quantum architectures using the IQMDevice class, which is a\nsubclass of cirq.devices.Device and implements general functionality relevant to all IQM devices. The native\ngates and connectivity of the architecture are available in the IQMDeviceMetadata object returned by the IQMDevice.metadata property. It is possible to use the IQMDevice class directly, but\ncertain devices with predefined metadata are also available as subclasses of IQMDevice. As an example, let\nus import the class Adonis , which describes IQM\u2019s five-qubit architecture, and view some of its\nproperties contained in its metadata property: IQM devices use cirq.NamedQubit to represent their qubits. The names of the qubits consist of a prefix\nfollowed by a numeric index, so we have qubit names like QB1 , QB2 , etc. Note that we use 1-based\nindexing. You can get the list of the qubits in a particular device by accessing the qubits attribute of a\ncorresponding IQMDevice instance: There are two main ways of constructing cirq.Circuit instances for IQM devices: Create a Circuit instance using arbitrary qubit names and types. Create a Circuit from an OpenQASM 2.0 program. The qubit names are determined by the OpenQASM qreg names,\nappended with zero-based indices. Below we give an example of each method. Construct a circuit and use arbitrary qubits: This will result in the circuit You can read an OpenQASM 2.0 program from a file (or a string), e.g. and convert it into a cirq.Circuit object using circuit_from_qasm() . circuit_from_qasm() uses the OpenQASM 2.0 parser in cirq.contrib.qasm_import . After a circuit has been constructed, it can be decomposed and routed against a particular IQMDevice . The method IQMDevice.decompose_circuit() accepts a cirq.Circuit object as an argument and\nreturns the decomposed circuit containing only native operations for the corresponding device: The Hadamard and CNOT gates are not native to Adonis, so they were decomposed to X, Y and CZ gates which are. Routing means transforming a circuit such that it acts on the device qubits, and respects the\ndevice connectivity.\nThe method IQMDevice.route_circuit() accepts a cirq.Circuit object as an argument,\nand returns the circuit routed against the device, acting on the device qubits instead of the\narbitrary qubits we had originally. Along with the routed circuit route_circuit() returns the initial_mapping and final_mapping .\nThe initial_mapping is either the mapping from circuit to device qubits as provided by an cirq.AbstractInitialMapper or a mapping that is initialized from the device graph.\nThe final_mapping is the mapping from physical qubits before inserting SWAP gates to the physical\nqubits after the routing is complete As mentioned above, you may also provide the initial mapping from the logical qubits in the circuit to the physical qubits on the device yourself, by using the keyword argument initial_mapper .\nIt serves as the starting point of the routing: Under the hood, route_circuit() leverages the routing provided by cirq.RouteCQC .\nIt works on single- and two-qubit gates, and measurement operations of arbitrary size.\nIf you have gates involving more than two qubits you need to decompose them before routing.\nSince routing may add some SWAP gates to the circuit, you will need to decompose the circuit\nagain after the routing, unless SWAP is a native gate for the target device. To ensure that the transpiler is restricted to a specific subset of qubits, you can provide a list\nof qubits in the qubit_subset argument such that ancillary qubits will not be added during\nrouting. This is particularly useful when running Quantum Volume benchmarks. Devices that have the IQM Star architecture (e.g. IQM Deneb) contain\ncomputational resonators in addition to qubits, and use qubit-resonator gates instead of two-qubit\ngates. These include the MOVE gate which moves qubit states to and from the resonators.\nThere are two main supported workflows for the Star architecture: Construct your circuit as you would for a regular qubits-only device, decompose (and optimize)\nit to native gates, and then route it using IQMDevice.route_circuit() .\nThis will attempt to route all the (fictional) two-qubit gates in the circuit through the\nresonator(s) using the native gates, adding MOVE gates as necessary.\nUnder the hood, this uses the transpile_insert_moves() function of the iqm_client library. Construct your circuit directly using the device qubits, resonators, and qubit-resonator gates,\nrouting it manually. Advanced users can use transpile_insert_moves_into_circuit() to transpile circuits that\nhave some MOVE gates in them in addition to fictional qubit-qubit gates. Yet another important topic is circuit optimization. In addition to the optimizers available in Cirq you can also\nbenefit from Cirq on IQM\u2019s optimizers module which contains some optimization tools geared towards IQM devices.\nThe function optimizers.simplify_circuit() is a convenience method encapsulating a particular sequence of\noptimizations. Let us try it out on our decomposed and routed circuit above: Note The funtion simplify_circuit() is not associated with any IQM device, so its result may contain non-native\ngates for a particular device. In the example above we don\u2019t have them, however it is generally a good idea to run\ndecomposition once again after the simplification. Some IQM quantum computers support classically-controlled gates, that is, gates that are executed\nconditionally depending on the result of a measurement preceding them in the quantum circuit. This\nsupport currently has several limitations: Only the PhasedXPowGate , XPowGate and YPowGate gates can be classically controlled. The gates can only be conditioned on the measurement result of a single qubit, and the only control available is to\napply the gate if the result is 1, and apply an identity gate if the result is 0. The availability of the controlled gates depends on the instrumentation of the quantum computer. The classical control can be applied on an operation using with_classical_controls() : After an X gate is applied on Alice , the qubit is measured and the result is stored\nin the key A . If the result is 1 (which it should always be in this case),\nanother X gate is subsequently applied on Bob . If it is 0, an identity gate of corresponding\nduration is applied instead. The final measurement in the above circuit should always return 11 , even though Alice and Bob are never\nactually entangled. Note Because classically controlled gates can currently only take feedback from one classical bit you must condition\nthem on a measurement key that only measures a single qubit. The cirq.R operation can be used to reset qubits to the \\(|0\\rangle\\) state.\nIt is currently implemented as a (projective) measurement followed by a classically controlled X\ngate conditioned on the result, and is only available if the quantum computer supports\nclassically controlled gates. In the above example, the X gate prepares the qubit q1 in a \\(|1\\rangle\\) state,\nand the reset then collapses it back into the \\(|0\\rangle\\) state.\nExecuting the circuit should result in (mostly) zeros being measured. Note You can access IQM quantum computers via IQM Resonance or use one of the IQM quantum computers deployed at HPC centers and research institutions around the globe. Cirq contains various simulators which you can use to simulate the circuits constructed above.\nIn this subsection we demonstrate how to run them on an IQM quantum computer. Cirq on IQM provides IQMSampler , a subclass of cirq.work.Sampler , which is used\nto execute quantum circuits and decompose/route them for the architecture of the quantum computer.\nOnce you have access to an IQM server you can create an IQMSampler instance and use its run() method to send a circuit for execution and retrieve the results: Note that the code snippet above assumes that you have set the variable iqm_server_url to the URL\nof the IQM server. Additionally, you can pass IQM backend specific options to the IQMSampler class.\nThe below table summarises the currently available options: Name Type Example value Description calibration_set_id uuid.UUID \u201cf7d9642e-b0ca-4f2d-af2a-30195bd7a76d\u201d Indicates the calibration set to use. Defaults to None , which means the IQM server will use the\ncurrent default calibration set automatically. compiler_options CircuitCompilationOptions see below Contains various options that affect the compilation of the quantum circuit into an\ninstruction schedule. The CircuitCompilationOptions class contains the following attributes (in addition to some\nadvanced options described in the API documentation): Name Type Example value Description max_circuit_duration_over_t2 float | None 1.0 Set server-side circuit disqualification threshold. If any circuit in a job is estimated to take longer than the\nshortest T2 time of any qubit used in the circuit multiplied by this value, the server will reject the job.\nSetting this value to 0.0 will disable circuit duration check.\nThe default value None means the server default value will be used. heralding_mode HeraldingMode \u201czeros\u201d Heralding mode to use during execution. The default value is \u201cnone\u201d, \u201czeros\u201d enables\nall-zeros heralding where the circuit qubits are measured before the circuit begins, and the\nserver post-selects and returns only those shots where the heralding measurement yields zeros\nfor all the qubits. For example if you would like to use a particular calibration set, you can provide it as follows: The sampler will by default use an IQMDevice created based on architecture data obtained\nfrom the server, which is then available in the IQMSampler.device property. The architecture\ndata depends on the calibration set used by the sampler, so one should usually use different sampler\ninstances for different calibration sets. Alternatively, the device can be specified directly with\nthe device argument, but this is not recommended when running on a real quantum computer. When executing a circuit that uses something other than the device qubits, you need to route it first,\nas explained in the Routing section above. If you are using IQM Resonance, you have two options to authenticate: Set the IQM_TOKEN environment variable with the API token obtained from the Resonance dashboard. Pass the token parameter to IQMSampler . This will be forwarded to IQMClient . If the IQM server you are connecting to requires authentication, you may use IQM Client CLI to retrieve and automatically refresh access tokens,\nthen set the IQM_TOKENS_FILE environment variable, as instructed, to point to the tokens file.\nSee IQM Client CLI\u2019s documentation for details. Alternatively, you may authenticate yourself using the IQM_AUTH_SERVER , IQM_AUTH_USERNAME and IQM_AUTH_PASSWORD environment variables, or pass them as\narguments to IQMSampler , but this approach is less secure and\nconsidered deprecated. Multiple circuits can be submitted to the IQM quantum computer at once using the run_iqm_batch() method of IQMSampler .  This is often faster than\nexecuting the circuits individually. Circuits submitted in a batch are still executed sequentially. It is possible to inspect the final circuits that would be submitted for execution before actually submitting them,\nwhich can be useful for debugging purposes. This can be done using IQMSampler.create_run_request() , which returns\na RunRequest containing the circuits and other data. The method accepts the same\nparameters as IQMSampler.run() and IQMSampler.run_iqm_batch() , and creates the run request in the same\nway as those functions. It is also possible to print a run request when it is actually submitted by setting the environment variable IQM_CLIENT_DEBUG=1 . More examples are available in the Cirq on IQM examples directory of the IQM Client repository. previous Qiskit on IQM User Guide next License By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release . Last updated on 2025-06-22."
  },
  {
    "package": "iqm-client",
    "title": "Qiskit on IQM User Guide",
    "url": "/iqm-client/user_guide_qiskit.html",
    "description": "This guide illustrates the main features of Qiskit on IQM, the Qiskit adapter for IQM Client.\nYou are encouraged to run the demonstrated code snippets and check the output yourself. Note IQM provides ...",
    "content": "This guide illustrates the main features of Qiskit on IQM, the Qiskit adapter for IQM Client.\nYou are encouraged to run the demonstrated code snippets and check the output yourself. Note IQM provides access to its quantum computers via IQM Resonance \u2013 IQM\u2019s quantum cloud service.\nPlease head over to our website to learn more. Here\u2019s a quick and easy way to run a small computation on an IQM quantum computer to check that\nthings are set up correctly, either\nthrough the IQM cloud service Resonance, or using an on-premises quantum computer. Login to IQM Resonance with your credentials. Upon your first visit to IQM Resonance, you can generate your unique, non-recoverable API token\ndirectly from the Dashboard page by selecting Generate token . It\u2019s important to copy the token\nimmediately from the window, as you won\u2019t be able to do so once the window is closed. If you lose\nyour token, you have the option to regenerate it at any time. However, be aware that regenerating\nyour API token will invalidate any previously generated token. Download one of the demo notebooks from IQM Academy or the resonance_example.py example file (Save Page As\u2026) Install Qiskit on IQM as instructed below. Add your API token to the example (either as the parameter token to the IQMProvider constructor, or by setting the environment variable IQM_TOKEN ) Run the Jupyter notebook (or run python resonance_example.py if you decided to go for the Python script). If you\u2019re connecting to a real quantum computer, the output should show almost half of the\nmeasurements resulting in \u201800000\u2019 and almost half in \u201811111\u2019 - if this is the case, things are\nset up correctly! You can find a video guide on how to set things up here .\nMore ready-to-run examples can also be found at IQM Academy . Download the bell_measure.py example file (Save Page As\u2026). Install Qiskit on IQM as instructed below. Install IQM Client CLI and log in as instructed in the documentation Set the environment variable as instructed by IQM Client CLI after logging in. Run $ python bell_measure.py --cortex_server_url https://demo.qc.iqm.fi/cocos - replace the example URL with the correct one. If you\u2019re connecting to a real quantum computer, the output should show almost half of the\nmeasurements resulting in \u201800\u2019 and almost half in \u201811\u2019 - if this is the case, things are set up\ncorrectly! Note If you have previously installed the (now deprecated) qiskit-iqm package in your Python environment,\nyou should first uninstall it with $ pip uninstall qiskit-iqm . In this case, you should also include\nthe --force-reinstall option in the iqm-client installation command. The recommended way is to install the optional qiskit feature of the iqm-client distribution package directly\nfrom the Python Package Index (PyPI): After installation, Qiskit on IQM can be imported in your Python code as follows: If you are using IQM Resonance, you have two options to authenticate: Set the IQM_TOKEN environment variable to the API token obtained from the Resonance dashboard. Pass the token parameter to IQMProvider . This will be forwarded to IQMClient . For an example, see the resonance_example.py file If the IQM server you are connecting to requires authentication, you may use IQM Client CLI to retrieve and automatically refresh access tokens,\nthen set the IQM_TOKENS_FILE environment variable, as instructed, to point to the tokens file.\nSee IQM Client CLI\u2019s documentation for details. You may also authenticate yourself using the IQM_AUTH_SERVER , IQM_AUTH_USERNAME and IQM_AUTH_PASSWORD environment variables, or pass them as\narguments to IQMProvider , however this approach is less secure and considered deprecated. In this section we demonstrate the practicalities of using Qiskit on IQM to execute\nquantum circuits on an IQM quantum computer. Let\u2019s consider the following quantum circuit which prepares and measures a GHZ state: To run this circuit on an IQM quantum computer you need to initialize an IQMProvider instance with the IQM server URL, use it to retrieve an IQMBackend instance representing\nthe quantum computer, and use Qiskit\u2019s transpile() function\nfollowed by IQMBackend.run() as usual. shots denotes the number of times the quantum\ncircuit(s) are sampled: Note As of qiskit >= 1.0 , Qiskit no longer supports execute() . Instead you should\nfirst transpile the circuit and then run it, as shown in the code above.\nSee the Transpilation section to learn how to transpile circuits in various ways. Note If you want to inspect the circuits that are sent to the device, use the circuit_callback keyword argument of IQMBackend.run() . See also Inspecting circuits before submitting them for execution for inspecting the actual run request sent for\nexecution. You can optionally provide IQMBackend specific options as additional keyword arguments to IQMBackend.run() , documented at IQMBackend.create_run_request() .\nFor example, you can enable heralding measurements using circuit_compilation_options as follows: The calibration data for an IQM quantum computer is stored in a calibration set . An IQMBackend instance\nalways corresponds to a specific calibration set, so that its transpilation target uses only those QPU components\n(qubits and computational resonators) and gates which are available in that calibration set. The server default\ncalibration set will be used by default, but you can also use a different calibration set by specifying the calibration_set_id parameter to IQMProvider.get_backend() or IQMBackend . If the server default\ncalibration set has changed after you have created the backend, the backend will still use the original default calibration\nset when submitting circuits for execution. When this happens you will get a warning.\nYou will need to create a new backend if you want to use the new default calibration set instead. The results of a job that was executed on the IQM quantum computer, represented as a Result instance, can be inspected using the usual Qiskit methods: The result comes with some metadata, such as the RunRequest that\nproduced it in result.request . The request contains e.g. the qubit mapping and the ID of the\ncalibration set that were used in the execution: Another piece of useful metadata are the timestamps of the various steps of processing the job. The\ntimestamps are stored in the dict result.timestamps . The job processing has three steps, compile where the circuits are converted to instruction schedules, submit where the instruction schedules are submitted for execution, and execution where the instruction schedules are executed and the measurement results are returned. The dict contains a timestamp for the start and end of each step.\nFor example, the timestamp of starting the circuit compilation is stored with key compile_start .\nIn the same way the other steps have their own timestamps with keys consisting of the step name and a _start or _end suffix. In addition to processing step timestamps, there are also timestamps for the job itself, job_start for when the job request was received by the server and job_end for when the job processing\nwas finished. If the processing of the job is terminated before it is complete, for example due to an error, the timestamps of\nprocessing steps that were not taken are not present in the dict. For example: The IQMBackend instance we created above provides all the standard backend functionality that one expects from a\nbackend in Qiskit. For this example, I am connected to an IQMBackend that features a 5-qubit chip with star-like\nconnectivity: Let\u2019s examine its basis gates and the coupling map through the backend instance Note that for IQMBackends the identity gate id is not actually a gate that is executed on the device and is simply omitted.\nAt IQM we identify qubits by their names, e.g. \u2018QB1\u2019, \u2018QB2\u2019, etc. as demonstrated above. In Qiskit, qubits are\nidentified by their indices in the quantum register, as you can see from the printed coupling map above. Most of the\ntime you do not need to deal with IQM-style qubit names when using Qiskit, however when you need, the methods IQMBackendBase.qubit_name_to_index() and IQMBackendBase.index_to_qubit_name() can become handy. Some IQM quantum computers support classically controlled gates, that is, gates that are executed\nconditionally depending on the result of a measurement preceding them in the quantum circuit. This\nsupport currently has several limitations: Only the x , y , rx , ry and r gates can be classically controlled. The gates can only be conditioned on one classical bit, and the only control available is to\napply the gate if the bit is 1, and apply an identity gate if the bit is 0. The availability of the controlled gates depends on the instrumentation of the quantum computer. The classical control can be applied on a circuit instruction using c_if() : The first measurement operation stores its result in the 1-bit classical register c . If the\nresult is 1, the X gate will be applied. If it is zero, an identity gate of corresponding\nduration is applied instead. Executing the above circuit should result in the counts being approximately 50/50 split\nbetween the \u201800 0\u2019 and \u201811 1\u2019 bins of the histogram (even though the state itself is never entangled). Note Because the gates can only take feedback from one classical bit you must place the measurement result\nin a 1-bit classical register, c in the above example. The qiskit.circuit.Reset operation can be used to reset qubits to the \\(|0\\rangle\\) state.\nIt is currently implemented as a (projective) measurement followed by a classically controlled X gate conditioned\non the result, and is only available if the quantum computer supports classically controlled gates. In the above example, the Hadamard gate prepares a uniform superposition of the \\(|0\\rangle\\) and \\(|1\\rangle\\) states, and the reset then collapses it back into the \\(|0\\rangle\\) state.\nExecuting the circuit should result in (mostly) zeros being measured. It is possible to inspect the final circuits that would be submitted for execution before actually submitting them,\nwhich can be useful for debugging purposes. This can be done using IQMBackend.create_run_request() , which returns\na RunRequest containing the circuits and other data. The method accepts the same\nparameters as IQMBackend.run() . It is also possible to print a run request when it is actually submitted by setting the environment variable IQM_CLIENT_DEBUG=1 . In this section we study how the circuit gets transpiled in more detail. You can use the default Qiskit transpiler on IQM quantum computers with both\nthe Crystal and the Star architectures.\nStarting from the GHZ circuit we created above: Under the hood the Qiskit transpiler uses the IQMDefaultSchedulingPlugin plugin that\nautomatically adapts the transpiled circuit to the IQMBackend. In particular, if optimization_level > 0 , the plugin will use the IQMOptimizeSingleQubitGates pass to optimize single-qubit gates, and for devices that have the IQM Star architecture, the plugin will use the IQMNaiveResonatorMoving pass to automatically insert MoveGate instructions\nas needed. Alternatively, you can use the transpile_to_IQM() function for more precise control over the\ntranspilation process as documented below. It is also possible to use one of our other pre-defined transpiler plugins as an argument to transpile() , for example transpile(circuit, backend=backend, scheduling_method=\"only_move_routing_keep\") .\nAdditionally, you can use any of our transpiler passes\nto define your own qiskit.transpiler.PassManager if you want to assemble custom\ntranspilation procedures manually. The IQM Star architecture includes computational resonators as additional QPU components,\nand uses qubit-resonator gates instead of two-qubit gates. These include MoveGate which moves qubit states to and from the resonators. The standard Qiskit transpiler does not know how to compile qubit-resonator gates.\nThis is why IQMBackend provides the Qiskit transpiler a simplified transpilation target in which\nthe resonators and MOVE gates have been abstracted away, and replaced with fictional two-qubit gates\nthat directly connect qubits that can be made to interact via a resonator. It then\nuses IQMDefaultSchedulingPlugin to re-introduce resonators and add MOVE gates between qubits and resonators as necessary at the scheduling stage. IQMDefaultSchedulingPlugin is executed automatically when you use the Qiskit transpiler.\nStarting from the GHZ circuit we created above: As an alternative to the native Qiskit transpiler integration, you can use the transpile_to_IQM() function.  It is meant for users who want at least one of the following: more fine grained control over the transpilation process without having to figure out which IQM\ntranspiler plugin to use, transpile Star architecture circuits that already contain qubit-resonator gates, or force the transpiler to use a strict subset of qubits on the device. For example, if you want to transpile the circuit with optimization_level=0 but also apply the\nsingle qubit gate optimization pass, you can do one of the following, equivalent things: Similarly, if you want to transpile a native Star architecture circuit that already contains MoveGate instances (that act on a qubit and a computational resonator), you can do the following: And if you want force the compiler to use a strict subset of qubits on the device, you can do the following: Note that if you do this, you do need to provide the IQMBackend.run() method a qubit\nmapping that matches the restriction: For the native integration of the custom IQM transpiler passes with the Qiskit transpiler, we\nhave implemented several scheduling plugins for the Qiskit transpiler. These plugins can be used as\nthe scheduling_method string argument for transpile() .\nThe mapping between these strings and the classes that implement the plugins is defined in the pyproject.toml file of this package.\nThe documentation of these plugins in found in the respective plugin classes. If you are unsure which plugin to use, you can use transpile_to_IQM() with the appropriate\narguments. This function determines which plugin to use based on the backend and the provided\narguments.  Note that the Qiskit transpiler automatically uses the IQMDefaultSchedulingPlugin when the backend is an IQMBackend. It is possible to submit multiple circuits to be executed, as a batch. In many cases this is more\ntime efficient than running the circuits one by one. Batch execution has some restrictions: all the\ncircuits must be executed for the same number of shots. For starters,\nlet\u2019s construct two circuits preparing and measuring different Bell states: Now, we can run them together in a batch: The batch execution functionality can be used to run a parameterized circuit for various concrete values of parameters: Note that it is important to transpile the parameterized circuit before binding the values to ensure a consistent qubit\nmeasurements across circuits in the batch. When multiple measurement instructions are present in a circuit, the measurements may be multiplexed, meaning the\nmeasurement pulses would be simultaneously executed on the quantum hardware, if possible. Multiplexing requires the\nmeasurement instructions to form a convex subgraph, i.e. not have other instructions between them acting on the same\nqubits. You don\u2019t have to do anything special to enable multiplexing, it is automatically attempted by the\ncircuit-to-pulse compiler on the server side. However, you can ensure multiplexing (whenever\npossible on the hardware level) by putting a barrier instruction before and after a group of\nmeasurements.  This prevents the transpiler from inserting any other instructions between the\nmeasurements.  There is no concept of multiplexed or simultaneous measurements in Qiskit, so the\ncircuit diagram will not indicate any multiplexing: In this section we show how to simulate the execution of quantum circuits on IQM quantum computers. Note Since the simulation happens locally, you do not need access to an actual quantum computer. The execution of circuits can be simulated locally, with a noise model to mimic the real hardware as\nmuch as possible.  To this end, Qiskit on IQM provides the class IQMFakeBackend that can\nbe instantiated with properties of a certain QPU, e.g. using functions such as IQMFakeAdonis() , IQMFakeApollo() and IQMFakeAphrodite() that represent specific IQM quantum architectures with pre-defined, representative noise models. Above, we use an IQMFakeAdonis() instance to run a noisy simulation of circuit on a simulated 5-qubit Adonis chip.\nThe noise model includes relaxation ( \\(T_1\\) ) and dephasing ( \\(T_2\\) ), gate infidelities and readout errors.\nIf you want to customize the noise model instead of using the default one provided by IQMFakeAdonis() , you can create\na copy of the IQMFakeBackend instance with an updated error profile: Circuits can be executed against a mock environment: an IQM server that has no real quantum computer hardware.\nResults from such executions are random bits. This may be useful when developing and testing software integrations. Qiskit on IQM contains IQMFacadeBackend , which allows to combine the mock remote execution with a local\nnoisy quantum circuit simulation. This way you can both validate your integration as well as get an idea of the expected circuit execution results. To run a circuit this way, use the \"facade_adonis\" backend retrieved from the provider. Note that the provider must be\ninitialized with the URL of a quantum computer with the equivalent architecture (i.e. names of qubits, their\nconnectivity, and the native gateset should match the 5-qubit Adonis architecture). Note When a classical register is added to the circuit, Qiskit fills it with classical bits of value 0 by default. If the\nregister is not used later, and the circuit is submitted to the IQM server, the results will not contain those\n0-filled bits. To make sure the facade backend returns results in the same format as a real IQM server, IQMFacadeBackend.run() checks for the presence of unused classical registers, and fails with an error if there\nare any. previous IQM Client CLI User Guide next Cirq on IQM User Guide By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release . Last updated on 2025-06-22."
  },
  {
    "package": "iqm-client",
    "title": "IQM client",
    "url": "/iqm-client/index.html",
    "description": " 2025-06-22 Client-side library for connecting to an IQM quantum computer. Includes Qiskit and Cirq adapters for IQM\u2019s quantum computers. See user guides for Qiskit and Cirq for introductions on how t...",
    "content": " 2025-06-22 Client-side library for connecting to an IQM quantum computer. Includes Qiskit and Cirq adapters for IQM\u2019s quantum computers. See user guides for Qiskit and Cirq for introductions on how to install and use the adapters. Also includes a CLI utility for managing user authentication when using IQM quantum computers. Index Module Index Search Page next IQM Client By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release . Last updated on 2025-06-22."
  },
  {
    "package": "iqm-client",
    "title": "API Reference",
    "url": "/iqm-client/API.html",
    "description": "previous IQM Client next Integration Guide By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release . Last updated on 2025-06-22....",
    "content": "previous IQM Client next Integration Guide By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release . Last updated on 2025-06-22."
  },
  {
    "package": "iqm-client",
    "title": "IQM Client CLI User Guide",
    "url": "/iqm-client/user_guide_cli.html",
    "description": "Command-line interface (CLI) for managing user authentication when using IQM quantum computers. For general usage instructions, run First, IQM Client CLI needs initialization, which produces a configu...",
    "content": "Command-line interface (CLI) for managing user authentication when using IQM quantum computers. For general usage instructions, run First, IQM Client CLI needs initialization, which produces a configuration file: IQM Client CLI will ask a few questions. You can also pass the values via command line to avoid having an interactive\nprompt. See iqmclient init --help for details. To log in, use This will ask you to enter your username and password. If you have a temporary password you will be asked to go to the\nauthentication server and enter a new password. URL of the authentication server will be provided. After a successful authentication, tokens will be saved into a tokens file (path specified in the configuration file),\nand a token manager daemon will start in the background. Token manager will periodically refresh the session and\nre-write the tokens file. To use the token manager in a foreground mode (not as daemon), run iqmclient auth login --no-daemon . This requires\nkeeping the shell session alive. However, you can start the process in the background by adding & after the\ncommand: iqmclient auth login --no-daemon & . This applies to Bash, zsh and similar shells, but may not be available\non all shells. To login and get tokens once, without starting a token manager at all, run iqmclient auth login --no-refresh . If the tokens file already exists, then running iqmclient auth login will first attempt to refresh the session\nwithout asking you for a username and password. If that fails (because existing tokens may already have expired), you\u2019ll\nbe asked to re-enter your credentials. See iqmclient auth login --help for more details. Adapters based on IQM Client, such as Cirq on IQM and Qiskit on IQM, can take advantage of the tokens file maintained by\nIQM Client CLI. This way you won\u2019t need to provide the authentication server URL, username, or password to the adapter\nlibrary itself. To achieve this, follow the instructions printed on the screen after running iqmclient auth login .\nNamely, set the IQM_TOKENS_FILE environment variable to point to your tokens file. On Linux: On Windows: Once set, this environment variable is read by the instance of IQM Client associated with the adapter. As a result,\nfrom the point of view of the adapter it looks like authentication is simply not required (i.e. no\nauthentication-related information has to be provided to the adapter). To see the current status of the token manager, use: If the tokens file exists, iqmclient auth status will report whether the corresponding token\nmanager is running. It will also print the time of the last successful refresh request, and\nhow much time is left until current tokens expire. See iqmclient auth status --help for more details. To log out, run This will send a logout request to the authentication server, kill the token manager daemon (if any), and delete the\ntokens file. You may want to stop the token manager, but maintain the session on the server and keep the tokens file intact.\nTo do so, run: See iqmclient auth logout --help for more details. By default, all IQM Client CLI commands read the configuration file from the default location ~/.config/iqm-client-cli/config.json . You can specify a different filepath by providing the --config-file value,\nfor example: previous Integration Guide next Qiskit on IQM User Guide By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release . Last updated on 2025-06-22."
  },
  {
    "package": "iqm-client",
    "title": "Contributors",
    "url": "/iqm-client/authors.html",
    "description": "Olli Ahonen < olli @ meetiqm . com > Ville Bergholm < ville @ meetiqm . com > Maija Nevala < maija @ meetiqm . com > Hayk Sargsyan < hayk @ meetiqm . com > Maxim Smirnov < dc914337 @ gmail . com > Oll...",
    "content": "Olli Ahonen < olli @ meetiqm . com > Ville Bergholm < ville @ meetiqm . com > Maija Nevala < maija @ meetiqm . com > Hayk Sargsyan < hayk @ meetiqm . com > Maxim Smirnov < dc914337 @ gmail . com > Olli Tyrkk\u00f6 < otyrkko @ meetiqm . com > Rakhim Davletkaliyev < rakhim . davletkaliyev @ meetiqm . com > Matthias Beuerle < matthias . beuerle @ meetiqm . com > Janne Kotilahti < janne @ meetiqm . com > Vladimir Kukushkin < vladimir . kukushkin @ meetiqm . com > Ricardas Brazinskas < ricardas . brazinskas @ meetiqm . com > Leon Wubben < leon @ meetiqm . com > Adrian Auer < adrian . auer @ meetiqm . com > Stefan Seegerer < stefan . seegerer @ meetiqm . com > Vicente Pina Canelles < vicente . pina @ meetiqm . com > Jake Muff < jake . muff @ vtt . fi > Johan Guldmyr < johan @ meetiqm . com > Caspar Ockeloen-Korppi < caspar @ meetiqm . com > previous License next Changelog By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release . Last updated on 2025-06-22."
  }
]