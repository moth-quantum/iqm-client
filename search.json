[
  {
    "package": "iqm-exa-common",
    "title": "API Reference",
    "url": "/iqm-exa-common/API.html",
    "description": "exa.common Shared errors, helpers, control structures, settings, API models etc. previous API documentation: exa-common next common \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated...",
    "content": "exa.common Shared errors, helpers, control structures, settings, API models etc. previous API documentation: exa-common next common \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "API documentation: exa-common",
    "url": "/iqm-exa-common/index.html",
    "description": "26.27.0 2025-07-07 This documentation describes the common library of the Experiment Automation ( EXA ) project. exa-common contains classes and functions that are shared by EXA , Cortex and Station C...",
    "content": "26.27.0 2025-07-07 This documentation describes the common library of the Experiment Automation ( EXA ) project. exa-common contains classes and functions that are shared by EXA , Cortex and Station Control . Index Module Index Search Page next API Reference \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "data_helper",
    "url": "/iqm-exa-common/api/exa.common.helpers.data_helper.html",
    "description": "Full path: exa.common.helpers.data_helper Functions add_data_array (ds,\u00a0da[,\u00a0name]) Add data array da to dataset ds . previous helpers next exa.common.helpers.data_helper.add_data_array \u00a9 Copyright 20...",
    "content": "Full path: exa.common.helpers.data_helper Functions add_data_array (ds,\u00a0da[,\u00a0name]) Add data array da to dataset ds . previous helpers next exa.common.helpers.data_helper.add_data_array \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.helpers.software_version_helper.get_vcs_description",
    "url": "/iqm-exa-common/api/exa.common.helpers.software_version_helper.get_vcs_description.html",
    "description": "Get Version Control System (VCS) description for the caller\u2019s current working directory. The description is used to verify if a directory is installed under VCS and whether changes to the files have\nb...",
    "content": "Get Version Control System (VCS) description for the caller\u2019s current working directory. The description is used to verify if a directory is installed under VCS and whether changes to the files have\nbeen made. First, the existence of .git directory will be checked from root_directory .\nOnly if it exists, a git command is executed in a subprocess with a timeout\nof 1 seconds as the best effort only. The path to the directory where the command will be executed. For instance when called from\nexa-experiment, it can be the exa-experiment root directory or any directory under it. If root_directory is not installed under git, None will be returned. Otherwise, the output of git describe --dirty --tags --long is returned. In case of errors in executing the command, the caught subprocess.CalledProcessError will be converted to string and returned. If the command fails or timeouts , an exception will be raised directly from subprocess.check_output. \u2013 root_directory ( str ) \u2013 str | None previous exa.common.helpers.software_version_helper.get_all_software_versions next yaml_helper \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.helpers.deprecation.format_deprecated",
    "url": "/iqm-exa-common/api/exa.common.helpers.deprecation.format_deprecated.html",
    "description": "old ( str ) \u2013 new ( str | None ) \u2013 since ( str ) \u2013 LiteralString previous deprecation next json_helper \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07....",
    "content": "old ( str ) \u2013 new ( str | None ) \u2013 since ( str ) \u2013 LiteralString previous deprecation next json_helper \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "helpers",
    "url": "/iqm-exa-common/api/exa.common.helpers.html",
    "description": "Miscellaneous helper functionality. Full path: exa.common.helpers Subpackages and modules data_helper  deprecation  json_helper  numpy_helper Coercion of numpy types. software_version_helper  yaml_hel...",
    "content": "Miscellaneous helper functionality. Full path: exa.common.helpers Subpackages and modules data_helper  deprecation  json_helper  numpy_helper Coercion of numpy types. software_version_helper  yaml_helper YAML utilities. previous exa.common.errors.station_control_errors.ValidationError next data_helper \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "setting_node",
    "url": "/iqm-exa-common/api/exa.common.data.setting_node.html",
    "description": "A tree-structured container for Settings . The SettingNode class combines a bunch of Settings together.\nIt may also contain other SettingNodes.\nTogether, the contents form a tree structure that provid...",
    "content": "A tree-structured container for Settings . The SettingNode class combines a bunch of Settings together.\nIt may also contain other SettingNodes.\nTogether, the contents form a tree structure that provides a useful way of grouping Settings. As an example, we manually construct a tree of SettingNodes with some dummy Settings, but it is usually not necessary.\nThe root node in the following examples is called 'node' . The easiest way to see the content of the node is the SettingNode.print_tree() method: We see that the 'root' node has two children, named 'root.flux' and 'root.pulse' , which\nthemselves are also SettingNodes.\nThis follows the typical naming convention in EXA: Subnodes include the names of their parents, separated by a dot. The children contain some dummy Settings, showing the keys, labels and current values. For other ways to access the content of the node, see also SettingNode.children , SettingNode.all_settings , and SettingNode.nodes_by_type() . The values within the nodes can be accessed using the attribute or dictionary syntax: The values can be changed with a simple = syntax: Note node.setting refers to the Setting object. node.setting.value syntax refers to the data stored inside. SettingNode also supports \u201cthe path notation\u201d by default (but not if align_name is set to False ,\nsince it cannot be made to work consistently if nodes are allowed to be named differently from their paths): is the same as node['flux']['voltage'] . Adding and deleting new Settings and nodes is simple: It is usually a good idea to make a copy of the original node, so that it won\u2019t be modified accidentally. The path notation of `` SettingNode``also works when inserting: Any nodes that did not already exist under node will be inserted (in this case flux already existed, but\nthe rest not, so under flux the nodes my , new , and path would be added), and then finally the\nvalue is added as child to the final node. Note: SettingNode always alings the path and name of any nodes under it,\nso this would result in the new setting being renamed as \u201cflux.my.new.path.foo\u201d: If align_name is set to False\", the name and path of nodes are not automatically aligned, but otherwise the above path notation will still work. The added nodes will be named by just their path fragments (\"my\", \"new\", \"path\", and so on), and the Setting will be added under the key \"foo\", but it will still retain its name \"bar\". Note: the root node name will always be excluded from the paths (and names when they are aligned with the path), so that the path of ``root.foo.bar is \"foo.bar\" . To merge values of two SettingNodes, there are helpers SettingNode.merge() and SettingNode.merge_values() . The first one merges the tree structure and values of two nodes and outputs a third one as a result. None values are always replaced by a proper value if such exists. In case of conflicting nodes or values,\nthe content of the first argument takes priority. Note how the result has values from node.flux , but also settings node.pulse that do not exist in node.flux . The SettingNode.merge_values() method is an in-place operation that only changes\nthe values of Settings that already exist in the node, if possible: Sometimes, it is easier to collect values in a dictionary and set them all at once by using SettingNode.set_from_dict() . The nested structure of the dictionary should match\nthe structure of the SettingNode. Keys that are not found in the tree are silently ignored, unless the strict flag is used. Full path: exa.common.data.setting_node Classes SettingNode A tree-structured Setting container. Inheritance previous Setting next SettingNode \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "logger",
    "url": "/iqm-exa-common/api/exa.common.logger.logger.html",
    "description": "Full path: exa.common.logger.logger Functions init_loggers ([loggers,\u00a0default_level,\u00a0...]) Set the log level of given logger names. Classes ExtraFormatter Helper formatter class to pass in arbitrary e...",
    "content": "Full path: exa.common.logger.logger Functions init_loggers ([loggers,\u00a0default_level,\u00a0...]) Set the log level of given logger names. Classes ExtraFormatter Helper formatter class to pass in arbitrary extra information to log messages. InfoFilter Helper class to filter log messages above INFO level. Inheritance previous logger next exa.common.logger.logger.init_loggers \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "sweep",
    "url": "/iqm-exa-common/api/exa.common.sweep.html",
    "description": "Sweep utilities. Full path: exa.common.sweep Subpackages and modules database_serialization Functions that encode and decode all sweep arguments(different types of sweeps, return parameters, settings,...",
    "content": "Sweep utilities. Full path: exa.common.sweep Subpackages and modules database_serialization Functions that encode and decode all sweep arguments(different types of sweeps, return parameters, settings, etc.). util Generic utilities for converting sweep definitions from user-friendly format to canonic ones. previous QCMDataClient next database_serialization \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "start_stop_base_options",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.option.start_stop_base_options.html",
    "description": "Range specification used with exponential sweeps. Full path: exa.common.control.sweep.option.start_stop_base_options Classes StartStopBaseOptions Range generation options. Inheritance previous exa.com...",
    "content": "Range specification used with exponential sweeps. Full path: exa.common.control.sweep.option.start_stop_base_options Classes StartStopBaseOptions Range generation options. Inheritance previous exa.common.control.sweep.option.option_converter.convert_to_options next StartStopBaseOptions \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "BaseModel",
    "url": "/iqm-exa-common/api/exa.common.data.base_model.BaseModel.html",
    "description": "Bases: BaseModel Pydantic base model to change the behaviour of pydantic globally.\nNote that setting model_config in child classes will merge the configs rather than override this one. https://docs.py...",
    "content": "Bases: BaseModel Pydantic base model to change the behaviour of pydantic globally.\nNote that setting model_config in child classes will merge the configs rather than override this one. https://docs.pydantic.dev/latest/concepts/config/#change-behaviour-globally Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.data.base_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Methods copy Returns a copy of the model. model_copy Returns a copy of the model. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Returns a copy of the model. Overrides the Pydantic default \u2018model_copy\u2019 to set \u2018deep=True\u2019 by default. update ( Mapping [ str , Any ] | None ) \u2013 deep ( bool ) \u2013 Self Returns a copy of the model. Self previous base_model next parameter \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "sweep",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.html",
    "description": "Classes for sweep specification. Full path: exa.common.control.sweep Subpackages and modules exponential_sweep Sweep specification with exponentially spaced values. fixed_sweep Sweep specification wit...",
    "content": "Classes for sweep specification. Full path: exa.common.control.sweep Subpackages and modules exponential_sweep Sweep specification with exponentially spaced values. fixed_sweep Sweep specification with arbitrary values. linear_sweep Sweep specification with linearly spaced values. option Range specifications for Sweeps. sweep Base immutable class for sweeps specifications. sweep_values Pydantic compatible annotated class for sweep values. previous control next exponential_sweep \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "numpy_helper",
    "url": "/iqm-exa-common/api/exa.common.helpers.numpy_helper.html",
    "description": "Coercion of numpy types. Full path: exa.common.helpers.numpy_helper Functions coerce_numpy_type_to_native (value) Convert numpy types to underlying native types, and Windows-specific int32 arrays to i...",
    "content": "Coercion of numpy types. Full path: exa.common.helpers.numpy_helper Functions coerce_numpy_type_to_native (value) Convert numpy types to underlying native types, and Windows-specific int32 arrays to int64s. previous exa.common.helpers.json_helper.get_json_encoder next exa.common.helpers.numpy_helper.coerce_numpy_type_to_native \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.sweep.database_serialization.decode_return_parameters",
    "url": "/iqm-exa-common/api/exa.common.sweep.database_serialization.decode_return_parameters.html",
    "description": "Deserialize return parameters. For backwards compatibility, changes values of the return parameters dict to a new,\nmore general format: NdSweeps, which is a list of tuples of Sweeps. Return parameters...",
    "content": "Deserialize return parameters. For backwards compatibility, changes values of the return parameters dict to a new,\nmore general format: NdSweeps, which is a list of tuples of Sweeps. Return parameters JSON syntax: [{\"parameter\": readout_parameter_json, \"hard_sweeps\": [hard_sweep,...]}, ...] . readout_parameter_json may be a Parameter or a Setting; both will be converted to a Parameter. hard_sweeps are converted with the following rules: 1 is converted to an empty NdSweep, i.e., a scalar. Other integers are converted to a linear_index_sweep() Sweep is converted to an NdSweep that contains only the sweep NdSweep and None are not converted. json_str ( str ) \u2013 JSON representation of the return_parameters loaded\nfrom e.g. persistence a reconstituted, typed return_parameters structure dict [ Parameter , list [ tuple [ Sweep , \u2026]] | None ] previous exa.common.sweep.database_serialization.decode_and_validate_sweeps next exa.common.sweep.database_serialization.decode_settings \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "center_span_options",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.option.center_span_options.html",
    "description": "Range specification to define a range around a center value. Full path: exa.common.control.sweep.option.center_span_options Classes CenterSpanOptions Range generation options. Inheritance previous Cen...",
    "content": "Range specification to define a range around a center value. Full path: exa.common.control.sweep.option.center_span_options Classes CenterSpanOptions Range generation options. Inheritance previous CenterSpanBaseOptions next CenterSpanOptions \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "util",
    "url": "/iqm-exa-common/api/exa.common.sweep.util.html",
    "description": "Generic utilities for converting sweep definitions from\nuser-friendly format to canonic ones. Full path: exa.common.sweep.util Functions convert_sweeps_to_list_of_tuples (sweeps) Validate sweeps and c...",
    "content": "Generic utilities for converting sweep definitions from\nuser-friendly format to canonic ones. Full path: exa.common.sweep.util Functions convert_sweeps_to_list_of_tuples (sweeps) Validate sweeps and convert it to format accepted by the station control. linear_index_sweep (parameter,\u00a0length) Produce an NdSweep over a dummy index. previous exa.common.sweep.database_serialization.encode_return_parameters next exa.common.sweep.util.convert_sweeps_to_list_of_tuples \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.GatewayTimeoutError",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.GatewayTimeoutError.html",
    "description": "Error raised when the gateway server did not receive a timely response. message ( str ) \u2013 previous exa.common.errors.station_control_errors.ForbiddenError next exa.common.errors.station_control_errors...",
    "content": "Error raised when the gateway server did not receive a timely response. message ( str ) \u2013 previous exa.common.errors.station_control_errors.ForbiddenError next exa.common.errors.station_control_errors.InternalServerError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.control.sweep.sweep_values.serialize_sweep_values",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.sweep_values.serialize_sweep_values.html",
    "description": "Serialize sweep values type to JSON serializable type, to support complex types. sweep_values ( Any ) \u2013 Any previous sweep_values next exa.common.control.sweep.sweep_values.validate_sweep_values \u00a9 Cop...",
    "content": "Serialize sweep values type to JSON serializable type, to support complex types. sweep_values ( Any ) \u2013 Any previous sweep_values next exa.common.control.sweep.sweep_values.validate_sweep_values \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "CHAD",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.CHAD.html",
    "description": "Bases: ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidate...",
    "content": "Bases: ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes computational_resonator_names Names of all the computational resonators declared in CHAD data. coupler_names Names of all the couplers declared in CHAD data. model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. probe_line_names Names of all the probe lines declared in CHAD data. qubit_names Names of all the qubits declared in CHAD data. mask_set_name  variant  components  Methods filter_qubit_components Filter qubit components from the input components. get_common_coupler_for Convenience method for getting the name of a coupler connecting a pair of components. get_component Get component by component name. get_coupler_mapping_for Get the coupler-component mapping for the couplers that connects to at least two components get_probe_line_mapping_for Get the probe line-component mapping. get_probe_line_names_for Get probe lines for given qubits in CHAD data. group_components_per_default_operations Groups given qubits/couplers based on their defined default operations. mask_set_name ( str ) \u2013 variant ( str ) \u2013 components ( Components ) \u2013 Get component by component name. component_name ( str ) \u2013 Component Names of all the qubits declared in CHAD data. Names of all the couplers declared in CHAD data. Names of all the probe lines declared in CHAD data. Names of all the computational resonators declared in CHAD data. Filter qubit components from the input components. component_names ( Collection [ str ] ) \u2013 list [ str ] Get probe lines for given qubits in CHAD data. component_names ( Collection [ str ] ) \u2013 list [ str ] Groups given qubits/couplers based on their defined default operations. The default operations that can be deducted from a CHAD are readout , drive , and flux . component_names ( Collection [ str ] ) \u2013 The component names to which to do the grouping.\nOther components present in the CHAD will not be included in the returned data. Tuple of qubits and couplers mapped to their connected default operations. The data is in the form of a dict with the keys being readout , drive , and flux ,\nand the values the list of component names having that particular operation. The data is in the form of a dict with the keys being readout , drive , and flux ,\nand the values the list of component names having that particular operation. tuple [ dict [ str , list [ str ]], dict [ str , list [ str ]]] in the given qubits. component_names ( Collection [ str ] ) \u2013 The qubit names. May contain any number of qubits. Coupler names mapped to the components they connect. - ValueError \u2013 If the provided qubit name list contains duplicates. dict [ str , list [ str ]] Get the probe line-component mapping. component_names ( Collection [ str ] ) \u2013 The qubit names. May contain any number of qubits. dict [ str , list [ str ]] Convenience method for getting the name of a coupler connecting a pair of components. first_component ( str ) \u2013 The name of the first component. second_component ( str ) \u2013 The name of the second component.\nThe order of qubits does not matter, i.e. the first_qubit and second_qubit arguments are interchangeable. The name of the coupler that connects the inputted components. The name of the coupler that connects the inputted components. - ValueError \u2013 If there were no couplers or more than one coupler connecting the component pair (the latter\n    should not be possible in a realistic chip). str Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous chad_model next Component \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "QCMDataClient",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.qcm_data_client.QCMDataClient.html",
    "description": "Bases: object Python client for QCM (Quantum Computer Management) Data API. root_url ( str ) \u2013 URL pointing to QCM Data service.\nThis URL can point to a local file storage as well.\nIn that case, the U...",
    "content": "Bases: object Python client for QCM (Quantum Computer Management) Data API. root_url ( str ) \u2013 URL pointing to QCM Data service.\nThis URL can point to a local file storage as well.\nIn that case, the URL should point to a directory which\nhas a directory structure identical to QCM Data service (for example /chip-data-records/),\nand files containing data in identical format returned by QCM Data service.\nFor example, CHAD files should be named {chip_label}.json, like M156_W531_A09_L09.json, and contain\na list instead of a single object. fallback_root_url ( str ) \u2013 Same as root_url , used if a query via root_url returns nothing. Module: exa.common.qcm_data.qcm_data_client Attributes root_url Returns the remote QCM Data service URL. Methods get_chip_design_record Get a raw chip design record matching the given chip label. Returns the remote QCM Data service URL. Get a raw chip design record matching the given chip label. chip_label ( str ) \u2013 Chip label. Data record matching the given chip label. dict previous qcm_data_client next sweep \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.BadGatewayError",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.BadGatewayError.html",
    "description": "Error raised when there are invalid responses from another server/proxy. message ( str ) \u2013 previous exa.common.errors.station_control_errors.map_from_status_code_to_error next exa.common.errors.statio...",
    "content": "Error raised when there are invalid responses from another server/proxy. message ( str ) \u2013 previous exa.common.errors.station_control_errors.map_from_status_code_to_error next exa.common.errors.station_control_errors.BadRequestError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "CenterSpanBaseOptions",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.option.center_span_base_options.CenterSpanBaseOptions.html",
    "description": "Bases: SweepOptions Range generation options. Values are generated over the interval from base power start of the range\nwith the center center and the size of span to base power end of the range\nwith ...",
    "content": "Bases: SweepOptions Range generation options. Values are generated over the interval from base power start of the range\nwith the center center and the size of span to base power end of the range\nwith the center center and the size of span . The number of values = count .\nThese options are used only for exponential sweep range. Module: exa.common.control.sweep.option.center_span_base_options Attributes asc Order of generated values. base  count Number of values to generate. data List of values for parameter center Value of interval center for the power. span Size of the interval for the power Methods center ( int | float ) \u2013 span ( int | float ) \u2013 count ( int | None ) \u2013 base ( int | float | None ) \u2013 asc ( bool | None ) \u2013 Value of interval center for the power. Size of the interval for the power Number of values to generate. Default to exa.common.control.sweep.option.constants.DEFAULT_COUNT . Order of generated values. Default to ascending List of values for parameter previous center_span_base_options next center_span_options \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.helpers.numpy_helper.coerce_numpy_type_to_native",
    "url": "/iqm-exa-common/api/exa.common.helpers.numpy_helper.coerce_numpy_type_to_native.html",
    "description": "Convert numpy types to underlying native types, and Windows-specific int32 arrays to int64s. value ( Any ) \u2013 Any previous numpy_helper next software_version_helper \u00a9 Copyright 2019-2025, IQM Finland O...",
    "content": "Convert numpy types to underlying native types, and Windows-specific int32 arrays to int64s. value ( Any ) \u2013 Any previous numpy_helper next software_version_helper \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "ImmutableBaseModel",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.immutable_base_model.ImmutableBaseModel.html",
    "description": "Bases: BaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form...",
    "content": "Bases: BaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.immutable_base_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Methods Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous immutable_base_model next qcm_data_client \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "api",
    "url": "/iqm-exa-common/api/exa.common.api.html",
    "description": "API helpers. Full path: exa.common.api Subpackages and modules previous common next control \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07....",
    "content": "API helpers. Full path: exa.common.api Subpackages and modules previous common next control \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.map_from_error_to_status_code",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.map_from_error_to_status_code.html",
    "description": "Map a StationControlError to an HTTPStatus code. error ( StationControlError ) \u2013 HTTPStatus previous station_control_errors next exa.common.errors.station_control_errors.map_from_status_code_to_error ...",
    "content": "Map a StationControlError to an HTTPStatus code. error ( StationControlError ) \u2013 HTTPStatus previous station_control_errors next exa.common.errors.station_control_errors.map_from_status_code_to_error \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "logger",
    "url": "/iqm-exa-common/api/exa.common.logger.html",
    "description": "Helper to initialize loggers to the specified logging level. Full path: exa.common.logger Subpackages and modules logger  previous exa.common.helpers.yaml_helper.load_yaml next logger \u00a9 Copyright 2019...",
    "content": "Helper to initialize loggers to the specified logging level. Full path: exa.common.logger Subpackages and modules logger  previous exa.common.helpers.yaml_helper.load_yaml next logger \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "CenterSpanOptions",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.option.center_span_options.CenterSpanOptions.html",
    "description": "Bases: SweepOptions Range generation options. Values are generated over the interval with the center center and the size of span .\nFor linear sweep range the number of generated values can be based ei...",
    "content": "Bases: SweepOptions Range generation options. Values are generated over the interval with the center center and the size of span .\nFor linear sweep range the number of generated values can be based either on count or step .\nIn case count is empty and step is not, step is used for calculating count .\nFor exponential sweep range only count is used. Module: exa.common.control.sweep.option.center_span_options Attributes asc Order of generated values. count Number of values to generate. data List of values for parameter step Size of spacing between values. center Value of interval center. span Size of the interval. Methods center ( int | float | complex ) \u2013 span ( int | float | complex ) \u2013 count ( int | None ) \u2013 step ( int | float | complex | None ) \u2013 asc ( bool | None ) \u2013 Value of interval center. Size of the interval. Number of values to generate.\nIf count and step are empty, the default value of count is exa.common.control.sweep.option.constants.DEFAULT_COUNT . Size of spacing between values. Order of generated values. Default to ascending List of values for parameter previous center_span_options next constants \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "option_converter",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.option.option_converter.html",
    "description": "Helper to create a SweepOptions instance from a dict. Full path: exa.common.control.sweep.option.option_converter Functions convert_to_options (config) Creates one of the options object based on confi...",
    "content": "Helper to create a SweepOptions instance from a dict. Full path: exa.common.control.sweep.option.option_converter Functions convert_to_options (config) Creates one of the options object based on configuration dictionary. previous FixedOptions next exa.common.control.sweep.option.option_converter.convert_to_options \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "Qubit",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.Qubit.html",
    "description": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form...",
    "content": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name  connections  Methods name ( str ) \u2013 connections ( tuple [ str , ... ] ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous ProbeLine next chip_topology \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.helpers.json_helper.get_json_encoder",
    "url": "/iqm-exa-common/api/exa.common.helpers.json_helper.get_json_encoder.html",
    "description": "Custom JSON encoder for complex number, ndarray or tuple Can be used in situation when serialization of JSON can be customised\n(json_encoders config in pydantic models, custom_encoder in jsonable_enco...",
    "content": "Custom JSON encoder for complex number, ndarray or tuple Can be used in situation when serialization of JSON can be customised\n(json_encoders config in pydantic models, custom_encoder in jsonable_encoder\nof fastapi, etc.) dict [ Any , Callable [[\u2026], dict [ str , Any ]]] previous exa.common.helpers.json_helper.decode_json next numpy_helper \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "sweep",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.sweep.html",
    "description": "Base immutable class for sweeps specifications. Full path: exa.common.control.sweep.sweep Classes Sweep Base immutable class for sweeps. Inheritance previous SweepOptions next Sweep \u00a9 Copyright 2019-2...",
    "content": "Base immutable class for sweeps specifications. Full path: exa.common.control.sweep.sweep Classes Sweep Base immutable class for sweeps. Inheritance previous SweepOptions next Sweep \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.helpers.software_version_helper.get_all_software_versions",
    "url": "/iqm-exa-common/api/exa.common.helpers.software_version_helper.get_all_software_versions.html",
    "description": "Get all available software version information. Currently, this function collects all Python package versions and Python interpreter version. reload_module ( bool ) \u2013 Whether to reload the pkg_resourc...",
    "content": "Get all available software version information. Currently, this function collects all Python package versions and Python interpreter version. reload_module ( bool ) \u2013 Whether to reload the pkg_resources module or not. By default,\nit is disabled because reloading the module is not thread safe!\nThis function should be called with reload_module=True when IPython autoreload is in use. dict [ str , str ] Example You have numpy==1.21.0 installed, and in the notebook you have executed the following IPython magic: You install numpy==1.21.1 You call this function with reload_module=False . This will result in some warning printouts and\nthe function will succeed by returning 1.21.0 for numpy, which is wrong because in reality IPython\nautoreload has reloaded the newly installed numpy 1.21.1.\nWith reload_module=True the correct version 1.21.1 is returned and no warnings are printed. information. A package\u2019s version information contains the base version, and the string\n\u201c(local editable)\u201d in the case the package is a local editable installation. previous software_version_helper next exa.common.helpers.software_version_helper.get_vcs_description \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "ComputationalResonator",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.ComputationalResonator.html",
    "description": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form...",
    "content": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name  connections  Methods name ( str ) \u2013 connections ( tuple [ str , ... ] ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous Components next Coupler \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "control",
    "url": "/iqm-exa-common/api/exa.common.control.html",
    "description": "Common data structures of abstract instrument control. Full path: exa.common.control Subpackages and modules sweep Classes for sweep specification. previous api next sweep \u00a9 Copyright 2019-2025, IQM F...",
    "content": "Common data structures of abstract instrument control. Full path: exa.common.control Subpackages and modules sweep Classes for sweep specification. previous api next sweep \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.data.value.serialize_value",
    "url": "/iqm-exa-common/api/exa.common.data.value.serialize_value.html",
    "description": "Serialize value type to JSON serializable type, to support complex and ndarray types. value ( Any ) \u2013 Any previous value next exa.common.data.value.validate_value \u00a9 Copyright 2019-2025, IQM Finland Oy...",
    "content": "Serialize value type to JSON serializable type, to support complex and ndarray types. value ( Any ) \u2013 Any previous value next exa.common.data.value.validate_value \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "common",
    "url": "/iqm-exa-common/api/exa.common.html",
    "description": "Shared errors, helpers, control structures, settings, API models etc. Full path: exa.common Subpackages and modules api API helpers. control Common data structures of abstract instrument control. data...",
    "content": "Shared errors, helpers, control structures, settings, API models etc. Full path: exa.common Subpackages and modules api API helpers. control Common data structures of abstract instrument control. data Classes for representing physical quantities and instrument settings. errors Common error messages. helpers Miscellaneous helper functionality. logger Helper to initialize loggers to the specified logging level. qcm_data  sweep Sweep utilities. previous API Reference next api \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.StationControlError",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.StationControlError.html",
    "description": "Base class for station control errors. message ( str ) \u2013 previous exa.common.errors.station_control_errors.ServiceUnavailableError next exa.common.errors.station_control_errors.UnauthorizedError \u00a9 Cop...",
    "content": "Base class for station control errors. message ( str ) \u2013 previous exa.common.errors.station_control_errors.ServiceUnavailableError next exa.common.errors.station_control_errors.UnauthorizedError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.exa_error.InvalidSweepOptionsTypeError",
    "url": "/iqm-exa-common/api/exa.common.errors.exa_error.InvalidSweepOptionsTypeError.html",
    "description": "The type of sweep options is invalid. previous exa.common.errors.exa_error.ExaError next exa.common.errors.exa_error.UnknownSettingError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last up...",
    "content": "The type of sweep options is invalid. previous exa.common.errors.exa_error.ExaError next exa.common.errors.exa_error.UnknownSettingError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "parameter",
    "url": "/iqm-exa-common/api/exa.common.data.parameter.html",
    "description": "Physical quantities and instrument settings. A basic data structure in EXA is the Parameter , which represents\na single variable. The variable can be a high-level or low-level control knob of an instr...",
    "content": "Physical quantities and instrument settings. A basic data structure in EXA is the Parameter , which represents\na single variable. The variable can be a high-level or low-level control knob of an instrument such as\nthe amplitude of a pulse or a control voltage; a physical quantity such as resonance frequency; or an abstract concept\nlike the number of averages in a measurement. The Parameter is a simple structure with a name, label, unit and a datatype without much functionality.\nThe Setting combines a Parameter and a value of the corresponding type.\nLike Parameters, Settings are lightweight objects that contain information but don\u2019t do anything by themselves. The Settings are immutable, which means that the value can\u2019t be changed, we can only make a copy with another value.\nWhen assigning a new value to a Setting, the datatype of the value is validated against the expected datatype of the\nparameter. Full path: exa.common.data.parameter Module Attributes SourceType Type for Setting sources. Classes CollectionType Parameter collection type. DataType Parameter data type. Parameter A basic data structure that represents a single variable. Setting Physical quantity represented as a Parameter attached to a numerical value. Inheritance previous BaseModel next exa.common.data.parameter.SourceType \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.UnauthorizedError",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.UnauthorizedError.html",
    "description": "Error raised when the user is not authorized. message ( str ) \u2013 previous exa.common.errors.station_control_errors.StationControlError next exa.common.errors.station_control_errors.ValidationError \u00a9 Co...",
    "content": "Error raised when the user is not authorized. message ( str ) \u2013 previous exa.common.errors.station_control_errors.StationControlError next exa.common.errors.station_control_errors.ValidationError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.ConflictError",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.ConflictError.html",
    "description": "This error happens when there is a conflict with the current state of the resource. For example, when doing duplicate submissions for the same unique data. message ( str ) \u2013 previous exa.common.errors...",
    "content": "This error happens when there is a conflict with the current state of the resource. For example, when doing duplicate submissions for the same unique data. message ( str ) \u2013 previous exa.common.errors.station_control_errors.BadRequestError next exa.common.errors.station_control_errors.ForbiddenError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "Launcher",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.Launcher.html",
    "description": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form...",
    "content": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. pin  function  name  connections  Methods name ( str ) \u2013 connections ( tuple [ str , ... ] ) \u2013 pin ( str ) \u2013 function ( str ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous Coupler next ProbeLine \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "ChipTopology",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chip_topology.ChipTopology.html",
    "description": "Bases: object Topology information for a chip (typically a QPU). Can represent the information found in a CHAD, as well as locus mappings for gates. qubits ( Iterable [ str ] ) \u2013 names of the qubits. ...",
    "content": "Bases: object Topology information for a chip (typically a QPU). Can represent the information found in a CHAD, as well as locus mappings for gates. qubits ( Iterable [ str ] ) \u2013 names of the qubits. computational_resonators ( Iterable [ str ] ) \u2013 names of the computational resonators. couplers ( dict [ str , Iterable [ str ] ] ) \u2013 mapping from coupler name to names of chip components it connects to. probe_lines ( dict [ str , Iterable [ str ] ] ) \u2013 mapping from probe line name to names of chip components it connects to. variant ( str ) \u2013 identifier of the QPU design variant. Module: exa.common.qcm_data.chip_topology Attributes computational_resonators Computational resonators on the chip, in any order. computational_resonators_sorted Computational resonators on the chip, sorted. couplers Tunable couplers on the chip, in any order. couplers_sorted Tunable couplers on the chip, sorted by numerical IDs. probe_lines Probe lines on the chip, in any order. probe_lines_sorted Probe lines on the chip, sorted. all_components All components on the chip. coupler_to_components Map from each coupler to all other components it connects to. component_to_couplers Map from each component to all couplers connected to it. probe_line_to_components Map from each probe line to all components it connects to. component_to_probe_line Map from each component to the probeline connected to it. Methods from_chad Construct a ChipTopology instance from a CHAD. from_chip_design_record Construct a ChipTopology instance from a raw Chip design record. get_all_common_resonators Computational resonators connected to all the given qubits via a coupler. get_common_computational_resonator Convenience method for getting the name of a computational resonator which is connected to both specified qubit components via tunable couplers. get_connected_coupler_map Returns a ComponentMap , including only the couplers between components that both are in the given subset. get_connected_probe_lines Get probelines that are connected to any of the given components. get_connecting_couplers Couplers that only connect to the given chip components, and connect at least two of them. get_coupler_for Common coupler for the given chip components (e.g. qubit or computational resonator). get_loci Gives all the loci of a given gate. get_neighbor_couplers Couplers that connect to at least one of the given chip components. get_neighbor_locus_components Chip components that are connected to the given components by a coupler, but not included in them. is_computational_resonator True iff the given component is a computational resonator. is_coupler True iff the given component is a coupler. is_probe_line True iff the given component is a probe line. is_qubit True iff the given component is a qubit. limit_values Prunes the given dictionary (e.g. a coupler-to-qubits map) to a subset of values. map_locus Returns the mapped components for the given locus and the given gate. map_to_locus Returns the locus that is mapped to the given components. set_locus_mapping Add a custom mapping from a gate locus to a set of components required for the gate operation. Computational resonators on the chip, in any order. Computational resonators on the chip, sorted. Tunable couplers on the chip, in any order. Tunable couplers on the chip, sorted by numerical IDs. Probe lines on the chip, in any order. Probe lines on the chip, sorted. All components on the chip. Map from each coupler to all other components it connects to. The values are sorted. Map from each component to all couplers connected to it. Map from each probe line to all components it connects to. Map from each component to the probeline connected to it.\nMax 1 connection per component is assumed.\nComponents without connection to a probe line don\u2019t appear. Construct a ChipTopology instance from a raw Chip design record. record ( dict ) \u2013 Record as returned by Station control. Corresponding chip topology ChipTopology Construct a ChipTopology instance from a CHAD. Use from_chip_design_record() if possible. chad ( CHAD ) \u2013 parsed CHAD model corresponding chip topology ChipTopology Couplers that connect to at least one of the given chip components. components ( Iterable [ str ] ) \u2013 some chip components, typically qubits and computational resonators couplers that connect to at least one of components set [ str ] Couplers that only connect to the given chip components, and connect at least two of them. Equivalent to returning the edges in the components -induced\nsubgraph of the coupling topology. components ( Collection [ str ] ) \u2013 some chip components, typically qubits and computational resonators couplers that connect to only members of components , and to at least two of them set [ str ] Common coupler for the given chip components (e.g. qubit or computational resonator). component_1 ( str ) \u2013 first component component_2 ( str ) \u2013 second component the common coupler ValueError \u2013 the given components have zero or more than one connecting coupler str Chip components that are connected to the given components by a coupler, but not included in them. components ( Collection [ str ] ) \u2013 some chip components, typically qubits and computational resonators components that are connected to components by a coupler, but not included in them set [ str ] Get probelines that are connected to any of the given components. components ( Collection [ str ] ) \u2013 set [ str ] Returns a ComponentMap , including only the couplers between components that both are in the given subset. components ( Collection [ str ] ) \u2013 Collection of coupled components to restrict the returned couplers. A ComponentMap , a dict mapping coupler names to the names of the coupled components. dict [ str , tuple [ str , \u2026]] Prunes the given dictionary (e.g. a coupler-to-qubits map) to a subset of values. Used to prune e.g. coupler_to_components to a subset of relevant elements. dct ( ComponentMap ) \u2013 Dictionary of collections of values. limit_to ( Collection [ str ] ) \u2013 Components to limit the output to. The input dictionary, but only with key-value pairs where the value intersects with limit_to . dict [ str , Collection [ str ]] True iff the given component is a qubit. component ( str ) \u2013 bool True iff the given component is a coupler. component ( str ) \u2013 bool True iff the given component is a probe line. component ( str ) \u2013 bool True iff the given component is a computational resonator. component ( str ) \u2013 bool Add a custom mapping from a gate locus to a set of components required for the gate operation. The mapping is of the form {<locus>: <components mapped to locus>}, where a locus can be mapped to one or more\ncomponents. The locus itself can be a frozenset (denoting a symmetric gate) or a tuple (non-symmetric gate). Some examples:\n- DEFAULT_2QB_MAPPING (added in __init__() ) maps pairs of qubits to their common coupler symmetrically.\n- Fast flux CZ-gate maps pairs of qubits to their couplers non-symmetrically (first locus qubit can perform flux pulses).\n- A two-qubit gate implementation that includes playing pulses on neighboring components in addition to the connecting coupler. name ( str ) \u2013 The name for the gate & implementation this locus mapping represents (typically in the format \"<gate name>.<implementation name>\" ). mapping ( dict [ tuple [ str , ... ] | frozenset [ str ] , tuple [ str , ... ] ] ) \u2013 The locus mapping to be added. None Validate that the components given in mapping are found in self and the mapping is correctly formed. mapping ( dict [ tuple [ str , ... ] | frozenset [ str ] , tuple [ str , ... ] ] ) \u2013 None Returns the mapped components for the given locus and the given gate. If the locus or the gate is not found from the locus mappings of self, returns None. locus ( tuple [ str , ... ] | frozenset [ str ] ) \u2013 The locus to map. name ( str | None ) \u2013 The name for the gate & implementation with which to map the locus (typically in the format \"<gate name>.<implementation name>\" ). The components mapped to the given locus or None if locus is not found in the given mapping. str | tuple [ str , \u2026] | None Returns the locus that is mapped to the given components. mapped ( str | tuple [ str ] ) \u2013 The mapped components. name ( str ) \u2013 The name for the gate & implementation with which to map the locus (typically in the format \"<gate name>.<implementation name>\" ). The locus mapped to the given components or None if the components are not mapped to any locus. tuple [ str , \u2026] | frozenset [ str ] | None Gives all the loci of a given gate. If no mapping with the given the name nor a default mapping with the given dimensionality is found,\nreturns an empty list. name ( str ) \u2013 The name for the gate & implementation with which to map the locus (typically in the format \"<gate name>.<implementation name>\" ). default_mapping_dimension ( int | None ) \u2013 If provided, will return the loci of the default mapping of the given\ndimensionality in case no mapping for name can be found. The loci associated with the given gate. list [ tuple [ str , \u2026] | frozenset [ str ]] Convenience method for getting the name of a computational resonator which is connected to both specified\nqubit components via tunable couplers. first_qubit ( str ) \u2013 The name of the first qubit. second_qubit ( str ) \u2013 The name of the second qubit. The order of qubits does not matter, i.e. the first_qubit and second_qubit arguments are interchangeable. The name of the second qubit. The order of qubits does not matter, i.e. the first_qubit and second_qubit arguments are interchangeable. The name of the computational resonator that is connected to both inputted qubits via tunable couplers. The name of the computational resonator that is connected to both inputted qubits via tunable couplers. - ValueError \u2013 If no computational resonator was found that is connected to both qubits via tunable couplers. \u2013 str Computational resonators connected to all the given qubits via a coupler. qubits ( list [ str ] ) \u2013 Qubit names. Names of the computational resonators neighboring all of qubits (can be an empty set). set [ str ] previous exa.common.qcm_data.chip_topology.sort_couplers next file_adapter \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "yaml_helper",
    "url": "/iqm-exa-common/api/exa.common.helpers.yaml_helper.html",
    "description": "YAML utilities. Full path: exa.common.helpers.yaml_helper Functions dump_yaml (data,\u00a0path) Dump a YAML data to the given path. load_yaml (path) Load a YAML file from the given path and raise error if ...",
    "content": "YAML utilities. Full path: exa.common.helpers.yaml_helper Functions dump_yaml (data,\u00a0path) Dump a YAML data to the given path. load_yaml (path) Load a YAML file from the given path and raise error if the file can't be loaded. previous exa.common.helpers.software_version_helper.get_vcs_description next exa.common.helpers.yaml_helper.dump_yaml \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.exa_error.ExaError",
    "url": "/iqm-exa-common/api/exa.common.errors.exa_error.ExaError.html",
    "description": "Base class for exa errors. message ( str ) \u2013 Error message. previous exa.common.errors.exa_error.EmptyComponentListError next exa.common.errors.exa_error.InvalidSweepOptionsTypeError \u00a9 Copyright 2019-...",
    "content": "Base class for exa errors. message ( str ) \u2013 Error message. previous exa.common.errors.exa_error.EmptyComponentListError next exa.common.errors.exa_error.InvalidSweepOptionsTypeError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.sweep.util.linear_index_sweep",
    "url": "/iqm-exa-common/api/exa.common.sweep.util.linear_index_sweep.html",
    "description": "Produce an NdSweep over a dummy index. Can be used in places where a \u201chardware sweep\u201d is needed but not really meaningful. parameter ( Parameter ) \u2013 Data parameter this index is for. length ( int ) \u2013 ...",
    "content": "Produce an NdSweep over a dummy index. Can be used in places where a \u201chardware sweep\u201d is needed but not really meaningful. parameter ( Parameter ) \u2013 Data parameter this index is for. length ( int ) \u2013 Number of integers in the dummy sweep. A linear sweep over a parameter whose name is parameter.name + _index and whose data ranges from 0 to length with steps of 1. list [ tuple [ Sweep ]] previous exa.common.sweep.util.convert_sweeps_to_list_of_tuples next Changelog \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "deprecation",
    "url": "/iqm-exa-common/api/exa.common.helpers.deprecation.html",
    "description": "Full path: exa.common.helpers.deprecation Functions format_deprecated (old,\u00a0new,\u00a0since)  previous exa.common.helpers.data_helper.add_data_array next exa.common.helpers.deprecation.format_deprecated \u00a9 ...",
    "content": "Full path: exa.common.helpers.deprecation Functions format_deprecated (old,\u00a0new,\u00a0since)  previous exa.common.helpers.data_helper.add_data_array next exa.common.helpers.deprecation.format_deprecated \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "fixed_sweep",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.fixed_sweep.html",
    "description": "Sweep specification with arbitrary values. Full path: exa.common.control.sweep.fixed_sweep Classes FixedSweep A sweep over arbitrary set of values, given by options . Inheritance previous ExponentialS...",
    "content": "Sweep specification with arbitrary values. Full path: exa.common.control.sweep.fixed_sweep Classes FixedSweep A sweep over arbitrary set of values, given by options . Inheritance previous ExponentialSweep next FixedSweep \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.BadRequestError",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.BadRequestError.html",
    "description": "Error raised when the request syntax is invalid or the method is unsupported in general. message ( str ) \u2013 previous exa.common.errors.station_control_errors.BadGatewayError next exa.common.errors.stat...",
    "content": "Error raised when the request syntax is invalid or the method is unsupported in general. message ( str ) \u2013 previous exa.common.errors.station_control_errors.BadGatewayError next exa.common.errors.station_control_errors.ConflictError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "InfoFilter",
    "url": "/iqm-exa-common/api/exa.common.logger.logger.InfoFilter.html",
    "description": "Bases: Filter Helper class to filter log messages above INFO level. Initialize a filter. Initialize with the name of the logger which, together with its\nchildren, will have its events allowed through ...",
    "content": "Bases: Filter Helper class to filter log messages above INFO level. Initialize a filter. Initialize with the name of the logger which, together with its\nchildren, will have its events allowed through the filter. If no\nname is specified, allow every event. Module: exa.common.logger.logger Methods filter Determine if the specified record is to be logged. Determine if the specified record is to be logged. Returns True if the record should be logged, or False otherwise.\nIf deemed appropriate, the record may be modified in-place. record ( LogRecord ) \u2013 bool previous ExtraFormatter next qcm_data \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.sweep.database_serialization.decode_and_validate_sweeps",
    "url": "/iqm-exa-common/api/exa.common.sweep.database_serialization.decode_and_validate_sweeps.html",
    "description": "Decodes and validates json string of list of Sweeps and tuples of Sweeps. sweeps_json ( str ) \u2013 json string of nested structure of Sweep objects list of sweeps and tuples of sweeps ValueError if decod...",
    "content": "Decodes and validates json string of list of Sweeps and tuples of Sweeps. sweeps_json ( str ) \u2013 json string of nested structure of Sweep objects list of sweeps and tuples of sweeps ValueError if decoded result is not expected return type \u2013 list [ Sweep | tuple [ Sweep , \u2026]] previous database_serialization next exa.common.sweep.database_serialization.decode_return_parameters \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "Parameter",
    "url": "/iqm-exa-common/api/exa.common.data.parameter.Parameter.html",
    "description": "Bases: BaseModel A basic data structure that represents a single variable. The variable can be a high-level or low-level control knob of an instrument such as the amplitude of a pulse\nor a control vol...",
    "content": "Bases: BaseModel A basic data structure that represents a single variable. The variable can be a high-level or low-level control knob of an instrument such as the amplitude of a pulse\nor a control voltage; a physical quantity such as resonance frequency; or an abstract concept\nlike the number of averages in a measurement. Setting combines Parameter with a numerical, boolean, or string value to represent a quantity. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.data.parameter Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. parent_label Returns the parent label. parent_name Returns the parent name. name Parameter name used as identifier label name unit SI unit of the quantity, if applicable. data_type Data type or a tuple of datatypes that this parameter accepts and validates. collection_type Data format that this parameter accepts and validates. element_indices For parameters representing a single value in a collection-valued parent parameter, this field gives the indices of that value. Methods build_data_array Attach Parameter information to a numerical array. build_data_set Build an xarray Dataset, where the only DataArray is given by results and coordinates are given by variables . create_element_parameter_for Utility for creating an element-wise parameter for a single value in a collection valued parameter. model_post_init This function is meant to behave like a BaseModel method to initialise private attributes. set Create a Setting object with given value . validate Validate that given value matches the data_type and collection_type . name ( str ) \u2013 label ( str ) \u2013 unit ( str ) \u2013 data_type ( DataType | tuple [ DataType , ... ] ) \u2013 collection_type ( CollectionType ) \u2013 element_indices ( int | list [ int ] | None ) \u2013 Parameter name used as identifier name Parameter label used as pretty identifier for display purposes. Default SI unit of the quantity, if applicable. Data type or a tuple of datatypes that this parameter accepts and validates. One of DataType .\nDefault: FLOAT. Data format that this parameter accepts and validates. One of CollectionType .\nDefault: SCALAR. For parameters representing a single value in a collection-valued parent parameter, this field gives the indices\nof that value. If populated, the self.name and self.label will be updated in post init to include\nthe indices (becoming \"<parent name>__<index0>__<index1>__...__<indexN>\" and \"<parent label> <indices>\" , respectively). The parent name can then be retrieved with self.parent_name and the parent label with self.parent_label . Returns the parent name. This None except in element-wise parameters where gives the name of the parent parameter. Returns the parent label. This None except in element-wise parameters where gives the label of the parent parameter. Create a Setting object with given value . value ( Any ) \u2013 Setting Build an xarray Dataset, where the only DataArray is given by results and coordinates are given by variables . The data is reshaped to correspond to the sizes of the variables. For example, variables = [(par_x, [1,2,3]), (par_y: [-1, -2])] will shape the data to 3-by-2 array. If there are not\nenough variables to reshape the data, remaining dimensions can be given by extra_variables . For example, variables = [(par_x: [1,2,3])], extra_variables=[('y', 2)] yields the same 3-by-2 data. 'y' will then be\na \u201cdimension without coordinate\u201d in xarray terms. variables ( list [ tuple [ Parameter , list [ Any ] ] ] ) \u2013 Coordinates of the set. data ( tuple [ Parameter , list [ Any ] | ndarray ] ) \u2013 Data Parameter and associated data as a possible nested list. attributes ( dict [ str , Any ] | None ) \u2013 metadata to attach to the whole Dataset. extra_variables ( list [ tuple [ str , int ] ] | None ) \u2013 Valueless dimensions and their sizes. Validate that given value matches the data_type and collection_type . value ( Any ) \u2013 bool Attach Parameter information to a numerical array. Given an array of numerical values, returns a corresponding xr.DataArray instance\nthat gets its name, units, and dimension names (unless explicitly given) from the Parameter instance. data ( ndarray ) \u2013 numerical values dimensions ( list [ str ] | list [ Hashable ] | None ) \u2013 names of the dimensions of data coords ( dict [ Hashable , Any ] | None ) \u2013 coordinates labeling the dimensions of data metadata ( dict [ str , Any ] | None ) \u2013 additional xr.DataArray.attrs corresponding DataArray DataArray Utility for creating an element-wise parameter for a single value in a collection valued parameter. indices ( int | list [ int ] ) \u2013 The indices in the collection for which to create the element-wise parameter. The element-wise parameter. UnprocessableEntityError \u2013 If self is not collection-valued. Parameter Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. This function is meant to behave like a BaseModel method to initialise private attributes. It takes context as an argument since that\u2019s what pydantic-core passes when calling it. self ( BaseModel ) \u2013 The BaseModel instance. context ( Any ) \u2013 The context. None previous DataType next Setting \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.exa_error.UnknownSettingError",
    "url": "/iqm-exa-common/api/exa.common.errors.exa_error.UnknownSettingError.html",
    "description": "This SettingNode does not have a given key. message ( str ) \u2013 previous exa.common.errors.exa_error.InvalidSweepOptionsTypeError next station_control_errors \u00a9 Copyright 2019-2025, IQM Finland Oy, Relea...",
    "content": "This SettingNode does not have a given key. message ( str ) \u2013 previous exa.common.errors.exa_error.InvalidSweepOptionsTypeError next station_control_errors \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "option",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.option.html",
    "description": "Range specifications for Sweeps. Full path: exa.common.control.sweep.option Subpackages and modules center_span_base_options Range specification used with exponential sweeps. center_span_options Range...",
    "content": "Range specifications for Sweeps. Full path: exa.common.control.sweep.option Subpackages and modules center_span_base_options Range specification used with exponential sweeps. center_span_options Range specification to define a range around a center value. constants Helper constants for SweepOptions classes. fixed_options Range specification for arbitrary set of values. option_converter Helper to create a SweepOptions instance from a dict. start_stop_base_options Range specification used with exponential sweeps. start_stop_options Range specification to define a linearly spaced interval. sweep_options Base class for sweep options. previous LinearSweep next center_span_base_options \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.control.sweep.sweep_values.validate_sweep_values",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.sweep_values.validate_sweep_values.html",
    "description": "Validate (i.e. deserialize) JSON serializable sweep values to Python type, to support complex types. sweep_values ( Any ) \u2013 Any previous exa.common.control.sweep.sweep_values.serialize_sweep_values ne...",
    "content": "Validate (i.e. deserialize) JSON serializable sweep values to Python type, to support complex types. sweep_values ( Any ) \u2013 Any previous exa.common.control.sweep.sweep_values.serialize_sweep_values next data \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exponential_sweep",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.exponential_sweep.html",
    "description": "Sweep specification with exponentially spaced values. Full path: exa.common.control.sweep.exponential_sweep Classes ExponentialSweep Generates parameter values spaced evenly on a geometric progression...",
    "content": "Sweep specification with exponentially spaced values. Full path: exa.common.control.sweep.exponential_sweep Classes ExponentialSweep Generates parameter values spaced evenly on a geometric progression based on options . Inheritance previous sweep next ExponentialSweep \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "data",
    "url": "/iqm-exa-common/api/exa.common.data.html",
    "description": "Classes for representing physical quantities and instrument settings. Full path: exa.common.data Subpackages and modules base_model  parameter Physical quantities and instrument settings. setting_node...",
    "content": "Classes for representing physical quantities and instrument settings. Full path: exa.common.data Subpackages and modules base_model  parameter Physical quantities and instrument settings. setting_node A tree-structured container for Settings . value  previous exa.common.control.sweep.sweep_values.validate_sweep_values next base_model \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "ProbeLine",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.ProbeLine.html",
    "description": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form...",
    "content": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name  connections  Methods name ( str ) \u2013 connections ( tuple [ str , ... ] ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous Launcher next Qubit \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.qcm_data.chip_topology.sort_couplers",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chip_topology.sort_couplers.html",
    "description": "Sort the given couplers in a human-readable way. couplers ( Iterable [ str ] ) \u2013 list [ str ] previous exa.common.qcm_data.chip_topology.sort_components next ChipTopology \u00a9 Copyright 2019-2025, IQM Fi...",
    "content": "Sort the given couplers in a human-readable way. couplers ( Iterable [ str ] ) \u2013 list [ str ] previous exa.common.qcm_data.chip_topology.sort_components next ChipTopology \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "SweepOptions",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.option.sweep_options.SweepOptions.html",
    "description": "Bases: object Base immutable class for sweep options. Module: exa.common.control.sweep.option.sweep_options Attributes data List of values for parameter Methods List of values for parameter previous s...",
    "content": "Bases: object Base immutable class for sweep options. Module: exa.common.control.sweep.option.sweep_options Attributes data List of values for parameter Methods List of values for parameter previous sweep_options next sweep \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "StartStopBaseOptions",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.option.start_stop_base_options.StartStopBaseOptions.html",
    "description": "Bases: SweepOptions Range generation options. Values are generated over the interval from base power start to base power stop .\nThe number of values = count . These options are used only for exponenti...",
    "content": "Bases: SweepOptions Range generation options. Values are generated over the interval from base power start to base power stop .\nThe number of values = count . These options are used only for exponential sweep range. Module: exa.common.control.sweep.option.start_stop_base_options Attributes base Number, that is raised to the power start or stop . count Number of values to generate. data List of values for parameter start The power for the start of the interval. stop The power for the end of the interval. Methods start ( int | float ) \u2013 stop ( int | float ) \u2013 count ( int ) \u2013 base ( int ) \u2013 The power for the start of the interval. The power for the end of the interval. Number of values to generate. Default to exa.common.control.sweep.option.constants.DEFAULT_COUNT . Number, that is raised to the power start or stop . Default to exa.common.control.sweep.option.constants.DEFAULT_BASE . List of values for parameter previous start_stop_base_options next start_stop_options \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "FixedSweep",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.fixed_sweep.FixedSweep.html",
    "description": "Bases: Sweep A sweep over arbitrary set of values, given by options . Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.Validatio...",
    "content": "Bases: Sweep A sweep over arbitrary set of values, given by options . Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.control.sweep.fixed_sweep Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. parameter The Sweep represents changing the values of this Parameter. data List of values for parameter Methods parameter ( Parameter ) \u2013 options ( FixedOptions | None ) \u2013 data ( list [ Any ] | ndarray ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous fixed_sweep next linear_sweep \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.ServiceUnavailableError",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.ServiceUnavailableError.html",
    "description": "Error raised when the service is unavailable. message ( str ) \u2013 previous exa.common.errors.station_control_errors.NotFoundError next exa.common.errors.station_control_errors.StationControlError \u00a9 Copy...",
    "content": "Error raised when the service is unavailable. message ( str ) \u2013 previous exa.common.errors.station_control_errors.NotFoundError next exa.common.errors.station_control_errors.StationControlError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "Component",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.Component.html",
    "description": "Bases: ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidate...",
    "content": "Bases: ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name  connections  Methods sort  name ( str ) \u2013 connections ( tuple [ str , ... ] ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous CHAD next Components \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "Setting",
    "url": "/iqm-exa-common/api/exa.common.data.parameter.Setting.html",
    "description": "Bases: BaseModel Physical quantity represented as a Parameter attached to a numerical value. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][...",
    "content": "Bases: BaseModel Physical quantity represented as a Parameter attached to a numerical value. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.data.parameter Attributes element_indices Element-wise indices of the parameter in self . label Label used as pretty identifier for display purposes, same as label of parameter . model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name Name used as identifier, same as name of parameter . parent_label Parent label of the parameter of self . parent_name Parent name of the parameter of self . source Return the source for this Setting's value. unit SI unit of the value , if applicable, same as unit of parameter . parameter The parameter this Setting represents. value Data value attached to the parameter. read_only Indicates if the attribute is read-only. path Path in the settings tree (starting from the root SettingNode ) for this setting. Methods create_element_parameter_for Utility for creating an element-wise parameter for a single value in a collection valued parameter. diff_sets Return a one-sided difference between two sets of Settings, prioritising values in first . get_by_name  merge  model_post_init This function is meant to behave like a BaseModel method to initialise private attributes. remove_by_name  replace  update Create a new setting object with updated value and source. validate_parameter_value_after  with_path_name Copy of self with the parameter name replaced by the path name. parameter ( Parameter | None ) \u2013 value ( ObservationValue | None ) \u2013 read_only ( bool ) \u2013 path ( str ) \u2013 source ( SourceType ) \u2013 The parameter this Setting represents. Data value attached to the parameter. Indicates if the attribute is read-only. Path in the settings tree (starting from the root SettingNode ) for this setting. The source for this Setting value. May contain an observation (ObservationDefinition or ObservationData)\nor a source-dict (e.g. {\"type\": \"configuration_source\", \"configurator\": \"defaults_from_yml\"} ). By default, None , which denotes the source not being specified (e.g. hardcoded defaults). The source is stored in a private\nattribute and thus is never serialized (the source field can contain non-serializable data such as Callables). Create a new setting object with updated value and source. value ( bool | str | int | float | complex | ndarray ) \u2013 New value for the setting. source ( None | BaseModel | dict [ str , Any ] ) \u2013 New source for the setting. Copy of self with modified properties. Setting Name used as identifier, same as name of parameter . Parent name of the parameter of self . Label used as pretty identifier for display purposes, same as label of parameter . Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. This function is meant to behave like a BaseModel method to initialise private attributes. It takes context as an argument since that\u2019s what pydantic-core passes when calling it. self ( BaseModel ) \u2013 The BaseModel instance. context ( Any ) \u2013 The context. None Parent label of the parameter of self . SI unit of the value , if applicable, same as unit of parameter . Element-wise indices of the parameter in self . Return the source for this Setting\u2019s value. Return a one-sided difference between two sets of Settings, prioritising values in first . first ( set [ Setting ] ) \u2013 Set whose values will be in the resulting diff. second ( set [ Setting ] ) \u2013 Set that is compared to first . A new set of Settings whose parameters are only found in first , and Settings in first whose\nvalues differ from their counterparts in second . set [ Setting ] Utility for creating an element-wise parameter for a single value in a collection valued parameter. indices ( int | list [ int ] ) \u2013 The indices in the collection for which to create the element-wise parameter. The element-wise parameter. ValueError \u2013 If self is not collection-valued. Parameter Copy of self with the parameter name replaced by the path name. Setting previous Parameter next setting_node \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "FileAdapter",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.file_adapter.FileAdapter.html",
    "description": "Bases: BaseAdapter Module: exa.common.qcm_data.file_adapter Methods close Cleans up adapter specific items. send Sends PreparedRequest object. Sends PreparedRequest object. Returns Response object. Cl...",
    "content": "Bases: BaseAdapter Module: exa.common.qcm_data.file_adapter Methods close Cleans up adapter specific items. send Sends PreparedRequest object. Sends PreparedRequest object. Returns Response object. Cleans up adapter specific items. previous file_adapter next immutable_base_model \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.sweep.util.convert_sweeps_to_list_of_tuples",
    "url": "/iqm-exa-common/api/exa.common.sweep.util.convert_sweeps_to_list_of_tuples.html",
    "description": "Validate sweeps and convert it to format accepted by the station control. Converts a more convenient sweep definition list to a strict list of tuples of sweeps.\nThe sweep instances themselves are the ...",
    "content": "Validate sweeps and convert it to format accepted by the station control. Converts a more convenient sweep definition list to a strict list of tuples of sweeps.\nThe sweep instances themselves are the same, except single sweep instances are turned\ninto a tuple containing a single sweep. Verify that:\n* sweeps list element is either Sweep or ParallelSweep\n* tuple_of_sweep element is a Sweep\n* tuple of sweeps contains at least one element\n* length of a data is identical in all tuples of sweeps sweeps ( list [ Sweep | tuple [ Sweep , ... ] ] ) \u2013 More user-friendly definition of a list of sweeps. List of tuples of sweeps. ValueError if sweeps parameter does not follow the contract. \u2013 list [ tuple [ Sweep , \u2026]] previous util next exa.common.sweep.util.linear_index_sweep \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "ExtraFormatter",
    "url": "/iqm-exa-common/api/exa.common.logger.logger.ExtraFormatter.html",
    "description": "Bases: Formatter Helper formatter class to pass in arbitrary extra information to log messages. Initialize the formatter with specified format strings. Initialize the formatter either with the specifi...",
    "content": "Bases: Formatter Helper formatter class to pass in arbitrary extra information to log messages. Initialize the formatter with specified format strings. Initialize the formatter either with the specified format string, or a\ndefault as described above. Allow for specialized date formatting with\nthe optional datefmt argument. If datefmt is omitted, you get an\nISO8601-like (or RFC 3339-like) format. Use a style parameter of \u2018%\u2019, \u2018{\u2019 or \u2018$\u2019 to specify that you want to\nuse one of %-formatting, str.format() ( {} ) formatting or string.Template formatting in your format string. Changed in version 3.2: Added the style parameter. Module: exa.common.logger.logger Attributes Methods format Format the specified record as text. extra_info_getter ( Callable [ [ ] , str ] | None ) \u2013 Format the specified record as text. The record\u2019s attribute dictionary is used as the operand to a\nstring formatting operation which yields the returned string.\nBefore formatting the dictionary, a couple of preparatory steps\nare carried out. The message attribute of the record is computed\nusing LogRecord.getMessage(). If the formatting string uses the\ntime (as determined by a call to usesTime(), formatTime() is\ncalled to format the event time. If there is exception information,\nit is formatted using formatException() and appended to the message. previous exa.common.logger.logger.init_loggers next InfoFilter \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.InternalServerError",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.InternalServerError.html",
    "description": "Error raised when an unexpected error happened on the server side. This error should never be raised when something expected happens,\nand whenever the client encounters this, it should be considered a...",
    "content": "Error raised when an unexpected error happened on the server side. This error should never be raised when something expected happens,\nand whenever the client encounters this, it should be considered as a server bug. message ( str ) \u2013 previous exa.common.errors.station_control_errors.GatewayTimeoutError next exa.common.errors.station_control_errors.NotFoundError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.ValidationError",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.ValidationError.html",
    "description": "Error raised when something is unprocessable in general, for example if the input value is not acceptable. message ( str ) \u2013 previous exa.common.errors.station_control_errors.UnauthorizedError next he...",
    "content": "Error raised when something is unprocessable in general, for example if the input value is not acceptable. message ( str ) \u2013 previous exa.common.errors.station_control_errors.UnauthorizedError next helpers \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "Coupler",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.Coupler.html",
    "description": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form...",
    "content": "Bases: Component Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name  connections  Methods name ( str ) \u2013 connections ( tuple [ str , ... ] ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous ComputationalResonator next Launcher \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.control.sweep.option.constants.DEFAULT_COUNT",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.option.constants.DEFAULT_COUNT.html",
    "description": "Default value for count value in options. previous constants next exa.common.control.sweep.option.constants.DEFAULT_BASE \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07...",
    "content": "Default value for count value in options. previous constants next exa.common.control.sweep.option.constants.DEFAULT_BASE \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.sweep.database_serialization.decode_settings",
    "url": "/iqm-exa-common/api/exa.common.sweep.database_serialization.decode_settings.html",
    "description": "Deserialize settings from json string json_str ( str ) \u2013 JSON representation of settings loaded\nfrom e.g. persistence deserialized settings SettingNode previous exa.common.sweep.database_serialization...",
    "content": "Deserialize settings from json string json_str ( str ) \u2013 JSON representation of settings loaded\nfrom e.g. persistence deserialized settings SettingNode previous exa.common.sweep.database_serialization.decode_return_parameters next exa.common.sweep.database_serialization.encode_nd_sweeps \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa_error",
    "url": "/iqm-exa-common/api/exa.common.errors.exa_error.html",
    "description": "Full path: exa.common.errors.exa_error Exceptions EmptyComponentListError (message,\u00a0*args) Error raised when an empty list is given as components for running an experiment. ExaError (message,\u00a0*args) B...",
    "content": "Full path: exa.common.errors.exa_error Exceptions EmptyComponentListError (message,\u00a0*args) Error raised when an empty list is given as components for running an experiment. ExaError (message,\u00a0*args) Base class for exa errors. InvalidSweepOptionsTypeError (**kwargs) The type of sweep options is invalid. UnknownSettingError (message,\u00a0*args) This SettingNode does not have a given key. previous errors next exa.common.errors.exa_error.EmptyComponentListError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "constants",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.option.constants.html",
    "description": "Helper constants for SweepOptions classes. Full path: exa.common.control.sweep.option.constants Module Attributes DEFAULT_COUNT Default value for count value in options. DEFAULT_BASE Default value for...",
    "content": "Helper constants for SweepOptions classes. Full path: exa.common.control.sweep.option.constants Module Attributes DEFAULT_COUNT Default value for count value in options. DEFAULT_BASE Default value for base value in options. OPTIONS_TYPE Dictionary with all possible types of options previous CenterSpanOptions next exa.common.control.sweep.option.constants.DEFAULT_COUNT \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "StartStopOptions",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.option.start_stop_options.StartStopOptions.html",
    "description": "Bases: SweepOptions Range generation options. Values are generated over the interval from start to stop . For linear sweep range the\nnumber of generated values can be based either on count or step . I...",
    "content": "Bases: SweepOptions Range generation options. Values are generated over the interval from start to stop . For linear sweep range the\nnumber of generated values can be based either on count or step . In case count is empty\nand step is not, step is used for calculating count . For exponential sweep range only count is used. Module: exa.common.control.sweep.option.start_stop_options Attributes count Number of values to generate. data List of values for parameter step Size of spacing between values. start Starting value of interval. stop Stopping value of interval. Methods start ( int | float | complex ) \u2013 stop ( int | float | complex ) \u2013 count ( int | None ) \u2013 step ( int | float | complex | None ) \u2013 Starting value of interval. Stopping value of interval. Number of values to generate. Must be non-negative.\nIf count and step are empty, the default value of count is exa.common.control.sweep.option.constants.DEFAULT_COUNT . Size of spacing between values. Must be non-zero.\nIf both count and step are not empty, only count is used List of values for parameter previous start_stop_options next sweep_options \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "base_model",
    "url": "/iqm-exa-common/api/exa.common.data.base_model.html",
    "description": "Full path: exa.common.data.base_model Classes BaseModel Pydantic base model to change the behaviour of pydantic globally. Inheritance previous data next BaseModel \u00a9 Copyright 2019-2025, IQM Finland Oy...",
    "content": "Full path: exa.common.data.base_model Classes BaseModel Pydantic base model to change the behaviour of pydantic globally. Inheritance previous data next BaseModel \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "Sweep",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.sweep.Sweep.html",
    "description": "Bases: BaseModel Base immutable class for sweeps. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input...",
    "content": "Bases: BaseModel Base immutable class for sweeps. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.control.sweep.sweep Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. parameter The Sweep represents changing the values of this Parameter. data List of values for parameter Methods model_post_init Override this method to perform additional initialization after __init__ and model_construct . parameter ( Parameter ) \u2013 options ( SweepOptions | None ) \u2013 data ( list [ Any ] | ndarray ) \u2013 The Sweep represents changing the values of this Parameter. List of values for parameter Override this method to perform additional initialization after __init__ and model_construct .\nThis is useful if you want to do some validation that requires the entire model to be initialized. _Sweep__context ( Any ) \u2013 None Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous sweep next sweep_values \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "sweep_options",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.option.sweep_options.html",
    "description": "Base class for sweep options. Full path: exa.common.control.sweep.option.sweep_options Classes SweepOptions Base immutable class for sweep options. Inheritance previous StartStopOptions next SweepOpti...",
    "content": "Base class for sweep options. Full path: exa.common.control.sweep.option.sweep_options Classes SweepOptions Base immutable class for sweep options. Inheritance previous StartStopOptions next SweepOptions \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.NotFoundError",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.NotFoundError.html",
    "description": "Error raised when nothing was found with the given parameters. This should be used when it\u2019s expected that something is found, for example when trying to find with an exact ID. message ( str ) \u2013 previ...",
    "content": "Error raised when nothing was found with the given parameters. This should be used when it\u2019s expected that something is found, for example when trying to find with an exact ID. message ( str ) \u2013 previous exa.common.errors.station_control_errors.InternalServerError next exa.common.errors.station_control_errors.ServiceUnavailableError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.data.parameter.SourceType",
    "url": "/iqm-exa-common/api/exa.common.data.parameter.SourceType.html",
    "description": "Type for Setting sources. previous parameter next CollectionType \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07....",
    "content": "Type for Setting sources. previous parameter next CollectionType \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.qcm_data.chip_topology.sort_components",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chip_topology.sort_components.html",
    "description": "Sort the given components in a human-readable way. components ( Iterable [ str ] ) \u2013 list [ str ] previous chip_topology next exa.common.qcm_data.chip_topology.sort_couplers \u00a9 Copyright 2019-2025, IQM...",
    "content": "Sort the given components in a human-readable way. components ( Iterable [ str ] ) \u2013 list [ str ] previous chip_topology next exa.common.qcm_data.chip_topology.sort_couplers \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "linear_sweep",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.linear_sweep.html",
    "description": "Sweep specification with linearly spaced values. Full path: exa.common.control.sweep.linear_sweep Classes LinearSweep Generates evenly spaced parameter values based on options . Inheritance previous F...",
    "content": "Sweep specification with linearly spaced values. Full path: exa.common.control.sweep.linear_sweep Classes LinearSweep Generates evenly spaced parameter values based on options . Inheritance previous FixedSweep next LinearSweep \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "file_adapter",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.file_adapter.html",
    "description": "Full path: exa.common.qcm_data.file_adapter Classes FileAdapter  Inheritance previous ChipTopology next FileAdapter \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07....",
    "content": "Full path: exa.common.qcm_data.file_adapter Classes FileAdapter  Inheritance previous ChipTopology next FileAdapter \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.control.sweep.option.constants.DEFAULT_BASE",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.option.constants.DEFAULT_BASE.html",
    "description": "Default value for base value in options. previous exa.common.control.sweep.option.constants.DEFAULT_COUNT next exa.common.control.sweep.option.constants.OPTIONS_TYPE \u00a9 Copyright 2019-2025, IQM Finland...",
    "content": "Default value for base value in options. previous exa.common.control.sweep.option.constants.DEFAULT_COUNT next exa.common.control.sweep.option.constants.OPTIONS_TYPE \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.map_from_status_code_to_error",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.map_from_status_code_to_error.html",
    "description": "Map an HTTPStatus code to a StationControlError. status_code ( HTTPStatus ) \u2013 type [ StationControlError ] previous exa.common.errors.station_control_errors.map_from_error_to_status_code next exa.comm...",
    "content": "Map an HTTPStatus code to a StationControlError. status_code ( HTTPStatus ) \u2013 type [ StationControlError ] previous exa.common.errors.station_control_errors.map_from_error_to_status_code next exa.common.errors.station_control_errors.BadGatewayError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "sweep_values",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.sweep_values.html",
    "description": "Pydantic compatible annotated class for sweep values. Full path: exa.common.control.sweep.sweep_values Functions serialize_sweep_values (sweep_values) Serialize sweep values type to JSON serializable ...",
    "content": "Pydantic compatible annotated class for sweep values. Full path: exa.common.control.sweep.sweep_values Functions serialize_sweep_values (sweep_values) Serialize sweep values type to JSON serializable type, to support complex types. validate_sweep_values (sweep_values) Validate (i.e. deserialize) JSON serializable sweep values to Python type, to support complex types. previous Sweep next exa.common.control.sweep.sweep_values.serialize_sweep_values \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "start_stop_options",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.option.start_stop_options.html",
    "description": "Range specification to define a linearly spaced interval. Full path: exa.common.control.sweep.option.start_stop_options Classes StartStopOptions Range generation options. Inheritance previous StartSto...",
    "content": "Range specification to define a linearly spaced interval. Full path: exa.common.control.sweep.option.start_stop_options Classes StartStopOptions Range generation options. Inheritance previous StartStopBaseOptions next StartStopOptions \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "chip_topology",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chip_topology.html",
    "description": "Chip topology class for parsing CHAD and other QPU related data into human-usable form. Full path: exa.common.qcm_data.chip_topology Functions sort_components (components) Sort the given components in...",
    "content": "Chip topology class for parsing CHAD and other QPU related data into human-usable form. Full path: exa.common.qcm_data.chip_topology Functions sort_components (components) Sort the given components in a human-readable way. sort_couplers (couplers) Sort the given couplers in a human-readable way. Classes ChipTopology Topology information for a chip (typically a QPU). Inheritance previous Qubit next exa.common.qcm_data.chip_topology.sort_components \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "fixed_options",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.option.fixed_options.html",
    "description": "Range specification for arbitrary set of values. Full path: exa.common.control.sweep.option.fixed_options Classes FixedOptions Range fixed options. Inheritance previous exa.common.control.sweep.option...",
    "content": "Range specification for arbitrary set of values. Full path: exa.common.control.sweep.option.fixed_options Classes FixedOptions Range fixed options. Inheritance previous exa.common.control.sweep.option.constants.OPTIONS_TYPE next FixedOptions \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "immutable_base_model",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.immutable_base_model.html",
    "description": "Full path: exa.common.qcm_data.immutable_base_model Classes ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Inheritance previous FileAdapter next Imm...",
    "content": "Full path: exa.common.qcm_data.immutable_base_model Classes ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Inheritance previous FileAdapter next ImmutableBaseModel \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.helpers.yaml_helper.dump_yaml",
    "url": "/iqm-exa-common/api/exa.common.helpers.yaml_helper.dump_yaml.html",
    "description": "Dump a YAML data to the given path. Create missing directories if necessary. data ( dict [ str , Any ] ) \u2013 path ( Path | str ) \u2013 None previous yaml_helper next exa.common.helpers.yaml_helper.load_yaml...",
    "content": "Dump a YAML data to the given path. Create missing directories if necessary. data ( dict [ str , Any ] ) \u2013 path ( Path | str ) \u2013 None previous yaml_helper next exa.common.helpers.yaml_helper.load_yaml \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "center_span_base_options",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.option.center_span_base_options.html",
    "description": "Range specification used with exponential sweeps. Full path: exa.common.control.sweep.option.center_span_base_options Classes CenterSpanBaseOptions Range generation options. Inheritance previous optio...",
    "content": "Range specification used with exponential sweeps. Full path: exa.common.control.sweep.option.center_span_base_options Classes CenterSpanBaseOptions Range generation options. Inheritance previous option next CenterSpanBaseOptions \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "json_helper",
    "url": "/iqm-exa-common/api/exa.common.helpers.json_helper.html",
    "description": "Full path: exa.common.helpers.json_helper Functions decode_json (obj) Custom json decoder for object, in case it is represented as complex number, ndarray or tuple. get_json_encoder () Custom JSON enc...",
    "content": "Full path: exa.common.helpers.json_helper Functions decode_json (obj) Custom json decoder for object, in case it is represented as complex number, ndarray or tuple. get_json_encoder () Custom JSON encoder for complex number, ndarray or tuple previous exa.common.helpers.deprecation.format_deprecated next exa.common.helpers.json_helper.decode_json \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "DataType",
    "url": "/iqm-exa-common/api/exa.common.data.parameter.DataType.html",
    "description": "Bases: IntEnum Parameter data type. Module: exa.common.data.parameter Attributes ANYTHING  FLOAT  COMPLEX  STRING  BOOLEAN  INT  NUMBER  Methods cast  validate  previous CollectionType next Parameter ...",
    "content": "Bases: IntEnum Parameter data type. Module: exa.common.data.parameter Attributes ANYTHING  FLOAT  COMPLEX  STRING  BOOLEAN  INT  NUMBER  Methods cast  validate  previous CollectionType next Parameter \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "CollectionType",
    "url": "/iqm-exa-common/api/exa.common.data.parameter.CollectionType.html",
    "description": "Bases: IntEnum Parameter collection type. Module: exa.common.data.parameter Attributes SCALAR Scalar, not a list of any kind. LIST Python list. NDARRAY Numpy ndarray. Methods cast Cast the given value...",
    "content": "Bases: IntEnum Parameter collection type. Module: exa.common.data.parameter Attributes SCALAR Scalar, not a list of any kind. LIST Python list. NDARRAY Numpy ndarray. Methods cast Cast the given value to this collection type. Scalar, not a list of any kind. Python list. Numpy ndarray. Cast the given value to this collection type. value ( Any ) \u2013 Any previous exa.common.data.parameter.SourceType next DataType \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "qcm_data",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.html",
    "description": "Full path: exa.common.qcm_data Subpackages and modules chad_model Pydantic models for CHAD. chip_topology Chip topology class for parsing CHAD and other QPU related data into human-usable form. file_a...",
    "content": "Full path: exa.common.qcm_data Subpackages and modules chad_model Pydantic models for CHAD. chip_topology Chip topology class for parsing CHAD and other QPU related data into human-usable form. file_adapter  immutable_base_model  qcm_data_client QCM (Quantum Computer Management) Data API client implementation. previous InfoFilter next chad_model \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "database_serialization",
    "url": "/iqm-exa-common/api/exa.common.sweep.database_serialization.html",
    "description": "Functions that encode and decode all sweep arguments(different types of\nsweeps, return parameters, settings, etc.). The module provides functions for\nserializing and deserializing sweep arguments befo...",
    "content": "Functions that encode and decode all sweep arguments(different types of\nsweeps, return parameters, settings, etc.). The module provides functions for\nserializing and deserializing sweep arguments before saving them to database. Full path: exa.common.sweep.database_serialization Functions decode_and_validate_sweeps (sweeps_json) Decodes and validates json string of list of Sweeps and tuples of Sweeps. decode_return_parameters (json_str) Deserialize return parameters. decode_settings (json_str) Deserialize settings from json string encode_nd_sweeps (sweeps,\u00a0**kwargs) Encode sweeps to a JSON string. encode_return_parameters (return_parameters,\u00a0...) Encode sweeps to a JSON string. previous sweep next exa.common.sweep.database_serialization.decode_and_validate_sweeps \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.data.value.validate_value",
    "url": "/iqm-exa-common/api/exa.common.data.value.validate_value.html",
    "description": "Validate (i.e. deserialize) JSON serializable value to Python type, to support complex and ndarray types. value ( Any ) \u2013 Any previous exa.common.data.value.serialize_value next errors \u00a9 Copyright 201...",
    "content": "Validate (i.e. deserialize) JSON serializable value to Python type, to support complex and ndarray types. value ( Any ) \u2013 Any previous exa.common.data.value.serialize_value next errors \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "LinearSweep",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.linear_sweep.LinearSweep.html",
    "description": "Bases: Sweep Generates evenly spaced parameter values based on options . If options is instance of StartStopOptions , then start and stop options are used for interval If options is instance of Center...",
    "content": "Bases: Sweep Generates evenly spaced parameter values based on options . If options is instance of StartStopOptions , then start and stop options are used for interval If options is instance of CenterSpanOptions ,\nthen the start and stop of the interval are calculated from center and span values ValueError \u2013 Error is raised if options is inconsistent. parameter ( Parameter ) \u2013 options ( StartStopOptions | CenterSpanOptions | None ) \u2013 data ( list [ Any ] | ndarray ) \u2013 Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.control.sweep.linear_sweep Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. parameter The Sweep represents changing the values of this Parameter. data List of values for parameter Methods Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous linear_sweep next option \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.control.sweep.option.option_converter.convert_to_options",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.option.option_converter.convert_to_options.html",
    "description": "Creates one of the options object based on configuration dictionary. If configuration has keys start and stop , StartStopOptions is created. If configuration has keys start_exp and stop_exp , StartSto...",
    "content": "Creates one of the options object based on configuration dictionary. If configuration has keys start and stop , StartStopOptions is created. If configuration has keys start_exp and stop_exp , StartStopBaseOptions is created. If configuration has keys center and span , CenterSpanOptions is created. If configuration has keys center_exp and span_exp , CenterSpanBaseOptions is created If configuration has keys fixed , FixedOptions is created. config ( dict [ str , Any ] ) \u2013 Configuration dictionary. ValueError \u2013 Error is raised if config has unsupported structure SweepOptions previous option_converter next start_stop_base_options \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.helpers.data_helper.add_data_array",
    "url": "/iqm-exa-common/api/exa.common.helpers.data_helper.add_data_array.html",
    "description": "Add data array da to dataset ds . Unlike the default xarray command, preserves metadata of the dataset. ds ( Dataset ) \u2013 Dataset to add to. da ( DataArray ) \u2013 DataArray to add name ( Hashable | None )...",
    "content": "Add data array da to dataset ds . Unlike the default xarray command, preserves metadata of the dataset. ds ( Dataset ) \u2013 Dataset to add to. da ( DataArray ) \u2013 DataArray to add name ( Hashable | None ) \u2013 name under which da can be accessed inside ds .\nBy default, uses the name property of da . The updated dataset. Dataset previous data_helper next deprecation \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.exa_error.EmptyComponentListError",
    "url": "/iqm-exa-common/api/exa.common.errors.exa_error.EmptyComponentListError.html",
    "description": "Error raised when an empty list is given as components for running an experiment. message ( str ) \u2013 previous exa_error next exa.common.errors.exa_error.ExaError \u00a9 Copyright 2019-2025, IQM Finland Oy, ...",
    "content": "Error raised when an empty list is given as components for running an experiment. message ( str ) \u2013 previous exa_error next exa.common.errors.exa_error.ExaError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "SettingNode",
    "url": "/iqm-exa-common/api/exa.common.data.setting_node.SettingNode.html",
    "description": "Bases: BaseModel A tree-structured Setting container. Each child of the node is a Setting , or another SettingNode .\nIterating over the node returns all children, recursively.\nSettings can be accessed...",
    "content": "Bases: BaseModel A tree-structured Setting container. Each child of the node is a Setting , or another SettingNode .\nIterating over the node returns all children, recursively.\nSettings can be accessed by dictionary syntax or attribute syntax: name ( str ) \u2013 Name of the node. settings ( dict [ str , Any ] | None ) \u2013 Dict of setting path fraqment names (usually the same as the setting name) to the settings. Mostly\nused when deserialising and otherwise left empty. subtrees ( dict [ str , Any ] | None ) \u2013 Dict of child node path fraqment names (usually the same as the child node name) to the settings.\nMostly used when deserialising and otherwise left empty. path ( str ) \u2013 Optionally give a path for the node, by default empty. generate_paths ( bool ) \u2013 If set True , all subnodes will get their paths autogenerated correctly. Only set to False if the subnodes already have correct paths set (e.g. when deserialising). kwargs \u2013 The children given as keyword arguments. Each argument must be a Setting , Parameter , or a SettingNode . The keywords are used as the names of the nodes.\nParameters will be cast into Settings with the value None . align_name ( bool ) \u2013 Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.data.setting_node Attributes all_settings Yields all Setting instances inside this node, recursively. child_nodes ItemsView of immediate child nodes of this node. child_settings ItemsView of settings of this node. children Dictionary of immediate child nodes of this node. model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name  settings  subtrees  path  align_name  Methods add_for_path Add nodes to self while creating the missing nodes in-between. diff Recursive diff between two SettingNodes. find_by_name Find first occurrence of Setting or SettingNode by name, by iterating recursively through all children. get_default_implementation_name Get the default implementation name for a given gate and locus. get_gate_node_for_locus Get the gate calibration sub-node for the locus given as a parameter if it exists in the settings tree. get_gate_properties_for_locus Get the gate characterization sub-node for the locus given as a parameter if it exists in the settings tree. get_locus_node_paths_for Get all the gate locus node paths for a given gate . get_node_for_path Return the node corresponding to the given path. get_parent_of Get the first SettingNode that has a Setting named name . merge Recursively combine the tree structures and values of two SettingNodes. merge_values Recursively combine the values from another SettingNode to this one. nodes_by_type Yields all nodes, filtered by given node_types . print_tree Print a tree representation of the contents of this node. prune Recursively delete all branches from this SettingNode that are not found in other . set_from_dict Recursively set values to Settings, taking values from a dictionary that has similar tree structure. set_source Set source recursively to all Settings in self . setting_with_path_name Get a copy of a setting with its name replaced with the path name. transform_node_types Reduce any subclass of SettingNode and it's contents into instances of cls . update_setting Update an existing Setting in this tree. This method generates the paths and aligns the names when required. None List items and subtree names, so they occur in IPython autocomplete after node[<TAB> Yields all nodes, filtered by given node_types . Used to find and iterate over nodes of specific types. node_types ( type | tuple [ type , ... ] | None ) \u2013 when iterating over the tree, yields only instances that match this type\nor any of the types in the tuple. By default, yields Settings and SettingNodes. recursive ( bool ) \u2013 If True, the search is carried recursively. If False, the search is limited to\nimmediate child nodes. Iterator that yields the filtered nodes. Iterator Update an existing Setting in this tree. setting ( Setting ) \u2013 Setting that will replace an existing Setting with the same name. Or if the setting is an\nelement-wise setting (i.e. it has a non-empty value of setting.element_indices ), the corresponding\nelement will be updated in the collection. UnknownSettingError \u2013 If no setting is found in the children of this tree. None Yields all Setting instances inside this node, recursively. Dictionary of immediate child nodes of this node. ItemsView of settings of this node. ItemsView of immediate child nodes of this node. Get the first SettingNode that has a Setting named name . name ( str ) \u2013 Name of the setting to look for. A SettingNode that has a child name . SettingNode Find first occurrence of Setting or SettingNode by name, by iterating recursively through all children. name ( str ) \u2013 Name of the Setting or SettingNode to look for. First found item, or None if nothing is found. SettingNode | Setting | None Recursively combine the tree structures and values of two SettingNodes. In case of conflicting nodes,values in first take priority regardless of the replaced content in second . None values are not prioritized unless merge_nones is set to True . first ( SettingNode ) \u2013 SettingNode to merge, whose values and structure take priority second ( SettingNode ) \u2013 SettingNode to merge. merge_nones ( bool ) \u2013 Whether to merge also None values from first to second . align_name ( bool ) \u2013 Whether to align the paths (and also names if second does not use align_name==False )\nwhen merging the nodes. Should never be set False unless the paths in first already align with\nwhat they should be in second (setting it False in such cases can improve performance). deep_copy ( bool ) \u2013 Whether to deepcopy or just shallow copy all the sub-nodes. Set to False with high caution\nand understand the consequences. A new SettingNode constructed from arguments. SettingNode Recursively combine the values from another SettingNode to this one. The resulting tree structure the same as that of self. other ( SettingNode ) \u2013 SettingNode to merge. prioritize_other ( bool ) \u2013 If True, will prioritize values in other. If False (default), only None values in self\nwill be replaced. Recursively delete all branches from this SettingNode that are not found in other . other ( SettingNode ) \u2013 None Print a tree representation of the contents of this node. levels ( int ) \u2013 display this many levels, starting from the root. None Reduce any subclass of SettingNode and it\u2019s contents into instances of cls . node ( SettingNode ) \u2013 node to transform. A new SettingNode with the same structure as the original, but where node instances are of type cls . SettingNode Recursively set values to Settings, taking values from a dictionary that has similar tree structure.\nKeys that are not found in self are ignored, unless strict is True. dct ( dict [ str , Any ] ) \u2013 Dictionary containing the new values to use. strict ( bool ) \u2013 If True, will raise error if dct contains a setting that is not found in self . source ( None | BaseModel | dict [ str , Any ] ) \u2013 Source for the settings (this same source is applied to all settings from the dict). UnknownSettingError \u2013 If the condition of strict happens. None Get a copy of a setting with its name replaced with the path name. setting ( Setting ) \u2013 Setting | None Recursive diff between two SettingNodes. This function is meant to produce human-readable output, e.g. for debugging purposes.\nIt returns the differences in a list of strings, each string detailing\none specific difference. The diff is non-symmetric. other ( SettingNode ) \u2013 second node to compare self to path ( str ) \u2013 node path to the currently compared nodes (used in printing the results) differences from self to other , in depth-first order list [ str ] Turn a numerical value and unit, and return rescaled value and SI prefixed unit. Unit must be a whitelisted SI base unit. Return the node corresponding to the given path. path ( str ) \u2013 The path. The node at path in self. ValueError \u2013 If the given path cannot be found in self. Setting | SettingNode Add nodes to self while creating the missing nodes in-between. Whether the names and paths are aligned is determined by the attribute align_name of the current node\n( self ). All the created missing nodes will use this same align_name value,\nwhich determines whether their names will align with their paths. nodes ( Iterable [ Setting | Parameter | SettingNode ] | dict [ str , Setting | Parameter | SettingNode ] ) \u2013 Nodes to add as new leaves/branches of path . If of type dict , maps the keys used in self.settings or self.subtrees to the nodes themselves. If align_name=False , the key and\nthe node name can differ, but otherwise the names will be replaced by the path anyways). path ( str ) \u2013 Path in self to which nodes will be added. If the path or any part (suffix) of it is not\nfound in self, the associated nodes will be created automatically. override_values ( dict [ str , Any ] | None ) \u2013 Optionally override the values for the Settings corresponding to nodes . This dict\nshould have the same structure as nodes , including matching names. override_source ( None | BaseModel | dict [ str , Any ] ) \u2013 Optionally override the source for the Settings corresponding to nodes . All the\nsettings will then have this same source. None Get the default implementation name for a given gate and locus. Takes into account the global default implementation and a possible locus specific implementation and also\nthe symmetry properties of the gate. NOTE: using this method requires the standard EXA settings tree structure. gate ( str ) \u2013 The name of the gate. locus ( str | Iterable [ str ] ) \u2013 Individual qubits, couplers, or combinations. The default implementation name. str Get the gate calibration sub-node for the locus given as a parameter if it exists in the settings tree. NOTE: using this method requires the standard EXA settings tree structure. gate ( str ) \u2013 The gate to retrieve the settings for. locus ( str | Iterable [ str ] ) \u2013 Individual qubits, couplers, or combinations. implementation ( str | None ) \u2013 Using a custom rather than the default gate implementation. The settings of the specified locus and gate. SettingNode Get all the gate locus node paths for a given gate . NOTE: using this method requires the standard EXA settings tree structure. gate ( str ) \u2013 Gate name. implementations ( list [ str ] | None ) \u2013 optionally limit the paths by these gate implementations. The locus node (string) paths corresponding to this gate. list [ str ] Get the gate characterization sub-node for the locus given as a parameter if it exists in the settings tree. NOTE: using this method requires the standard EXA settings tree structure. gate ( str ) \u2013 The gate to retrieve the settings for. locus ( str | Iterable [ str ] ) \u2013 Individual qubits, couplers, or combinations. implementation ( str | None ) \u2013 Using a custom rather than the default gate implementation. The settings of the specified locus and gate. SettingNode Set source recursively to all Settings in self . source ( None | BaseModel | dict [ str , Any ] ) \u2013 The source to set. ignore_nones ( bool ) \u2013 If True , the source will not be set for Settings with None value. None Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous setting_node next value \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.helpers.json_helper.decode_json",
    "url": "/iqm-exa-common/api/exa.common.helpers.json_helper.decode_json.html",
    "description": "Custom json decoder for object, in case it is represented as\ncomplex number, ndarray or tuple.\nOtherwise decoder won\u2019t be applied Here is an example of encoded/decoded json with complex number and nda...",
    "content": "Custom json decoder for object, in case it is represented as\ncomplex number, ndarray or tuple.\nOtherwise decoder won\u2019t be applied Here is an example of encoded/decoded json with complex number and ndarray: obj ( Any ) \u2013 Any previous json_helper next exa.common.helpers.json_helper.get_json_encoder \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.logger.logger.init_loggers",
    "url": "/iqm-exa-common/api/exa.common.logger.logger.init_loggers.html",
    "description": "Set the log level of given logger names. Logs with INFO or DEBUG logging levels are written into stdout, and logs with other levels are written into stderr. By default, the root logger uses WARNING le...",
    "content": "Set the log level of given logger names. Logs with INFO or DEBUG logging levels are written into stdout, and logs with other levels are written into stderr. By default, the root logger uses WARNING level. See Python\u2019s logging module for possible logging levels. loggers ( dict [ str , str | None ] | None ) \u2013 A mapping from logger name to (case insensitive) logging level. If logging level is None or empty\nstring, default_level will be used for that logger. It is possible to fine tune logging for individual\nmodules, since logger propagation is turned off. Overriding works both ways: a parent logger can have higher\nlogging level than its descendants, and vice versa.\nFor example, {\"sqlalchemy\": None, \"sqlalchemy.engine\": \"debug\"} will put\n\u201csqlalchemy\u201d and its descendants (i.e. \u201csqlalchemy.dialects\u201d, \u201csqlalchemy.dialects.sqlite\u201d, etc.) into default_level , except for \u201csqlalchemy.engine\u201d for which DEBUG level is defined.\nFor the root logger, use empty string key, for example: {\"\": \"INFO\"} .\nIf empty dict or None is given, only the root logger will be initialized to its default WARNING level. default_level ( str ) \u2013 The default level (case insensitive) to be used for logger names given with loggers for which a level is not specified. verbose ( bool ) \u2013 If False, :const: BRIEF format will be used for log messages, otherwise :const: VERBOSE . extra_info_getter ( Callable [ [ ] , str ] | None ) \u2013 Optional callable to convey extra information to log messages. It will get called before\neach log message emission and the output will get appended to the log message. None previous logger next ExtraFormatter \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "qcm_data_client",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.qcm_data_client.html",
    "description": "QCM (Quantum Computer Management) Data API client implementation. Full path: exa.common.qcm_data.qcm_data_client Classes QCMDataClient Python client for QCM (Quantum Computer Management) Data API. Inh...",
    "content": "QCM (Quantum Computer Management) Data API client implementation. Full path: exa.common.qcm_data.qcm_data_client Classes QCMDataClient Python client for QCM (Quantum Computer Management) Data API. Inheritance previous ImmutableBaseModel next QCMDataClient \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.sweep.database_serialization.encode_return_parameters",
    "url": "/iqm-exa-common/api/exa.common.sweep.database_serialization.encode_return_parameters.html",
    "description": "Encode sweeps to a JSON string. return_parameters ( dict [ Parameter , list [ tuple [ Sweep , ... ] ] | None ] ) \u2013 Return parameters as specified by sweep() . kwargs \u2013 keyword arguments passed to json...",
    "content": "Encode sweeps to a JSON string. return_parameters ( dict [ Parameter , list [ tuple [ Sweep , ... ] ] | None ] ) \u2013 Return parameters as specified by sweep() . kwargs \u2013 keyword arguments passed to json.dumps json as a string str previous exa.common.sweep.database_serialization.encode_nd_sweeps next util \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.errors.station_control_errors.ForbiddenError",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.ForbiddenError.html",
    "description": "Error raised when the operation is forbidden for the user. message ( str ) \u2013 previous exa.common.errors.station_control_errors.ConflictError next exa.common.errors.station_control_errors.GatewayTimeou...",
    "content": "Error raised when the operation is forbidden for the user. message ( str ) \u2013 previous exa.common.errors.station_control_errors.ConflictError next exa.common.errors.station_control_errors.GatewayTimeoutError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "software_version_helper",
    "url": "/iqm-exa-common/api/exa.common.helpers.software_version_helper.html",
    "description": "Full path: exa.common.helpers.software_version_helper Functions get_all_software_versions ([reload_module]) Get all available software version information. get_vcs_description (root_directory) Get Ver...",
    "content": "Full path: exa.common.helpers.software_version_helper Functions get_all_software_versions ([reload_module]) Get all available software version information. get_vcs_description (root_directory) Get Version Control System (VCS) description for the caller's current working directory. previous exa.common.helpers.numpy_helper.coerce_numpy_type_to_native next exa.common.helpers.software_version_helper.get_all_software_versions \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "ExponentialSweep",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.exponential_sweep.ExponentialSweep.html",
    "description": "Bases: Sweep Generates parameter values spaced evenly on a geometric progression based on options . If options is instance of StartStopBaseOptions ,\nthe start and stop of the interval are calculated f...",
    "content": "Bases: Sweep Generates parameter values spaced evenly on a geometric progression based on options . If options is instance of StartStopBaseOptions ,\nthe start and stop of the interval are calculated from powers of start and stop. If options is instance of CenterSpanBaseOptions ,\nthe start and stop of the interval are calculated from powers of start and stop,\nwhich are derived from center and span. ValueError \u2013 Error is raised if options is inconsistent. parameter ( Parameter ) \u2013 options ( StartStopBaseOptions | CenterSpanBaseOptions | None ) \u2013 data ( list [ Any ] | ndarray ) \u2013 Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.control.sweep.exponential_sweep Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. parameter The Sweep represents changing the values of this Parameter. data List of values for parameter Methods Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous exponential_sweep next fixed_sweep \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.control.sweep.option.constants.OPTIONS_TYPE",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.option.constants.OPTIONS_TYPE.html",
    "description": "Dictionary with all possible types of options previous exa.common.control.sweep.option.constants.DEFAULT_BASE next fixed_options \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on...",
    "content": "Dictionary with all possible types of options previous exa.common.control.sweep.option.constants.DEFAULT_BASE next fixed_options \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.helpers.yaml_helper.load_yaml",
    "url": "/iqm-exa-common/api/exa.common.helpers.yaml_helper.load_yaml.html",
    "description": "Load a YAML file from the given path and raise error if the file can\u2019t be loaded. path ( Path | str ) \u2013 dict [ str , Any ] previous exa.common.helpers.yaml_helper.dump_yaml next logger \u00a9 Copyright 201...",
    "content": "Load a YAML file from the given path and raise error if the file can\u2019t be loaded. path ( Path | str ) \u2013 dict [ str , Any ] previous exa.common.helpers.yaml_helper.dump_yaml next logger \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "Components",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.Components.html",
    "description": "Bases: ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidate...",
    "content": "Bases: ImmutableBaseModel Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: exa.common.qcm_data.chad_model Attributes all  model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. qubits  couplers  probe_lines  launchers  computational_resonators  Methods sort_components  qubit ( tuple [ Qubit , ... ] ) \u2013 tunable_coupler ( tuple [ Coupler , ... ] ) \u2013 probe_line ( tuple [ ProbeLine , ... ] ) \u2013 launcher ( tuple [ Launcher , ... ] ) \u2013 computational_resonator ( tuple [ ComputationalResonator , ... ] ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous Component next ComputationalResonator \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "errors",
    "url": "/iqm-exa-common/api/exa.common.errors.html",
    "description": "Common error messages. Full path: exa.common.errors Subpackages and modules exa_error  station_control_errors Errors used in the station control client-server communication. previous exa.common.data.v...",
    "content": "Common error messages. Full path: exa.common.errors Subpackages and modules exa_error  station_control_errors Errors used in the station control client-server communication. previous exa.common.data.value.validate_value next exa_error \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "chad_model",
    "url": "/iqm-exa-common/api/exa.common.qcm_data.chad_model.html",
    "description": "Pydantic models for CHAD. Full path: exa.common.qcm_data.chad_model Classes CHAD Create a new model by parsing and validating input data from keyword arguments. Component Create a new model by parsing...",
    "content": "Pydantic models for CHAD. Full path: exa.common.qcm_data.chad_model Classes CHAD Create a new model by parsing and validating input data from keyword arguments. Component Create a new model by parsing and validating input data from keyword arguments. Components Create a new model by parsing and validating input data from keyword arguments. ComputationalResonator Create a new model by parsing and validating input data from keyword arguments. Coupler Create a new model by parsing and validating input data from keyword arguments. Launcher Create a new model by parsing and validating input data from keyword arguments. ProbeLine Create a new model by parsing and validating input data from keyword arguments. Qubit Create a new model by parsing and validating input data from keyword arguments. Inheritance previous qcm_data next CHAD \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "FixedOptions",
    "url": "/iqm-exa-common/api/exa.common.control.sweep.option.fixed_options.FixedOptions.html",
    "description": "Bases: SweepOptions Range fixed options. Module: exa.common.control.sweep.option.fixed_options Attributes data List of values for parameter fixed List of values. Methods fixed ( list [ Any ] | ndarray...",
    "content": "Bases: SweepOptions Range fixed options. Module: exa.common.control.sweep.option.fixed_options Attributes data List of values for parameter fixed List of values. Methods fixed ( list [ Any ] | ndarray ) \u2013 List of values. List of values for parameter previous fixed_options next option_converter \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "exa.common.sweep.database_serialization.encode_nd_sweeps",
    "url": "/iqm-exa-common/api/exa.common.sweep.database_serialization.encode_nd_sweeps.html",
    "description": "Encode sweeps to a JSON string. sweeps ( list [ tuple [ Sweep , ... ] ] ) \u2013 sweeps to be serialized. kwargs \u2013 keyword arguments passed to json.dumps json as a string str previous exa.common.sweep.data...",
    "content": "Encode sweeps to a JSON string. sweeps ( list [ tuple [ Sweep , ... ] ] ) \u2013 sweeps to be serialized. kwargs \u2013 keyword arguments passed to json.dumps json as a string str previous exa.common.sweep.database_serialization.decode_settings next exa.common.sweep.database_serialization.encode_return_parameters \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "station_control_errors",
    "url": "/iqm-exa-common/api/exa.common.errors.station_control_errors.html",
    "description": "Errors used in the station control client-server communication. Full path: exa.common.errors.station_control_errors Functions map_from_error_to_status_code (error) Map a StationControlError to an HTTP...",
    "content": "Errors used in the station control client-server communication. Full path: exa.common.errors.station_control_errors Functions map_from_error_to_status_code (error) Map a StationControlError to an HTTPStatus code. map_from_status_code_to_error (status_code) Map an HTTPStatus code to a StationControlError. Exceptions BadGatewayError (message,\u00a0*args) Error raised when there are invalid responses from another server/proxy. BadRequestError (message,\u00a0*args) Error raised when the request syntax is invalid or the method is unsupported in general. ConflictError (message,\u00a0*args) This error happens when there is a conflict with the current state of the resource. ForbiddenError (message,\u00a0*args) Error raised when the operation is forbidden for the user. GatewayTimeoutError (message,\u00a0*args) Error raised when the gateway server did not receive a timely response. InternalServerError (message,\u00a0*args) Error raised when an unexpected error happened on the server side. NotFoundError (message,\u00a0*args) Error raised when nothing was found with the given parameters. ServiceUnavailableError (message,\u00a0*args) Error raised when the service is unavailable. StationControlError (message,\u00a0*args) Base class for station control errors. UnauthorizedError (message,\u00a0*args) Error raised when the user is not authorized. ValidationError (message,\u00a0*args) Error raised when something is unprocessable in general, for example if the input value is not acceptable. previous exa.common.errors.exa_error.UnknownSettingError next exa.common.errors.station_control_errors.map_from_error_to_status_code \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-exa-common",
    "title": "value",
    "url": "/iqm-exa-common/api/exa.common.data.value.html",
    "description": "Full path: exa.common.data.value Functions serialize_value (value) Serialize value type to JSON serializable type, to support complex and ndarray types. validate_value (value) Validate (i.e. deseriali...",
    "content": "Full path: exa.common.data.value Functions serialize_value (value) Serialize value type to JSON serializable type, to support complex and ndarray types. validate_value (value) Validate (i.e. deserialize) JSON serializable value to Python type, to support complex and ndarray types. previous SettingNode next exa.common.data.value.serialize_value \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 26.27.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "Quick Start",
    "url": "/iqm-pulla/Quick Start.html",
    "description": "IQM PulLA is a client-side software which allows the user to control the generation and execution of pulse-level instruction schedules on a quantum computer. Within the existing IQM QCCSW stack, PulLA...",
    "content": "IQM PulLA is a client-side software which allows the user to control the generation and execution of pulse-level instruction schedules on a quantum computer. Within the existing IQM QCCSW stack, PulLA is somewhere between circuit-level execution and EXA-experiment. Namely, with pulse-level access the user can: compile a quantum circuit (e.g. a Qiskit circuit) into an instruction schedule on the client side access and modify the calibration data to be used for the circuit-to-schedule compilation view and modify the default implementations of quantum gates define custom implementations of quantum gates define new composite gates out of native gates and set their calibration data control the multi-step compilation procedure, and edit the intermediate data use custom pulse shapes This notebook contains a small meaningful example for a \u201cquick start\u201d. Refer to other chapters for more details on various aspects of Pulla. Pulla provides a Qiskit backend, with limited functionality. Its main purpose is to replace the normal execution of run() , which submits circuits to the remote server, with a local compilation and submission of pulse schedules to the remote server. IQMPullaBackend does not provide any new functionality, but rather packs existing features and actions behind an illusion of using a normal Qiskit backend. You can perform all of the actions of IQMPullaBackend manually, but you may choose to use IQMPullaBackend in these cases: You don\u2019t need to control compilation, and want to use Pulla in the same way as a remote circuit-executing IQM Server uses it. You want to run some existing apps written for Qiskit, e.g. benchmarking tools; they often build on top ot the circuit abstraction, and don\u2019t necessarily give you easy access to the circuits, which makes it harder to use Pulla normally. You don\u2019t have access to a remote circuit-executing IQM Server, only to a pulse-executing IQM Server. You don\u2019t have any remote servers at all; all of the quantum control software is running locally (relevant for niche research cases) To initialize an IQMPullaBackend instance, provide 3 arguments: Quantum architecture in QuantumArchitectureSpecification format of IQM Client Instance of Pulla Instance of Compiler When IQMPullaBackend.run() is called, the following steps are performed: Given Qiskit circuits are converted to Pulla format using qiskit_circuits_to_pulla() . Circuits are compiled with the provided compiler using Compiler.compile() . Settings are generated with the provided compiler using Compiler.build_settings() . Circuits are executed on the station associated with the provided Pulla instance. Results are retrieved and converted into a DummyJob , partially compatible with Qiskit Job . Working example below: If the remote station requires authentication: Install IQM Client CLI with pip install iqm-client[cli] Run iqmclient init . The wizard will start and ask questions. Accepting defaults is ok. Wizard will ask for Authentication server URL . Usually, it\u2019s of the form https://STATION_ROOT/auth . E.g. if the Station Control URL is \"https://abc.com/station/\" , then the auth server URL is \"https://abc.com/auth/\" Run iqmclient auth login . You should see info like so: Set the environment variable IQM_TOKENS_FILE accordingly in your Jupyter notebook and pass get_token_callback to the Pulla initialization call like so: Setting IQM_TOKENS_FILE env. variable enables authentication for CoCoS as well, so your Qiskit runs against the same station will work, too. Pulla can also be used with IQM Resonance cloud service. You need to set the station URL to point to Resonance. In addition to that, you must provide a get_token_callback parameter function that returns your Resonance API token. IQM Pulse comes with a schedule visualizer. It takes a Playlist (i.e. a compressed list of instruction schedules) and a list of schedule/segment indices to inspect.\nThe playlist variable below is the one which we derived from the original Qiskit circuit using the Pulla compiler, and it only has one schedule. previous User guides next Configuration and Usage By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "Import required packages",
    "url": "/iqm-pulla/Example - Randomized Benchmarking.html",
    "description": "Contact: pedro.romero@meetiqm.com & manish.thapa@meetiqm.com NB: Familiarity with quantum channels, gates and Clifford gates is assumed. The idea behind Clifford Randomized Benchmarking (CRB) is that ...",
    "content": "Contact: pedro.romero@meetiqm.com & manish.thapa@meetiqm.com NB: Familiarity with quantum channels, gates and Clifford gates is assumed. The idea behind Clifford Randomized Benchmarking (CRB) is that under certain (simplified) types of noise, the average survival probability of the initial state of a quantum system under uniformly random sequences of multi-qubit Clifford gates with sequence inversion will decay exponentially in the length of the sequences. From such decay, one can in turn infer the average fidelity of the corresponding Clifford group. CRB sequences are of the form $$\\mathcal{S} m:=\\mathcal{C} {m+1}\\circ\\mathcal{C}_m\\circ\\cdots\\circ\\mathcal{C}_1,$$ for any $m\\geq1$, where $\\mathcal{C} i(\\cdot):=C_i(\\cdot)C_i^\\dagger$ is a unitary channel with $C_i$ being a Clifford gate, and where by definition $$\\mathcal{C} {m+1}=(\\mathcal{C}_m\\circ\\cdots\\circ\\mathcal{C} 1)^{-1}.$$ It is important to notice that $C {m+1}$ is itself a Clifford gate, i.e., one would not implement the sequence $\\mathcal{C}_m\\circ\\cdots\\circ\\mathcal{C} 1$ in practice, but rather compile the corresponding unitary operator $C_mC {m-1}\\cdots{C}_1$ into a single Clifford gate. The main assumption is that the real noisy gates can be approximately modeled independently by a quantum channel $\\mathcal{E}$ (completely positive, trace non-increasing map) as $\\tilde{\\mathcal{C}}_i\\approx\\mathcal{E}\\circ\\mathcal{C}_i$, or (ultimately equivalently) as $\\tilde{\\mathcal{C}}_i\\approx\\mathcal{C}_i\\circ\\mathcal{E}$. This implies that the noise is modeled as Markovian , time-stationary and gate-independent \u2014 while here we will take these for granted, a lot about RB in more general regimes is known, but it is in general more complicated, and often this simplistic scenario goes a long way as a useful first approximation. NB: CRB is not generally intended to work for $n>2$, both because of the scaling of the size of the $n$-qubit Clifford group in $n$, and because such gates have to eventually be transpiled to a native basis of 1Q and 2Q gates! While a high level of optimization in transpile is usually desirable, one must be careful for the optimization not to mess with the Clifford gates, i.e., we want the transformations between barriers in the circuit to implement a Clifford regardless of how it is decomposed. The specific decomposition still matters, however, because the (average) number of 2Q and 1Q gates (i.e., cz and r , respectively) will dictate how noisily we can implement the Cliffords on average, i.e., the average gate fidelity we will ultimately obtain. We will not do this check here, but it is now known that a good decomposition of Clifford gates in our basis will have on average 8.25 cz gates and 1.5 r gates (e.g., see arXiv:1402.4848 ). We can count the number of native 1Q and 2Q gates by using the circuit attribute count_ops() One important reason why CRB works \u2013and why specifically it uses Clifford gates\u2013, is that the uniformly distributed multi-qubit Clifford group forms a unitary 2-design. This essentially means that any quantity that takes two copies of the pair $C, C^\\dagger$ and then averaged over all possible $C$s, will be exactly the same as if $C$ had been any uniformly distributed (so-called Haar) random unitary. This matters because there are plenty of results allowing to easily compute such quantities (i.e., second moments) over the whole uniformly distributed unitary group \u2014 in fact, such second moment simply takes the form of a depolarizing channel (RB precisely extracts the average gate fidelity through the corresponding polarization parameter). The CRB sequences are quantities of this type because of the final inverse at the end (i.e. all sequences will have 2 copies of pairs $C_i,C_i^\\dagger$ for all $i=1,2,\\ldots,m$). This is the reason why the theory behind RB, under the noise assumptions above, can ensure that the decay in average fidelity, i.e., quantities like $$f_0=\\langle0|\\mathcal{S}_m(|0\\rangle!\\langle0|)|0\\rangle$$ take the form of a function $$f_0=Ap^m+B$$ for $0\\leq{A,B,p}\\leq1$. Furthermore, it ensures that $p$ will encode the average gate fidelity of the noisy Clifford gates, whilst $A,B$ will encode (and isolate) errors due to state preparation and measurement. This is what is meant by RB being SPAM-robust. In the modeling with assummptions of noisy gates above, this means $p\\sim\\int{d}\\psi\\langle\\psi|\\mathcal{E}(|\\psi\\rangle!\\langle\\psi|)|\\psi\\rangle$ for all possible uniformly distributed pure states $|\\psi\\rangle$, and $A\\sim\\langle0|\\mathcal{E} \\text{spam}(|0\\rangle!\\langle0|)|0\\rangle$, $B\\sim\\langle0|\\mathcal{E} \\text{spam}(\\mathbb{I}/2^n)|0\\rangle$ for a composition of the state preparation and measurement noise. We may now fix a number of circuit samples and sequence lengths. Despite the Clifford group having a (super) exponential amount of terms (e.g., 24 for 1Q, then 11,520 for 2Q), approximating the average over the whole group with finite samples quickly converges to the Haar average. On the other hand, the sequence lengths can be chosen as exponentially spaced and aiming at long sequences, if possible, serves to better determine the offset constant (often named the nuisance parameter, for obvious reasons) in the decay. Depending on how many circuits we want to execute, we could either generate all circuit samples for all circuit lengths and send all for execution once, or we may, for example, generate a given amount of circuits, send them to execution while meanwhile continuing to generate circuits and sending them. In either case, one may retrieve the results later. Here we will generate all circuits for all sequence lengths, and send them to execute as a single batch on the backend. It is generally a good idea to store (at least at this stage) both the abstract and the transpiled circuits, so that we can inspect them later on. We can inspect the circuits just as a sanity check Task : Count the average number of 1Q and 2Q gates in the circuits for each sequence length. Task : Since the Clifford group is a 2-design, its so-called frame potential (see e.g., arXiv:1610.04903 ) has to satisfy $\\displaystyle{\\sum_{k,,k^\\prime=1}^K}\\left|\\mathrm{tr}\\left(C_{k^\\prime}^{\\dagger}C_k\\right)\\right|^4/K^2 = 2$. Verify this condition for the 1Q Clifford group. warning for the 2Q Clifford group: there are in total $n=11,520^2 = 132,710,400$ values in the sum! It suffices to compute the values in a triangular part of the matrix $U_{k^\\prime}^{\\dagger}U_k$  \u2014 so you can definitely verify this property, however there will still be $n(n-1)/2$ such terms for your computer to sum up! We can now send the transpiled circuits to be run on the hardware. NB: It is generally preferable to use backend.run instead of execute command, since the latter performs a transpilation pass \u201cunder the hood\u201d. We can now inspect the results for a given sequence length (we will use the one defined above). The counts at the ground state relate to the survival probability (or state fidelity) of such state under our random Clifford circuits. Task : Compare the histograms between the outcomes for the narrowest and the deepest circuits NB: You can wrap plot_histogram() with display(*) to show both results in one cell By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "Executing QIR programs",
    "url": "/iqm-pulla/Example - Executing QIR programs.html",
    "description": "If you have a QIR string or bitcode, you can start by creating Pulla-compatible circuits representation. You can also generate a QIR string or bitcode from a qiskit circuit using IQM\u2019s fork of qiskit_...",
    "content": "If you have a QIR string or bitcode, you can start by creating Pulla-compatible circuits representation. You can also generate a QIR string or bitcode from a qiskit circuit using IQM\u2019s fork of qiskit_qir , available as the package iqm-qiskit-qir . previous Example: Dynamical decoupling next API Reference By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "Contributors",
    "url": "/iqm-pulla/authors.html",
    "description": "Rakhim Davletkaliyev < rakhim . davletkaliyev @ meetiqm . com > Ville Bergholm < ville @ meetiqm . com > Joni Ikonen < joni @ meetiqm . com > Arianne Meijer < qaremei @ meetiqm . com > Tuukka Hiltunen...",
    "content": "Rakhim Davletkaliyev < rakhim . davletkaliyev @ meetiqm . com > Ville Bergholm < ville @ meetiqm . com > Joni Ikonen < joni @ meetiqm . com > Arianne Meijer < qaremei @ meetiqm . com > Tuukka Hiltunen < tuukka @ meetiqm . com > Jussi Ritvas < jussi . ritvas @ meetiqm . com > Miikka Koistinen < miikka @ meetiqm . com > previous Changelog next License By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "Example: Dynamical decoupling",
    "url": "/iqm-pulla/Example - Simple Dynamical Decoupling.html",
    "description": "There is a standard compilation stage for automatically applying dynamical decoupling (DD) sequences to an instruction schedule,\ncontrolled by the dd_mode compiler option. By default the DD stage is d...",
    "content": "There is a standard compilation stage for automatically applying dynamical decoupling (DD) sequences to an instruction schedule,\ncontrolled by the dd_mode compiler option. By default the DD stage is disabled. The iqm.cpc.compiler.dd module contains various utility functions the DD stage uses, e.g. for locating specific instructions in a schedule, constructing DD sequences, and replacing select instructions with them. For example, we can find locations of Wait instructions on qubit drive channels with a certain minimum duration, and replace them with an arbitrary sequence of Wait and IQPulse instructions that dynamically decouples the qubit, given that the total duration of the sequence is the same as the duration of the original Wait . Let\u2019s create and transpile a quantum circuit that prepares a superposition on one qubit, and then executes a long sequence of gates on other qubits while the first qubit is idling and experiencing decoherence. Finally we reverse the superposition and measure the qubits. Now let us create a pair of Pulla compilers, one with DD and one without. Compiling the circuit using the non-DD compiler produces a schedule with a long wait on QB1__drive.awg. We then execute this schedule and compute the probability of finding QB1 in the |0> state. Ideally this should be one, but due to the decoherence experienced by the superposition state it will be less. Compiling the circuit using the DD compiler instead produces a schedule where the long wait on QB1__drive.awg is replaced by a DD sequence. We execute the DD schedule and again compute the probability of finding QB1 in the |0> state, and will likely see that the probability has gone up, due to the DD sequence partially decoupling the idling QB1 from various decoherence sources and better preserving the superposition state. We can see that the long wait on QB1__drive.awg was indeed replaced by a DD sequence. previous Example: Measuring T1 next Executing QIR programs By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "Custom Gates and Gate Implementations",
    "url": "/iqm-pulla/Custom Gates and Implementations.html",
    "description": "This notebook demonstrates how to work with user-defined quantum operations and gate implementations that go beyond the standard gate set. Each quantum operation is associated with one or more GateImp...",
    "content": "This notebook demonstrates how to work with user-defined quantum operations and gate implementations that go beyond the standard gate set. Each quantum operation is associated with one or more GateImplementation s which translate the high-level concepts to lower-level instructions accepted by the IQM server. This example shows how the user can Selecting a non-default implementation for a gate Add a custom implementation for an existing gate Add a custom gate and a custom implementation for it by using existing gates as building blocks (composite gates) Defining new pulse waveforms for implementations Please refer to the User Guide.ipynb for basic usage, termninology, and environment setup. Circuits are usually defined without specifying implementations for any of the gates.\nThe implementations available in a given calibration set are listed in the corresponding dynamic quantum architecture, through Cocos. Let\u2019s see a list of available implementations, with their parameters: You can specify a default implementation for each native operation type in the circuit, and then override it for specific loci.\nLet\u2019s change all cz gates to use the slepian implementation, and make an execption for the qubit pair (QB1, QB2) . Note that the default implementations are merely suggestions to the compiler. If the compiler does not have calibration data for a default implementation, it will ignore it and use what it can. If you executed the cell below, you would get an error if the requested implementation 'drag_gaussian' does not have calibration data. You can also force the compiler to use a specific implementation for each circuit instruction separately in the IQM Pulse native format, which describes a circuit as a list of CircuitOperation instances. IQM Pulse allows the user to define composite gates: gates consisting of other registered gates.\nComposite gates are particularly useful because they allow reusing the calibrated of data of the other gates.\nFurthermore, it is possible to use different calibration data for the registered gates inside a composite gate than outside it. Let\u2019s define a prx implementation that acts like a normal prx , except it implements x with 2 pulses with a 100 ns wait between them.\nThe __call__ method produces a TimeBox using IQM Pulse\u2019s ScheduleBuilder.\nIt\u2019s worth mentioning that the composite gate is not restricted to using only registered gates; it could equally well return a TimeBox with lower level instructions. Now we register a new gate custom_x , which StretchedX implements. We want to make it compatible with the circuit-level prx , so we declare that it has the same parameters.\nThen we change the fist prx in the IQM Pulse circuit to use our new implementation. Inspecting the schedule, we can see that the X gate in the circuit is indeed split into two pulses with a wait in between: Finally, let\u2019s change the pulse waveforms of an existing gate. The tricky part of this is that we need to provide the calibration data by hand.\nIQM Pulse provides several \u201cgate with custom waveforms\u201d base classes so that users need only write the waveforms. Let\u2019s define a new implementation of PRX using a raised cosine pulse: The class attributes of the waveforms define the calibration data they require. The PRX_CustomWaveforms class adds some more. We can add the new prx implementation to the compiler, and check what calibration data it needs: Let us then make one of the prx gates in the circuit use our new implementation: Compiling this circuit right now would fail with an error: (The locus (\u2018QB1\u2019,) may differ in your output due to the stochastic nature of routing.) The point is that the compiler does not have necessary calibration data for this new implementation. One way to fix this is to amend the current calibration. The numbers here are arbitrary, in reality you would need to calibrate the gate parameters somehow. Data with gates.prx.raised_cosine.* is now visible in compiler.get_calibration() . Note that we added the same calibration data to all qubits. In practice, this rarely makes sense, because each qubit\nis usually calibrated differently. Now the compilation succeeds and we see that raised_cosine was used once. Using the schedule visualization you could also verify that the pulse shape is indeed different on the first prx instance. previous Compilation Stages next Examples By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "Common errors",
    "url": "/iqm-pulla/common_errors.html",
    "description": "This document describes some common errors which you may encounter when using Pulla, and ways to fix them. If you have modified any timing aspect of the schedule, you may encounter an error like this:...",
    "content": "This document describes some common errors which you may encounter when using Pulla, and ways to fix them. If you have modified any timing aspect of the schedule, you may encounter an error like this: The granularity is an instrument limitation. Specifically, the part (e.g. HDAWG) which plays the drive pulses.\nSome instrument may use e.g. a sample rate of 2.4 GHz, and each instruction duration must be an integer multiple of 16\nsamples. Instructions therefore must be a multiple of 6.666ns (16 / 2.4 GHz).\nDurations that are within 0.005 samples of an allowed number of samples are rounded to that\n(the software assumes it is what the user meant), otherwise an error is raised. Different stations have different instruments.\nIQM instruments use a fixed sample rate of 2 GHz, and have a granularity of 8 samples. You can view the granularity information in channel properties, for example Pulla.get_channel_properties()[0]['QB1__drive.awg'] : If you were to turn off the error and use an instruction with a duration that does not fit the granularity, it would\njust silently be extended to the next longest allowed granularity, and would not do what you expect. previous iqm.pulla.utils_qiskit.IQMPullaBackend next Changelog By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "API Reference",
    "url": "/iqm-pulla/API.html",
    "description": "iqm.cpc IQM Circuit to Pulse Compiler. iqm.pulla Client-side library for Pulse-level access to IQM quantum computers. previous Executing QIR programs next iqm.cpc By IQM Pulla developers \u00a9 Copyright 2...",
    "content": "iqm.cpc IQM Circuit to Pulse Compiler. iqm.pulla Client-side library for Pulse-level access to IQM quantum computers. previous Executing QIR programs next iqm.cpc By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "Configuration and Usage",
    "url": "/iqm-pulla/Configuration and Usage.html",
    "description": "This notebook describes the basic concepts and configuration of Pulla. Now let\u2019s create a Pulla object. A Pulla object is conceptually an IQM quantum computer client for fetching calibration data and ...",
    "content": "This notebook describes the basic concepts and configuration of Pulla. Now let\u2019s create a Pulla object. A Pulla object is conceptually an IQM quantum computer client for fetching calibration data and constructing a circuit-to-pulse compiler. . It consists of: methods for fetching calibration sets from the server methods for fetching metadata about the QC from the server method for executing pulse-level instruction schedules (e.g. ones created by the compiler) A Compiler object defines a particular circuit-to-pulse compilation logic . It consists of: single calibration set schedule builder based on the calibration set circuit compilation options information about the QC (chip topology, channel properties, etc.) compilation stages set of available circuit-level quantum operations (\u201cnative operations\u201d) (including user-defined operations) set of implementations for each native operation (including user-defined implementations) methods for manipulating the calibration, operations, and implementations Pulla can construct a standard compiler equivalent to the one used by the server side (CoCoS). You can also construct a Compiler manually. To create an instance of Pulla, you need to provide the URL of Station Control. Upon successful initialization, some configuration data is printed (the verbosity of such messages will be controlled by a debug level value). You can access various things like channel properties of the connected station, chip topology, or the current calibration. The initial calibration is the latest calibration of the connected station. Call get_standard_compiler() method to get an instance of Compiler . It will be pre-populated with the latest default calibration set and standard compilation stages. This standard compiler is the same one that CoCoS uses on the server side when processing circuits. get_standard_compiler() fetches the latest calibration set from the server. This network request takes a few moments. You may want to create many Compiler instances without such delay. It may also be possible that, due to human error, the latest calibration set stored on the server is invalid (or incompatible with your version of Pulla or IQM Pulse). In that case get_standard_compiler() will fail. To avoid this, you can pass the calibration set manually, and Pulla will construct the compiler with it instead of getting one from the server. If you want to reuse the calibration of an existing compiler, call Compiler.get_calibration() , e.g.: You can also get a specific calibration set from the server if you know its UUID by calling Pulla.fetch_calibration_set_by_id() , e.g.: The compiler initializes with the following default configuration options: circuit_boundary_mode='all' measurement_mode='all' heralding_mode='none' dd_mode='none' You can change them by changing the corresponding attributes of compiler.options . For the constant implementation of the measure operation, the readout type is controlled by the acquisition_type parameter. By default, it\u2019s set to \"threshold\" . Let\u2019s change it to \"complex\" . The full key in the calibration set dictionary is gates.measure.constant.QUBIT.acquisition_type , where QUBIT is the physical qubit name. Note that we call get_calibration() to get a copy of the compiler\u2019s current calibration set, make changes to the copy, then replace the compiler\u2019s set with the copy. The compiler always contains a single calibration set only. previous Quick Start next Compilation Stages By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "IQM Pulla",
    "url": "/iqm-pulla/index.html",
    "description": "8.2.0 2025-07-07 Client-side library for Pulse-level access to IQM quantum computers. Index Module Index Search Page next IQM Pulla By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Relea...",
    "content": "8.2.0 2025-07-07 Client-side library for Pulse-level access to IQM quantum computers. Index Module Index Search Page next IQM Pulla By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "References",
    "url": "/iqm-pulla/references.html",
    "description": "Nic Ezzell, Bibek Pokharel, Lina Tewala, Gregory Quiroz, and Daniel\u00a0A. Lidar. Dynamical decoupling for superconducting qubits: a performance survey. Phys. Rev. Appl. , 20:064027, Dec 2023. arXiv:2207....",
    "content": "Nic Ezzell, Bibek Pokharel, Lina Tewala, Gregory Quiroz, and Daniel\u00a0A. Lidar. Dynamical decoupling for superconducting qubits: a performance survey. Phys. Rev. Appl. , 20:064027, Dec 2023. arXiv:2207.03670 , doi:10.1103/PhysRevApplied.20.064027 . previous License By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "IQM Pulla",
    "url": "/iqm-pulla/readme.html",
    "description": "Pulla (pulse-level access) is a client-side software which allows the user to control the generation and\nexecution of pulse schedules on a quantum computer. Within the existing IQM QCCSW stack, PulLA ...",
    "content": "Pulla (pulse-level access) is a client-side software which allows the user to control the generation and\nexecution of pulse schedules on a quantum computer. Within the existing IQM QCCSW stack, PulLA is somewhere between\ncircuit-level execution and EXA-experiment. An interactive user guide is available as a Jupyter notebook in the docs folder. Create a virtual environment and install dependencies: The [qiskit] option is to enable Qiskit-related features and utilities, like converting Qiskit circuits to Pulla circuits, constructing a compatible compiler instance, or constructing a PullaBackend for running Qiskit jobs. The [qir] option is to enable QIR support, e.g. the qir_to_pulla function. The [notebook] option is to be able to run the example notebooks, using\nand run it in Jupyter Notebook: Install development and testing dependencies: e2e testing is execution of all user guides (Jupyter notebooks). User guides cover the majority of user-level features,\nso we achieve two things: end-to-end-test Pulla as a client library, and make sure the user guides are correct.\n(Server-side use of Pulla is e2e-tested as part of CoCoS.) You have to provide CoCoS and Station Control URLs as environment variables: Notebooks are executed using jupyter execute command. It does not print any output if there are no errors. If you want\nto run a particular notebook and see the output cells printed in the terminal, you can use nbconvert with jq ( https://jqlang.github.io/jq/download/ ) like so: Run unit tests, build docs, build package: Copyright 2025 IQM Licensed under the Apache License, Version 2.0 (the \u201cLicense\u201d);\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \u201cAS IS\u201d BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License. previous IQM Pulla next Migration guide By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "Example: Measuring T1",
    "url": "/iqm-pulla/Example - Measuring T1.html",
    "description": "T1 is an experiment that measures the relaxation time of a qubit. Information stored in a qubit decays exponentially. The time constant of the decay is called the relaxation time $T_1$. The experiment...",
    "content": "T1 is an experiment that measures the relaxation time of a qubit. Information stored in a qubit decays exponentially. The time constant of the decay is called the relaxation time $T_1$. The experiment measures $T_1$ by preparing selected qubits in the  excited state by playing an X gate,\nwaiting some time, and measuring the qubit. The waiting time is swept to reveal the exponential decay of the excited state probability. High-level QuantumOperations like Quantum gates can be implemented using different GateImplementations.\nTo control low-level aspects of the execution, we can create custom operations, the implementation of which we can control. Here we invent a custom operation \"custom\" and write an implementation \"Wait\" , which only inserts a delay of certain duration.\nIn principle, the custom gate implementation could include any number of low-level instructions,\nbut for this task we only need a wait.\nhttps://iqm-finland.github.io/docs/iqm-pulse/using_builder.html for more details about lower level controls. In later cells, we mix the custom gate with other, more familiar gates. We must register the operation, so that the compiler knows what to do with it: We need to select the physical qubits to work on. These are available on the QPU: Out of these, we select a few: Now we create all the circuits. In each circuit, we do a PRX(pi), or X, then our custom operation that waits, then measure all qubits.\nWe create a circuit for each delay time we want on the time axis. Then compile the circuits. We tweak the settings so that the shots are averaged by the server, so that we don\u2019t need to.\nThe results therefore return as sampled probabilities. Extract the results We can also visualise the final playlist. We should see that each circuit is different and the waits at the end are increasing towards the end. previous Examples next Example: Dynamical decoupling By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "Migration guide",
    "url": "/iqm-pulla/migration_guide.html",
    "description": "This document describes the changes that need to be made to existing code to migrate between major versions of Pulla. The changes in 4.0 are not truly breaking, as your code should still run. However,...",
    "content": "This document describes the changes that need to be made to existing code to migrate between major versions of Pulla. The changes in 4.0 are not truly breaking, as your code should still run. However, there are some changes that\nmight affect the compilation results, and you might want to adjust your code accordingly: New compilation pass prepend_reset added to the (TimeBox-level) standard compiler stage. It adds a reset timebox\nto all circuits. It is the last pass of the TimeBox-level stage. If the calibration lacks reset_wait data, the prepend_reset will have no effect. Optional attribute :attr: .CircuitExecutionOptions.active_reset_cycles added to CircuitExecutionOptions ,\nthat is used to control the reset functionality. By default, it is set to None , which results in delay by wait. :meth`.Pulla.get_standard_compiler` now has an optional argument for overriding default circuit execution options. The function iqm.pulla.utils_qiskit.qiskit_to_cpc was replaced by iqm.pulla.utils_qiskit.qiskit_circuits_to_pulla() and iqm.pulla.utils_qiskit.qiskit_to_pulla() . qiskit_circuits_to_pulla() is a more direct replacement, with the difference that it also requires a\nmapping of qiskit qubit indices to physical qubit names which was not required before.\nThis can be e.g. obtained from an iqm.qiskit_iqm.iqm_provider.IQMBackend instance. qiskit_to_pulla() is a convenience method that in addition to\nconverting the Qiskit circuit(s) also returns a Compiler instance that can be used to compile them\ninto a playlist. It takes as additional parameters a Pulla instance (for building the compiler),\nand an IQMBackend instance (containing the calibration set ID and\nqubit mapping to use). The IQMBackend instance should usually be the same one that was used to transpile\nthe Qiskit circuits. Compiler code is consolidated under the iqm.cpc.compiler.compiler module.\nThere is no more iqm.cpc.compiler.compiler2 . Compiler , CompilationStage are now under iqm.cpc.compiler.compiler . Pulla no longer needs CoCoS URL: Compiler initialization now requires all arguments to be keyword arguments. Pulla no longer retrieves qubit mapping from CoCoS. If your circuit uses same qubits names as physical qubits\n(e.g. QB1 , QB2 , etc.), then you don\u2019t have to do anything. If your circuit uses other qubit names, then you have to\nprovide component_mapping to the Compiler like so: If you use Qiskit, the mapping can be generated with {str(idx): qb for idx, qb in backend._idx_to_qb.items()} . .Compiler.set_default_implementation_for_locus changed to Compiler.set_default_implementation_for_loci() : Compiler.amend_calibration_for_gate_implementation() now accepts a Locus (a tuple of strings)\ninstead of string qubit name, so you can apply the change to multiple loci in a single call: iqm.pulla.utils.qiskit_to_cpc() and iqm.pulla.station_control_result_to_qiskit() , previously marked for\ndeprecation in v. 1.0, are now removed. Use iqm.pulla.utils_qiskit.qiskit_to_cpc() and iqm.pulla.utils_qiskit.station_control_result_to_qiskit() , respectively. The main change in 1.0 is the splitting of Pulla and Compiler , and the move of some compiler-related methods to\nthe more appropriate Compiler class. The Pulla class now only contains methods to retrieve calibration data,\nconstruct a standard compiler instance, and submit pulse schedules to the server. Setting default implementation is now done in the compiler directly, and there is no need to manually refresh the\ncompiler anymore. Same goes for adding implementations, and amending the calibration set with custom data for custom implementations: The calibration is now stored solely in the compiler instance, and can be retrieved using Compiler.get_calibration() : Fetching calibration sets from the server is still done via Pulla.fetch_latest_calibration_set() and Pulla.fetch_calibration_set_by_id() . Standard compilation stages are now available via get_standard_stages() . This ensures the immutability of\nbuilt-in standard stages. previous IQM Pulla next User guides By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "Compilation using a locally created calibration set",
    "url": "/iqm-pulla/Example - Compilation With Local Calibration Set.html",
    "description": "This notebook shows how to construct a calibration set locally and use the local calibration set for compiling circuits. The calibration itself is done using IQM\u2019s Graph Based Calibration (GBC) softwa...",
    "content": "This notebook shows how to construct a calibration set locally and use the local calibration set for compiling circuits. The calibration itself is done using IQM\u2019s Graph Based Calibration (GBC) software. In this notebook we show recalibration based on the latest calibration set. The usage of Pulla with a local calibration set works mostly the same way also for a full calibration from scratch. In that case you would just have to use a different GBC graph, and possibly manually add observations to the observation stash if it does not yet have all observations required for a valid calibration set. Using the principles shown in this notebook, it is possible to use all Pulla functionality as a helpful tool during the calibration process. NOTE: Some of the libraries used in this notebook are only available to on-premise customers and are not currently available publicly. First we prepare a Pulla object, a qiskit-iqm backend, and a circuit as explained in Quick Start.ipynb . Let\u2019s also define a function that compiles and runs the above circuit using the given compiler state. This function will be used to compile and execute the circuit at different points of the calibration process: First we compile and execute the circuit using the compiler obtained above, which uses the current default calibration set on the server. The results of this execution can then be compared to the results after performing (parts of) the recalibration process. Now we will start recalibration using GBC. We need a CalibrationSetWrapper instance for handling calibration sets and a Calibrator for running the calibration: To start with, we run the first node that runs any actual calibration experiments: Then we can create a local calibration set based on the results of the above calibration node, and update the compiler to use this calibration set. We compile and execute a circuit using the updated compiler to see how our updates to the calibration set affect the results. Because many observations of the updated calibration set don\u2019t yet take into account the results of the executed node, the results could even be worse than before updating the calibration set with these intermediate results. We could repeat the above steps multiple times for different nodes of the calibration graph, to see how the results change during the calibration process. Finally, we run the full recalibration, which runs all the remaining nodes that we did not run above: Then we again update the compiler using the results of the calibration in the same way as before. If the full recalibration was successful, the execution results should hopefully be at least as good as before the recalibration. By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "User guides",
    "url": "/iqm-pulla/user_guides.html",
    "description": "previous Migration guide next Quick Start By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07....",
    "content": "previous Migration guide next Quick Start By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "Examples",
    "url": "/iqm-pulla/examples.html",
    "description": "previous Custom Gates and Gate Implementations next Example: Measuring T1 By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07....",
    "content": "previous Custom Gates and Gate Implementations next Example: Measuring T1 By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "Compilation Stages",
    "url": "/iqm-pulla/Compilation Stages.html",
    "description": "The generic lifecycle of a Pulla job is a one-way multi-step transformation. The states are as follow: Quantum Circuit in a specific format (e.g. Qiskit, Cirq) Equivalent Quantum Circuit in an IQM Pul...",
    "content": "The generic lifecycle of a Pulla job is a one-way multi-step transformation. The states are as follow: Quantum Circuit in a specific format (e.g. Qiskit, Cirq) Equivalent Quantum Circuit in an IQM Pulse format (list of CircuitOperations) IQM Pulse nested Timebox representation IQM Pulse Schedule representation Measurement results You don\u2019t have to start with a circuit, you can define quantum operations directly (roughly starting from state 2), or define pulse shapes directly (roughly starting from state 3 or 4). The compilation which produces states 3 and 4 is itself multi-step: it consists of multiple stages, and each stage of one or more passes. Let\u2019s go over the generic use case, starting from creating a Qiskit circuit to work on: Pulla has utility functions which accept circuits in different formats (Qiskit, Cirq, IQM JSON) and convert them into Pulla/IQM Pulse format, which is a list of CircuitOperation objects. Let\u2019s do that. Note that none of the operations have an implementation specified ( implementation=None ). The Qiskit conversion utility also gives us a standard compiler with the same calibration set as the one used by backend , in this case the current default one. In order to understand how the compilation stages work, let\u2019s remove the standard stages from the compiler: You can check the readiness of the compiler by calling compiler.ready() . Right now it would return False due to empty stages list. The compiler flow consists of one or more stages, and each stage consists of one or more passes. When the compiler is initialized created by Pulla, it is pre-populated with standard stages. You can define your own stages, with your own passes, grouping them in some meaningful way. Each pass is a function which accepts two arguments: data and context. Data is an iterable of objects of an applicable data type, and context is a dictionary of any additional information. Each pass can transform the data and modify the context, and must return both data and context. This convention allows the compiler to pipe arbitrary amount of passes. A stage is just an ordered collection of passes. The compiler has methods run_stage() and run_pass() allowing you to run particular stages or passes. The compile() method is just calling run_stage() in correct order and passes its initial context to the first pass of the first stage. Let\u2019s write a simple compilation stage to illustrate the concept: Now let\u2019s write two simple passes for that stage. For the first: perhaps we want to add a leading barrier to each circuit. add_leading_barrier below determines the locations of qubits used in the circuit and adds a barrier on those qubits as the first instruction. Note that the function takes data and context and returns data and context. It happens to neither use nor modify the context, but it should still provide it down to the next passes. Ok, let\u2019s define another pass: this one would increase the phase of each prx operation by 0.25 . This may or may\nnot make practical sense, but bear with us for the purposes of illustration: Now let\u2019s add those two passes to our stage, then replace the empty stages property of the compiler with a list consisting of our single stage, and then call show_stages() : The boolean flag full of show_stages() is optional; when True , the doc strings of each pass are printed on the screen. Now that the compiler is ready and we can run compile . The compiler always operates on batches of circuits, so you need to provide an iterable; in our case, it\u2019s a list with a single circuit. Note that it did not really compile the circuits into pulse schedules, because the only passes we\u2019ve defined only modify the circuits, but don\u2019t perform the conversion to pulse schedules. The compilation to pulse schedules usually consists of converting circuits to TimeBox es, then resolving TimeBox es into a single TimeBox , then resolving it into a Schedule , and finally converting a Schedule into a final Schedule ready to be submitted to the server. There might be cases when your compilation stages need additional data. You can provide such data as a custom context dictionary. Get the initial compiler context and modify it, then pass it when calling compile . As mentioned earlier, Pulla comes with a pre-defined \u201cstandard\u201d set of stages which you can use and, if needed, modify. These standard stages are used by CoCoS if you were to submit a circuit to CoCoS (without using Pulla). Thus, if you use the same version of the Pulla library that the remote CoCoS uses, you will be able to produce and inspect the same pulse schedules that CoCoS would (assuming you use the same calibration set). Let\u2019s replace our current single stage with standard stages, and view them: There are 7 standard stages: circuit-level: takes care of validating the circuit, renaming some deprecated names, gathering\ninformation for the next stages circuit resolution: converts circuits to TimeBox es timebox-level: optimizes \u201cmeasure\u201d gates by multiplexing them if possible timebox resolution: converts TimeBox es to Schedule schedule-level: applies dynamical decoupling schedule-level: potentially applies some corrections, then cleans up the schedules schedule resolution: converts Schedule to the final Playlist ready to be executed Variable data now contains the Playlist in its final form, and context contains a dictionary of various things\nwhich were either necessary in some of the passes, or will be necessary for the final execution. It also contains a\ncopy of schedules from before the final playlist resolution. Some of those pieces of data will be needed to build\nStation  Control settings (more on that later). Instead of calling compile() , which runs all the stages, you can run each stage, or even each separate pass, by yourself. In that case you will have to take care of two things: Provide initial context to the first pass of the first stage. Save data and context returned by each pass (or stage) in order to provide it to the next pass (or stage). To help you with 1, the compiler has a method compiler_context() which returns a dictionary of initial context. (Note: to run a pass of any particular stage: compiler.stages[0].passes[0](data, context) ) Let\u2019s create another circuit and compile it manually. We\u2019ll use this example to understand each standard stage: The first stage is circuit-level passes: When defining a circuit in IQM JSON or IQM Pulse format directly, you can specify an implementation for each gate (selecting from implementations provided by the calibration set). If no implementation is specified, the standard circuit-level stage will select the default implementation for each gate automatically. Currently, the choice of the default implementation is global: e.g. prx may have drag_gaussian as the default. In the future, the calibration may yield different implementations for different loci, striving to provide the best quality. Now we can convert the circuit to TimeBox es. TimeBox is a concept of IQM Pulse: a container for one or more instruction schedule fragments, to be scheduled according to a given scheduling strategy. timeboxes is a list of TimeBox objects, and you can edit them manually. A TimeBox can contain multiple children TimeBox es, each containing either more TimeBox es or a Schedule . A TimeBox containing a Schedule rather than children is referred to as \u201catomic\u201d. In our example here the circuit was converted into one TimeBox containing 11 children atomic TimeBox es, which correspond to 11 circuit operations (7 gates + 1 barrier gate + 3 measurement gates). An atomic TimeBox holds its Schedule in an atom property: Next is a timebox-level stage, which only has one pass: multiplexing measurements. The measure_all() we called when\ncreating the circuit adds a single TimeBox with the gate implementation Measure_Constant for each qubit in the\ncircuit.\nWith the measurement_mode='all' option, the first stage has also added a measurement TimeBox for the unused qubits. Multiplexing means executing all of these measurements at once, instead of one after the other.\nThe multiplexing pass does this optimization for us: If you construct a circuit in Qiskit, and want to ensure multiplexing of measurement instructions, you have to \u201cwrap\u201d a group of measurement instructions with barrier s. This would prevent the Qiskit transpiler from putting any other instructions, acting on the same qubits, in between measurements, thus allowing the compiler to multiplex. Next we convert TimeBox es into a single Schedule . This is a recursive process which resolves all nested TimeBox es into atomic TimeBox es, and finally assembles a single Schedule out each of batches of TimeBox es. At this stage, all relative timings between pulses are resolved and fixed. Dynamical decoupling pulse sequences get inserted to replace Wait instructions. The process is controlled by a user-submitted dynamical decoupling strategy. By default, this stage is disabled. Please see other notebooks for examples of how to enable and apply dynamical decoupling. Next is a schedule-level stage. Its first pass applies calibrated phase corrections if MOVE gates are used (only applicable to QCs with computational resonator, i.e. IQM Star Architecture). The second pass removes non-functional instructions from the schedules. Finally, the last stage builds a final schedule from a number of instruction schedules. A playlist is just a compressed Schedule with no duplicate information, ready to be submitted for execution. In order to submit this final schedule for execution, we have to do one more thing: build the Station Control settings. The settings control the behaviour of instruments. At this point everything is ready to be submitted for execution to the server. Namely, these three objects will be used to construct a request to Station Control Service: playlist : sequence of instruction schedules corresponding to the batch of circuits to be executed settings : Station Control settings node context['readout_mappings'] : a mapping from measurement keys to the names of readout controller acquisition labels that will hold the measurement results Now we can convert these raw results into a Qiskit Result object: We can also submit the same circuit to CoCoS for execution. CoCoS is essentially a server-side Pulla with fixed standard stages. Since we started with a normal Qiskit backend and a circuit, execution is as simple as: previous Configuration and Usage next Custom Gates and Gate Implementations By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.standard_stages.prepend_reset",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.standard_stages.prepend_reset.html",
    "description": "Add a reset timebox to all circuits. timeboxes ( Iterable [ TimeBox ] ) \u2013 builder ( ScheduleBuilder ) \u2013 options ( CircuitExecutionOptions ) \u2013 circuit_metrics ( Iterable [ CircuitMetrics ] ) \u2013 Iterable...",
    "content": "Add a reset timebox to all circuits. timeboxes ( Iterable [ TimeBox ] ) \u2013 builder ( ScheduleBuilder ) \u2013 options ( CircuitExecutionOptions ) \u2013 circuit_metrics ( Iterable [ CircuitMetrics ] ) \u2013 Iterable [ TimeBox ] previous iqm.cpc.compiler.standard_stages.prepend_heralding next iqm.cpc.compiler.standard_stages.resolve_circuits By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.CompilationPassError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.CompilationPassError.html",
    "description": "There is something wrong with the compilation pass. previous iqm.cpc.compiler.errors.ClientError next iqm.cpc.compiler.errors.InsufficientContextError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQ...",
    "content": "There is something wrong with the compilation pass. previous iqm.cpc.compiler.errors.ClientError next iqm.cpc.compiler.errors.InsufficientContextError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.station_settings.build_station_settings",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.station_settings.build_station_settings.html",
    "description": "Build the station settings for executing a batch of quantum circuits using the given QPU\nelements and calibration data. circuit_qubits ( Iterable [ str ] ) \u2013 physical qubit names used in the circuit c...",
    "content": "Build the station settings for executing a batch of quantum circuits using the given QPU\nelements and calibration data. circuit_qubits ( Iterable [ str ] ) \u2013 physical qubit names used in the circuit circuit_couplers ( Iterable [ str ] ) \u2013 coupler names used in the circuit measured_probe_lines ( Iterable [ str ] ) \u2013 probe line names used in the measurements shots ( int ) \u2013 number of times to repeat each circuit\u2019s execution calibration_set ( dict [ str , bool | str | int | float | complex | ndarray ] ) \u2013 calibration set as a mapping from observation paths to observation values boundary_qubits ( Iterable [ str ] ) \u2013 physical qubits connected to the boundary_couplers but not in circuit_qubits boundary_couplers ( Iterable [ str ] ) \u2013 coupler names of couplers connected to the circuit boundary but not in circuit_couplers flux_pulsed_qubits ( Collection [ str ] ) \u2013 names of qubits that have flux pulse capability station settings tree SettingNode previous iqm.cpc.compiler.station_settings next iqm.cpc.compiler.station_settings.find_observation By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.calibration",
    "url": "/iqm-pulla/api/iqm.pulla.calibration.html",
    "description": "Provider of calibration sets and quality metrics from remote IQM servers. Classes CalibrationDataProvider (station_control) Access calibration info via station control client and cache data in memory....",
    "content": "Provider of calibration sets and quality metrics from remote IQM servers. Classes CalibrationDataProvider (station_control) Access calibration info via station control client and cache data in memory. Inheritance previous iqm.pulla next iqm.pulla.calibration.CalibrationDataProvider By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils_qiskit.qiskit_circuits_to_pulla",
    "url": "/iqm-pulla/api/iqm.pulla.utils_qiskit.qiskit_circuits_to_pulla.html",
    "description": "Convert Qiskit quantum circuits into IQM Pulse quantum circuits. Lower-level method, you may want to use qiskit_to_pulla() instead. qiskit_circuits ( QuantumCircuit | Sequence [ QuantumCircuit ] ) \u2013 O...",
    "content": "Convert Qiskit quantum circuits into IQM Pulse quantum circuits. Lower-level method, you may want to use qiskit_to_pulla() instead. qiskit_circuits ( QuantumCircuit | Sequence [ QuantumCircuit ] ) \u2013 One or many Qiskit quantum circuits to convert. qubit_idx_to_name ( dict [ int , str ] ) \u2013 Mapping from Qiskit qubit indices to the names of the corresponding\nqubit names. custom_gates ( Collection [ str ] ) \u2013 Names of custom gates that should be treated as additional native gates\nby qiskit-iqm, i.e. they should be passed as-is to Pulla. Equivalent IQM Pulse circuit(s). list [ Circuit ] previous iqm.pulla.utils_qiskit next iqm.pulla.utils_qiskit.qiskit_to_pulla By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils.get_hash_for",
    "url": "/iqm-pulla/api/iqm.pulla.utils.get_hash_for.html",
    "description": "Get a unique id hash for a given circuit. In the context of this function, two CPC circuits are considered equal if they have:\n1. The same CircuitOperations in the same order.\n2. The loci of those cir...",
    "content": "Get a unique id hash for a given circuit. In the context of this function, two CPC circuits are considered equal if they have:\n1. The same CircuitOperations in the same order.\n2. The loci of those circuit operations are the same in all operation. circuit ( Circuit ) \u2013 int previous iqm.pulla.utils.find_circuit_boundary next iqm.pulla.utils.initialize_schedule_builder By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils.calset_to_cal_data_tree",
    "url": "/iqm-pulla/api/iqm.pulla.utils.calset_to_cal_data_tree.html",
    "description": "Build an iqm-pulse QuantumOp calibration data tree from a calibration set. Splits the dotted observation names that are prefixed with \u201cgates.\u201d into the corresponding\ncalibration data tree paths. calib...",
    "content": "Build an iqm-pulse QuantumOp calibration data tree from a calibration set. Splits the dotted observation names that are prefixed with \u201cgates.\u201d into the corresponding\ncalibration data tree paths. calibration_set ( dict [ str , bool | str | int | float | complex | ndarray ] ) \u2013 dict [ str , dict [ str , dict [ tuple [ str , \u2026] | None, dict [ str , Any ]]]] previous iqm.pulla.utils.calset_from_observations next iqm.pulla.utils.circuit_operations_to_cpc By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils_qiskit",
    "url": "/iqm-pulla/api/iqm.pulla.utils_qiskit.html",
    "description": "Utilities for working with Qiskit objects. Functions qiskit_circuits_to_pulla (qiskit_circuits,\u00a0...) Convert Qiskit quantum circuits into IQM Pulse quantum circuits. qiskit_to_pulla (pulla,\u00a0backend,\u00a0q...",
    "content": "Utilities for working with Qiskit objects. Functions qiskit_circuits_to_pulla (qiskit_circuits,\u00a0...) Convert Qiskit quantum circuits into IQM Pulse quantum circuits. qiskit_to_pulla (pulla,\u00a0backend,\u00a0qiskit_circuits) Convert transpiled Qiskit quantum circuits to IQM Pulse quantum circuits. station_control_result_to_qiskit (...) Convert a Station Control result to a Qiskit Result. Classes DummyJob (backend,\u00a0qiskit_result) A dummy job object that can be used to retrieve the result of a locally compiled circuit. IQMPullaBackend (architecture,\u00a0pulla,\u00a0compiler) A backend that compiles circuits locally using Pulla and submits them to Station Control for execution. Inheritance previous iqm.pulla.utils_qir.qir_to_pulla next iqm.pulla.utils_qiskit.qiskit_circuits_to_pulla By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.quantum_architecture.create_static_quantum_architecture",
    "url": "/iqm-pulla/api/iqm.pulla.quantum_architecture.create_static_quantum_architecture.html",
    "description": "Creates a static quantum architecture (SQA) for the given chip topology. chip_topology ( ChipTopology ) \u2013 The chip topology. Static quantum architecture containing information about qubits, computatio...",
    "content": "Creates a static quantum architecture (SQA) for the given chip topology. chip_topology ( ChipTopology ) \u2013 The chip topology. Static quantum architecture containing information about qubits, computational resonators, and connectivity. StaticQuantumArchitecture previous iqm.pulla.quantum_architecture.create_dynamic_quantum_architecture next iqm.pulla.utils By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.ClientError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.ClientError.html",
    "description": "Client submitted a bad request, and needs to be notified. Errors inheriting this class will be reported to the client in the message field of the failed job. previous iqm.cpc.compiler.errors.CircuitEr...",
    "content": "Client submitted a bad request, and needs to be notified. Errors inheriting this class will be reported to the client in the message field of the failed job. previous iqm.cpc.compiler.errors.CircuitError next iqm.cpc.compiler.errors.CompilationPassError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.interface.TaskStatus",
    "url": "/iqm-pulla/api/iqm.pulla.interface.TaskStatus.html",
    "description": "Bases: StrEnum Status of a Station Control task. Attributes READY Task has completed successfully FAILED Task has failed PROGRESS Task is being executed PENDING Task is waiting to be executed Methods ...",
    "content": "Bases: StrEnum Status of a Station Control task. Attributes READY Task has completed successfully FAILED Task has failed PROGRESS Task is being executed PENDING Task is waiting to be executed Methods __format__ (format_spec,\u00a0/) Return a formatted version of the string as described by format_spec. __new__ (value)  __str__ () Return str(self). Task has completed successfully Task has failed Task is being executed Task is waiting to be executed previous iqm.pulla.interface.StationControlResult next iqm.pulla.interface.CHADRetrievalException By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils.map_sweep_results_to_logical_qubits",
    "url": "/iqm-pulla/api/iqm.pulla.utils.map_sweep_results_to_logical_qubits.html",
    "description": "Convert sweep results returned by Station Control to the circuit measurement results the client expects. sweep_results ( dict [ str , list [ ndarray ] ] ) \u2013 mapping of acquisition labels to a list of ...",
    "content": "Convert sweep results returned by Station Control to the circuit measurement results the client expects. sweep_results ( dict [ str , list [ ndarray ] ] ) \u2013 mapping of acquisition labels to a list of soft sweep spots, each represented by a 1D\narray of readout results, with shots * num_triggers_for_label elements. readout_mappings ( tuple [ dict [ str , tuple [ str , ... ] ] , ... ] ) \u2013 for each circuit in the batch, a mapping of measurement keys to corresponding\ntuples of result parameter names. heralding_mode ( HeraldingMode ) \u2013 Heralding mode, either ZEROS (when doing heralded readout) or NONE . converted, filtered measurement results, with the heralding measurement data removed list [ dict [ str , list [ list [ int ]]]] previous iqm.pulla.utils.map_qubit_indices next iqm.pulla.utils.print_channel By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.interface.compiler",
    "url": "/iqm-pulla/api/iqm.cpc.interface.compiler.html",
    "description": "Pydantic models used by the API. Module Attributes CircuitBatch Type that represents a list of quantum circuits to be executed together in a single batch. PRXSequence A sequence of PRX gates. ReadoutM...",
    "content": "Pydantic models used by the API. Module Attributes CircuitBatch Type that represents a list of quantum circuits to be executed together in a single batch. PRXSequence A sequence of PRX gates. ReadoutMapping Type for matching measurement keys from the quantum circuit with acquisition labels in Station Control. ReadoutMappingBatch Type that represents tuple of readout mappings, one per each circuit in a circuit batch. Classes Circuit (name,\u00a0instructions) Quantum circuit to be executed. CircuitBoundaryMode (value[,\u00a0names,\u00a0module,\u00a0...]) Circuit boundary mode for circuit compilation. CircuitCompilationResult (playlist,\u00a0...) Compiled circuit and associated settings returned by CPC to Cocos. CircuitExecutionOptions (measurement_mode,\u00a0...) Various discrete options for quantum circuit execution. CircuitMetrics (components,\u00a0...[,\u00a0gate_loci,\u00a0...]) Metrics describing a circuit and its compilation result. DDMode (value[,\u00a0names,\u00a0module,\u00a0qualname,\u00a0...]) Dynamical Decoupling (DD) mode for circuit execution. DDStrategy ([merge_contiguous_waits,\u00a0...]) Describes a particular dynamical decoupling strategy. HeraldingMode (value[,\u00a0names,\u00a0module,\u00a0...]) Heralding mode for circuit execution. MeasurementMode (value[,\u00a0names,\u00a0module,\u00a0...]) Measurement mode for circuit execution. MoveGateFrameTrackingMode (value[,\u00a0names,\u00a0...]) MOVE gate frame tracking mode for circuit compilation. MoveGateValidationMode (value[,\u00a0names,\u00a0...]) MOVE gate validation mode for circuit compilation. Inheritance previous iqm.cpc.interface next iqm.cpc.interface.compiler.CircuitBatch By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils_dd.generate_phases_of_urn_sequence",
    "url": "/iqm-pulla/api/iqm.pulla.utils_dd.generate_phases_of_urn_sequence.html",
    "description": "Generate PRX gate phases for the URn sequence. More information on the URn sequence is available in [ 1 ] , at the end in Appendix A.1. n ( int ) \u2013 Number of single qubit PRX pulses with different pha...",
    "content": "Generate PRX gate phases for the URn sequence. More information on the URn sequence is available in [ 1 ] , at the end in Appendix A.1. n ( int ) \u2013 Number of single qubit PRX pulses with different phases to apply, must be a positive even number. Phases to be used by the URn sequence. list [ float ] previous iqm.pulla.utils_dd next iqm.pulla.utils_qir By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.calibration.CalibrationDataProvider",
    "url": "/iqm-pulla/api/iqm.pulla.calibration.CalibrationDataProvider.html",
    "description": "Bases: object Access calibration info via station control client and cache data in memory. Methods _get_latest_calibration_set (dut_label)  get_calibration_set (cal_set_id) Get the calibration set con...",
    "content": "Bases: object Access calibration info via station control client and cache data in memory. Methods _get_latest_calibration_set (dut_label)  get_calibration_set (cal_set_id) Get the calibration set contents from the database and cache it. get_calibration_set_values (calibration_set_id) Get saved calibration set observations by UUID. get_latest_calibration_set (chip_label) Get the latest calibration set id for chip_label from the database, return it and the set contents. station_control ( StationControlInterface ) \u2013 Get the calibration set contents from the database and cache it. cal_set_id ( UUID ) \u2013 dict [ str , bool | str | int | float | complex | ndarray ] Get the latest calibration set id for chip_label from the database, return it and the set contents. chip_label ( str ) \u2013 tuple [ dict [ str , bool | str | int | float | complex | ndarray ], UUID ] Get saved calibration set observations by UUID. calibration_set_id ( UUID ) \u2013 UUID of the calibration set to retrieve. Dictionary of observations belonging to the given calibration set. dict [ str , bool | str | int | float | complex | ndarray ] previous iqm.pulla.calibration next iqm.pulla.interface By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.quantum_architecture",
    "url": "/iqm-pulla/api/iqm.pulla.quantum_architecture.html",
    "description": "Methods for creating static and dynamic quantum architectures. Functions create_dynamic_quantum_architecture (...) Creates a dynamic quantum architecture (DQA) for the given calibration set. create_st...",
    "content": "Methods for creating static and dynamic quantum architectures. Functions create_dynamic_quantum_architecture (...) Creates a dynamic quantum architecture (DQA) for the given calibration set. create_static_quantum_architecture (chip_topology) Creates a static quantum architecture (SQA) for the given chip topology. previous iqm.pulla.pulla.Pulla next iqm.pulla.quantum_architecture.create_dynamic_quantum_architecture By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils",
    "url": "/iqm-pulla/api/iqm.pulla.utils.html",
    "description": "Utility functions for IQM Pulla. Module Attributes InstructionLocation (channel_name,\u00a0index,\u00a0...) Return type for locate_instructions() . Functions build_settings (shots,\u00a0calibration_set,\u00a0...) Constru...",
    "content": "Utility functions for IQM Pulla. Module Attributes InstructionLocation (channel_name,\u00a0index,\u00a0...) Return type for locate_instructions() . Functions build_settings (shots,\u00a0calibration_set,\u00a0...) Construct the Station Control settings needed for executing a batch of quantum circuits. calset_from_observations (calset_observations) Create a calibration set from the given observations. calset_to_cal_data_tree (calibration_set) Build an iqm-pulse QuantumOp calibration data tree from a calibration set. circuit_operations_to_cpc (circ_ops[,\u00a0name]) Convert a list of CircuitOperations to an IQM CPC Circuit. convert_sweep_spot (results,\u00a0readout_mappings) Convert the sweep measurement results from Station Control into circuit measurement results. convert_sweep_spot_with_heralding_mode_zero (...) Like convert_sweep_spot() , but for results that contain heralding measurements. extract_readout_controller_result_names (...) Prepare readout controller names for the request. find_circuit_boundary (mode,\u00a0...) Determine the boundary of a circuit executed on the QPU. get_hash_for (circuit) Get a unique id hash for a given circuit. initialize_schedule_builder (calibration_set,\u00a0...) Initialize a new schedule builder for the station, validate that it is configured properly. iqm_circuit_to_gate_implementation (circuit,\u00a0...) Wrap a circuit to a single GateImplementation that can then be registered as an independent \"gate\". locate_instructions (schedule,\u00a0instruction_type) Locate specific instructions in a schedule. map_qubit_indices (circuits,\u00a0context) Map qubit indices in circuits to the indices in the component mapping. map_sweep_results_to_logical_qubits (...) Convert sweep results returned by Station Control to the circuit measurement results the client expects. print_channel (schedule,\u00a0channel_name) Print all instructions in a channel of a schedule. print_schedule (schedule) Print all instructions in each segment of a schedule. replace_instruction_in_place (schedule,\u00a0...) Replace an instruction in a schedule with one or more instructions. Classes InstructionLocation (channel_name,\u00a0index,\u00a0...) Return type for locate_instructions() . Inheritance previous iqm.pulla.quantum_architecture.create_static_quantum_architecture next iqm.pulla.utils.InstructionLocation By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.CalibrationError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.CalibrationError.html",
    "description": "A required calibration observation is missing from the calibration set, or an unknown\ngate calibration observation is encountered. previous iqm.cpc.compiler.errors next iqm.cpc.compiler.errors.Circuit...",
    "content": "A required calibration observation is missing from the calibration set, or an unknown\ngate calibration observation is encountered. previous iqm.cpc.compiler.errors next iqm.cpc.compiler.errors.CircuitError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils_qir",
    "url": "/iqm-pulla/api/iqm.pulla.utils_qir.html",
    "description": "Utilities for working with a QIR module. Functions qir_to_pulla (pulla,\u00a0qir[,\u00a0qubit_mapping]) Convert a QIR module to a CPC circuit. previous iqm.pulla.utils_dd.generate_phases_of_urn_sequence next iq...",
    "content": "Utilities for working with a QIR module. Functions qir_to_pulla (pulla,\u00a0qir[,\u00a0qubit_mapping]) Convert a QIR module to a CPC circuit. previous iqm.pulla.utils_dd.generate_phases_of_urn_sequence next iqm.pulla.utils_qir.qir_to_pulla By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.UnknownCircuitExecutionOptionError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.UnknownCircuitExecutionOptionError.html",
    "description": "An unsupported value was used in circuit execution options. previous iqm.cpc.compiler.errors.SettingsConventionError next iqm.cpc.compiler.errors.UnknownHardwareComponentError By IQM Pulla developers ...",
    "content": "An unsupported value was used in circuit execution options. previous iqm.cpc.compiler.errors.SettingsConventionError next iqm.cpc.compiler.errors.UnknownHardwareComponentError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.interface.compiler.MoveGateValidationMode",
    "url": "/iqm-pulla/api/iqm.cpc.interface.compiler.MoveGateValidationMode.html",
    "description": "Bases: StrEnum MOVE gate validation mode for circuit compilation. Attributes STRICT MOVE(qubit, resonator) gates must only appear in sandwiches (pairs). ALLOW_PRX Allow PRX gates on the MOVE qubit ins...",
    "content": "Bases: StrEnum MOVE gate validation mode for circuit compilation. Attributes STRICT MOVE(qubit, resonator) gates must only appear in sandwiches (pairs). ALLOW_PRX Allow PRX gates on the MOVE qubit inside MOVE sandwiches during validation. NONE Do not perform any MOVE gate validation. Methods __format__ (format_spec,\u00a0/) Return a formatted version of the string as described by format_spec. __new__ (value)  __str__ () Return str(self). MOVE(qubit, resonator) gates must only\nappear in sandwiches (pairs). Inside a sandwich there must be no gates acting on the\nMOVE qubit, and no other MOVE gates acting on the resonator. Perform standard MOVE gate validation Allow PRX gates on the MOVE qubit inside MOVE sandwiches during validation. Do not perform any MOVE gate validation. previous iqm.cpc.interface.compiler.MoveGateFrameTrackingMode next iqm.pulla By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.interface",
    "url": "/iqm-pulla/api/iqm.cpc.interface.html",
    "description": "Pydantic models used by the API. Subpackages and modules compiler Pydantic models used by the API. previous iqm.cpc.compiler.station_settings.Map next iqm.cpc.interface.compiler By IQM Pulla developer...",
    "content": "Pydantic models used by the API. Subpackages and modules compiler Pydantic models used by the API. previous iqm.cpc.compiler.station_settings.Map next iqm.cpc.interface.compiler By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.InsufficientContextError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.InsufficientContextError.html",
    "description": "The context provided to the compilation pass does not contain all necessary fields. previous iqm.cpc.compiler.errors.CompilationPassError next iqm.cpc.compiler.errors.SettingsConventionError By IQM Pu...",
    "content": "The context provided to the compilation pass does not contain all necessary fields. previous iqm.cpc.compiler.errors.CompilationPassError next iqm.cpc.compiler.errors.SettingsConventionError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.pulla",
    "url": "/iqm-pulla/api/iqm.pulla.pulla.html",
    "description": "Pulse level access library for IQM\u2019s circuit-to-pulse compiler and Station Control API. Classes Pulla (station_control_url,\u00a0*[,\u00a0...]) Pulse level access library for IQM's circuit-to-pulse compiler and...",
    "content": "Pulse level access library for IQM\u2019s circuit-to-pulse compiler and Station Control API. Classes Pulla (station_control_url,\u00a0*[,\u00a0...]) Pulse level access library for IQM's circuit-to-pulse compiler and Station Control API. Inheritance previous iqm.pulla.interface.SettingsRetrievalException next iqm.pulla.pulla.Pulla By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.standard_stages.build_playlist",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.standard_stages.build_playlist.html",
    "description": "Build the playlist from the schedules. schedules ( Iterable [ Schedule ] ) \u2013 builder ( ScheduleBuilder ) \u2013 tuple [ Playlist , dict [ str , Any ]] previous iqm.cpc.compiler.standard_stages.apply_move_g...",
    "content": "Build the playlist from the schedules. schedules ( Iterable [ Schedule ] ) \u2013 builder ( ScheduleBuilder ) \u2013 tuple [ Playlist , dict [ str , Any ]] previous iqm.cpc.compiler.standard_stages.apply_move_gate_phase_corrections next iqm.cpc.compiler.standard_stages.choose_op_implementations By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.compiler.CompilationStage",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.compiler.CompilationStage.html",
    "description": "Bases: object Sequence of compiler passes that are applied to the data. The data and context are returned after all passes have been applied.\nA pass is a function that takes the data and context as ar...",
    "content": "Bases: object Sequence of compiler passes that are applied to the data. The data and context are returned after all passes have been applied.\nA pass is a function that takes the data and context as arguments and\nreturns the modified data and context. The context is a dictionary that can contain any information that needs to be\npassed between the passes. Methods add_passes (*pass_functions) Add multiple passes to the stage. ready () Check if the stage is ready to run. run (data,\u00a0context) Run all the passes in the stage on the data and context. name ( str ) \u2013 Check if the stage is ready to run. A stage is ready if it has at least one pass defined. bool Add multiple passes to the stage. pass_functions ( Callable [ [ Any , dict [ str , Any ] ] , tuple [ Any , dict [ str , Any ] ] ] ) \u2013 One or more pass functions to be added to the stage. None Run all the passes in the stage on the data and context. The data and context are returned after all passes have\nbeen applied. data ( Any ) \u2013 The data to be processed. context ( dict [ str , Any ] ) \u2013 A dictionary containing any additional information that needs to be passed between the passes. The processed data and context. tuple [ Any , dict [ str , Any ]] previous iqm.cpc.compiler.compiler.pass_function_idempotent next iqm.cpc.compiler.compiler.Compiler By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils.build_settings",
    "url": "/iqm-pulla/api/iqm.pulla.utils.build_settings.html",
    "description": "Construct the Station Control settings needed for executing a batch of quantum circuits. shots ( int ) \u2013 number of times to execute/sample each circuit calibration_set ( dict [ str , bool | str | int ...",
    "content": "Construct the Station Control settings needed for executing a batch of quantum circuits. shots ( int ) \u2013 number of times to execute/sample each circuit calibration_set ( dict [ str , bool | str | int | float | complex | ndarray ] ) \u2013 calibration data for the station the circuits are executed on builder ( ScheduleBuilder ) \u2013 schedule builder object, encapsulating station properties and gate calibration data circuit_metrics ( Iterable [ CircuitMetrics ] ) \u2013 statistics about the circuits to be executed options ( CircuitExecutionOptions ) \u2013 various discrete options for circuit execution that affect compilation Station Control settings SettingNode previous iqm.pulla.utils.InstructionLocation next iqm.pulla.utils.calset_from_observations By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.interface.compiler.ReadoutMappingBatch",
    "url": "/iqm-pulla/api/iqm.cpc.interface.compiler.ReadoutMappingBatch.html",
    "description": "Type that represents tuple of readout mappings, one per each circuit in a circuit batch. alias of tuple [ dict [ str , tuple [ str , \u2026]], \u2026] previous iqm.cpc.interface.compiler.ReadoutMapping next iqm...",
    "content": "Type that represents tuple of readout mappings, one per each circuit in a circuit batch. alias of tuple [ dict [ str , tuple [ str , \u2026]], \u2026] previous iqm.cpc.interface.compiler.ReadoutMapping next iqm.cpc.interface.compiler.Circuit By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils.map_qubit_indices",
    "url": "/iqm-pulla/api/iqm.pulla.utils.map_qubit_indices.html",
    "description": "Map qubit indices in circuits to the indices in the component mapping. circuits ( Iterable [ Circuit ] ) \u2013 context ( dict [ str , Any ] ) \u2013 tuple [ list [ Circuit ], dict [ str , Any ]] previous iqm.p...",
    "content": "Map qubit indices in circuits to the indices in the component mapping. circuits ( Iterable [ Circuit ] ) \u2013 context ( dict [ str , Any ] ) \u2013 tuple [ list [ Circuit ], dict [ str , Any ]] previous iqm.pulla.utils.locate_instructions next iqm.pulla.utils.map_sweep_results_to_logical_qubits By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils_qir.qir_to_pulla",
    "url": "/iqm-pulla/api/iqm.pulla.utils_qir.qir_to_pulla.html",
    "description": "Convert a QIR module to a CPC circuit. pulla ( Pulla ) \u2013 The Pulla instance to get compiler from. qir ( str | bytes ) \u2013 The QIR source or bitcode to convert to a circuit. qubit_mapping ( dict [ int , ...",
    "content": "Convert a QIR module to a CPC circuit. pulla ( Pulla ) \u2013 The Pulla instance to get compiler from. qir ( str | bytes ) \u2013 The QIR source or bitcode to convert to a circuit. qubit_mapping ( dict [ int , str ] | None ) \u2013 A dictionary mapping QIR qubit indexes to physical qubit names,\nNone will assume opaque pointers match physical names. The QIR program name,\ntuple[CircuitOperation, \u2026]: The circuit operations extracted from the QIR code. str ValueError \u2013 If the QIR program has more than one basic block. previous iqm.pulla.utils_qir next iqm.pulla.utils_qiskit By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils.locate_instructions",
    "url": "/iqm-pulla/api/iqm.pulla.utils.locate_instructions.html",
    "description": "Locate specific instructions in a schedule. schedule ( Schedule ) \u2013 The schedule to search. instruction_type ( type [ Instruction ] ) \u2013 The type of the instruction to search for. min_duration ( int ) ...",
    "content": "Locate specific instructions in a schedule. schedule ( Schedule ) \u2013 The schedule to search. instruction_type ( type [ Instruction ] ) \u2013 The type of the instruction to search for. min_duration ( int ) \u2013 The minimum duration of the instruction to search for (in samples). channels ( Iterable [ str ] | None ) \u2013 Names of channels in schedule to search. Iff None, search all the channels. For each located instruction, a namedtuple containing the channel name, instruction index, and duration. list [ InstructionLocation ] previous iqm.pulla.utils.iqm_circuit_to_gate_implementation next iqm.pulla.utils.map_qubit_indices By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.interface.compiler.DDStrategy",
    "url": "/iqm-pulla/api/iqm.cpc.interface.compiler.DDStrategy.html",
    "description": "Bases: object Describes a particular dynamical decoupling strategy. The current standard DD stategy can be found in STANDARD_DD_STRATEGY ,\nbut users can use this class to provide their own dynamical d...",
    "content": "Bases: object Describes a particular dynamical decoupling strategy. The current standard DD stategy can be found in STANDARD_DD_STRATEGY ,\nbut users can use this class to provide their own dynamical decoupling strategies. See [ 1 ] for information on DD sequences. Attributes merge_contiguous_waits Merge contiguous Wait instructions into one if they are separated only by Block instructions. skip_leading_wait Skip processing leading Wait instructions. skip_trailing_wait Skip processing trailing Wait instructions. target_qubits Qubits on which dynamical decoupling should be applied. gate_sequences Available decoupling gate sequences to chose from in this strategy. Methods __eq__ (other) Return self==value. __repr__ () Return repr(self). merge_contiguous_waits ( bool ) \u2013 target_qubits ( frozenset [ str ] | None ) \u2013 skip_leading_wait ( bool ) \u2013 skip_trailing_wait ( bool ) \u2013 gate_sequences ( list [ tuple [ int , str | list [ tuple [ float , float ] ] , str ] ] ) \u2013 Merge contiguous Wait instructions into one if they are separated only by Block instructions. Qubits on which dynamical decoupling should be applied. If None , all qubits are targeted. Skip processing leading Wait instructions. Skip processing trailing Wait instructions. Available decoupling gate sequences to chose from in this strategy. Each sequence is defined by a tuple of (ratio, gate pattern, align) : ratio: Minimal duration for the sequence (in PRX gate durations). gate pattern: Gate pattern can be defined in two ways. It can be a string containing \u201cX\u201d and \u201cY\u201d characters,\nencoding a PRX gate sequence. For example, \u201cYXYX\u201d corresponds to the\nXY4 sequence, \u201cXYXYYXYX\u201d to the EDD sequence, etc. If more flexibility is needed, a gate pattern can be\ndefined as a sequence of PRX gate argument tuples (that contain a rotation angle and a phase angle). For\nexample, sequence \u201cYX\u201d could be written as [(math.pi, math.pi / 2), (math.pi, 0)] . align: Controls the alignment of the sequence within the time window it is inserted in. Supported values: \u201casap\u201d: Corresponds to a ASAP-aligned sequence with no waiting time before the first pulse. \u201ccenter\u201d: Corresponds to a symmetric sequence. \u201calap\u201d: Corresponds to a ALAP-aligned sequence. The Dynamical Decoupling algorithm uses the best fitting gate sequence by first sorting them\nby ratio in descending order. Then the longest fitting pattern is determined by comparing ratio with the duration of the time window divided by the PRX gate duration. previous iqm.cpc.interface.compiler.DDMode next iqm.cpc.interface.compiler.HeraldingMode By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.interface.CircuitMeasurementResultsBatch",
    "url": "/iqm-pulla/api/iqm.pulla.interface.CircuitMeasurementResultsBatch.html",
    "description": "Type that represents measurement results for a batch of circuits. alias of list [ dict [ str , list [ list [ int ]]]] previous iqm.pulla.interface.CircuitMeasurementResults next iqm.pulla.interface.BU...",
    "content": "Type that represents measurement results for a batch of circuits. alias of list [ dict [ str , list [ list [ int ]]]] previous iqm.pulla.interface.CircuitMeasurementResults next iqm.pulla.interface.BUFFER_AFTER_MEASUREMENT_PROBE By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils_qiskit.station_control_result_to_qiskit",
    "url": "/iqm-pulla/api/iqm.pulla.utils_qiskit.station_control_result_to_qiskit.html",
    "description": "Convert a Station Control result to a Qiskit Result. station_control_result ( StationControlResult ) \u2013 The Station Control result to convert. shots ( int ) \u2013 number of shots requested execution_option...",
    "content": "Convert a Station Control result to a Qiskit Result. station_control_result ( StationControlResult ) \u2013 The Station Control result to convert. shots ( int ) \u2013 number of shots requested execution_options ( CircuitExecutionOptions ) \u2013 Circuit execution options used to produce the result. The equivalent Qiskit Result. Result previous iqm.pulla.utils_qiskit.qiskit_to_pulla next iqm.pulla.utils_qiskit.DummyJob By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.standard_stages.resolve_circuits",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.standard_stages.resolve_circuits.html",
    "description": "Resolve the circuits to timeboxes. circuits ( Iterable [ Circuit ] ) \u2013 builder ( ScheduleBuilder ) \u2013 list [ TimeBox ] previous iqm.cpc.compiler.standard_stages.prepend_reset next iqm.cpc.compiler.stan...",
    "content": "Resolve the circuits to timeboxes. circuits ( Iterable [ Circuit ] ) \u2013 builder ( ScheduleBuilder ) \u2013 list [ TimeBox ] previous iqm.cpc.compiler.standard_stages.prepend_reset next iqm.cpc.compiler.standard_stages.resolve_timeboxes By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc",
    "url": "/iqm-pulla/api/iqm.cpc.html",
    "description": "IQM Circuit to Pulse Compiler. IQM Circuit to Pulse Compiler is a Python-based library for converting quantum circuits\ninto instruction schedules (which map Station Control controller names to their p...",
    "content": "IQM Circuit to Pulse Compiler. IQM Circuit to Pulse Compiler is a Python-based library for converting quantum circuits\ninto instruction schedules (which map Station Control controller names to their pulse playlists) and Station Control settings\nrequired for circuit execution, using the calibration data it is given.\nThe generated schedules and settings can be sent to Station Control\nfor execution on real or simulated quantum hardware. CPC is normally only accessed indirectly through Cocos or its reference client IQM client ,\nor a frontend such as Cirq on IQM or Qiskit on IQM . Subpackages and modules compiler Compile quantum circuits into instruction schedules and settings that can be executed on a station. interface Pydantic models used by the API. previous API Reference next iqm.cpc.compiler By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils.calset_from_observations",
    "url": "/iqm-pulla/api/iqm.pulla.utils.calset_from_observations.html",
    "description": "Create a calibration set from the given observations. calset_observations ( Iterable [ ObservationBase ] ) \u2013 observations that form a calibration set calibration set dict [ str , bool | str | int | fl...",
    "content": "Create a calibration set from the given observations. calset_observations ( Iterable [ ObservationBase ] ) \u2013 observations that form a calibration set calibration set dict [ str , bool | str | int | float | complex | ndarray ] previous iqm.pulla.utils.build_settings next iqm.pulla.utils.calset_to_cal_data_tree By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils_dd",
    "url": "/iqm-pulla/api/iqm.pulla.utils_dd.html",
    "description": "Utilities for working with Dynamical Decoupling. Functions generate_phases_of_urn_sequence (n) Generate PRX gate phases for the URn sequence. previous iqm.pulla.utils_cirq.cirq_to_cpc next iqm.pulla.u...",
    "content": "Utilities for working with Dynamical Decoupling. Functions generate_phases_of_urn_sequence (n) Generate PRX gate phases for the URn sequence. previous iqm.pulla.utils_cirq.cirq_to_cpc next iqm.pulla.utils_dd.generate_phases_of_urn_sequence By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.standard_stages.validate_execution_options",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.standard_stages.validate_execution_options.html",
    "description": "Validate the circuit execution options (only some combinations make sense). circuits ( Iterable [ Circuit ] ) \u2013 options ( CircuitExecutionOptions ) \u2013 previous iqm.cpc.compiler.standard_stages.validate...",
    "content": "Validate the circuit execution options (only some combinations make sense). circuits ( Iterable [ Circuit ] ) \u2013 options ( CircuitExecutionOptions ) \u2013 previous iqm.cpc.compiler.standard_stages.validate_circuits next iqm.cpc.compiler.station_settings By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils.iqm_circuit_to_gate_implementation",
    "url": "/iqm-pulla/api/iqm.pulla.utils.iqm_circuit_to_gate_implementation.html",
    "description": "Wrap a circuit to a single GateImplementation that can then be registered as an independent \u201cgate\u201d. Returns a composite GateImplementation which, when called, produces a TimeBox with the circuit conte...",
    "content": "Wrap a circuit to a single GateImplementation that can then be registered as an independent \u201cgate\u201d. Returns a composite GateImplementation which, when called, produces a TimeBox with the circuit contents\nscheduled ASAP. The input circuit must contain only gates that are registered in IQM Pulse.\nThe gate implementation does not need calibration data of its own: it uses the calibration of the registered gates. circuit ( Circuit ) \u2013 circuit to wrap, typically a small subset of a larger circuit. qubit_mapping ( dict [ str , str ] ) \u2013 Mapping from logical qubit names to physical qubit names. A new class CircuitAsComposite which can be registered as a new gate implementation. type [ CompositeGate ] previous iqm.pulla.utils.initialize_schedule_builder next iqm.pulla.utils.locate_instructions By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.standard_stages.prepend_heralding",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.standard_stages.prepend_heralding.html",
    "description": "Add the heralding measurement timebox to all circuits. timeboxes ( Iterable [ TimeBox ] ) \u2013 builder ( ScheduleBuilder ) \u2013 heralded_components ( tuple [ tuple [ str , ... ] , ... ] ) \u2013 options ( Circui...",
    "content": "Add the heralding measurement timebox to all circuits. timeboxes ( Iterable [ TimeBox ] ) \u2013 builder ( ScheduleBuilder ) \u2013 heralded_components ( tuple [ tuple [ str , ... ] , ... ] ) \u2013 options ( CircuitExecutionOptions ) \u2013 list [ TimeBox ] previous iqm.cpc.compiler.standard_stages.multiplex_readout next iqm.cpc.compiler.standard_stages.prepend_reset By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.station_settings.find_observation",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.station_settings.find_observation.html",
    "description": "Return the value of the given calibration observation, or raise an error. observation_path ( str ) \u2013 observation we want to find in calibration_set calibration_set ( CalibrationSet ) \u2013 mapping of obse...",
    "content": "Return the value of the given calibration observation, or raise an error. observation_path ( str ) \u2013 observation we want to find in calibration_set calibration_set ( CalibrationSet ) \u2013 mapping of observation paths to observation values required ( bool ) \u2013 iff True and the observation cannot be found, raise an error value of the observation, or None if not found CalibrationError \u2013 required is True and the observation cannot be\n    found in calibration_set ObservationValue previous iqm.cpc.compiler.station_settings.build_station_settings next iqm.cpc.compiler.station_settings.Map By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils.convert_sweep_spot_with_heralding_mode_zero",
    "url": "/iqm-pulla/api/iqm.pulla.utils.convert_sweep_spot_with_heralding_mode_zero.html",
    "description": "Like convert_sweep_spot() , but for results that contain heralding measurements. For each circuit we only keep the shots for which the heralding result is zero for all the\nqubits used in the circuit. ...",
    "content": "Like convert_sweep_spot() , but for results that contain heralding measurements. For each circuit we only keep the shots for which the heralding result is zero for all the\nqubits used in the circuit. results ( dict [ str , ndarray ] ) \u2013 Mapping of acquisition labels to 1D arrays of readout results with the length num_shots * num_triggers_for_label_in_batch . The herald\nresults are found under HERALDING_KEY . readout_mappings ( tuple [ dict [ str , tuple [ str , ... ] ] , ... ] ) \u2013 For each circuit in the batch, a mapping of measurement keys to corresponding\ntuples of acquisition labels. converted, filtered measurement results, with the heralding measurement data removed list [ dict [ str , list [ list [ int ]]]] previous iqm.pulla.utils.convert_sweep_spot next iqm.pulla.utils.extract_readout_controller_result_names By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.standard_stages.get_standard_stages",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.standard_stages.get_standard_stages.html",
    "description": "Get a copy of the standard compilation stages. idempotent ( bool ) \u2013 If True, the passes will be made idempotent. The standard compilation stages. list [ CompilationStage ] previous iqm.cpc.compiler.s...",
    "content": "Get a copy of the standard compilation stages. idempotent ( bool ) \u2013 If True, the passes will be made idempotent. The standard compilation stages. list [ CompilationStage ] previous iqm.cpc.compiler.standard_stages.derive_readout_mappings next iqm.cpc.compiler.standard_stages.map_components By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils.initialize_schedule_builder",
    "url": "/iqm-pulla/api/iqm.pulla.utils.initialize_schedule_builder.html",
    "description": "Initialize a new schedule builder for the station, validate that it is configured properly. calibration_set ( dict [ str , bool | str | int | float | complex | ndarray ] ) \u2013 calibration data for the s...",
    "content": "Initialize a new schedule builder for the station, validate that it is configured properly. calibration_set ( dict [ str , bool | str | int | float | complex | ndarray ] ) \u2013 calibration data for the station the circuits are executed on chip_topology ( ChipTopology ) \u2013 topology of the QPU the circuits are executed on channel_properties ( dict [ str , ChannelProperties ] ) \u2013 properties of control channels on the station component_channels ( dict [ str , dict [ str , str ] ] ) \u2013 QPU component to function to channel mapping schedule builder for the station ScheduleBuilder previous iqm.pulla.utils.get_hash_for next iqm.pulla.utils.iqm_circuit_to_gate_implementation By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.dd.merge_wait_instructions_in_schedule",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.dd.merge_wait_instructions_in_schedule.html",
    "description": "Merge adjacent Wait instructions in the drive channels of the given schedule. Makes a deep copy schedule and iterates through its drive channels to merge adjacent Wait instructions into a single Wait ...",
    "content": "Merge adjacent Wait instructions in the drive channels of the given schedule. Makes a deep copy schedule and iterates through its drive channels to merge adjacent Wait instructions into a single Wait instruction. Also merges Wait instructions if they are separated by Block instructions. builder ( ScheduleBuilder ) \u2013 Provides channel information. schedule ( Schedule ) \u2013 Schedule to process. Deep copy of schedule with Wait instructions merged. Schedule previous iqm.cpc.compiler.dd.insert_dd_sequences next iqm.cpc.compiler.dd.DDError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.interface.compiler.HeraldingMode",
    "url": "/iqm-pulla/api/iqm.cpc.interface.compiler.HeraldingMode.html",
    "description": "Bases: StrEnum Heralding mode for circuit execution. Attributes NONE Do not do any heralding. ZEROS Perform a heralding measurement on all the components used in each circuit (if they have measurement...",
    "content": "Bases: StrEnum Heralding mode for circuit execution. Attributes NONE Do not do any heralding. ZEROS Perform a heralding measurement on all the components used in each circuit (if they have measurement data available in the calset), only retain shots where all the components are measured to be in the zero state. Methods __format__ (format_spec,\u00a0/) Return a formatted version of the string as described by format_spec. __new__ (value)  __str__ () Return str(self). Do not do any heralding. Perform a heralding measurement on all the components used in each circuit (if they have\nmeasurement data available in the calset), only retain shots where all the components\nare measured to be in the zero state. previous iqm.cpc.interface.compiler.DDStrategy next iqm.cpc.interface.compiler.MeasurementMode By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.CircuitError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.CircuitError.html",
    "description": "There is something wrong with the quantum circuit. previous iqm.cpc.compiler.errors.CalibrationError next iqm.cpc.compiler.errors.ClientError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland...",
    "content": "There is something wrong with the quantum circuit. previous iqm.cpc.compiler.errors.CalibrationError next iqm.cpc.compiler.errors.ClientError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.interface.StationControlResult",
    "url": "/iqm-pulla/api/iqm.pulla.interface.StationControlResult.html",
    "description": "Bases: object Result of a station control task Attributes end_time Time when the sweep ended in the station control message Information about task failure result Sweep results converted to the circuit...",
    "content": "Bases: object Result of a station control task Attributes end_time Time when the sweep ended in the station control message Information about task failure result Sweep results converted to the circuit measurement results expected by the client start_time Time when the sweep began in the station control sweep_id ID of the executed sweep task_id ID of the station control task status Status of the station control task Methods __eq__ (other) Return self==value. __repr__ () Return repr(self). sweep_id ( UUID ) \u2013 task_id ( UUID ) \u2013 status ( TaskStatus ) \u2013 start_time ( str | None ) \u2013 end_time ( str | None ) \u2013 result ( list [ dict [ str , list [ list [ int ] ] ] ] | None ) \u2013 message ( str | None ) \u2013 ID of the executed sweep ID of the station control task Status of the station control task Time when the sweep began in the station control Time when the sweep ended in the station control Sweep results converted to the circuit measurement results expected by the client Information about task failure previous iqm.pulla.interface.Instruction next iqm.pulla.interface.TaskStatus By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.standard_stages.map_old_operations",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.standard_stages.map_old_operations.html",
    "description": "Map backwards-compatible aliases for quantum operation names into the current name. circuits ( Iterable [ Circuit ] ) \u2013 previous iqm.cpc.compiler.standard_stages.map_components next iqm.cpc.compiler.s...",
    "content": "Map backwards-compatible aliases for quantum operation names into the current name. circuits ( Iterable [ Circuit ] ) \u2013 previous iqm.cpc.compiler.standard_stages.map_components next iqm.cpc.compiler.standard_stages.merge_multiplexed_timeboxes By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.station_settings.Map",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.station_settings.Map.html",
    "description": "Bases: object Mapping from a calibration observation path to a corresponding station settings path. If settings_path_template is None , it is derived from observation_path_template . A Parameter objec...",
    "content": "Bases: object Mapping from a calibration observation path to a corresponding station settings path. If settings_path_template is None , it is derived from observation_path_template . A Parameter object is included in the mapping to conveniently handle the unit and data type.\nIts name is unused. Attributes required  settings_path_template  parameter  observation_path_template  Methods __delattr__ (name) Implement delattr(self, name). __eq__ (other) Return self==value. __hash__ () Return hash(self). __repr__ () Return repr(self). __setattr__ (name,\u00a0value) Implement setattr(self, name, value). observation_path (component) Observation path for the given component. settings_path (component) Settings path for the given component. parameter ( Parameter ) \u2013 observation_path_template ( str ) \u2013 settings_path_template ( str | None ) \u2013 required ( bool ) \u2013 Observation path for the given component. component ( str ) \u2013 str Settings path for the given component. component ( str ) \u2013 str previous iqm.cpc.compiler.station_settings.find_observation next iqm.cpc.interface By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.interface",
    "url": "/iqm-pulla/api/iqm.pulla.interface.html",
    "description": "Common data types and exceptions for the IQM Pulla interface. Many of these must be identical to those in iqm-client. Module Attributes CircuitMeasurementResults Measurement results from a single circ...",
    "content": "Common data types and exceptions for the IQM Pulla interface. Many of these must be identical to those in iqm-client. Module Attributes CircuitMeasurementResults Measurement results from a single circuit/schedule. CircuitMeasurementResultsBatch Type that represents measurement results for a batch of circuits. BUFFER_AFTER_MEASUREMENT_PROBE Buffer that allows the readout resonator and qubit state to stabilize after a probe pulse, in s. Classes Circuit (*,\u00a0name,\u00a0instructions[,\u00a0metadata]) Quantum circuit to be executed. Instruction (*,\u00a0name[,\u00a0implementation]) An instruction in a quantum circuit. StationControlResult (sweep_id,\u00a0task_id,\u00a0status) Result of a station control task TaskStatus (value[,\u00a0names,\u00a0module,\u00a0qualname,\u00a0...]) Status of a Station Control task. Exceptions CHADRetrievalException Exception for CHAD retrieval failures. ChipLabelRetrievalException Exception for chip label retrieval failures. SettingsRetrievalException Exception for Station Control settings retrieval failures. Inheritance previous iqm.pulla.calibration.CalibrationDataProvider next iqm.pulla.interface.CircuitMeasurementResults By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils.print_schedule",
    "url": "/iqm-pulla/api/iqm.pulla.utils.print_schedule.html",
    "description": "Print all instructions in each segment of a schedule. schedule ( Schedule ) \u2013 The schedule to print None previous iqm.pulla.utils.print_channel next iqm.pulla.utils.replace_instruction_in_place By IQM...",
    "content": "Print all instructions in each segment of a schedule. schedule ( Schedule ) \u2013 The schedule to print None previous iqm.pulla.utils.print_channel next iqm.pulla.utils.replace_instruction_in_place By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.dd.DDError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.dd.DDError.html",
    "description": "Something was wrong in user input for dynamical decoupling. previous iqm.cpc.compiler.dd.merge_wait_instructions_in_schedule next iqm.cpc.compiler.errors By IQM Pulla developers \u00a9 Copyright 2024-2025,...",
    "content": "Something was wrong in user input for dynamical decoupling. previous iqm.cpc.compiler.dd.merge_wait_instructions_in_schedule next iqm.cpc.compiler.errors By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.html",
    "description": "Definitions of error classes used to raise issues during circuit compilation. Exceptions CalibrationError A required calibration observation is missing from the calibration set, or an unknown gate cal...",
    "content": "Definitions of error classes used to raise issues during circuit compilation. Exceptions CalibrationError A required calibration observation is missing from the calibration set, or an unknown gate calibration observation is encountered. CircuitError There is something wrong with the quantum circuit. ClientError Client submitted a bad request, and needs to be notified. CompilationPassError There is something wrong with the compilation pass. InsufficientContextError The context provided to the compilation pass does not contain all necessary fields. SettingsConventionError While parsing Station Control settings, something breaks a structural or naming convention. UnknownCircuitExecutionOptionError An unsupported value was used in circuit execution options. UnknownHardwareComponentError Circuit contains a reference to an unknown hardware component. UnknownLogicalQubitError A logical qubit in the circuit has not been defined in the qubit mapping. previous iqm.cpc.compiler.dd.DDError next iqm.cpc.compiler.errors.CalibrationError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils_qiskit.IQMPullaBackend",
    "url": "/iqm-pulla/api/iqm.pulla.utils_qiskit.IQMPullaBackend.html",
    "description": "Bases: IQMBackendBase A backend that compiles circuits locally using Pulla and submits them to Station Control for execution. architecture ( DynamicQuantumArchitecture ) \u2013 Describes the backend archit...",
    "content": "Bases: IQMBackendBase A backend that compiles circuits locally using Pulla and submits them to Station Control for execution. architecture ( DynamicQuantumArchitecture ) \u2013 Describes the backend architecture. pulla ( Pulla ) \u2013 Instance of Pulla used to execute the circuits. compiler ( Compiler ) \u2013 Instance of Compiler used to compile the circuits. Attributes max_circuits The maximum number of circuits (or Pulse schedules) that can be run in a single job. architecture Dynamic quantum architecture of the backend instance. name Name of the backend. description Optional human-readable description. online_date Date that the backend came online. backend_version Version of the backend being provided. Methods _default_options () Return the default options run (run_input,\u00a0**options) Run on the backend. Run on the backend. This method returns a Job object\nthat runs circuits. Depending on the backend this may be either an async\nor sync call. It is at the discretion of the provider to decide whether\nrunning should block until the execution is finished or not: the Job\nclass can handle either situation. run_input ( QuantumCircuit or Schedule or ScheduleBlock or list ) \u2013 An\nindividual or a list of QuantumCircuit , ScheduleBlock , or Schedule objects to\nrun on the backend. options \u2013 Any kwarg options to pass to the backend for running the\nconfig. If a key is also present in the options\nattribute/object then the expectation is that the value\nspecified will be used instead of what\u2019s set in the options\nobject. The job object for the run Job The maximum number of circuits (or Pulse schedules) that can be\nrun in a single job. If there is no limit this will return None previous iqm.pulla.utils_qiskit.DummyJob next Common errors By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.interface.compiler.CircuitMetrics",
    "url": "/iqm-pulla/api/iqm.cpc.interface.compiler.CircuitMetrics.html",
    "description": "Bases: object Metrics describing a circuit and its compilation result. Attributes min_execution_time shots * (instruction schedule duration + reset), in seconds. schedule_duration Duration of the inst...",
    "content": "Bases: object Metrics describing a circuit and its compilation result. Attributes min_execution_time shots * (instruction schedule duration + reset), in seconds. schedule_duration Duration of the instruction schedule created for the circuit, in seconds. components Locus components used in the circuit. component_pairs_with_gates Pairs of locus components which have two-component gates between them in the circuit. gate_loci Mapping from operation name to mapping from implementation name to a counter of loci of that operation in the circuit. Methods __eq__ (other) Return self==value. __repr__ () Return repr(self). components ( frozenset [ str ] ) \u2013 component_pairs_with_gates ( frozenset [ tuple [ str , str ] ] ) \u2013 gate_loci ( dict [ str , dict [ str , Counter [ tuple [ str , ... ] ] ] ] ) \u2013 schedule_duration ( float ) \u2013 min_execution_time ( float ) \u2013 Locus components used in the circuit. Pairs of locus components which have two-component gates between them in the circuit. Mapping from operation name to mapping from implementation name to a counter of loci of\nthat operation in the circuit. Duration of the instruction schedule created for the circuit, in seconds. shots * (instruction schedule duration + reset), in seconds. Lower bound on the actual execution time previous iqm.cpc.interface.compiler.CircuitExecutionOptions next iqm.cpc.interface.compiler.DDMode By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils.InstructionLocation",
    "url": "/iqm-pulla/api/iqm.pulla.utils.InstructionLocation.html",
    "description": "Bases: tuple Return type for locate_instructions() . Attributes channel_name Alias for field number 0 duration Alias for field number 2 index Alias for field number 1 Methods __getnewargs__ () Return ...",
    "content": "Bases: tuple Return type for locate_instructions() . Attributes channel_name Alias for field number 0 duration Alias for field number 2 index Alias for field number 1 Methods __getnewargs__ () Return self as a plain tuple. __new__ (_cls,\u00a0channel_name,\u00a0index,\u00a0duration) Create new instance of InstructionLocation(channel_name, index, duration) __repr__ () Return a nicely formatted representation string _asdict () Return a new dict which maps field names to their values. _make (iterable) Make a new InstructionLocation object from a sequence or iterable _replace (**kwds) Return a new InstructionLocation object replacing specified fields with new values Alias for field number 0 Alias for field number 2 Alias for field number 1 previous iqm.pulla.utils next iqm.pulla.utils.build_settings By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.compiler.Compiler",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.compiler.Compiler.html",
    "description": "Bases: object Stateful object that contains a calibration set, a schedule builder, and a set\nof compilation stages. The compiler\u2019s state does not include the data to be compiled. calibration_set ( Cal...",
    "content": "Bases: object Stateful object that contains a calibration set, a schedule builder, and a set\nof compilation stages. The compiler\u2019s state does not include the data to be compiled. calibration_set ( CalibrationSet ) \u2013 Calibration data. chip_topology ( ChipTopology ) \u2013 Physical layout and connectivity of the quantum chip. channel_properties ( dict [ str , ChannelProperties ] ) \u2013 Channel properties. component_channels ( dict [ str , dict [ str , str ] ] ) \u2013 Mapping between components and their control channels. component_mapping ( dict [ str , str ] | None ) \u2013 Custom mapping of components. Defaults to None. options ( CircuitExecutionOptions ) \u2013 Circuit execution options.\nDefaults to STANDARD_CIRCUIT_EXECUTION_OPTIONS. stages ( list [ CompilationStage ] | None ) \u2013 List of compilation stages. Defaults to None.\nNote that in the absence of stages, the compiler will not be ready to compile circuits. strict ( bool ) \u2013 If True, raises CalibrationError on calibration validation failures.\nIf False, only logs warnings. Defaults to False. CalibrationError \u2013 When strict=True and calibration validation fails during compiler initialization. Attributes gates Registered quantum gates. Methods _refresh () Refresh the compiler by re-creating the ScheduleBuilder and validating the calibration. add_implementation (op_name,\u00a0impl_name,\u00a0...) Adds a new implementation of a quantum operation (gate). amend_calibration_for_gate_implementation (...) Update the current local calibration set with calibration values for a specific gate/implementation/locus. build_settings (context,\u00a0shots) Build the settings for the execution. compile (data[,\u00a0context]) Run all compiler stages. compiler_context () Return initial compiler context dictionary. get_calibration () Returns a copy of the current local calibration set. print_all_implementations_trees () Prints all implementations of all currently known quantum operations (gates), including parameters. print_implementations_trees (op) Prints all implementation of a particular quantum operation (gate). ready () Check if the compiler is ready to compile circuits. set_calibration (calibration) Sets the current calibration set to a given calibration set, then refreshes the compiler. set_default_implementation (gate_name,\u00a0...) Set the default implementation of a gate. set_default_implementation_for_loci (...) Set the default implementation for a gate for a specific loci. show_stages ([full]) Print the stages and passes defined in the compiler. Returns a copy of the current local calibration set. dict [ str , bool | str | int | float | complex | ndarray ] Sets the current calibration set to a given calibration set, then refreshes the compiler. calibration ( dict [ str , bool | str | int | float | complex | ndarray ] ) \u2013 The calibration set to be set as the current calibration set. None Registered quantum gates. Set the default implementation of a gate. gate_name ( str ) \u2013 Name of the gate. implementation_name ( str ) \u2013 Name of the implementation to set as the default. None Set the default implementation for a gate for a specific loci. gate_name ( str ) \u2013 Name of the gate. implementation_name ( str ) \u2013 Name of the implementation to set as the default for loci . loci ( Iterable [ tuple [ str , ... ] ] ) \u2013 Loci of the gate for which to set implementation_name as the default. None Update the current local calibration set with calibration values for a specific gate/implementation/locus. The calibration values are given as a dictionary\nof parameter names and their values. This method refreshes the compiler after amending the calibration set. gate_name ( str ) \u2013 Name of the gate to which the calibration values are applied. impl_name ( str ) \u2013 Name of the implementation of the gate to which the calibration values are applied. locus ( tuple [ str , ... ] ) \u2013 Locus of the gate to which the calibration values are applied. params ( dict [ str , Any ] ) \u2013 Updated parameter names and their values. None Adds a new implementation of a quantum operation (gate). Refreshes the compiler after adding a new implementation. op_name ( str ) \u2013 The gate name for which to register a new implementation. impl_name ( str ) \u2013 The \u201chuman-readable\u201d name with which the new gate implementation will be found e.g. in settings. implementation ( type [ GateImplementation ] ) \u2013 The python class of the new gate implementation to be added. set_as_default ( bool ) \u2013 Whether to set the new implementation as the default implementation for the gate. overwrite ( bool ) \u2013 If True, allows replacing any existing implementation of the same name. quantum_op_specs ( QuantumOp | dict | None ) \u2013 The quantum operation this gate represents. If a QuantumOp is given, it is used as is.\nIf None is given and the same gate has been registered before, the previously registered properties are\nused.\nOtherwise, the given dict values are given to the constructor of QuantumOp .\nFor any missing constructor values, some defaults suitable for a 1-QB gate are used. None Check if the compiler is ready to compile circuits. The compiler is ready if at least one stage is defined, and\nall the stages are non-empty. bool Prints all implementations of all currently known quantum operations (gates), including parameters. None Prints all implementation of a particular quantum operation (gate). op ( QuantumOp ) \u2013 Quantum operation (gate) to print implementations of. None Print the stages and passes defined in the compiler. full ( bool ) \u2013 Iff True, also print the docstring of each pass function. None Return initial compiler context dictionary. Used automatically by Compiler.compile() . dict [ str , Any ] Run all compiler stages. Initial context will be derived from Compiler.compiler_context() unless a custom\ncontext dictionary is provided. data ( Iterable [ Any ] ) \u2013 An iterable of circuits to be compiled. context ( dict [ str , Any ] | None ) \u2013 Custom initial compiler context dictionary. tuple [ Iterable [ Any ], dict [ str , Any ]] Build the settings for the execution. Updates context[\u201ccircuit_metrics\u201d] with schedule_duration and\nmin_execution_time. context ( dict [ str , Any ] ) \u2013 A dictionary containing the necessary data for building the settings. shots ( int ) \u2013 The number of shots to be executed. A dictionary containing the settings for the execution.\ncontext: The updated context. settings previous iqm.cpc.compiler.compiler.CompilationStage next iqm.cpc.compiler.dd By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.standard_stages.multiplex_readout",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.standard_stages.multiplex_readout.html",
    "description": "Merge any MultiplexedProbeTimeBoxes inside a TimeBox representing a circuit. timeboxes ( Iterable [ TimeBox ] ) \u2013 previous iqm.cpc.compiler.standard_stages.merge_multiplexed_timeboxes next iqm.cpc.com...",
    "content": "Merge any MultiplexedProbeTimeBoxes inside a TimeBox representing a circuit. timeboxes ( Iterable [ TimeBox ] ) \u2013 previous iqm.cpc.compiler.standard_stages.merge_multiplexed_timeboxes next iqm.cpc.compiler.standard_stages.prepend_heralding By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.dd.STANDARD_DD_STRATEGY",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.dd.STANDARD_DD_STRATEGY.html",
    "description": "The default DD strategy uses the following gate sequences: Simple symmetric CPMG sequence for short idling times. Asymmetric (left-aligned) universal XY4 sequence for medium idling times. Asymmetric (...",
    "content": "The default DD strategy uses the following gate sequences: Simple symmetric CPMG sequence for short idling times. Asymmetric (left-aligned) universal XY4 sequence for medium idling times. Asymmetric (left-aligned) universal EDD sequence for longer idling times. previous iqm.cpc.compiler.dd next iqm.cpc.compiler.dd.insert_dd_sequences By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.interface.compiler.CircuitExecutionOptions",
    "url": "/iqm-pulla/api/iqm.cpc.interface.compiler.CircuitExecutionOptions.html",
    "description": "Bases: object Various discrete options for quantum circuit execution. Attributes measurement_mode  heralding_mode  dd_mode  dd_strategy  circuit_boundary_mode  move_gate_validation  move_gate_frame_tr...",
    "content": "Bases: object Various discrete options for quantum circuit execution. Attributes measurement_mode  heralding_mode  dd_mode  dd_strategy  circuit_boundary_mode  move_gate_validation  move_gate_frame_tracking  active_reset_cycles  Methods __delattr__ (name) Implement delattr(self, name). __eq__ (other) Return self==value. __hash__ () Return hash(self). __repr__ () Return repr(self). __setattr__ (name,\u00a0value) Implement setattr(self, name, value). measurement_mode ( MeasurementMode ) \u2013 heralding_mode ( HeraldingMode ) \u2013 dd_mode ( DDMode ) \u2013 dd_strategy ( DDStrategy | None ) \u2013 circuit_boundary_mode ( CircuitBoundaryMode ) \u2013 move_gate_validation ( MoveGateValidationMode ) \u2013 move_gate_frame_tracking ( MoveGateFrameTrackingMode ) \u2013 active_reset_cycles ( int | None ) \u2013 previous iqm.cpc.interface.compiler.CircuitCompilationResult next iqm.cpc.interface.compiler.CircuitMetrics By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.dd.insert_dd_sequences",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.dd.insert_dd_sequences.html",
    "description": "Insert dynamical decoupling sequences into the given schedule. Note Modifies schedule in-place. Note Assumes that the PRX implementation used only applies non-wait instructions on a single drive chann...",
    "content": "Insert dynamical decoupling sequences into the given schedule. Note Modifies schedule in-place. Note Assumes that the PRX implementation used only applies non-wait instructions on a single drive channel,\nand that the PRX duration does not depend on its arguments. builder ( ScheduleBuilder ) \u2013 Schedule builder used to build schedule , containing channel information. schedule ( Schedule ) \u2013 Schedule to modify. strategy ( DDStrategy ) \u2013 Dynamical decoupling strategy to use. None previous iqm.cpc.compiler.dd.STANDARD_DD_STRATEGY next iqm.cpc.compiler.dd.merge_wait_instructions_in_schedule By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.interface.ChipLabelRetrievalException",
    "url": "/iqm-pulla/api/iqm.pulla.interface.ChipLabelRetrievalException.html",
    "description": "Exception for chip label retrieval failures. previous iqm.pulla.interface.CHADRetrievalException next iqm.pulla.interface.SettingsRetrievalException By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM ...",
    "content": "Exception for chip label retrieval failures. previous iqm.pulla.interface.CHADRetrievalException next iqm.pulla.interface.SettingsRetrievalException By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.compiler.pass_function_idempotent",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.compiler.pass_function_idempotent.html",
    "description": "Wrap a pass function to make it idempotent. function ( Callable [ [ Any , dict [ str , Any ] ] , tuple [ Any , dict [ str , Any ] ] ] ) \u2013 Callable [[ Any , dict [ str , Any ]], tuple [ Any , dict [ st...",
    "content": "Wrap a pass function to make it idempotent. function ( Callable [ [ Any , dict [ str , Any ] ] , tuple [ Any , dict [ str , Any ] ] ] ) \u2013 Callable [[ Any , dict [ str , Any ]], tuple [ Any , dict [ str , Any ]]] previous iqm.cpc.compiler.compiler.compiler_pass next iqm.cpc.compiler.compiler.CompilationStage By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.standard_stages.apply_dd_strategy",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.standard_stages.apply_dd_strategy.html",
    "description": "Insert dynamical decoupling sequences into the schedules, if dynamical decoupling is enabled. schedules ( Iterable [ Schedule ] ) \u2013 builder ( ScheduleBuilder ) \u2013 options ( CircuitExecutionOptions ) \u2013 ...",
    "content": "Insert dynamical decoupling sequences into the schedules, if dynamical decoupling is enabled. schedules ( Iterable [ Schedule ] ) \u2013 builder ( ScheduleBuilder ) \u2013 options ( CircuitExecutionOptions ) \u2013 list [ Schedule ] previous iqm.cpc.compiler.standard_stages next iqm.cpc.compiler.standard_stages.apply_move_gate_phase_corrections By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.standard_stages.merge_multiplexed_timeboxes",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.standard_stages.merge_multiplexed_timeboxes.html",
    "description": "Merge any MultiplexedProbeTimeBoxes inside a TimeBox representing a circuit. This pass optimizes a situation where multiple \u201cmeasure\u201d gates on disjoint set of loci exist sequentially in the\ncircuit.\nW...",
    "content": "Merge any MultiplexedProbeTimeBoxes inside a TimeBox representing a circuit. This pass optimizes a situation where multiple \u201cmeasure\u201d gates on disjoint set of loci exist sequentially in the\ncircuit.\nWithout optimization, each gate would result in a separate trigger event, which results in worse performance.\nFor example, with the measurement instructions [M(QB1), M(QB2), M(QB3)], we\u2019d first measure QB1, then QB2, then QB3.\nThis optimization merges the measurement timeboxes, so that we\u2019ll measure QB1, QB2, and QB3 at the same time\n(if the hardware channel configuration allows it), corresponding to M(QB1, QB2, QB3). Goes through the children of circuit_box , and places them in the same temporal order.\nWhenever a MultiplexedProbeTimeBox is encountered (i.e. from a measure gate), it is merged with the previous pending\nMultiplexedProbeTimeBox and left pending.\nIf any other box type with colliding loci is encountered, first places the pending MultiplexedProbeTimeBox.\nThis essentially delays all measurements until the last possible moment. circuit_box ( TimeBox ) \u2013 Timebox representing a circuit, where each child should represent a single gate. A new Timebox with the same content, except with some MultiplexedProbeTimeBoxes merged. TimeBox previous iqm.cpc.compiler.standard_stages.map_old_operations next iqm.cpc.compiler.standard_stages.multiplex_readout By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.interface.compiler.MoveGateFrameTrackingMode",
    "url": "/iqm-pulla/api/iqm.cpc.interface.compiler.MoveGateFrameTrackingMode.html",
    "description": "Bases: StrEnum MOVE gate frame tracking mode for circuit compilation. Attributes FULL Perform complete MOVE gate frame tracking, applying both the explicit z rotations on the resonator and the dynamic...",
    "content": "Bases: StrEnum MOVE gate frame tracking mode for circuit compilation. Attributes FULL Perform complete MOVE gate frame tracking, applying both the explicit z rotations on the resonator and the dynamic phase correction due to qubit-resonator detuning to the qubit at the end of a MOVE sandwich. NO_DETUNING_CORRECTION Do not apply the detuning correction at the end of a MOVE sandwich. NONE Do not perform any MOVE gate frame tracking. Methods __format__ (format_spec,\u00a0/) Return a formatted version of the string as described by format_spec. __new__ (value)  __str__ () Return str(self). Perform complete MOVE gate frame tracking, applying both the explicit z rotations\non the resonator and the dynamic phase correction due to qubit-resonator detuning to\nthe qubit at the end of a MOVE sandwich. Do not apply the detuning correction at the end of a MOVE sandwich. Do not perform any MOVE gate frame tracking. previous iqm.cpc.interface.compiler.MeasurementMode next iqm.cpc.interface.compiler.MoveGateValidationMode By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.standard_stages",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.standard_stages.html",
    "description": "Standard compilation stages, their constituent compiler passes, and functions for implementing them. There are 6 standard compilation stages: Circuit-to-circuit. Circuit-to-timebox. Timebox-to-timebox...",
    "content": "Standard compilation stages, their constituent compiler passes, and functions for implementing them. There are 6 standard compilation stages: Circuit-to-circuit. Circuit-to-timebox. Timebox-to-timebox. Timebox-to-schedule. Schedule-to-schedule. Schedule-to-playlist. Breakdown of compiler passes of each stage: Validate the circuit execution options. Map backwards-compatible aliases for quantum operation names into the current name. This is needed until old\noperation names such as phased_rx and measurement are no longer supported. Validate the contents of the circuits. Map the logical QPU components to physical QPU components. Provided mapping is used, if any.\nOtherwise, identity mapping is used. Choose implementations for circuit operations based on the calibration set. Derive mapping between station acquisition labels and user\u2019s measurement keys. Populates readout_mappings and heralded_components of context. Resolve the circuits to timeboxes using ScheduleBuilder.circuit_to_timebox() . Merge any MultiplexedProbeTimeBoxes inside each TimeBox using TimeBox.composite() . Add the heralding measurement timebox to all circuits if HeraldingMode in circuit execution options\nrequires it. Add a reset timebox to all circuits. Resolve the timeboxes to schedules using ScheduleBuilder.resolve_timebox() . Apply dynamical decoupling sequences to the schedule if requested. Apply resonator-related phase corrections if MOVE gates are used. Remove non-functional instructions from schedules using ScheduleBuilder._finish_schedule() . Build the playlist from the schedules using ScheduleBuilder.build_playlist() . Functions apply_dd_strategy (schedules,\u00a0builder,\u00a0options) Insert dynamical decoupling sequences into the schedules, if dynamical decoupling is enabled. apply_move_gate_phase_corrections (schedules,\u00a0...) Apply calibrated phase corrections if MOVE gates are used. build_playlist (schedules,\u00a0builder) Build the playlist from the schedules. choose_op_implementations (circuits,\u00a0builder,\u00a0...) Analyze the instructions in the circuits and pick an implementation for each (operation, locus). clean_schedule (schedules,\u00a0builder) Remove non-functional instructions from schedules . derive_readout_mappings (circuits,\u00a0builder,\u00a0...) Derive mapping between station acquisition labels and user's measurement keys. get_standard_stages ([idempotent]) Get a copy of the standard compilation stages. map_components (circuits,\u00a0builder,\u00a0...) Map the logical QPU components to physical QPU components using component_mapping . map_old_operations (circuits) Map backwards-compatible aliases for quantum operation names into the current name. merge_multiplexed_timeboxes (circuit_box) Merge any MultiplexedProbeTimeBoxes inside a TimeBox representing a circuit. multiplex_readout (timeboxes) Merge any MultiplexedProbeTimeBoxes inside a TimeBox representing a circuit. prepend_heralding (timeboxes,\u00a0builder,\u00a0...) Add the heralding measurement timebox to all circuits. prepend_reset (timeboxes,\u00a0builder,\u00a0options,\u00a0...) Add a reset timebox to all circuits. resolve_circuits (circuits,\u00a0builder) Resolve the circuits to timeboxes. resolve_timeboxes (timeboxes,\u00a0builder) Resolve the timeboxes to schedules. validate_circuits (circuits,\u00a0builder) Validate the contents of the quantum circuits. validate_execution_options (circuits,\u00a0options) Validate the circuit execution options (only some combinations make sense). previous iqm.cpc.compiler.errors.UnknownLogicalQubitError next iqm.cpc.compiler.standard_stages.apply_dd_strategy By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.interface.compiler.ReadoutMapping",
    "url": "/iqm-pulla/api/iqm.cpc.interface.compiler.ReadoutMapping.html",
    "description": "Type for matching measurement keys from the quantum circuit with acquisition labels in Station Control. In quantum circuits, measurements are identified by measurement keys.\nMeasurements in Station Co...",
    "content": "Type for matching measurement keys from the quantum circuit with acquisition labels in Station Control. In quantum circuits, measurements are identified by measurement keys.\nMeasurements in Station Control are identified by acquisition labels specific to a readout controller.\nThis type is a dictionary mapping measurement keys to lists of acquisition labels \u2014 each acquisition\nlabel should hold the readout of a single qubit at a single point in the circuit, and the order in\nthe list corresponds to the order of qubits in the measurement instruction. E.g. if one has\nmeasurement instruction with key='mk' and qubits=[QB2, QB1] , then the corresponding entry in\nthis dict would be 'mk': ('QB2__mk', 'QB1__mk') The values of the ReadoutMapping are used to determine which measurement results Station Control\nshould return to Cocos. alias of dict [ str , tuple [ str , \u2026]] previous iqm.cpc.interface.compiler.PRXSequence next iqm.cpc.interface.compiler.ReadoutMappingBatch By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.standard_stages.derive_readout_mappings",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.standard_stages.derive_readout_mappings.html",
    "description": "Derive mapping between station acquisition labels and user\u2019s measurement keys. circuits ( Iterable [ Circuit ] ) \u2013 builder ( ScheduleBuilder ) \u2013 options ( CircuitExecutionOptions ) \u2013 circuit_metrics (...",
    "content": "Derive mapping between station acquisition labels and user\u2019s measurement keys. circuits ( Iterable [ Circuit ] ) \u2013 builder ( ScheduleBuilder ) \u2013 options ( CircuitExecutionOptions ) \u2013 circuit_metrics ( Iterable [ CircuitMetrics ] ) \u2013 tuple [ list [ Circuit ], dict [ str , Any ]] previous iqm.cpc.compiler.standard_stages.clean_schedule next iqm.cpc.compiler.standard_stages.get_standard_stages By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.interface.CircuitMeasurementResults",
    "url": "/iqm-pulla/api/iqm.pulla.interface.CircuitMeasurementResults.html",
    "description": "Measurement results from a single circuit/schedule. For each measurement operation in the circuit,\nmaps the measurement key to the corresponding results. The outer list elements correspond to shots,\na...",
    "content": "Measurement results from a single circuit/schedule. For each measurement operation in the circuit,\nmaps the measurement key to the corresponding results. The outer list elements correspond to shots,\nand the inner list elements to the qubits measured in the measurement operation. alias of dict [ str , list [ list [ int ]]] previous iqm.pulla.interface next iqm.pulla.interface.CircuitMeasurementResultsBatch By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.SettingsConventionError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.SettingsConventionError.html",
    "description": "While parsing Station Control settings, something breaks a structural or naming convention. previous iqm.cpc.compiler.errors.InsufficientContextError next iqm.cpc.compiler.errors.UnknownCircuitExecuti...",
    "content": "While parsing Station Control settings, something breaks a structural or naming convention. previous iqm.cpc.compiler.errors.InsufficientContextError next iqm.cpc.compiler.errors.UnknownCircuitExecutionOptionError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.html",
    "description": "Compile quantum circuits into instruction schedules and settings that can be executed on a station. Subpackages and modules circuit_compilation_request_handler Convert quantum circuits into instructio...",
    "content": "Compile quantum circuits into instruction schedules and settings that can be executed on a station. Subpackages and modules circuit_compilation_request_handler Convert quantum circuits into instruction schedules. compiler Convert quantum circuits into instruction schedules. dd Dynamical decoupling utilities. errors Definitions of error classes used to raise issues during circuit compilation. standard_stages Standard compilation stages, their constituent compiler passes, and functions for implementing them. station_settings Mapping calibration observations to station settings. previous iqm.cpc next iqm.cpc.compiler.circuit_compilation_request_handler By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.interface.compiler.PRXSequence",
    "url": "/iqm-pulla/api/iqm.cpc.interface.compiler.PRXSequence.html",
    "description": "A sequence of PRX gates. A generic PRX gate is defined by rotation angle and phase angle, Theta and Phi\nrespectively. alias of list [ tuple [ float , float ]] previous iqm.cpc.interface.compiler.Circu...",
    "content": "A sequence of PRX gates. A generic PRX gate is defined by rotation angle and phase angle, Theta and Phi\nrespectively. alias of list [ tuple [ float , float ]] previous iqm.cpc.interface.compiler.CircuitBatch next iqm.cpc.interface.compiler.ReadoutMapping By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.interface.compiler.DDMode",
    "url": "/iqm-pulla/api/iqm.cpc.interface.compiler.DDMode.html",
    "description": "Bases: StrEnum Dynamical Decoupling (DD) mode for circuit execution. Attributes DISABLED Do not apply dynamical decoupling. ENABLED Apply dynamical decoupling. Methods __format__ (format_spec,\u00a0/) Retu...",
    "content": "Bases: StrEnum Dynamical Decoupling (DD) mode for circuit execution. Attributes DISABLED Do not apply dynamical decoupling. ENABLED Apply dynamical decoupling. Methods __format__ (format_spec,\u00a0/) Return a formatted version of the string as described by format_spec. __new__ (value)  __str__ () Return str(self). Do not apply dynamical decoupling. Apply dynamical decoupling. previous iqm.cpc.interface.compiler.CircuitMetrics next iqm.cpc.interface.compiler.DDStrategy By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.standard_stages.choose_op_implementations",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.standard_stages.choose_op_implementations.html",
    "description": "Analyze the instructions in the circuits and pick an implementation for each (operation, locus). Note This function modifies circuits in place. circuits ( Iterable [ Circuit ] ) \u2013 builder ( ScheduleBu...",
    "content": "Analyze the instructions in the circuits and pick an implementation for each (operation, locus). Note This function modifies circuits in place. circuits ( Iterable [ Circuit ] ) \u2013 builder ( ScheduleBuilder ) \u2013 options ( CircuitExecutionOptions ) \u2013 tuple [ list [ Circuit ], dict [ str , Any ]] previous iqm.cpc.compiler.standard_stages.build_playlist next iqm.cpc.compiler.standard_stages.clean_schedule By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils.circuit_operations_to_cpc",
    "url": "/iqm-pulla/api/iqm.pulla.utils.circuit_operations_to_cpc.html",
    "description": "Convert a list of CircuitOperations to an IQM CPC Circuit. circ_ops ( tuple [ CircuitOperation ] ) \u2013 The CircuitOperations to convert. name ( str | None ) \u2013 Optional name of the circuit. The equivalen...",
    "content": "Convert a list of CircuitOperations to an IQM CPC Circuit. circ_ops ( tuple [ CircuitOperation ] ) \u2013 The CircuitOperations to convert. name ( str | None ) \u2013 Optional name of the circuit. The equivalent IQM CPC Circuit. Circuit previous iqm.pulla.utils.calset_to_cal_data_tree next iqm.pulla.utils.convert_sweep_spot By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.UnknownHardwareComponentError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.UnknownHardwareComponentError.html",
    "description": "Circuit contains a reference to an unknown hardware component. previous iqm.cpc.compiler.errors.UnknownCircuitExecutionOptionError next iqm.cpc.compiler.errors.UnknownLogicalQubitError By IQM Pulla de...",
    "content": "Circuit contains a reference to an unknown hardware component. previous iqm.cpc.compiler.errors.UnknownCircuitExecutionOptionError next iqm.cpc.compiler.errors.UnknownLogicalQubitError By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.standard_stages.validate_circuits",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.standard_stages.validate_circuits.html",
    "description": "Validate the contents of the quantum circuits. circuits ( Iterable [ Circuit ] ) \u2013 builder ( ScheduleBuilder ) \u2013 previous iqm.cpc.compiler.standard_stages.resolve_timeboxes next iqm.cpc.compiler.stand...",
    "content": "Validate the contents of the quantum circuits. circuits ( Iterable [ Circuit ] ) \u2013 builder ( ScheduleBuilder ) \u2013 previous iqm.cpc.compiler.standard_stages.resolve_timeboxes next iqm.cpc.compiler.standard_stages.validate_execution_options By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils.find_circuit_boundary",
    "url": "/iqm-pulla/api/iqm.pulla.utils.find_circuit_boundary.html",
    "description": "Determine the boundary of a circuit executed on the QPU. See CircuitBoundaryMode for the definitions of the circuit boundaries. mode ( CircuitBoundaryMode ) \u2013 method of determining the circuit border ...",
    "content": "Determine the boundary of a circuit executed on the QPU. See CircuitBoundaryMode for the definitions of the circuit boundaries. mode ( CircuitBoundaryMode ) \u2013 method of determining the circuit border circuit_components ( set [ str ] | frozenset [ str ] ) \u2013 all locus components used in the circuit circuit_couplers ( set [ str ] ) \u2013 all couplers used in the circuit to apply gates device ( ChipTopology ) \u2013 describes the QPU topology boundary locus components, boundary couplers UnknownCircuitExecutionOptionError \u2013 unknown mode tuple [ Set [ str ], Set [ str ]] previous iqm.pulla.utils.extract_readout_controller_result_names next iqm.pulla.utils.get_hash_for By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.interface.compiler.CircuitCompilationResult",
    "url": "/iqm-pulla/api/iqm.cpc.interface.compiler.CircuitCompilationResult.html",
    "description": "Bases: object Compiled circuit and associated settings returned by CPC to Cocos. Attributes playlist sequence of instruction schedules corresponding to the batch of circuits to be executed readout_map...",
    "content": "Bases: object Compiled circuit and associated settings returned by CPC to Cocos. Attributes playlist sequence of instruction schedules corresponding to the batch of circuits to be executed readout_mappings For each circuit in the batch, mapping from measurement keys to the names of readout controller result parameters that will hold the measurement results. settings Station Control settings node containing the settings for circuit execution circuit_metrics metrics describing the circuit and its compilation result for each circuit in the batch Methods __eq__ (other) Return self==value. __repr__ () Return repr(self). playlist ( Playlist ) \u2013 readout_mappings ( tuple [ dict [ str , tuple [ str , ... ] ] , ... ] ) \u2013 settings ( SettingNode ) \u2013 circuit_metrics ( tuple [ CircuitMetrics , ... ] ) \u2013 sequence of instruction schedules corresponding to the batch of circuits to be executed For each circuit in the batch, mapping from measurement keys to the names of readout\ncontroller result parameters that will hold the measurement results. If heralding is enabled, qubits\nwhich are not measured in the circuit itself but are heralded appear under the reserved key \u201c__herald. Station Control settings node containing the settings for circuit execution metrics describing the circuit and its compilation result for each circuit in the batch previous iqm.cpc.interface.compiler.CircuitBoundaryMode next iqm.cpc.interface.compiler.CircuitExecutionOptions By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils_qiskit.qiskit_to_pulla",
    "url": "/iqm-pulla/api/iqm.pulla.utils_qiskit.qiskit_to_pulla.html",
    "description": "Convert transpiled Qiskit quantum circuits to IQM Pulse quantum circuits. Also provides the Compiler object for compiling them, with the correct\ncalibration set and component mapping initialized. pull...",
    "content": "Convert transpiled Qiskit quantum circuits to IQM Pulse quantum circuits. Also provides the Compiler object for compiling them, with the correct\ncalibration set and component mapping initialized. pulla ( Pulla ) \u2013 Quantum computer pulse level access object. backend ( IQMBackend ) \u2013 qiskit-iqm backend used to transpile the circuits. Determines\nthe calibration set to be used by the returned compiler. qiskit_circuits ( QuantumCircuit | Sequence [ QuantumCircuit ] ) \u2013 One or many transpiled Qiskit QuantumCircuits to convert. Equivalent IQM Pulse circuit(s), compiler for compiling them. tuple [ list [CPC_Circuit], Compiler ] previous iqm.pulla.utils_qiskit.qiskit_circuits_to_pulla next iqm.pulla.utils_qiskit.station_control_result_to_qiskit By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.quantum_architecture.create_dynamic_quantum_architecture",
    "url": "/iqm-pulla/api/iqm.pulla.quantum_architecture.create_dynamic_quantum_architecture.html",
    "description": "Creates a dynamic quantum architecture (DQA) for the given calibration set. calibration_set_id ( UUID ) \u2013 ID of the calibration set used to create the DQA. observations ( list [ ObservationLite ] ) \u2013 ...",
    "content": "Creates a dynamic quantum architecture (DQA) for the given calibration set. calibration_set_id ( UUID ) \u2013 ID of the calibration set used to create the DQA. observations ( list [ ObservationLite ] ) \u2013 Calibration set observations used to create the DQA. chip_topology ( ChipTopology ) \u2013 The chip topology. Dynamic quantum architecture containing information about calibrated gates/operations. DynamicQuantumArchitecture previous iqm.pulla.quantum_architecture next iqm.pulla.quantum_architecture.create_static_quantum_architecture By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.interface.compiler.Circuit",
    "url": "/iqm-pulla/api/iqm.cpc.interface.compiler.Circuit.html",
    "description": "Bases: object Quantum circuit to be executed. Attributes name name of the circuit instructions operations comprising the circuit Methods __eq__ (other) Return self==value. __repr__ () Return repr(self...",
    "content": "Bases: object Quantum circuit to be executed. Attributes name name of the circuit instructions operations comprising the circuit Methods __eq__ (other) Return self==value. __repr__ () Return repr(self). name ( str ) \u2013 instructions ( tuple [ CircuitOperation , ... ] ) \u2013 name of the circuit operations comprising the circuit previous iqm.cpc.interface.compiler.ReadoutMappingBatch next iqm.cpc.interface.compiler.CircuitBoundaryMode By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.compiler.compiler_pass",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.compiler.compiler_pass.html",
    "description": "Convenience wrapper to create a valid compiler pass. When the wrapped function is called, the compilation data (e.g. circuits) is passed as the first argument.\nIf function has any other arguments, the...",
    "content": "Convenience wrapper to create a valid compiler pass. When the wrapped function is called, the compilation data (e.g. circuits) is passed as the first argument.\nIf function has any other arguments, the wrapper takes their values from the context dict.\nIf no matching key is found for a required argument, an error is raised. function` must return either a tuple of ``(data, ctx) where data is the\ncompilation result and ctx is a dict with any new context data, or only data .\nThe contents of ctx will be merged to the input context.\nNote the difference to a plain, unwrapped CompilationPass: not returning ctx is valid. Callable [[ Any , dict [ str , Any ]], tuple [ Any , dict [ str , Any ]]] previous iqm.cpc.compiler.compiler.PassFunction next iqm.cpc.compiler.compiler.pass_function_idempotent By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils_cirq",
    "url": "/iqm-pulla/api/iqm.pulla.utils_cirq.html",
    "description": "Utilities for working with Cirq objects. Functions cirq_to_cpc () Convert a Cirq Circuit to an IQM CPC Circuit. previous iqm.pulla.utils.replace_instruction_in_place next iqm.pulla.utils_cirq.cirq_to_...",
    "content": "Utilities for working with Cirq objects. Functions cirq_to_cpc () Convert a Cirq Circuit to an IQM CPC Circuit. previous iqm.pulla.utils.replace_instruction_in_place next iqm.pulla.utils_cirq.cirq_to_cpc By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.standard_stages.clean_schedule",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.standard_stages.clean_schedule.html",
    "description": "Remove non-functional instructions from schedules . schedules ( Iterable [ Schedule ] ) \u2013 builder ( ScheduleBuilder ) \u2013 list [ Schedule ] previous iqm.cpc.compiler.standard_stages.choose_op_implementa...",
    "content": "Remove non-functional instructions from schedules . schedules ( Iterable [ Schedule ] ) \u2013 builder ( ScheduleBuilder ) \u2013 list [ Schedule ] previous iqm.cpc.compiler.standard_stages.choose_op_implementations next iqm.cpc.compiler.standard_stages.derive_readout_mappings By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.standard_stages.apply_move_gate_phase_corrections",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.standard_stages.apply_move_gate_phase_corrections.html",
    "description": "Apply calibrated phase corrections if MOVE gates are used. schedules ( Iterable [ Schedule ] ) \u2013 builder ( ScheduleBuilder ) \u2013 circuit_metrics ( Iterable [ CircuitMetrics ] ) \u2013 options ( CircuitExecut...",
    "content": "Apply calibrated phase corrections if MOVE gates are used. schedules ( Iterable [ Schedule ] ) \u2013 builder ( ScheduleBuilder ) \u2013 circuit_metrics ( Iterable [ CircuitMetrics ] ) \u2013 options ( CircuitExecutionOptions ) \u2013 list [ Schedule ] previous iqm.cpc.compiler.standard_stages.apply_dd_strategy next iqm.cpc.compiler.standard_stages.build_playlist By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.interface.Instruction",
    "url": "/iqm-pulla/api/iqm.pulla.interface.Instruction.html",
    "description": "Bases: BaseModel An instruction in a quantum circuit. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name name of...",
    "content": "Bases: BaseModel An instruction in a quantum circuit. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name name of the quantum operation implementation name of the implementation qubits names of the logical qubits the operation acts on args arguments for the operation Methods to_dataclass () Convert the model to a dataclass. name ( str ) \u2013 implementation ( str | None ) \u2013 qubits ( tuple [ str , ... ] ) \u2013 args ( dict [ str , Any ] ) \u2013 name of the quantum operation name of the implementation names of the logical qubits the operation acts on arguments for the operation Convert the model to a dataclass. CircuitOperation Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.pulla.interface.Circuit next iqm.pulla.interface.StationControlResult By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils.print_channel",
    "url": "/iqm-pulla/api/iqm.pulla.utils.print_channel.html",
    "description": "Print all instructions in a channel of a schedule. schedule ( Schedule ) \u2013 The schedule to search. channel_name ( str ) \u2013 The name of the channel to print. None previous iqm.pulla.utils.map_sweep_resu...",
    "content": "Print all instructions in a channel of a schedule. schedule ( Schedule ) \u2013 The schedule to search. channel_name ( str ) \u2013 The name of the channel to print. None previous iqm.pulla.utils.map_sweep_results_to_logical_qubits next iqm.pulla.utils.print_schedule By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.compiler.PassFunction",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.compiler.PassFunction.html",
    "description": "A function that takes the data and context as arguments and returns the modified data and context.\nThe context is a dictionary that can contain any information that needs to be passed between the pass...",
    "content": "A function that takes the data and context as arguments and returns the modified data and context.\nThe context is a dictionary that can contain any information that needs to be passed between the passes. alias of Callable [ Any , dict [ str , Any ], tuple [ Any , dict [ str , Any ]]] previous iqm.cpc.compiler.compiler next iqm.cpc.compiler.compiler.compiler_pass By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils_qiskit.DummyJob",
    "url": "/iqm-pulla/api/iqm.pulla.utils_qiskit.DummyJob.html",
    "description": "Bases: JobV1 A dummy job object that can be used to retrieve the result of a locally compiled circuit. The job_id is the same as the sweep_id of the StationControlResult . Attributes Methods result ()...",
    "content": "Bases: JobV1 A dummy job object that can be used to retrieve the result of a locally compiled circuit. The job_id is the same as the sweep_id of the StationControlResult . Attributes Methods result () Return the results of the job. status () Return the status of the job, among the values of JobStatus . submit () Submit the job to the backend for execution. Return the results of the job. Return the status of the job, among the values of JobStatus . Submit the job to the backend for execution. previous iqm.pulla.utils_qiskit.station_control_result_to_qiskit next iqm.pulla.utils_qiskit.IQMPullaBackend By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.interface.CHADRetrievalException",
    "url": "/iqm-pulla/api/iqm.pulla.interface.CHADRetrievalException.html",
    "description": "Exception for CHAD retrieval failures. previous iqm.pulla.interface.TaskStatus next iqm.pulla.interface.ChipLabelRetrievalException By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Relea...",
    "content": "Exception for CHAD retrieval failures. previous iqm.pulla.interface.TaskStatus next iqm.pulla.interface.ChipLabelRetrievalException By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.interface.compiler.CircuitBatch",
    "url": "/iqm-pulla/api/iqm.cpc.interface.compiler.CircuitBatch.html",
    "description": "Type that represents a list of quantum circuits to be executed together in a single batch. alias of list [ Circuit ] previous iqm.cpc.interface.compiler next iqm.cpc.interface.compiler.PRXSequence By ...",
    "content": "Type that represents a list of quantum circuits to be executed together in a single batch. alias of list [ Circuit ] previous iqm.cpc.interface.compiler next iqm.cpc.interface.compiler.PRXSequence By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils_cirq.cirq_to_cpc",
    "url": "/iqm-pulla/api/iqm.pulla.utils_cirq.cirq_to_cpc.html",
    "description": "Convert a Cirq Circuit to an IQM CPC Circuit. previous iqm.pulla.utils_cirq next iqm.pulla.utils_dd By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-0...",
    "content": "Convert a Cirq Circuit to an IQM CPC Circuit. previous iqm.pulla.utils_cirq next iqm.pulla.utils_dd By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.compiler",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.compiler.html",
    "description": "Convert quantum circuits into instruction schedules. This is the core module of CPC . It contains the functionality to define a compiler, whose job is to\nconvert quantum circuits and calibration data ...",
    "content": "Convert quantum circuits into instruction schedules. This is the core module of CPC . It contains the functionality to define a compiler, whose job is to\nconvert quantum circuits and calibration data into configuration settings and instruction schedules that\ncan be executed by the IQM server on quantum hardware. Module Attributes PassFunction A function that takes the data and context as arguments and returns the modified data and context. Functions compiler_pass (function) Convenience wrapper to create a valid compiler pass. pass_function_idempotent (function) Wrap a pass function to make it idempotent. Classes CompilationStage (name) Sequence of compiler passes that are applied to the data. Compiler (*,\u00a0calibration_set,\u00a0chip_topology,\u00a0...) Stateful object that contains a calibration set, a schedule builder, and a set of compilation stages. Inheritance previous iqm.cpc.compiler.circuit_compilation_request_handler.handle_circuit_compilation_request next iqm.cpc.compiler.compiler.PassFunction By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils.convert_sweep_spot",
    "url": "/iqm-pulla/api/iqm.pulla.utils.convert_sweep_spot.html",
    "description": "Convert the sweep measurement results from Station Control into circuit measurement results. results ( dict [ str , ndarray ] ) \u2013 mapping of acquisition labels to 1D arrays of readout results with the...",
    "content": "Convert the sweep measurement results from Station Control into circuit measurement results. results ( dict [ str , ndarray ] ) \u2013 mapping of acquisition labels to 1D arrays of readout results with the length num_shots * num_triggers_for_label_in_batch readout_mappings ( tuple [ dict [ str , tuple [ str , ... ] ] , ... ] ) \u2013 for each circuit in the batch, a mapping of measurement keys to corresponding\ntuples of acquisition labels converted measurement results list [ dict [ str , list [ list [ int ]]]] previous iqm.pulla.utils.circuit_operations_to_cpc next iqm.pulla.utils.convert_sweep_spot_with_heralding_mode_zero By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.standard_stages.resolve_timeboxes",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.standard_stages.resolve_timeboxes.html",
    "description": "Resolve the timeboxes to schedules. timeboxes ( Iterable [ TimeBox ] ) \u2013 builder ( ScheduleBuilder ) \u2013 list [ Schedule ] previous iqm.cpc.compiler.standard_stages.resolve_circuits next iqm.cpc.compile...",
    "content": "Resolve the timeboxes to schedules. timeboxes ( Iterable [ TimeBox ] ) \u2013 builder ( ScheduleBuilder ) \u2013 list [ Schedule ] previous iqm.cpc.compiler.standard_stages.resolve_circuits next iqm.cpc.compiler.standard_stages.validate_circuits By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.errors.UnknownLogicalQubitError",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.errors.UnknownLogicalQubitError.html",
    "description": "A logical qubit in the circuit has not been defined in the qubit mapping. previous iqm.cpc.compiler.errors.UnknownHardwareComponentError next iqm.cpc.compiler.standard_stages By IQM Pulla developers \u00a9...",
    "content": "A logical qubit in the circuit has not been defined in the qubit mapping. previous iqm.cpc.compiler.errors.UnknownHardwareComponentError next iqm.cpc.compiler.standard_stages By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.interface.Circuit",
    "url": "/iqm-pulla/api/iqm.pulla.interface.Circuit.html",
    "description": "Bases: BaseModel Quantum circuit to be executed. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name name of the ...",
    "content": "Bases: BaseModel Quantum circuit to be executed. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name name of the circuit instructions instructions comprising the circuit metadata arbitrary metadata associated with the circuit Methods to_dataclass () Convert the model to a dataclass. name ( str ) \u2013 instructions ( tuple [ Instruction , ... ] ) \u2013 metadata ( dict [ str , Any ] | None ) \u2013 name of the circuit instructions comprising the circuit arbitrary metadata associated with the circuit Convert the model to a dataclass. Circuit Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.pulla.interface.BUFFER_AFTER_MEASUREMENT_PROBE next iqm.pulla.interface.Instruction By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils.replace_instruction_in_place",
    "url": "/iqm-pulla/api/iqm.pulla.utils.replace_instruction_in_place.html",
    "description": "Replace an instruction in a schedule with one or more instructions. schedule ( Schedule ) \u2013 The schedule to modify. channel_name ( str ) \u2013 The name of the channel containing the instruction to replace...",
    "content": "Replace an instruction in a schedule with one or more instructions. schedule ( Schedule ) \u2013 The schedule to modify. channel_name ( str ) \u2013 The name of the channel containing the instruction to replace. index ( int ) \u2013 The index of the instruction to replace. replacement ( Iterable [ Instruction ] ) \u2013 Instructions to replace the original instruction with. The modified schedule. Schedule previous iqm.pulla.utils.print_schedule next iqm.pulla.utils_cirq By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla",
    "url": "/iqm-pulla/api/iqm.pulla.html",
    "description": "Client-side library for Pulse-level access to IQM quantum computers. Subpackages and modules calibration Provider of calibration sets and quality metrics from remote IQM servers. interface Common data...",
    "content": "Client-side library for Pulse-level access to IQM quantum computers. Subpackages and modules calibration Provider of calibration sets and quality metrics from remote IQM servers. interface Common data types and exceptions for the IQM Pulla interface. pulla Pulse level access library for IQM's circuit-to-pulse compiler and Station Control API. quantum_architecture Methods for creating static and dynamic quantum architectures. utils Utility functions for IQM Pulla. utils_cirq Utilities for working with Cirq objects. utils_dd Utilities for working with Dynamical Decoupling. utils_qir Utilities for working with a QIR module. utils_qiskit Utilities for working with Qiskit objects. previous iqm.cpc.interface.compiler.MoveGateValidationMode next iqm.pulla.calibration By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.interface.compiler.CircuitBoundaryMode",
    "url": "/iqm-pulla/api/iqm.cpc.interface.compiler.CircuitBoundaryMode.html",
    "description": "Bases: StrEnum Circuit boundary mode for circuit compilation. Attributes NEIGHBOUR Circuit boundary consists of those QPU elements (qubits and couplers) that are adjacent to the qubits and couplers us...",
    "content": "Bases: StrEnum Circuit boundary mode for circuit compilation. Attributes NEIGHBOUR Circuit boundary consists of those QPU elements (qubits and couplers) that are adjacent to the qubits and couplers used by the circuit, but do not belong to them. ALL Circuit boundary consists of all the QPU elements that are not used in the circuit. Methods __format__ (format_spec,\u00a0/) Return a formatted version of the string as described by format_spec. __new__ (value)  __str__ () Return str(self). Circuit boundary consists of those QPU elements (qubits and couplers) that\nare adjacent to the qubits and couplers used by the circuit, but do not belong to them.\nSpecifically, Boundary qubits are connected to a circuit qubit by any coupler, but are not circuit qubits themselves. Boundary couplers are connected to at least one circuit qubit, but are not used in the circuit themselves. Circuit boundary consists of all the QPU elements that are not used in the circuit. previous iqm.cpc.interface.compiler.Circuit next iqm.cpc.interface.compiler.CircuitCompilationResult By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.interface.SettingsRetrievalException",
    "url": "/iqm-pulla/api/iqm.pulla.interface.SettingsRetrievalException.html",
    "description": "Exception for Station Control settings retrieval failures. previous iqm.pulla.interface.ChipLabelRetrievalException next iqm.pulla.pulla By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, ...",
    "content": "Exception for Station Control settings retrieval failures. previous iqm.pulla.interface.ChipLabelRetrievalException next iqm.pulla.pulla By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.station_settings",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.station_settings.html",
    "description": "Mapping calibration observations to station settings. Observations are physical quantities stored in the EXA database. CPC uses them to represent the\ncalibrated values of various instrument settings a...",
    "content": "Mapping calibration observations to station settings. Observations are physical quantities stored in the EXA database. CPC uses them to represent the\ncalibrated values of various instrument settings and gate parameters, needed to execute quantum circuits.\nThe following iqm.station_control.interface.models.observation.ObservationLite fields are needed\nfor this purpose: dut_field : identifies the quantity, and possibly the QPU component(s) it is associated with value : value of the quantity unit : unit of the quantity (currently only base SI units are used, e.g. Hz instead of GHz) The calibration observations come from two conceptually different sources. ConfigurationSource observations determine the base operating point of the station\n(in principle an arbitrary choice), and form the input of the calibration procedure. AnalysisSource observations are the output of the calibration procedure. When EXA saves its settings as observations, it maps the settings tree paths directly to observation dut_field paths. CPC uses the same direct mapping, with a single minor modification (\u201coptions.end_delay\u201d),\nto map observation dut_field paths to Station Control controller settings paths. Quantum operation parameters are stored in the EXA settings tree under the top-level branch gates .\nThis data is only used in building the instruction schedules. The controller settings paths may change whenever Station Control is updated, since it\nconsumes the settings. Hence, this may break old calibration sets. New paths may be introduced into the calibration set when the calibration procedure changes,\nor a new gate implementation is introduced. CPC only consumes observations created by the calibration process, stored explicitly as calibration\nsets in the database. In addition to the station settings obtained from the calibration set, circuit execution also\nrequires some static settings that typically change only when Station Control is updated, or\nthe station itself is physically modified. The settings that depend on the makeup of a particular\nstation, e.g. the types of the control instruments, are set in the station.yml configuration file\nif possible. Examples of such settings are the input and output ranges and powers of various instruments.\nNote that these settings can also be considered a part of the definition of the basic operating point. For some station settings, the default value is already good. Finally, there are some static station settings that are defined in this module, mostly because if\nthey were set in station.yml they might negatively interfere with running EXA experiments on\nthe station. Functions build_station_settings (*,\u00a0circuit_qubits,\u00a0...) Build the station settings for executing a batch of quantum circuits using the given QPU elements and calibration data. find_observation (observation_path,\u00a0...[,\u00a0...]) Return the value of the given calibration observation, or raise an error. Classes Map (parameter,\u00a0observation_path_template[,\u00a0...]) Mapping from a calibration observation path to a corresponding station settings path. Inheritance previous iqm.cpc.compiler.standard_stages.validate_execution_options next iqm.cpc.compiler.station_settings.build_station_settings By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.utils.extract_readout_controller_result_names",
    "url": "/iqm-pulla/api/iqm.pulla.utils.extract_readout_controller_result_names.html",
    "description": "Prepare readout controller names for the request. readout_mappings ( tuple [ dict [ str , tuple [ str , ... ] ] , ... ] ) \u2013 set [ str ] previous iqm.pulla.utils.convert_sweep_spot_with_heralding_mode_...",
    "content": "Prepare readout controller names for the request. readout_mappings ( tuple [ dict [ str , tuple [ str , ... ] ] , ... ] ) \u2013 set [ str ] previous iqm.pulla.utils.convert_sweep_spot_with_heralding_mode_zero next iqm.pulla.utils.find_circuit_boundary By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.pulla.Pulla",
    "url": "/iqm-pulla/api/iqm.pulla.pulla.Pulla.html",
    "description": "Bases: object Pulse level access library for IQM\u2019s circuit-to-pulse compiler and Station Control API.\nConceptually, represents a connection to a remote quantum computer, and a provider of calibration ...",
    "content": "Bases: object Pulse level access library for IQM\u2019s circuit-to-pulse compiler and Station Control API.\nConceptually, represents a connection to a remote quantum computer, and a provider of calibration data.\nCan create a compiler instance ready to be used with the connected quantum computer. station_control_url ( str ) \u2013 URL to a Station Control instance. get_token_callback ( Callable [ [ ] , str ] | None ) \u2013 An optional function that returns an authentication token for the Station Control API. Methods _get_station_control_settings () Returns the Station Control settings node that was fetched from the IQM server during Pulla initialization. execute (playlist,\u00a0context,\u00a0settings[,\u00a0verbose]) Executes a quantum circuit on the remote quantum computer. fetch_calibration_set_by_id (calibration_set_id) Fetches a specific calibration set from the server, and returns its decoded representation. fetch_latest_calibration_set () Fetches the latest default calibration set from the server, and returns its decoded representation and id. get_channel_properties () Control channel properties from Station Control controller settings. get_chip_label () Returns the chip label of the current quantum computer. get_chip_topology () Returns chip topology that was fetched from the IQM server during Pulla initialization. get_standard_compiler ([calibration_set,\u00a0...]) Returns a new instance of the compiler with the default calibration set and standard stages. Returns a new instance of the compiler with the default calibration set and standard stages. calibration_set ( dict [ str , bool | str | int | float | complex | ndarray ] | None ) \u2013 Calibration set to use. If None, the default calibration set will be used. circuit_execution_options ( CircuitExecutionOptions | dict | None ) \u2013 circuit execution options to use for the compiler. If a CircuitExecutionOptions\nobject is provided, the compiler use it as is. If a dict is provided, the default values will be\noverridden for the present keys in that dict. If left None , the default options will be used. The compiler object. Compiler Fetches the latest default calibration set from the server, and returns its decoded representation and id. tuple [ dict [ str , bool | str | int | float | complex | ndarray ], UUID ] Fetches a specific calibration set from the server, and returns its decoded representation.\nAll calibration sets are cached in-memory, so if the calibration set with the given id has already been fetched,\nit will be returned immediately. calibration_set_id ( UUID ) \u2013 id of the calibration set to fetch. dict [ str , bool | str | int | float | complex | ndarray ] Returns the chip label of the current quantum computer. The chip label is fetched from the Station Control API. str Returns chip topology that was fetched from the IQM server during Pulla initialization. ChipTopology Control channel properties from Station Control controller settings. Mapping from channel names to  their properties.\ncomponent_to_channel: Mapping from chip component names to functions to channel names. For example, \u2018QB1\u2019 -> \u2018drive\u2019 -> \u2018QB1__drive.awg\u2019 Mapping from channel names to  their properties.\ncomponent_to_channel: Mapping from chip component names to functions to channel names. For example, \u2018QB1\u2019 -> \u2018drive\u2019 -> \u2018QB1__drive.awg\u2019 channel_properties Executes a quantum circuit on the remote quantum computer. playlist ( Playlist ) \u2013 Final schedule to be executed. context ( dict [ str , Any ] ) \u2013 Context object of the successful compiler run, containing the readout mappings. settings ( SettingNode ) \u2013 Station settings. verbose ( bool ) \u2013 Whether to print results. results of the execution StationControlResult previous iqm.pulla.pulla next iqm.pulla.quantum_architecture By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.circuit_compilation_request_handler",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.circuit_compilation_request_handler.html",
    "description": "Convert quantum circuits into instruction schedules. This is the entry-point for integrations, e.g. for a server-side component performing circuit-to-pulse compilation. Functions handle_circuit_compil...",
    "content": "Convert quantum circuits into instruction schedules. This is the entry-point for integrations, e.g. for a server-side component performing circuit-to-pulse compilation. Functions handle_circuit_compilation_request (job_id,\u00a0...) Compile a batch of quantum circuits into a form that can be executed by Station Control. previous iqm.cpc.compiler next iqm.cpc.compiler.circuit_compilation_request_handler.handle_circuit_compilation_request By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.pulla.interface.BUFFER_AFTER_MEASUREMENT_PROBE",
    "url": "/iqm-pulla/api/iqm.pulla.interface.BUFFER_AFTER_MEASUREMENT_PROBE.html",
    "description": "Buffer that allows the readout resonator and qubit state to stabilize after a probe pulse, in s.\nTODO: not needed after EXA-2089 is done. previous iqm.pulla.interface.CircuitMeasurementResultsBatch ne...",
    "content": "Buffer that allows the readout resonator and qubit state to stabilize after a probe pulse, in s.\nTODO: not needed after EXA-2089 is done. previous iqm.pulla.interface.CircuitMeasurementResultsBatch next iqm.pulla.interface.Circuit By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.standard_stages.map_components",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.standard_stages.map_components.html",
    "description": "Map the logical QPU components to physical QPU components using component_mapping . circuits ( Iterable [ Circuit ] ) \u2013 builder ( ScheduleBuilder ) \u2013 component_mapping ( dict [ str , str ] ) \u2013 previou...",
    "content": "Map the logical QPU components to physical QPU components using component_mapping . circuits ( Iterable [ Circuit ] ) \u2013 builder ( ScheduleBuilder ) \u2013 component_mapping ( dict [ str , str ] ) \u2013 previous iqm.cpc.compiler.standard_stages.get_standard_stages next iqm.cpc.compiler.standard_stages.map_old_operations By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.interface.compiler.MeasurementMode",
    "url": "/iqm-pulla/api/iqm.cpc.interface.compiler.MeasurementMode.html",
    "description": "Bases: StrEnum Measurement mode for circuit execution. Determines which QPU components are measured by Station Control in the final measurement.\nMeasurement results which are not required by the circu...",
    "content": "Bases: StrEnum Measurement mode for circuit execution. Determines which QPU components are measured by Station Control in the final measurement.\nMeasurement results which are not required by the circuits to be executed are discarded. Attributes CIRCUIT In each circuit separately, measure only the components that have final measurement operations on them. ALL Measure all the components on the QPU that have measurement data in the calset. Methods __format__ (format_spec,\u00a0/) Return a formatted version of the string as described by format_spec. __new__ (value)  __str__ () Return str(self). In each circuit separately, measure only the components that have final measurement\noperations on them. Measure all the components on the QPU that have measurement data in the calset.\nThis is typically how measurement is calibrated. previous iqm.cpc.interface.compiler.HeraldingMode next iqm.cpc.interface.compiler.MoveGateFrameTrackingMode By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.circuit_compilation_request_handler.handle_circuit_compilation_request",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.circuit_compilation_request_handler.handle_circuit_compilation_request.html",
    "description": "Compile a batch of quantum circuits into a form that can be executed by Station Control. job_id ( str ) \u2013 ID of the job requesting compilation, used in logging circuits ( list [ Circuit ] ) \u2013 quantum ...",
    "content": "Compile a batch of quantum circuits into a form that can be executed by Station Control. job_id ( str ) \u2013 ID of the job requesting compilation, used in logging circuits ( list [ Circuit ] ) \u2013 quantum circuits to compile into schedules shots ( int ) \u2013 number of times to repeat the execution of each circuit calibration_set ( dict [ str , bool | str | int | float | complex | ndarray ] ) \u2013 calibration data for the station the circuits are executed on chip_topology ( ChipTopology ) \u2013 topology of the QPU the circuits are executed on channel_properties ( dict [ str , ChannelProperties ] ) \u2013 properties of control channels on the station component_channels ( dict [ str , dict [ str , str ] ] ) \u2013 QPU component to function to channel mapping options ( CircuitExecutionOptions ) \u2013 various discrete options for circuit execution that affect compilation custom_settings ( SettingNode | None ) \u2013 additional Station Control settings to override generated settings qubit_mapping ( dict [ str , str ] | None ) \u2013 Mapping of logical qubit names to physical qubit names. None means the identity mapping. trace_context ( dict [ str , Any ] | None ) \u2013 telemetry context to be propagated during circuit compilation circuit compilation result CircuitCompilationResult previous iqm.cpc.compiler.circuit_compilation_request_handler next iqm.cpc.compiler.compiler By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulla",
    "title": "iqm.cpc.compiler.dd",
    "url": "/iqm-pulla/api/iqm.cpc.compiler.dd.html",
    "description": "Dynamical decoupling utilities. Module Attributes STANDARD_DD_STRATEGY The default DD strategy uses the following gate sequences: Functions insert_dd_sequences (builder,\u00a0schedule,\u00a0strategy) Insert dyn...",
    "content": "Dynamical decoupling utilities. Module Attributes STANDARD_DD_STRATEGY The default DD strategy uses the following gate sequences: Functions insert_dd_sequences (builder,\u00a0schedule,\u00a0strategy) Insert dynamical decoupling sequences into the given schedule. merge_wait_instructions_in_schedule (builder,\u00a0...) Merge adjacent Wait instructions in the drive channels of the given schedule. Exceptions DDError Something was wrong in user input for dynamical decoupling. previous iqm.cpc.compiler.compiler.Compiler next iqm.cpc.compiler.dd.STANDARD_DD_STRATEGY By IQM Pulla developers \u00a9 Copyright 2024-2025, IQM Finland Oy, Release 8.2.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "Custom gate implementations",
    "url": "/iqm-pulse/custom_gates.html",
    "description": "Quantum gates are represented by QuantumOp data classes, containing the required\nmetadata to define the gate. A QuantumOp is identified by its name , and arity defines number of locus components the o...",
    "content": "Quantum gates are represented by QuantumOp data classes, containing the required\nmetadata to define the gate. A QuantumOp is identified by its name , and arity defines number of locus components the operation acts on. For example,\nthe PRX operation (Phased X Rotation) is a single-qubit operation, so its arity is 1, whereas the CZ (Controlled-Z) gate\nacts on two qubits, having arity 2. Arity 0 has a special meaning that the operation in question can act on any number\nof components (for example Barrier ). The attribute symmetric defines whether the effect of the quantum operation\nis symmetric with respect to changing the order of its locus components. As an example, the CZ gate is a symmetric\ntwo-qubit gate, whereas CNOT (Controlled-NOT) is not symmetric. Some quantum operations are defined as \u201cfunctions\u201d, taking one or more parameters to define the effect. These\narguments are stored in the attribute params . As an example, the PRX gate\ntakes two arguments, angle (the rotation angle with respect to the z-axis of the Bloch sphere), and phase (the rotation phase in the rotating frame). On the other hand, many operations do not require any parameters, in\nwhich case this field is an empty tuple (e.g. the CZ gate). A QuantumOp has unambiguous definition in terms of its intended effect on the computational subspace of the\nQPU component, but it can be implemented in various ways. Each implementation is represented as a GateImplementation subclass. A QuantumOp stores its known implementations in the\nfield implementations . Note that even though QuantumOp is a frozen data class, the implementations dictionary can be modified, e.g.\nto add new implementations or to change their order (usually programmatically by some client procedure, but nothing as\nsuch prevents the user from manipulating the contents manually). The default implementation is how the user prefers\nto implement the operation unless otherwise specified (in effect, this is what will get called in most cases the\noperation is invoked). In the implementations dict, the default implementation is defined as the first entry.\nQuantumOp contains helpful methods that allow setting and returning the default implementation for specific cases: set_default_implementation() , get_default_implementation_for_locus() , and set_default_implementation_for_locus() . The attribute unitary stores a function that can be used to get the unitary\nmatrix representing the quantum operation in question. The unitary function must have the same arguments\nas defined in params , such that for each collection of these parameters it\ngives the associated unitary matrix. Note that not all QuantumOps necessarily even represent a unitary gate (e.g.\nthe measure operation is not one), or the exact form of the unitary matrix might not be known. In these cases, the\nfield can be left None . The unitary does not need to be defined for most of the basic usage of a QuantumOp, but certain\nalgorithmic methods (e.g. some implementations of Randomized Benchmarking) may require the unitary matrices to be known,\nand such operations that do not define the getter function cannot then be used in these contexts. For more information, see the API docs of QuantumOp for the full list of fields needed\nto define a quantum operation and the available class methods. While QuantumOp represents an abstract quantum operation, its implementations contain\nthe concrete logic of how to make that operation happen using QC hardware. Gate implementations are subclasses of GateImplementation . In this section, the main features of that class are\nintroduced (for a full list of class methods see the API docs), with the emphasis being on how to create your own\ngate implementations. Starting with __init__() , it is important to note that the init\nmethods of all gate implementations must have the exact same signature: Here, parent is the QuantumOp this gate implementation implements, and name is the implementation\u2019s name in\nthe dictionary implementations . locus is the set of (usually logical) components\nthe QuantumOp acts on (the size of the locus must be consistent with the parent \u2019s arity ), while calibration_data gives the required calibration data values\nfor this implementation and locus (can be empty in case the implementation needs no calibration data). Finally,\nThe implementations store a reference to the ScheduleBuilder that created it. This is\nbecause GateImplementations are practically never created manually by calling the init method itself. Instead, one\nneeds a builder and uses get_implementation() . The responsibility of the init method is to (at least) store the calibration_data provided from the builder for\nfurther use, but in many cases, one might want to create some intermediate objects like pulses or instructions from that calibration data already at this point. Note that ScheduleBuilder caches its GateImplementations per each locus and calibration_data , so as long as the calibration is not changed, the code in init will be called just once per locus. GateImplementations are Callables, i.e. they implement the __call__ method. It should take as its arguments at least\nthe QuantumOpt parameters defined for the parent in params , but in\naddition it may have optional extra arguments. The call method should return a TimeBox object\nthat contains the pulses, instructions and other logic required to implement the quantum operation in question. The\ntypical usage of gate implementations then looks like this (See Using ScheduleBuilder and Pulse timing for more\ninfo on scheduling and the ScheduleBuilder): The base class __call__() method does automatic TimeBox caching based\non the unique values of the call arguments, and in many cases, one does not want to reimplement this caching in their own\nimplementations. For this reason, there is the method _call which contains just the pure TimeBox creation logic.\nDevelopers can choose to override that instead of __call__ in cases where the call args are hashable python types,\nand then they can utilize the default caching of TimeBoxes from the base class. When writing a GateImplementation, a developer should consider what parts of the logic should go to the class init and\nwhat to the __call__ or _call method. A general rule of thumb would be that any parts that can be precomputed\nand do not depend on the call arguments can go to init, and the rest to call. As an example, let\u2019s go through a simple PRX _call method (note that the default PRX implementations do not\nuse this exact call method, as this is a simplified example for educational purposes): Here, we first create an IQPulse object which is a low-level Instruction. IQPulse\nmeans a \u201ccomplex pulse\u201d which has two orthogonal components i and q \u2013 this what drive pulses look like in general. In\nthis simplified example, we have hardcoded the pulse waveforms into TruncatedGaussian and TruncatedGaussianDerivative for the i and q components, respectively (this is a DRAG implementation, so the\nq component is the derivative of the i component). The waveforms are parametrized by the calibration_data for the\ngiven locus (see the next subsection for more info on Waveforms and calibration data). The PRX QuantumOp param angle scales the pulse amplitude linearly (the waveforms are normalized to one), and the param phase defines relative\nphase modulation. Then the returned TimeBox is created out of the instruction . Note that\nsince we override _call here, instead of __call__ , so this implementation would utilize the default base class\ncaching such that the TimeBoxes are cached per unique values of (angle, phase) . Another important concept is a the so called locus mapping of a gate implementation. Locus mappings define on which\nloci, i.e. groups of components, a given implementation can be defined. They are used to relay the information which\nloci are supported to a client application (e.g. EXA). In addition, the gate implementation itself can programmatically\nuse this information self.builder.chip_topology . For example, a PRX can be defined on all single components that are connected to a drive line, and CZ can be defined on\nconnected pairs of qubits. Locus mappings live in ScheduleBuilder.chip_topology which is a ChipTopology object. Locus mapping is a dict whose keys are the loci\n( tuple[str, ...] keys denote asymmetric loci where the order of the components matter, and frozenset[str] type\nloci denote symmetric ones), and the values are groups of components, typed tuple[str, ...] , where each locus can be\nmapped with some additional components that are needed for the operation of the implementation. For example, some CZ\nimplementation that tries to correct for crosstalk could map the non-locus components that see this crosstalk here.\nThe values of the dict can be left empty or just replicate the key components in case such extra information is not\nneeded. GateImplementations can define their locus mappings via get_custom_locus_mapping() or if a client application already\nadds the mapping, we can just return its name via get_locus_mapping_name() .\nIf neither of these methods are overridden in a GateImplementation class, the default behaviour will be such that an arity==1 loci will be assumed to use the mapping where all single qubits are the keys, and arity==2 loci the\n(symmetric) mapping where the keys are all pairs of connected qubits. For other arities there is no default behaviour,\nso it is then mandatory to define the mapping explicitly using the aforementioned methods. In order to implement most QuantumOps, one has to physically alter the state of the QPU. This is typically done by playing\nspecified and correctly calibrated pulses via the control electronics (this applies to all typical logical gates such as\ne.g. PRX or CZ \u2013 non-physcial metaoperations such as Barrier are an exception). In defining these pulses, there are two\nlevels of abstractions: Waveform and Instruction . Waveform represents the physical form of the control pulse, typically normalized to the interval [-1.0, 1.0] . The\nEach Waveform subclass can define any number of waveform parameters as class\nattributes, which can be used to programmatically define the waveform. For example, a Gaussian could be defined in terms\nof the average mu and spread sigma . A Waveform class then essentially contains just the parameters\nand a recipe for computing the samples as an np.ndarray . As an example, here is how one writes the Waveform class\nfor Gaussian : The Instructions RealPulse and IQPulse allow handling the amplitudes (via the attribute scale ) without\nhaving to resample the waveform for every different amplitude value. However, one can always choose to include\nthe amplitude into the sampling and then use scale=1 . The waveform parameters (like sigma in the above Gaussian) typically require calibration when the Waveform is used\nin a quantum gate. However, the GateImplementation usually has other calibrated parameters as well defined in the\nimplementation itself. As an example, here are the implementation-level parameters of the default PRX implementation,\ndefined as class attribute: Note the amplitudes are defined here on this level, since the default PRX uses normalized Waveforms and factors in the\namplitudes via scale . In these parameters, the unit is not just metadata. The control electronics understand time\nin terms of samples and their sample rate, while human users typically want to input seconds instead of doing the sample\nconversion manually. For this reason, there is logic that converts anything that has the unit \"s\" into samples.\nSimilarly, parameters with \"Hz\" units are converted to 1/sample . For the Waveform parameters, the same logic\napplies, but by default it is assumed that all parameters are time-like and this converted from seconds to samples.\nIf some Waveform parameters needs to be made unitless or e.g. frequency-like (with \"Hz\" units), it can be achieved\nwith the method non_timelike_attributes() : In the above dict, the keys should be the attribute names and values their units. To make creating new GateImplementations more comfortable, there are additional base classes on top of GateImplementation itself. CompositeGate allows quick implementation of gates in terms of other gates,\nusing a similar syntax as with creating/scheduling several TimeBoxes together (see Using ScheduleBuilder ). At it\nsimplest, a ComposteGate is just the _call method: Here, one could use also builder.get_implementation instead of build() , but the latter allows calibrating the member gates\ncase specifically for this composite if they are first registered via registered_gates (in this case, there is\njust one member, PRX). Creating new implementations for the PRX, CZ and Measure gates often means just coming up with new waveforms for the\ncontrol pulses. If this is the case, there are helpful base classes that make those implementations into oneliners\n(outside of defining the Waveforms themselves): PRX_CustomWaveforms , FluxPulseGate , and Measure_CustomWaveforms . Using these\nbase classes at its simplest looks like this: All of these classes automatically include the associated Waveform parameters into the calibration parameters of\nthe implementation itself. There is also a general base class for any gate that implements a single IQPulse (both PRX_CustomWaveForms and Measure_MyCoolWaveforms actually inherit from it), regardless of the context: CustomIQWaveforms . Gate definitions (i.e. QuantumOps) are stored in ScheduleBuilder \u2019s attribute op_table . When the builder is created, the op_table comes preloaded with the all the basic QuantumOps needed for\ntypical circuit execution and their default implementations. These include e.g. the PRX gate, the CZ gate, the measure\noperation, the conditional prx operation, the reset operation, and the barrier operation. In order to add custom operations, there is a helpful function register_implementation() that\nin addition to adding new implementations allows one to add altogether new quantum operations. As an example here is a snippet that adds the CNOT gate, and its implementation, into an existing builder: Here, the CNOT implementation MyCNotClass needs to be of course defined first (a QuantumOp always needs at least one\nimplementation). Note: The end user cannot modify the canonical mapping (defined in iqm-pulse) between implementation_name and implementation_class . Note that often ScheduleBuilder is created and operated by some client application, and the same application usually\nhas its own interface for adding/manipulating QuantumOps. However, if the user has access to the builder object, the\nabove method will always work. previous Using ScheduleBuilder next Pulse timing \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "Concepts and Classes",
    "url": "/iqm-pulse/concepts.html",
    "description": "This section gives an overview of the main concepts and terminology in IQM Pulse. QPUs contain components : qubits, computational resonators, couplers, and probelines. Each component may have some con...",
    "content": "This section gives an overview of the main concepts and terminology in IQM Pulse. QPUs contain components : qubits, computational resonators, couplers, and probelines. Each component may have some control channels connected to it. Control channels deliver physical control pulses\nto the QPU. Quantum operations have a locus , which is the set of quantum information carrying components\n(qubits and resonators) the operation acts on.\nOne operation may involve sending pulses to multiple control channels. The assembly of a Playlist, or a batch of quantum circuits, can be summarized as follows: A Playlist contains multiple independent segments , to be executed as a batch. A segment is a conceptual unit at a time scale where the quantum information of the QPU can be\nassumed to be preserved. A quantum circuit corresponds to one segment. What is executed during a segment is determined by a Schedule . A Schedule is a set of hardware control channels, each with a strictly timed sequence of Instructions . A Schedule is formed by scheduling a Timebox . A TimeBox can contain other TimeBoxes without precise relative timing,\nor it can be atomic, in which case it contains a single Schedule . The image below illustrates how a Playlist of two segments is formed from TimeBoxes. Hardware instructions are the lowest-level construct visible on the client side.\nInstructions are a set of atomic, real-time execution commands for the control hardware supported by IQM.\nThey work in a time scale where the quantum information of the QPU can be assumed to be preserved.\nExamples of Instructions are IQPulse to play a microwave pulse on a channel, VirtualRZ to adjust the modulation phase, ReadoutTrigger to acquire measurement data,\nand Wait to delay the next Instruction for a given time.\nSee iqm.pulse.playlist.instructions for the complete list. During execution, each hardware control channel executes its own sequence of Instructions.\nEach Instruction blocks the next until it is completed.\nInstructions are as explicit as possible, so that there is no ambiguity on what will be executed when.\nIQM Station control transforms Instructions to machine-specific commands. All Instructions have a duration, measured in samples, though the duration can be zero.\nThe durations are subject to hardware-specific granularity constraints.\nFor example, some hardware might require all instructions to be a multiple of 16 samples long, with a minimum of 32.\nInstructions violating the granularity constraints will raise an error.\nHowever, a typical user does not need to concern themselves about the constraints, as\nthe gate implementations and IQM Pulse\u2019s scheduling ensures the constraints are respected.\nThe philosophy is that Station Control, which is inaccessible to the user, does not attempt to do any smart\n\u201cmagic\u201d to fix inconsistencies in the user\u2019s input, it simply executes the Playlist it is given.\nInstead, the magic happens on the client side so that it is transparent to the user. Note For technical reasons, IQM Pulse mostly uses classes from iqm.pulse.playlist.instructions , but when\nfinalizing the output, the instructions are converted to iqm.models.playlist.instructions .\nThese two class families are semantically equivalent, apart from a few exceptions like Block which\nonly exists on the client side to help with scheduling. Schedule contains a number of control channels, each with a lists of Instructions.\nAll channels in a Schedule start executing at the same instant, and the timing is defined by the duration of the\nindividual Instructions.\nSchedules can be thought of as a fixed block that occupies some interval on a timeline of some channels. Schedules appear in two contexts: gate implementations and as complete segments.\nFor example, when an implementation of a PRX gate is requested,\na small Schedule involving the drive channel of a single qubit is created.\nWhen all the desired gates in a circuit have been scheduled by concatenating the gate-schedules together,\nthe end result, a segment, is a large Schedule occupying all necessary channels.\nA typical segment starts with initializing the qubits and ends with reading out their state. Whereas a Schedule is a container with strict relative timing, a TimeBox is a container with undefined\nrelative timing.\nEach TimeBox can be labeled using a human-readable label describing it, and operates on a number\nof locus components , using some of their control channels.\nA composite TimeBox contains other TimeBoxes as children, whereas atomic TimeBoxes contain a Schedule. TimeBoxes are the main language in which users define the order and relative alignment of execution elements, be it\ngates, Schedules, or larger TimeBoxes. A key process is the scheduling, in which TimeBoxes are resolved recursively into a fixed Schedule.\nWhen resolving, all Schedules inside the TimeBox are concatenated and are either left-aligned (ASAP) or right-aligned\n(ALAP), respecting the hardware constraints.\nImportantly, if some TimeBoxes have content on disjoint channels, the Schedules are allowed to happen simultaneously.\nIf they have content on partly overlapping channels, the Schedules are concatenated while preserving their internal\ntiming.\nAny interval that does not have explicit instructions is filled with Wait Instructions.\nThe figure above demonstrates how TimeBoxes are resolved. The syntax and rules are explained in more detail in Using ScheduleBuilder . A higher-level concept, a QuantumOp can represent a unitary quantum gate,\nor for example a measurement operation (not all QuantumOps necessarily represent a unitary gate).\nQuantumOps are simple, abstract, self-contained actions one can execute on a station as parts of a quantum circuit.\nThey include quantum gates like PRX, CZ, and measurements and resets.\nWhereas Schedules and Instructions act on control channels, QuantumOps act on named components on the QPU, such as\nqubits or computational resonators. A QuantumOp has unambiguous definition in terms of its intended effect on the computational subspace of the\nQPU component, but it can be implemented in various ways.\nEach implementation is represented as a GateImplementation. The list of available QuantumOps at runtime can be obtained with iqm.pulse.builder.build_quantum_ops() .\nA new QuantumOp can be registered at runtime, together with an implementation, with iqm.pulse.gates.register_implementation() . A GateImplementation bridges the gap between QuantumOps and TimeBoxes.\nWhen a user requests a QuantumOp from ScheduleBuilder with specific parameters and locus components, the\nchosen GateImplementation (usually the default) for the operation is used to produce a TimeBox.\nThis TimeBox, usually atomic, contains a Schedule on the appropriate control channels.\nThe Instructions within are constructed following the calibration values from the ScheduleBuilder. All gate implementations are listed in iqm.pulse.gates .\nSection Custom gate implementations explains how to add more implementations. Once all TimeBoxes are scheduled into large Schedules, one for each segment/circuit,\nthe Schedules are collected into a Playlist .\nThe Playlist is the final product that is sent to Station Control.\nIts contents are compressed by indexing all unique Instructions and waveforms on each channel,\nand representing the control channels in each segment as lists of Instruction indices. During execution, the segments in the Playlist are executed in order, and the whole sequence is repeated\na number of times equal to the number of repetitions (shots). Segments are separated in time by end delay , a parameter outside the Playlist.\nA long end delay can be used to prevent quantum information carrying from one segment to the next,\nthus resetting the qubits.\nAlternatively, the reset can be encoded in each segment as a long Wait instruction or using some active reset scheme. Station Control aims to execute all segments together, but sometimes this is not possible due to various memory\nconstraints.\nIn case the whole Playlist does not fit in memory, the segments are split into chunks which are executed separately.\nThe delay between chunks is undefined.\nTherefore, the time between segments is guaranteed to be at least the duration of the end delay, but can be much larger. inspect_playlist() provides a neat visual representation of the playlist, as blocks of instructions on a\ntimeline. previous IQM Pulse next Using ScheduleBuilder \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "API Reference",
    "url": "/iqm-pulse/API.html",
    "description": "iqm.pulse Control pulses, gates and instruction schedules for quantum computers. previous Pulse timing next pulse \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07....",
    "content": "iqm.pulse Control pulses, gates and instruction schedules for quantum computers. previous Pulse timing next pulse \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "IQM Pulse",
    "url": "/iqm-pulse/index.html",
    "description": "9.18.0 2025-07-07 IQM Pulse provides an abstraction that transforms high-level quantum circuit operations\nto a unified set of lower-level instructions for IQM quantum computers. A quantum circuit is a...",
    "content": "9.18.0 2025-07-07 IQM Pulse provides an abstraction that transforms high-level quantum circuit operations\nto a unified set of lower-level instructions for IQM quantum computers. A quantum circuit is an abstract mathematical construct which conveniently hides all implementation\ndetails such as the timing of microwave pulses, waveform shapes, sampling rates, signal capture, and so on.\nBut in order to execute a circuit you need to convert it into a schedule of hardware instructions which involve\nall of the above. IQM Pulse provides a framework for defining abstract quantum gates/operations, as well as their concrete implementations in terms of hardware instructions machinery to easily construct circuit-level gate sequences, and compile them into instruction schedules. a set of ready-made gates with implementations. IQM Pulse is not a standalone tool, but is used in IQM\u2019s client libraries, IQM Pulla and Exa.\nTo use them effectively, you are encouraged to familiarize yourself with IQM Pulse, especially the most common\nconcepts. Index Module Index Search Page next Concepts and Classes \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "References",
    "url": "/iqm-pulse/references.html",
    "description": "Eric Hyypp\u00e4, Antti Veps\u00e4l\u00e4inen, Miha Papi\u010d, Chun\u00a0Fai Chan, Sinan Inel, Alessandro Landra, Wei Liu, J\u00fcrgen Luus, Fabian Marxer, Caspar Ockeloen-Korppi, and others. Reducing leakage of single-qubit gate...",
    "content": "Eric Hyypp\u00e4, Antti Veps\u00e4l\u00e4inen, Miha Papi\u010d, Chun\u00a0Fai Chan, Sinan Inel, Alessandro Landra, Wei Liu, J\u00fcrgen Luus, Fabian Marxer, Caspar Ockeloen-Korppi, and others. Reducing leakage of single-qubit gates for superconducting quantum processors using analytical control pulse envelopes. PRX Quantum , 5(3):030353, 2024. doi:10.1103/PRXQuantum.5.030353 . John\u00a0M. Martinis and Michael\u00a0R. Geller. Fast adiabatic qubit gates using only $\\sigma _z$ control. Phys. Rev. A , 90:022307, Aug 2014. arXiv:1402.5467 , doi:10.1103/PhysRevA.90.022307 . R.\u00a0G. Lyons. Understanding Digital Signal Processing . Prentice Hall, 2nd edition, 2004. ISBN 978-0131089891. Cecilia\u00a0Gisele Jarne. A heuristic approach to obtain signal envelope with a simple software implementation. ANALES AFA , 29(2):51\u201357, 2018. arXiv:1703.06812 , doi:10.31527/analesafa.2018.29.2.51 . Eyob\u00a0A. Sete, Nicolas Didier, Angela\u00a0Q. Chen, Shobhan Kulshreshtha, Riccardo Manenti, and Stefano Poletto. Parametric-resonance entangling gates with a tunable coupler. Phys. Rev. Appl. , 16:024050, Aug 2021. arXiv:2104.03511 , doi:10.1103/PhysRevApplied.16.024050 . Youngkyu Sung, Leon Ding, Jochen Braum\u00fcller, Antti Veps\u00e4l\u00e4inen, Bharath Kannan, Morten Kjaergaard, Ami Greene, Gabriel\u00a0O. Samach, Chris McNally, David Kim, Alexander Melville, Bethany\u00a0M. Niedzielski, Mollie\u00a0E. Schwartz, Jonilyn\u00a0L. Yoder, Terry\u00a0P. Orlando, Simon Gustavsson, and William\u00a0D. Oliver. Realization of high-fidelity CZ and ZZ-free iSWAP gates with a tunable coupler. Phys. Rev. X , 11:021058, Jun 2021. arXiv:2011.01261 , doi:10.1103/PhysRevX.11.021058 . previous Changelog next License \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "Using ScheduleBuilder",
    "url": "/iqm-pulse/using_builder.html",
    "description": "This section describes how to use ScheduleBuilder to compose pulse schedules.\nScheduleBuilder encapsulates registered QuantumOps, the calibration information for them, QPU components and their\ntopolog...",
    "content": "This section describes how to use ScheduleBuilder to compose pulse schedules.\nScheduleBuilder encapsulates registered QuantumOps, the calibration information for them, QPU components and their\ntopology, and control channel properties. In the context of IQM Pulla and EXA, an instance of ScheduleBuilder is given by the framework,\nand it contains all the necessary information to execute against a particular quantum computer instance.\nHere, we assume that user has an instance of ScheduleBuilder builder to work with. A typical workflow begins with calling get_implementation() with the name of a desired QuantumOp and the locus\nfor the operation.\nThe locus is the logical target of the operation, usually a sequence of qubits or computational resonators.\nThis outputs a an instance of GateImplementation , which is capable of producing TimeBoxes with the correct\ncalibration for that locus. For example, here we ask for the GateImplementation of prx , cz , and measure , all of which are standard\ngates recognized by IQM Pulse, for qubits QB1 and QB3 .\nAny gate which is registered in the runtime can be requested this way. Notice how the number of qubits matches the operation: CZ acts on 2 qubits, while PRX acts on only one.\nMeasure can act on any number of qubits. There might be several available implementations for an operation. get_implementation gives the implementation that is set as the default, unless a specific implementation is\nrequested with a keyword argument. To instantiate some concrete TimeBoxes, we call time implementation with the logical parameters of the operations, as\ndefined by the QuantumOps.\nPRX has 2 parameters: the 2 angles of a phased rotation.\nCZ does not have any parameters. One important method is the wait() , which blocks the control channels of the given components for a certain time: In all of the examples above, the TimeBoxes are atomic, which can be organized into composite TimeBoxes to decide\ntheir relative order. TimeBoxes can be concatenated with the following rules: Addition ( + ) concatenates the children of the operands into a single TimeBox.\nUse addition to allow gates on disjoint loci to execute simultaneously, for example doing a PRX on all qubits. The pipe operation ( | ) groups two TimeBoxes together without concatenating.\nThis results in composite TimeBox with two children, the operands, which are scheduled separately.\nUse the pipe to ensure that certain operations execute before some others. Iterables of TimeBoxes are treated as the sum of the elements. This would execute 2 PRX gates on QB1 and QB2 simultaneously: If the last operator was | instead, the second gate on QB2 would execute only after the first 3 gates. Together, these rules provide a handy way of defining complex circuits easily: A TimeBox are made atomic by resolving it using ScheduleBuilder.resolve_timebox() .\nWhen using a framework like IQM Pulla or Exa, the framework will take care of the resolving as part of compilation,\nso the user does not need to do it explicitly. TimeBoxes are resolved recursively: The children of a TimeBox are resolved, and resulting (sub-)Schedules are aligned\naccording to the SchedulingStrategy (ASAP or ALAP) of the TimeBox.\nThe time duration of a TimeBox is determined by its contents and the way they are scheduled during the resolution.\nFinally, all channels are padded with Waits so that the total duration of Instructions on every channel is equal.\nIn other words, the Schedule becomes a \u201crectangle\u201d. An important part of the scheduling are the blocking rules, that is, whether the contents of two TimeBoxes block or\nslide past each other.\nThe rules are: An atomic TimeBox is considered to act on a component if it has instructions on any of the non-virtual channels\nrelated to that component. A composite TimeBox acts on the union of its children\u2019s locus components. A TimeBox blocks all channels related to any component it acts on. When scheduling two TimeBoxes, the instructions will not overlap in time if the TimeBoxes block overlapping channels. In addition to blocking the channels actually present in a TimeBox, it is possible to block neighbouring channels\nas well (for example in order to limit cross-talk).\nThe applied neighbourhood is specified in ScheduleBuilder.resolve_timebox() .\nThe neighbourhood is defined as an integer such that 0 means \u201cblock only the involved channels\u201d,\n1 means \u201cblock the involved channels and the channels of any neighbouring couplers\u201d,\n2 means \u201cthe same as in (1) but in addition block all channels connected by those couplers\u201d, and so on.\nThe blocking rules do not add actual Wait or Block instructions are added to the neighbourhood channels, and two\noverlapping neighbourhoods do not block each other.\nThe blocking comes in question only when actual content would be added to those neighbourhood channels. In practice, the rules and default GateImplementations ensure that the user can concatenate arbitrary gates\nwithout worrying that the gates have an adverse effect on each other.\nFor example, the pulse of a PRX gate playing at the same time as a CZ gate or a measurement would ruin both operations.\nIf overlapping of such gates is desired, the best way is to arrange the Instructions on the Schedule level and wrap the\nschedule into an atomic TimeBox. Note Virtual channels are special channels that exist only to aid the scheduling algorithm.\nExamples are tracking the phases of the MOVE gate, and timing of fast feedback.\nThese channels are removed when the Playlist is finalized. You are encouraged to discover the many features of ScheduleBuilder and TimeBox by reading the\nAPI: ScheduleBuilder , TimeBox . A quick reference of selected features is provided in the examples below. Finding information about the target system: Working with TimeBoxes: Some typical errors that are easy to make with the syntax: Not calling the implementation to get a TimeBox. The call is easy to forget especially if there are no parameters\nto give: Giving a single component as locus: previous Concepts and Classes next Custom gate implementations \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "Pulse timing",
    "url": "/iqm-pulse/pulse_timing.html",
    "description": "The ReadoutTrigger Instruction responsible of qubit readout has several\ntiming-related attributes.\nThe measure.constant gate implementation produces the lower-level ReadoutTrigger instruction\nfrom a s...",
    "content": "The ReadoutTrigger Instruction responsible of qubit readout has several\ntiming-related attributes.\nThe measure.constant gate implementation produces the lower-level ReadoutTrigger instruction\nfrom a simplified set of settings.\nThe figure below shows how the settings relate to the more flexible attributes of the instruction. With conditional Instructions, we specify how the information from readout operations should affect Instructions at\nruntime.\nUsually, the goal is use the information as soon as possible, but it takes a finite time to propagate from the\nacquisition unit to the drive channels that execute the Instructions conditionally. Note On all hardware supported by IQM QCCSW, ConditionalInstruction reads the signal bit at the time of\nexcution, regardless of when the signal bit was last updated.\nThis means that if the Conditionalinstruction is executed too early, the condition will be executed based on the\nprevious state of the bit. To facilitate efficient timing of the feedback signals, IQM Pulse uses virtual channels between probeline channels\n(the source of the signals) and drive channels (the destinations).\nBlock instructions on the virtual channel represent the travel time of the signals. CCPRX_Composite is GateImplementation of the cc_prx (classically controlled PRX) that outputs two\nTimeBoxes:\nthe first one to represent the travel time, and the second one with the actual ConditionalInstruction .\nIn typical use, both should be scheduled in the same order, to ensure the Conditionalinstrucion starts when the\nsignal bit is available. The following image illustrates how the TimeBoxes are used for qubits QB2 and QB3 .\nFor QB2, this is also how Reset_Conditional implements the reset operation. The equaivalent code would be Instructions are spaced out in time only for visual clarity. When scheduled ASAP, they would be left-aligned\nsuch that the ConditionalInstructions start right after the associated control_delay has passed. The bottom of the image illustrates an alternative use of CCPRX_Composite to have more freedom in the timing.\nThere, the optional delay TimeBox is not used for scheduling the Instructions on QB4.\nInstead, the user has ensured that the other instructions take enough time for the signal to arrive.\nThis could be used to act on the previous feedback signal (not shown). Note This section is not about IQM Pulse itself, but might help in understanding the details of the execution. The image below shows a typical timing of a Playlist segment with 2 AWG devices for driving, and a readout instrument.\nHere, all statements that apply to an AWG apply to readout instruments as well.\nThe AWGs can output an arbitrary sequence of pulses, and the readout instrument can additionally read out\nthe response to the pulses. With readout, the raw signal response from the readout pulse will be integrated to produce a single number, such as a\ncomplex number or a bit, corresponding to a particular qubit in a particular segment. In the figure, one of the AWGs has been selected as the trigger master, which means it sends trigger pulses to\nstart the execution on the slave devices.\nAs shown in the picture, different delays caused by the travel time of signals can be compensated for by\nadjusting the trigger_delay setting of each device. Settings in the figure that can be adjusted by user in the higher level libraries: Setting Explanation <awg>.trigger_delay Wait time between the end of the trigger signal of the AWG master and the beginning of the pulse sequence. <awg>.trigger_delay (slave) Wait time between receiving the trigger signal at the AWG slave and the beginning of the pulse sequence. options.end_delay Wait time between the end of the pulse segment and the next trigger. <gate>.<implementation>.<locus>.duration The duration of the hardware instruction for a gate, possibly rounded to satisfy granularity constraints.\nFor the ReadoutTrigger instruction, the meaning is different, see below. Other notes: The AWG spcecified by options.trigger_master is the only channel that does not wait for a trigger\nat the start of a segment. Slave AWGs may also emit a trigger pulse to allow daisy chaining trigger signals. Systems with IQM Control System are triggered centrally and the channels run independently, and the options.trigger_master has no effect. Pipeline delays are delays between the execution of a command and the pulse actually getting outputted\nfrom a device. This delay is caused by the hardware and cannot be changed.\nIn practice, it can be thought as being part of the cable delays, and thus can be compensated with trigger_delay setting. previous Custom gate implementations next API Reference \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "rz",
    "url": "/iqm-pulse/api/iqm.pulse.gates.rz.html",
    "description": "Single-qubit RZ gate. The z rotation gate is defined as where the rotation angle \\(\\phi\\) is in radians. Full path: iqm.pulse.gates.rz Functions get_unitary_rz (angle) Unitary for an RZ gate. Classes ...",
    "content": "Single-qubit RZ gate. The z rotation gate is defined as where the rotation angle \\(\\phi\\) is in radians. Full path: iqm.pulse.gates.rz Functions get_unitary_rz (angle) Unitary for an RZ gate. Classes RZ_ACStarkShift Implementation of the RZ gate using an AC Stark pulse. RZ_ACStarkShift_CosineRiseFall AC stark pulse implemented as a modulated cosine rise fall pulse. RZ_ACStarkShift_smoothConstant Constant AC stark pulse with cosine rise and fall padding. RZ_PRX_Composite RZ gate implemented as a sequence of PRX gates. RZ_Virtual Implementation of the RZ gate using the virtual z rotation technique. Inheritance previous Reset_Wait next iqm.pulse.gates.rz.get_unitary_rz \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "MultiplexedIQPulse",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.instructions.MultiplexedIQPulse.html",
    "description": "Bases: Instruction Instruction to simultaneously play multiple IQ pulses. Each component pulse can have an arbitrary delay from the beginning of this instruction.\nOutside the interval of the Multiplex...",
    "content": "Bases: Instruction Instruction to simultaneously play multiple IQ pulses. Each component pulse can have an arbitrary delay from the beginning of this instruction.\nOutside the interval of the MultiplexedIQPulse, the component pulses are truncated.\nWhere overlapping, samples of component pulse entries are summed.\nWhere the interval of a MultiplexedIQPulse does not overlap with any of its component pulses,\nits samples are zeroes. Module: iqm.pulse.playlist.instructions Attributes entries ( pulse , offset ) pairs. duration Time duration of the instruction. Methods duration ( int ) \u2013 entries ( tuple [ tuple [ IQPulse , int ] , ... ] ) \u2013 ( pulse , offset ) pairs. offset is the number of samples pulse is delayed from the beginning of the instruction.\nIt has no granularity constraints. Negative values are allowed, but beginning will be truncated. previous Instruction next ReadoutTrigger \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "Probe_Constant",
    "url": "/iqm-pulse/api/iqm.pulse.gates.measure.Probe_Constant.html",
    "description": "Bases: ProbePulse_CustomWaveforms_noIntegration Implementation of a single-qubit projective, dispersive measurement in the Z basis. Uses a constant probe pulse. Module: iqm.pulse.gates.measure Attribu...",
    "content": "Bases: ProbePulse_CustomWaveforms_noIntegration Implementation of a single-qubit projective, dispersive measurement in the Z basis. Uses a constant probe pulse. Module: iqm.pulse.gates.measure Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). parameters Required calibration data, may be nested Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 If set True , the Q channel waveform is considered to depend on the I channel\u2019s waveform\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\nwill be initialised as True . Required calibration data, may be nested alias of Constant alias of Constant previous ProbePulse_CustomWaveforms_noIntegration next Shelved_Measure_Constant \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "ComplexIntegration",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.instructions.ComplexIntegration.html",
    "description": "Bases: AcquisitionMethod Perform a weighted integration of the IQ raw signal, resulting in a complex number. Module: iqm.pulse.playlist.instructions Attributes weights Integration weights. label Ident...",
    "content": "Bases: AcquisitionMethod Perform a weighted integration of the IQ raw signal, resulting in a complex number. Module: iqm.pulse.playlist.instructions Attributes weights Integration weights. label Identifier for the returned data, like QB1__readout.time_trace . delay_samples Delay from beginning of probe pulse to beginning of acquisition window, in samples. Methods label ( str ) \u2013 delay_samples ( int ) \u2013 weights ( IQPulse ) \u2013 Integration weights. previous Block next ConditionalInstruction \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.playlist.channel.get_channel_properties",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.channel.get_channel_properties.html",
    "description": "Internal function to get channel properties. chip_topology ( ChipTopology ) \u2013 drive_controllers ( dict [ str , SettingNode ] ) \u2013 flux_controllers ( dict [ str , SettingNode ] ) \u2013 readout_controllers (...",
    "content": "Internal function to get channel properties. chip_topology ( ChipTopology ) \u2013 drive_controllers ( dict [ str , SettingNode ] ) \u2013 flux_controllers ( dict [ str , SettingNode ] ) \u2013 readout_controllers ( dict [ str , SettingNode ] ) \u2013 tuple [ dict [ str , ChannelProperties ], dict [ str , dict [ str , str ]]] previous channel next iqm.pulse.playlist.channel.get_channel_properties_from_station_settings \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "Shelved_Measure_CustomWaveforms",
    "url": "/iqm-pulse/api/iqm.pulse.gates.measure.Shelved_Measure_CustomWaveforms.html",
    "description": "Bases: Measure_CustomWaveforms Base class for shelved readout. Shelved readout applies a prx_12(pi) gate before and after a standard dispersive readout on each qubit measured.\nThe first prx_12(pi) swa...",
    "content": "Bases: Measure_CustomWaveforms Base class for shelved readout. Shelved readout applies a prx_12(pi) gate before and after a standard dispersive readout on each qubit measured.\nThe first prx_12(pi) swaps the amplitudes of the | 1> and | 2> states, and the second one swaps them back after\nthe measurement has (roughtly) collapsed the state. If the discriminator of the readout is calibrated such that\nthe | 0> state is on one side and the | 1> and | 2> states are on the other, the end result is equivalent to the\nstandard readout operation but with the advantage that the population in the | 2> state is less susceptible to \\(T_1\\) decay during the readout than the population in the | 1> state. Note Mixed implementation multiplexing is not supported. Module: iqm.pulse.gates.measure Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). wave_i Waveform for the I channel. wave_q Waveform for the Q channel. Methods probe_timebox Returns a \"naked\" probe timebox that supports convenient multiplexing through MultiplexedProbeTimeBox.__add__ . parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 If set True , the Q channel waveform is considered to depend on the I channel\u2019s waveform\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\nwill be initialised as True . Returns a \u201cnaked\u201d probe timebox that supports convenient multiplexing through MultiplexedProbeTimeBox.__add__ . This method can be used if the user wants to control the multiplexing explicitly. With two MultiplexedProbeTimeBox``es ``A and B the result A + B has all the ReadoutTrigger instructions\non each probe channel of A and B multiplexed together and played simultaneously. key ( str ) \u2013 The readout results generated on this trigger will be assigned to f\"{qubit}__{key}\" , where qubit goes over the component names in self.locus . If empty,\nthe key \u201creadout.result\u201d will be used to maintain backwards compatibility. feedback_key ( str ) \u2013 The signals generated by this measure operation are routed using this key for\nfast feedback purposes. See __call__() . do_acquisition ( bool ) \u2013 if False, no acquisitions are added. _skip_override ( bool ) \u2013 MultiplexedProbeTimeBox containing the ReadoutTrigger instruction. TimeBox Returns a TimeBox containing the multiplexed simultaneous measurement. If len(self.locus) == 1 , the TimeBox contains the measurement for just that component, otherwise\nthe measurements of components that belong to the same probeline are multiplexed together. The returned TimeBox instances behave like any other TimeBox in scheduling and circuit\ngeneration. With measurement TimeBoxes A and B the result A + B first plays the ReadoutTrigger instructions of A and only then those of B in each probe channel. If the multiplexing features of MultiplexedProbeTimeBox are needed, the method probe_timebox() can be used. In scheduling, the returned TimeBox blocks the locus components and the probe\nlines they are associated with. key ( str ) \u2013 Readout results generated on this trigger will be assigned to the acquisition labels f\"{qubit}__{key}\" , where qubit goes over the component names in self.locus .\nIf empty, the key \"readout.result\" will be used to maintain backwards compatibility. feedback_key ( str ) \u2013 If the readout mode is \u201cthreshold\u201d, the results generated by this measure operation\nare routed using the label f\"{qubit}__{feedback_key}\" for fast feedback purposes.\nThe signals are picked up by ConditionalInstruction`s that have the same label. The default value ` \u201d\u201d`` means the signal is not routed anywhere. TODO: currently the HW does not\nsupport multiple feedback keys per drive channel, so the actual key used will be FEEDBACK_KEY whenever any non-empty key is inputted. When the HW is improved, the actual key the user inputs\nshould be passed. TimeBox containing the ReadoutTrigger instruction. TimeBox previous Shelved_Measure_Constant next move \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "CouplerFluxPulseQubitACStarkPulseGate",
    "url": "/iqm-pulse/api/iqm.pulse.gates.cz.CouplerFluxPulseQubitACStarkPulseGate.html",
    "description": "Bases: GateImplementation Base class for CZ gates with coupler flux pulse and a qubit AC Stark pulse. Analogous to the fast qubit flux pulse, the AC Stark pulse can tune the frequency of the qubit. To...",
    "content": "Bases: GateImplementation Base class for CZ gates with coupler flux pulse and a qubit AC Stark pulse. Analogous to the fast qubit flux pulse, the AC Stark pulse can tune the frequency of the qubit. Together with the\ncoupler flux pulse, this can implement a fast qubit pulsed CZ gate. Module: iqm.pulse.gates.cz Attributes excluded_parameters Parameters names to be excluded from self.parameters . root_parameters  coupler_wave Flux pulse Waveform to be played in the coupler flux AWG. qubit_drive_wave Qubit drive pulse waveform to be played in the qubit drive AWG. Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). get_locus_mapping_name Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Flux pulse Waveform to be played in the coupler flux AWG. Qubit drive pulse waveform to be played in the qubit drive AWG. Parameters names to be excluded from self.parameters . Inheriting classes may override this if certain\nparameters are not wanted in that class (also parameters defined by the waveforms can be excluded). Returns an AC Stark pulse which consists of a modulated I and modulated Q waveform, where the Q quadrature\nhas an additional phase of -pi/2. phase ( float ) \u2013 amplitude ( float ) \u2013 phase_increment ( float ) \u2013 IQPulse The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs\nin the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.\nSubclasses can reimplement this method in case it makes sense in their context. float Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. By default, it is \"<operation_name>.<implementation_name>\" . Inheriting classes may\noverride this for different behaviour. operation_name ( str ) \u2013 name of the quantum operation. implementation_name ( str ) \u2013 name of the implementation name of the locus mapping str previous CZ_TruncatedGaussianSmoothedSquare next FluxPulseGate \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.circuit_operations.reorder",
    "url": "/iqm-pulse/api/iqm.pulse.circuit_operations.reorder.html",
    "description": "Permutes the order of the qubits in an n-qubit operator matrix. A ( ndarray ) \u2013 Matrix of an operator acting on the state space of n qubits, to be reordered. perm ( list [ int ] ) \u2013 Permutation vector...",
    "content": "Permutes the order of the qubits in an n-qubit operator matrix. A ( ndarray ) \u2013 Matrix of an operator acting on the state space of n qubits, to be reordered. perm ( list [ int ] ) \u2013 Permutation vector for the n qubits. perm[k] is the new index for the k:th qubit in the old ordering.\nFor example, reorder(kron(A, B, C)), [2, 0, 1]) == kron(B, C, A) . Reordered A . ndarray previous iqm.pulse.circuit_operations.get_unitary_from_op next iqm.pulse.circuit_operations.reshape_unitary \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "XYGate",
    "url": "/iqm-pulse/api/iqm.pulse.gates.enums.XYGate.html",
    "description": "Bases: IntEnum Enumerate all single-qubit Clifford gates whose rotation axis is in the XY plane. Members of this enum can be mapped to the corresponding unitary propagator using XYGATE_UNITARIES . Onl...",
    "content": "Bases: IntEnum Enumerate all single-qubit Clifford gates whose rotation axis is in the XY plane. Members of this enum can be mapped to the corresponding unitary propagator using XYGATE_UNITARIES . Only used in the tomography experiments. Module: iqm.pulse.gates.enums Attributes IDENTITY  X_90  X_180  X_M90  Y_90  Y_180  Y_M90  Methods previous TwoQubitGate next flux_multiplexer \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.validation.InvalidInstructionError",
    "url": "/iqm-pulse/api/iqm.pulse.validation.InvalidInstructionError.html",
    "description": "Error raised when encountering an invalid instruction. previous iqm.pulse.validation.AWGScheduleValidationError next iqm.pulse.validation.PlaylistValidationError \u00a9 Copyright 2019-2025, IQM Finland Oy,...",
    "content": "Error raised when encountering an invalid instruction. previous iqm.pulse.validation.AWGScheduleValidationError next iqm.pulse.validation.PlaylistValidationError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.playlist.hd_drag.evaluate_hd_drag_q_envelope",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.hd_drag.evaluate_hd_drag_q_envelope.html",
    "description": "Evaluate Q-envelope of HD DRAG given the coefficients of the derivative terms and the cosine terms. The Q-envelope is defined as \\(Q(t) = \\sum_{n=0}^{K} \\beta_{2n} g^{(2n+1)}(t)\\) , where \\(K\\) is the...",
    "content": "Evaluate Q-envelope of HD DRAG given the coefficients of the derivative terms and the cosine terms. The Q-envelope is defined as \\(Q(t) = \\sum_{n=0}^{K} \\beta_{2n} g^{(2n+1)}(t)\\) , where \\(K\\) is the number\nof suppressed frequency ranges, \\(\\{beta_{2n}\\}\\) are the coefficients of the derivative terms, and \\(g(t)\\) is the basis envelope. The pulse is assumed to start at time -pulse_duration/2 ,\nand end at time pulse_duration/2 . t_arr ( ndarray ) \u2013 Array of time points, at which the function is to be evaluated pulse_duration ( float ) \u2013 Pulse duration in the same units as t_arr derivative_coefs_arr ( ndarray ) \u2013 Coefficients of the derivatives cosine_coefs_arr ( ndarray ) \u2013 Coefficients of the cosine terms in the basis envelope Q-envelope of a HD DRAG pulse evaluated at t_arr ndarray previous iqm.pulse.playlist.hd_drag.evaluate_hd_drag_i_envelope next iqm.pulse.playlist.hd_drag.evaluate_nth_derivative_of_basis_envelope \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.validation.AWGScheduleValidationError",
    "url": "/iqm-pulse/api/iqm.pulse.validation.AWGScheduleValidationError.html",
    "description": "Error raised when schedule validation for an AWG fails. previous AWGScheduleValidationData next iqm.pulse.validation.InvalidInstructionError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last...",
    "content": "Error raised when schedule validation for an AWG fails. previous AWGScheduleValidationData next iqm.pulse.validation.InvalidInstructionError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "builder",
    "url": "/iqm-pulse/api/iqm.pulse.builder.html",
    "description": "Tools for building instruction schedules. Full path: iqm.pulse.builder Functions build_quantum_ops (ops) Builds the table of known quantum operations. load_config (path) Load quantum operation definit...",
    "content": "Tools for building instruction schedules. Full path: iqm.pulse.builder Functions build_quantum_ops (ops) Builds the table of known quantum operations. load_config (path) Load quantum operation definitions and calibration data from a YAML config file. validate_quantum_circuit (operations,\u00a0op_table,\u00a0*) Validate a sequence of circuit operations constituting a quantum circuit. Classes CircuitOperation Specific quantum operation applied on a specific part of the QPU, e.g. in a quantum circuit. ScheduleBuilder Builds instruction schedules out of quantum circuits or individual quantum operations. Inheritance previous iqm.pulse.base_utils.merge_dicts next iqm.pulse.builder.build_quantum_ops \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "schedule",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.schedule.html",
    "description": "Instruction schedules for controlling the instruments. Full path: iqm.pulse.playlist.schedule Module Attributes TOLERANCE remove when COMP-1281 is done. Classes Nothing Used to extend a control channe...",
    "content": "Instruction schedules for controlling the instruments. Full path: iqm.pulse.playlist.schedule Module Attributes TOLERANCE remove when COMP-1281 is done. Classes Nothing Used to extend a control channel in time, without blocking it, during scheduling. Schedule Set of synchronously executed AWG/readout programs that start on a single trigger. Segment Sequence of instructions, for a single channel. Inheritance previous playlist next iqm.pulse.playlist.schedule.TOLERANCE \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_DRIVE_LOCUS_MAPPING",
    "url": "/iqm-pulse/api/iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_DRIVE_LOCUS_MAPPING.html",
    "description": "Locus mapping name for mapping all components that have the drive operation defined. previous iqm.pulse.gate_implementation.NestedParams next iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_READO...",
    "content": "Locus mapping name for mapping all components that have the drive operation defined. previous iqm.pulse.gate_implementation.NestedParams next iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_READOUT_LOCUS_MAPPING \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "Segment",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.schedule.Segment.html",
    "description": "Bases: object Sequence of instructions, for a single channel. Basically a list[Instruction] that keeps track of the time duration of its contents. instructions ( Iterable [ Instruction ] ) \u2013 contents ...",
    "content": "Bases: object Sequence of instructions, for a single channel. Basically a list[Instruction] that keeps track of the time duration of its contents. instructions ( Iterable [ Instruction ] ) \u2013 contents of the segment duration ( int | None ) \u2013 If None, compute the sum of the durations of instructions .\nOtherwise, the time duration (in samples) of the segment, which must match\nthe aforementioned sum if the Segment is still to be modified. Module: iqm.pulse.playlist.schedule Attributes duration Sum of the durations of the instructions in the segment, in samples. Methods append Append an instruction to the end of the segment. copy Make an independent copy of the segment. extend Append all instructions from an iterable to the end of the segment. pop Remove and return the instruction at the given index of the segment. prepend Prepend an instruction to the beginning of the segment. contents total duration of the segment, in samples Make an independent copy of the segment. Mutating the original must not affect the copy, or vice versa.\nInstructions are immutable, so they need not be copied. copy of the segment Segment Append an instruction to the end of the segment. instruction ( Instruction ) \u2013 None Prepend an instruction to the beginning of the segment. instruction ( Instruction ) \u2013 None Append all instructions from an iterable to the end of the segment. instructions ( Iterable [ Instruction ] ) \u2013 None Remove and return the instruction at the given index of the segment. idx ( int ) \u2013 Instruction Sum of the durations of the instructions in the segment, in samples. previous Schedule next visualisation \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "Measure_Constant_Qnd",
    "url": "/iqm-pulse/api/iqm.pulse.gates.measure.Measure_Constant_Qnd.html",
    "description": "Bases: Measure_CustomWaveforms Implementation of a single-qubit projective, non quantum demolition, dispersive\nmeasurements in the Z basis. Uses a constant probe pulse. Module: iqm.pulse.gates.measure...",
    "content": "Bases: Measure_CustomWaveforms Implementation of a single-qubit projective, non quantum demolition, dispersive\nmeasurements in the Z basis. Uses a constant probe pulse. Module: iqm.pulse.gates.measure Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). parameters Required calibration data, may be nested Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 If set True , the Q channel waveform is considered to depend on the I channel\u2019s waveform\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\nwill be initialised as True . Required calibration data, may be nested alias of Constant alias of Constant previous Measure_Constant next Measure_CustomWaveforms \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.playlist.hd_drag.solve_cosine_coefs_for_hd_drag",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.hd_drag.solve_cosine_coefs_for_hd_drag.html",
    "description": "Solve cosine coefficients of the basis envelope given the number of suppressed frequencies. The cosine coefficients \\(\\{d_k\\}_{k=1}^{K+1}\\) define the basis envelope as \\(g(t) = \\sum_{k=1}^{K+1} d_k (...",
    "content": "Solve cosine coefficients of the basis envelope given the number of suppressed frequencies. The cosine coefficients \\(\\{d_k\\}_{k=1}^{K+1}\\) define the basis envelope as \\(g(t) = \\sum_{k=1}^{K+1} d_k (1 - \\cos(2\\pi k t/t_p + k\\pi))\\) , where the pulse is defined on the\ninterval \\(t \\in [-t_p/2, t_p/2]\\) . number_of_suppressed_freqs ( int ) \u2013 Number of suppressed frequencies Coefficient array of length number_of_suppressed_freqs + 1 ndarray previous iqm.pulse.playlist.hd_drag.evaluate_nth_derivative_of_basis_envelope next iqm.pulse.playlist.hd_drag.solve_hd_drag_coefficients_from_suppressed_frequencies \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "PRX_SinglePulse_GateImplementation",
    "url": "/iqm-pulse/api/iqm.pulse.gates.prx.PRX_SinglePulse_GateImplementation.html",
    "description": "Bases: SinglePulseGate , PrxGateImplementation Base class for PRX gates implemented using a single IQ pulse. This class implements phased x rotation gates on a specific qubit using an IQPulse instance...",
    "content": "Bases: SinglePulseGate , PrxGateImplementation Base class for PRX gates implemented using a single IQ pulse. This class implements phased x rotation gates on a specific qubit using an IQPulse instance, derived from the pulse calibration data provided at construction by\nthe static method _single_iq_pulse() .\nThe pulse is used to resonantly drive the qubit to effect the required rotation. The pulse calibration data consists of the parameters of an \\(x_\\pi\\) IQPulse only.\nIt is assumed that the transfer function from the AWG to the qubit is linear, i.e.,\nother rotation angles can be obtained by linearly scaling the pulse amplitude, and other phase angles can be obtained by adjusting the IQ modulation phase. The generated pulses all have the same time duration, also for identity rotations. In the special case of the\nduration being zero, the gate implementation will apply a Block(0) instruction to the qubit\u2019s drive channel. Module: iqm.pulse.gates.prx Attributes iq_pulse Alias for self.pulse for backward compatibility Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Phased X rotation gate. angle ( float ) \u2013 Rotation angle in radians. phase ( float ) \u2013 Phase angle in radians. Boxed instruction schedule implementing the phased X rotation gate. TimeBox Alias for self.pulse for backward compatibility previous PRX_ModulatedDRAGCosineRiseFall next PrxGateImplementation \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "RZ_ACStarkShift_smoothConstant",
    "url": "/iqm-pulse/api/iqm.pulse.gates.rz.RZ_ACStarkShift_smoothConstant.html",
    "description": "Bases: Constant_PRX_with_smooth_rise_fall Constant AC stark pulse with cosine rise and fall padding.\nImplemented as a 3-instruction Schedule. Constructs an instance of the AC Stark pulse for the given...",
    "content": "Bases: Constant_PRX_with_smooth_rise_fall Constant AC stark pulse with cosine rise and fall padding.\nImplemented as a 3-instruction Schedule. Constructs an instance of the AC Stark pulse for the given locus. Module: iqm.pulse.gates.rz Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 alias of CosineFall alias of Constant Required calibration data, may be nested alias of CosineRise True iff the implementation is symmetric in its locus components.\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous RZ_ACStarkShift_CosineRiseFall next RZ_PRX_Composite \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "gates",
    "url": "/iqm-pulse/api/iqm.pulse.gates.html",
    "description": "Implementations of quantum gates. The GateImplementation subclasses in this subpackage construct TimeBox instances to\nimplement specific native gates, using the calibration data that the class has bee...",
    "content": "Implementations of quantum gates. The GateImplementation subclasses in this subpackage construct TimeBox instances to\nimplement specific native gates, using the calibration data that the class has been initialized with.\nEach GateImplementation instance encapsulates the calibration data for a specific implementation of a specific\nnative gate acting on a specific locus. Several different implementations and calibration schemes can be supported for a given gate,\neach represented by its own GateImplementation subclass.\nLikewise, a single GateImplementation subclass can be sometimes used to implement several different gates\nthrough different calibration data. Full path: iqm.pulse.gates Functions expose_implementation (implementation[,\u00a0...]) Add the given gate implementation to the list of known implementations. get_implementation_class (class_name) Get gate implementation class by class name. register_implementation (operations,\u00a0...[,\u00a0...]) Register a new gate implementation, and a new gate (operation) if needed. Subpackages and modules barrier Barrier metaoperation. conditional Classically controlled gates. cz Two-qubit controlled-Z (CZ) gate. default_gates This file defines the default quantum gates and operations for IQM's pulse control system delay Force a delay between instructions on the control channels of specific locus components. enums Enumerations for representing a set of important one- and two-qubit gates. flux_multiplexer GateImplementation for correcting flux crosstalk for a given set of flux-pulse TimeBoxes measure Projective measurement in the Z basis. move Two-qubit MOVE gate. prx Single-qubit PRX gate. reset Resetting qubits to the zero state. rz Single-qubit RZ gate. sx Single-qubit sqrt(X) gate. u Single-qubit SU(2) gate. previous SinglePulseGate next iqm.pulse.gates.expose_implementation \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "channel",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.channel.html",
    "description": "Control channel properties. Full path: iqm.pulse.playlist.channel Functions get_channel_properties (chip_topology,\u00a0...) Internal function to get channel properties. get_channel_properties_from_station...",
    "content": "Control channel properties. Full path: iqm.pulse.playlist.channel Functions get_channel_properties (chip_topology,\u00a0...) Internal function to get channel properties. get_channel_properties_from_station_settings (...) Get channel properties from Station Control controller settings following the standard convention. round_duration_to_granularity_samples (...[,\u00a0...]) Round a time duration to the least common multiple of the granularities of the given channels. Classes ChannelConfiguration Base class for configuring channels. ChannelDescription Channel specific data, including tables for the instructions and waveforms used. ChannelProperties Defines the properties of a control or measurement channel. IQChannelConfig Requested configuration of an IQ channel. ProbeChannelProperties ChannelProperties for probe line channels. RealChannelConfig Requested configuration of a real channel. Inheritance previous playlist next iqm.pulse.playlist.channel.get_channel_properties \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.builder.load_config",
    "url": "/iqm-pulse/api/iqm.pulse.builder.load_config.html",
    "description": "Load quantum operation definitions and calibration data from a YAML config file. path ( str ) \u2013 path to a YAML config file quantum operation definitions, calibration data tree tuple [ dict [ str , Qua...",
    "content": "Load quantum operation definitions and calibration data from a YAML config file. path ( str ) \u2013 path to a YAML config file quantum operation definitions, calibration data tree tuple [ dict [ str , QuantumOp ], dict [ str , dict [ str , dict [ tuple [ str , \u2026] | None , dict [ str , Any ]]]]] previous iqm.pulse.builder.build_quantum_ops next iqm.pulse.builder.validate_quantum_circuit \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "CosineRiseFallDerivative",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.waveforms.CosineRiseFallDerivative.html",
    "description": "Bases: Waveform Derivative of a waveform that has a sinusoidal rise and fall, and a constant part in between. where \\(c\\) is center_offset , \\(r\\) is rise_time , and \\(p\\) is the plateau width,\ncalcul...",
    "content": "Bases: Waveform Derivative of a waveform that has a sinusoidal rise and fall, and a constant part in between. where \\(c\\) is center_offset , \\(r\\) is rise_time , and \\(p\\) is the plateau width,\ncalculated via \\(p :=\\) full_width - 2 * rise_time . Its values are in \\([-1, 1]\\) . full_width ( float ) \u2013 Duration of the support of the pulse, >= 2 * rise_time . rise_time ( float ) \u2013 Duration of the sinusoidal rise (and fall) part of the waveform, >= 0. center_offset ( float ) \u2013 The waveform is centered at this offset from the midpoint of the sampling window. n_samples ( int ) \u2013 Module: iqm.pulse.playlist.waveforms Attributes center_offset  full_width  rise_time  n_samples Requested number of samples for the waveform. Methods Actually samples the waveform. sample_coords ( ndarray ) \u2013 coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) ndarray previous CosineRise next ModulatedCosineRiseFall \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "CZ_Slepian_ACStarkCRF",
    "url": "/iqm-pulse/api/iqm.pulse.gates.cz.CZ_Slepian_ACStarkCRF.html",
    "description": "Bases: CouplerFluxPulseQubitACStarkPulseGate Controlled-Z two-qubit gate. CZ gate implemented using a slepian flux pulse for the coupler and a modulated cosine rise fall (CRF) AC Stark\npulse on one qu...",
    "content": "Bases: CouplerFluxPulseQubitACStarkPulseGate Controlled-Z two-qubit gate. CZ gate implemented using a slepian flux pulse for the coupler and a modulated cosine rise fall (CRF) AC Stark\npulse on one qubit. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 alias of Slepian Required calibration data, may be nested alias of ModulatedCosineRiseFall True iff the implementation is symmetric in its locus components.\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous CZ_Slepian next CZ_Slepian_CRF \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "MoveMarker",
    "url": "/iqm-pulse/api/iqm.pulse.gates.move.MoveMarker.html",
    "description": "Bases: Wait Special annotation instruction to indicate the beginning and ending of MOVE gates. The same instance of this instruction will be inserted into the qubit drive channel and the\nresonator vir...",
    "content": "Bases: Wait Special annotation instruction to indicate the beginning and ending of MOVE gates. The same instance of this instruction will be inserted into the qubit drive channel and the\nresonator virtual drive channel, right before the beginning MOVE VirtualRZ instructions,\nto link the channels together (otherwise, there would be nothing explicit in the Schedule\nindicating that there is a MOVE gate happening between the qubit and the resonator). Another shared instance will be inserted to the aforementioned channels right before the ending\nMOVE VirtualRZ instruction. The VirtualRZ instructions between the markers on the resonator\nchannel will be applied to the qubit instead in a post-compilation pass. Module: iqm.pulse.gates.move Attributes duration Time duration of the instruction. qubit  resonator  detuning  Methods duration ( int ) \u2013 qubit ( str ) \u2013 resonator ( str ) \u2013 detuning ( float ) \u2013 Time duration of the instruction. In samples at the channel sample rate. previous MOVE_TGSS_CRF next prx \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "barrier",
    "url": "/iqm-pulse/api/iqm.pulse.gates.barrier.html",
    "description": "Barrier metaoperation. The barrier is an n-qubit metaoperation that forces a specific temporal ordering on the quantum\noperations on different sides of it (the ones preceding the barrier are always ex...",
    "content": "Barrier metaoperation. The barrier is an n-qubit metaoperation that forces a specific temporal ordering on the quantum\noperations on different sides of it (the ones preceding the barrier are always executed first). Full path: iqm.pulse.gates.barrier Classes Barrier GateImplementation for the n-qudit barrier metaoperation. Inheritance previous iqm.pulse.gates.register_implementation next Barrier \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.gate_implementation.OILCalibrationData",
    "url": "/iqm-pulse/api/iqm.pulse.gate_implementation.OILCalibrationData.html",
    "description": "Calibration data for a particular implementation of a particular quantum operation at a particular locus. alias of dict [ str , Any ] previous iqm.pulse.gate_implementation.Locus next iqm.pulse.gate_i...",
    "content": "Calibration data for a particular implementation of a particular quantum operation at a particular locus. alias of dict [ str , Any ] previous iqm.pulse.gate_implementation.Locus next iqm.pulse.gate_implementation.OICalibrationData \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "CosineRise",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.waveforms.CosineRise.html",
    "description": "Bases: Waveform Cosine Rise waveform. This waveform assumes that during its duration, the only thing happening is signal occurring to the required\namplitude.\nThe waveform is made for pairing with \u2018Con...",
    "content": "Bases: Waveform Cosine Rise waveform. This waveform assumes that during its duration, the only thing happening is signal occurring to the required\namplitude.\nThe waveform is made for pairing with \u2018Constant\u2019 waveform to enable arbitrarily long pulses with smooth rise part.\nThe rise time is equal to pulse duration. rise_time \u2013 Dummy parameter, used only as due to a bug. FIXME it is not used, placed for resolving exa bug n_samples ( int ) \u2013 Module: iqm.pulse.playlist.waveforms Attributes n_samples Requested number of samples for the waveform. Methods Actually samples the waveform. sample_coords ( ndarray ) \u2013 coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) ndarray previous CosineFall next CosineRiseFallDerivative \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.gates.rz.get_unitary_rz",
    "url": "/iqm-pulse/api/iqm.pulse.gates.rz.get_unitary_rz.html",
    "description": "Unitary for an RZ gate. angle ( float ) \u2013 rotation angle (in rad) 2x2 unitary representing rz(angle) . ndarray previous rz next RZ_ACStarkShift \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. L...",
    "content": "Unitary for an RZ gate. angle ( float ) \u2013 rotation angle (in rad) 2x2 unitary representing rz(angle) . ndarray previous rz next RZ_ACStarkShift \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "IQChannelConfig",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.channel.IQChannelConfig.html",
    "description": "Bases: RealChannelConfig Requested configuration of an IQ channel. Module: iqm.pulse.playlist.channel Attributes frequency upconversion frequency for the IQ pulses (in Hz) sample_rate sample rate of t...",
    "content": "Bases: RealChannelConfig Requested configuration of an IQ channel. Module: iqm.pulse.playlist.channel Attributes frequency upconversion frequency for the IQ pulses (in Hz) sample_rate sample rate of the instrument responsible for the channel (in Hz) Methods sample_rate ( float ) \u2013 frequency ( float ) \u2013 upconversion frequency for the IQ pulses (in Hz) previous ChannelProperties next ProbeChannelProperties \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.circuit_operations.get_unitary_from_op",
    "url": "/iqm-pulse/api/iqm.pulse.circuit_operations.get_unitary_from_op.html",
    "description": "Unitary matrix representing an operation within the context of the circuit. First, fetches the unitary corresponding to the correct operation from the QuantumOpTable. If that unitary\nis a function, ge...",
    "content": "Unitary matrix representing an operation within the context of the circuit. First, fetches the unitary corresponding to the correct operation from the QuantumOpTable. If that unitary\nis a function, gets the matrix by calling the function with values of quantum operation params stored\nin the operation. Checks whether the size of the unitary is correct. Then, optionally extends that unitary to act\non the Hilbert space of the entire circuit. op ( CircuitOperation ) \u2013 quantum operation instance table ( dict [ str , QuantumOp ] ) \u2013 registered quantum operations qubits ( list [ str ] ) \u2013 qubits of the whole circuit, in big-endian order Unitary matrix representing op on the Hilbert space of the circuit. ndarray previous iqm.pulse.circuit_operations.get_unitary_from_circuit next iqm.pulse.circuit_operations.reorder \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.playlist.channel.round_duration_to_granularity_samples",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.channel.round_duration_to_granularity_samples.html",
    "description": "Round a time duration to the least common multiple of the granularities of the given channels. Note Assumes that all the given control channels have the same sample rate. channels ( Iterable [ Channel...",
    "content": "Round a time duration to the least common multiple of the granularities of the given channels. Note Assumes that all the given control channels have the same sample rate. channels ( Iterable [ ChannelProperties ] ) \u2013 all these channels must be able to handle the rounded duration duration ( float ) \u2013 time duration in s round_up ( bool ) \u2013 whether to round the duration up, or to the closest granularity force_min_duration ( bool ) \u2013 whether to force the duration to be at least the largest instruction_duration_min of channels duration rounded to common channel granularity, in samples int previous iqm.pulse.playlist.channel.get_channel_properties_from_station_settings next ChannelConfiguration \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "instructions",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.instructions.html",
    "description": "Instructions for control instruments. Full path: iqm.pulse.playlist.instructions Classes AcquisitionMethod Describes a way to acquire readout data. Block Behave strictly as if outputting zero-valued s...",
    "content": "Instructions for control instruments. Full path: iqm.pulse.playlist.instructions Classes AcquisitionMethod Describes a way to acquire readout data. Block Behave strictly as if outputting zero-valued samples for the duration of the instruction. ComplexIntegration Perform a weighted integration of the IQ raw signal, resulting in a complex number. ConditionalInstruction Choice between multiple Instructions, depending on a condition. FluxPulse RealPulse representing a flux pulse. IQPulse Play an upconverted pulse that contains real in-phase and quadrature waveforms. Instruction Command that can be executed by the quantum computer on a control channel. MultiplexedIQPulse Instruction to simultaneously play multiple IQ pulses. ReadoutTrigger Instruction for playing a probe pulse and acquiring the associated readout results. RealPulse Play a real-valued pulse. ThresholdStateDiscrimination Perform a weighted integration of the IQ raw signal and compare the real part of the result against a threshold value, resulting in a boolean. TimeTrace Capture the raw IQ signal without integration. VirtualRZ Change the upconversion phase reference. Wait Behave as if outputting zero-valued samples for the duration of the instruction. Inheritance previous HdDragQ next AcquisitionMethod \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.circuit_operations.reshape_unitary",
    "url": "/iqm-pulse/api/iqm.pulse.circuit_operations.reshape_unitary.html",
    "description": "Extend a unitary propagator to act on a larger system. Given a unitary matrix acting on N qubits, indices of N qubits in a larger Hilbert space, and the number\nof qubits in that Hilbert space, calcula...",
    "content": "Extend a unitary propagator to act on a larger system. Given a unitary matrix acting on N qubits, indices of N qubits in a larger Hilbert space, and the number\nof qubits in that Hilbert space, calculate a unitary acting on the larger Hilbert space, which acts as\nthe given unitary on the N selected qubits and as identity on the others. unitary ( tuple [ tuple [ float , ... ] , ... ] ) \u2013 original unitary as a nested tuple for hashing & caching purposes. indices ( tuple [ int , ... ] ) \u2013 qubit indices in the larger Hilbert space, all in range(num_qubits) n_qubits ( int ) \u2013 number of qubits in the larger Hilbert space Unitary matrix acting as unitary on the selected qubits in the larger Hilbert space. ndarray previous iqm.pulse.circuit_operations.reorder next CircuitOperationList \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "IQPulse",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.instructions.IQPulse.html",
    "description": "Bases: Instruction Play an upconverted pulse that contains real in-phase and quadrature waveforms. Module: iqm.pulse.playlist.instructions Attributes modulation_frequency Modulation frequency of the w...",
    "content": "Bases: Instruction Play an upconverted pulse that contains real in-phase and quadrature waveforms. Module: iqm.pulse.playlist.instructions Attributes modulation_frequency Modulation frequency of the waveforms, in units of the sampling rate. phase Phase of the pulse relative to the channel frequency, in radians. phase_increment Relative phase increment to the phase in the carrier frequency of this pulse and all pulses that are played after it. scale_i Scaling factor for the I quadrature. scale_q Scaling factor for the Q quadrature. wave_i I quadrature envelope. wave_q Q quadrature envelope. duration Time duration of the instruction. Methods get_waveforms Returns all the waveforms the Instruction contains. validate Validate the instruction attributes. duration ( int ) \u2013 wave_i ( Waveform ) \u2013 wave_q ( Waveform ) \u2013 scale_i ( float ) \u2013 scale_q ( float ) \u2013 phase ( float ) \u2013 modulation_frequency ( float ) \u2013 phase_increment ( float ) \u2013 I quadrature envelope. Q quadrature envelope. Scaling factor for the I quadrature. Scaling factor for the Q quadrature. Phase of the pulse relative to the channel frequency, in radians. Modulation frequency of the waveforms, in units of the sampling rate.\nThis modulation is additional to the channel frequency.\nThe default value of 0.0 does not modulate.\nNote that the phase of this modulation resets for every instruction, that is, successive instances of the same\nmodulated pulse are not phase coherent. Relative phase increment to the phase in the carrier frequency of this pulse and all pulses that\nare played after it. Unit: rad. Validate the instruction attributes. ValueError \u2013 something about the instruction is not ok Returns all the waveforms the Instruction contains. tuple [ Waveform , \u2026] previous FluxPulse next Instruction \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.gates.move.apply_move_gate_phase_corrections",
    "url": "/iqm-pulse/api/iqm.pulse.gates.move.apply_move_gate_phase_corrections.html",
    "description": "Schedule-level pass applying resonator-related phase corrections in MOVE sandwiches to the moved qubit. Note Assumes the MOVE gate implementation is based on MOVE_CustomWaveforms . Processes all the M...",
    "content": "Schedule-level pass applying resonator-related phase corrections in MOVE sandwiches to the moved qubit. Note Assumes the MOVE gate implementation is based on MOVE_CustomWaveforms . Processes all the MOVE sandwiches in schedule , summing up the VirtualRZ instructions\non the resonator virtual drive channels, adding the phase difference resulting from\nqubit-resonator detuning to the total, and applying it on the qubit at the end of each sandwich. schedule ( Schedule ) \u2013 instruction schedule to process builder ( ScheduleBuilder ) \u2013 schedule builder that was used to build schedule apply_detuning_corrections ( bool ) \u2013 if True, also apply detuning phase corrections copy of schedule with the phase corrections applied Schedule previous move next iqm.pulse.gates.move.validate_move_instructions \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "RealChannelConfig",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.channel.RealChannelConfig.html",
    "description": "Bases: ChannelConfiguration Requested configuration of a real channel. Module: iqm.pulse.playlist.channel Attributes sample_rate sample rate of the instrument responsible for the channel (in Hz) Metho...",
    "content": "Bases: ChannelConfiguration Requested configuration of a real channel. Module: iqm.pulse.playlist.channel Attributes sample_rate sample rate of the instrument responsible for the channel (in Hz) Methods sample_rate ( float ) \u2013 sample rate of the instrument responsible for the channel (in Hz) previous ProbeChannelProperties next fast_drag \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.gates.prx.get_unitary_prx",
    "url": "/iqm-pulse/api/iqm.pulse.gates.prx.get_unitary_prx.html",
    "description": "Unitary for a PRX gate. angle ( float ) \u2013 rotation angle (in rad) phase ( float ) \u2013 phase angle (in rad) 2x2 unitary representing prx(angle, phase) . ndarray previous prx next ABC_Constant_smooth \u00a9 Co...",
    "content": "Unitary for a PRX gate. angle ( float ) \u2013 rotation angle (in rad) phase ( float ) \u2013 phase angle (in rad) 2x2 unitary representing prx(angle, phase) . ndarray previous prx next ABC_Constant_smooth \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "ABC_Constant_smooth",
    "url": "/iqm-pulse/api/iqm.pulse.gates.prx.ABC_Constant_smooth.html",
    "description": "Bases: PrxGateImplementation Base class for creating gates with an arbitrarily long Constant pulses with smooth rise and fall.\nThis pulse creates a :\u2019Segment\u2019 consisting of three instructions : [rise_...",
    "content": "Bases: PrxGateImplementation Base class for creating gates with an arbitrarily long Constant pulses with smooth rise and fall.\nThis pulse creates a :\u2019Segment\u2019 consisting of three instructions : [rise_waveform, main_waveform, fall_waveform].\nThis class is created so that one can use middle waveform as a constant, thus enabling to use arbitrarily\nlong pulses, not limited by the awg memory. main_waveform: The middle part of the pulse, which should (but doesn\u2019t have to) be a Constant waveform\nrise_waveform: rise part of the pulse\nfall_waveform: fall part of the pulse\nchannel: Name of the drive channel on which the AC Stark pulse is played. Constructs an instance of the AC Stark pulse for the given locus. Module: iqm.pulse.gates.prx Attributes main_waveform  rise_waveform  fall_waveform  Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Phased X rotation gate. angle ( float ) \u2013 Rotation angle in radians. phase ( float ) \u2013 Phase angle in radians. Boxed instruction schedule implementing the phased X rotation gate. TimeBox Returns the main part pulse. Waveform is the same for both I and Q channels n_samples ( int ) \u2013 amplitude_i ( float ) \u2013 amplitude_q ( float ) \u2013 phase ( float ) \u2013 IQPulse Returns a rise pulse. n_samples ( int ) \u2013 amplitude_i ( float ) \u2013 amplitude_q ( float ) \u2013 IQPulse Returns a fall pulse n_samples ( int ) \u2013 amplitude_i ( float ) \u2013 amplitude_q ( float ) \u2013 IQPulse previous iqm.pulse.gates.prx.get_unitary_prx next Constant_PRX_with_smooth_rise_fall \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.gate_implementation.OCalibrationData",
    "url": "/iqm-pulse/api/iqm.pulse.gate_implementation.OCalibrationData.html",
    "description": "For a particular quantum operation, maps implementation names to their calibration data. alias of dict [ str , dict [ tuple [ str , \u2026] | None , dict [ str , Any ]]] previous iqm.pulse.gate_implementat...",
    "content": "For a particular quantum operation, maps implementation names to their calibration data. alias of dict [ str , dict [ tuple [ str , \u2026] | None , dict [ str , Any ]]] previous iqm.pulse.gate_implementation.OICalibrationData next iqm.pulse.gate_implementation.OpCalibrationDataTree \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "visualisation",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.visualisation.html",
    "description": "Full path: iqm.pulse.playlist.visualisation Subpackages and modules base Function for visualising playlists. previous Segment next base \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last upda...",
    "content": "Full path: iqm.pulse.playlist.visualisation Subpackages and modules base Function for visualising playlists. previous Segment next base \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "GateImplementation",
    "url": "/iqm-pulse/api/iqm.pulse.gate_implementation.GateImplementation.html",
    "description": "Bases: ABC ABC for implementing quantum gates and other quantum operations using instruction schedules. There is a separate GateImplementation subclass for every implementation of every operation type...",
    "content": "Bases: ABC ABC for implementing quantum gates and other quantum operations using instruction schedules. There is a separate GateImplementation subclass for every implementation of every operation type.\nEach GateImplementation instance represents a particular locus for that implementation, and encapsulates\nthe calibration data it requires. All GateImplementation subclasses __init__ must have exactly the below arguments in order to be\nusable via ScheduleBuilder.get_implementation() . GateImplementations also have the __call__() method, which takes the operation parameters\n(e.g. rotation angles) as input, and returns a TimeBox instance which implements\nan instance of the operation at that locus. parent ( QuantumOp ) \u2013 Quantum operation this instance implements. name ( str ) \u2013 Name of the implementation provided by this instance. locus ( Locus ) \u2013 Locus the operation acts on. calibration_data ( OILCalibrationData ) \u2013 (Raw) calibration data for the (operation, implementation, locus) represented by this instance builder ( ScheduleBuilder ) \u2013 Schedule builder. Module: iqm.pulse.gate_implementation Attributes parameters Required calibration data, may be nested qualified_name Qualified name of the implementation. special_implementation Set to True if  the implementation is a special purpose implementation that should never get called in ScheduleBuilder.get_implementation unless explicitly requested via the impl_name argument. symmetric True iff the implementation is symmetric in its locus components. Methods build Utility method for constructing a GateImplementation with self.builder . convert_calibration_data Convert time-like items in the calibration data to fractions of the time duration of the gate. duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). get_custom_locus_mapping Get custom locus mapping for this GateImplementation. get_locus_mapping_name Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. get_parameters Calibration data tree the GateImplementation subclass expects for each locus. needs_calibration Whether the implementation needs calibration data to_timebox Wraps the given instruction schedule into an atomic/resolved timebox. True iff the implementation is symmetric in its locus components.\nOnly meaningful if arity != 1 , and the locus components are of the same type. Required calibration data, may be nested Set to True if  the implementation is a special purpose implementation that should never get called in ScheduleBuilder.get_implementation unless explicitly requested via the impl_name argument. Qualified name of the implementation. Whether the implementation needs calibration data Returns True if the calibration dict must contain a node with keyed with\n<operation name>: <implementation name>: <appropriate locus> in order to use this implementation. bool The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs\nin the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox | list [ TimeBox ] Utility method for constructing a GateImplementation with self.builder . Inheriting classes may override this in order to add additional logic. op_name ( str ) \u2013 operation name locus ( tuple [ str , ... ] ) \u2013 locus the operation acts on impl_name ( str | None ) \u2013 implementation name. Uses the assigned default implementation if not specified. strict_locus ( bool ) \u2013 iff False, for non-symmetric implementations of symmetric ops the locus order may\nbe changed if no calibration data is available for the requested locus order Calibrated gate implementation. GateImplementation Wraps the given instruction schedule into an atomic/resolved timebox. schedule ( Schedule ) \u2013 TimeBox Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.\nSubclasses can reimplement this method in case it makes sense in their context. float Convert time-like items in the calibration data to fractions of the time duration of the gate. This is a convenience method for converting calibration data items involving time\ndurations measured in seconds into fractions of the duration of the gate. Values of items that are not measured in seconds or Hz are returned as is. Additionally, converts duration to channel samples and adds it in the converted\ncalibration data under the key \"n_samples\" , while the original \"duration\" key is removed. calibration_data ( OILCalibrationData ) \u2013 (subset of) calibration data for the gate/implementation/locus params ( NestedParams ) \u2013 (subset of) cls.parameters specifying the calibration_data items\nto convert and return channel_props ( ChannelProperties ) \u2013 used to convert \"duration\" from seconds into channel samples duration ( float | None ) \u2013 Time duration of the gate, in seconds. If None, calibration_data must have\nan item named \"duration\" , measured in seconds, which will be used instead. converted calibration_data items OILCalibrationData Calibration data tree the GateImplementation subclass expects for each locus. Helper method for EXA use. locus ( Iterable [ str ] ) \u2013 Locus component names to replace the wildcard character \"*\" in the calibration\nparameter names. One Setting will be generated for each component name in locus .\nIf there are no wildcard characters in cls.parameters , this argument has no effect. path ( Iterable [ str ] ) \u2013 parts of the dotted name for the root node, if any. EXA setting node describing the required calibration data for each locus.\nAll the Setting values are None . SettingNode Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. By default, it is \"<operation_name>.<implementation_name>\" . Inheriting classes may\noverride this for different behaviour. operation_name ( str ) \u2013 name of the quantum operation. implementation_name ( str ) \u2013 name of the implementation name of the locus mapping str Get custom locus mapping for this GateImplementation. This method can be used to return the locus mapping (wrt. to the given ChipTopology ) for this GateImplementation . Overriding this method allows a GateImplementation to be \u201cself-sufficient\u201d in the\nsense that it knows its own locus mapping. chip_topology ( ChipTopology ) \u2013 ChipTopology instance in which context to create the custom locus mapping. component_to_channels ( dict [ str , Iterable [ str ] ] ) \u2013 dict mapping QPU component names to an Iterable of channel operation names\navailable for this component (i.e. \u201creadout\u201d, \u201cdrive\u201d, \u201cflux\u201d). This info is often needed\nin building a locus mapping. Custom locus mapping for this GateImplementation or None if the gate implementation has no need for a custom locus mapping, otherwise the returned mapping should be like in ChipTopology.set_locus_mapping() custom locus mapping, otherwise the returned mapping should be like in ChipTopology.set_locus_mapping() dict [ tuple [ str , \u2026] | frozenset [ str ], tuple [ str , \u2026]] | None previous CustomIQWaveforms next SinglePulseGate \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.utils.map_waveform_param_types",
    "url": "/iqm-pulse/api/iqm.pulse.utils.map_waveform_param_types.html",
    "description": "Map a python typehint into EXA Parameter\u2019s (DataType, CollectionType) tuple. type \u2013 python typehint. type_hint ( type ) \u2013 A (DataType, CollectionType) tuple ValueError \u2013 for a non-supported type. tupl...",
    "content": "Map a python typehint into EXA Parameter\u2019s (DataType, CollectionType) tuple. type \u2013 python typehint. type_hint ( type ) \u2013 A (DataType, CollectionType) tuple ValueError \u2013 for a non-supported type. tuple [ DataType , CollectionType ] previous utils next iqm.pulse.utils.normalize_angle \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "Instruction",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.instructions.Instruction.html",
    "description": "Bases: object Command that can be executed by the quantum computer on a control channel. Has a well-specified time duration. Module: iqm.pulse.playlist.instructions Attributes duration Time duration o...",
    "content": "Bases: object Command that can be executed by the quantum computer on a control channel. Has a well-specified time duration. Module: iqm.pulse.playlist.instructions Attributes duration Time duration of the instruction. Methods copy Make a copy of the Instruction with the given changes applied to its contents. get_child_instructions Returns all the child Instructions the Instruction contains. get_waveforms Returns all the waveforms the Instruction contains. validate Validate the instruction attributes. duration ( int ) \u2013 Time duration of the instruction. In samples at the channel sample rate. Validate the instruction attributes. ValueError \u2013 something about the instruction is not ok None Make a copy of the Instruction with the given changes applied to its contents. Instruction Returns all the child Instructions the Instruction contains. tuple [ Instruction , \u2026] Returns all the waveforms the Instruction contains. tuple [ Waveform , \u2026] previous IQPulse next MultiplexedIQPulse \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.gate_implementation.Locus",
    "url": "/iqm-pulse/api/iqm.pulse.gate_implementation.Locus.html",
    "description": "Sequence of QPU component physical names a quantum operation is acting on. The order may matter. alias of tuple [ str , \u2026] previous gate_implementation next iqm.pulse.gate_implementation.OILCalibratio...",
    "content": "Sequence of QPU component physical names a quantum operation is acting on. The order may matter. alias of tuple [ str , \u2026] previous gate_implementation next iqm.pulse.gate_implementation.OILCalibrationData \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "MOVE_SLEPIAN_CRF",
    "url": "/iqm-pulse/api/iqm.pulse.gates.move.MOVE_SLEPIAN_CRF.html",
    "description": "Bases: MOVE_CustomWaveforms Qubit-resonator MOVE gate using the Slepian waveform for the coupler flux pulse and the\nCRF waveform for the qubit flux pulse. Module: iqm.pulse.gates.move Attributes param...",
    "content": "Bases: MOVE_CustomWaveforms Qubit-resonator MOVE gate using the Slepian waveform for the coupler flux pulse and the\nCRF waveform for the qubit flux pulse. Module: iqm.pulse.gates.move Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 alias of Slepian Required calibration data, may be nested alias of CosineRiseFall True iff the implementation is symmetric in its locus components.\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous MOVE_CustomWaveforms next MOVE_TGSS_CRF \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "ConditionalInstruction",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.instructions.ConditionalInstruction.html",
    "description": "Bases: Instruction Choice between multiple Instructions, depending on a condition. Module: iqm.pulse.playlist.instructions Attributes condition can be evaluated to an integer >= 0 outcomes maps possib...",
    "content": "Bases: Instruction Choice between multiple Instructions, depending on a condition. Module: iqm.pulse.playlist.instructions Attributes condition can be evaluated to an integer >= 0 outcomes maps possible outcomes of the condition to the corresponding instructions duration Time duration of the instruction. Methods get_child_instructions Returns all the child Instructions the Instruction contains. validate Validate the instruction attributes. duration ( int ) \u2013 condition ( str ) \u2013 outcomes ( tuple [ Instruction , ... ] ) \u2013 can be evaluated to an integer >= 0 maps possible outcomes of the condition to the corresponding instructions Validate the instruction attributes. ValueError \u2013 something about the instruction is not ok Returns all the child Instructions the Instruction contains. tuple [ Instruction , \u2026] previous ComplexIntegration next FluxPulse \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "Block",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.instructions.Block.html",
    "description": "Bases: Instruction Behave strictly as if outputting zero-valued samples for the duration of the instruction. Used to block a control channel during compilation.\nA more strict version of Wait , cannot ...",
    "content": "Bases: Instruction Behave strictly as if outputting zero-valued samples for the duration of the instruction. Used to block a control channel during compilation.\nA more strict version of Wait , cannot be replaced with DD sequences during compilation.\nConverted to a Wait instruction at the end of compilation process. In \u201cTetris\u201d scheduling, several Block instructions can overlap in time, whereas Waits cannot. Module: iqm.pulse.playlist.instructions Attributes duration Time duration of the instruction. Methods duration ( int ) \u2013 previous AcquisitionMethod next ComplexIntegration \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.quantum_ops.validate_locus_calibration",
    "url": "/iqm-pulse/api/iqm.pulse.quantum_ops.validate_locus_calibration.html",
    "description": "Validates calibration for a particular gate implementation at particular locus. cal_data ( OILCalibrationData ) \u2013 Calibration data tree for the locus. impl ( type [ GateImplementation ] ) \u2013 GateImplem...",
    "content": "Validates calibration for a particular gate implementation at particular locus. cal_data ( OILCalibrationData ) \u2013 Calibration data tree for the locus. impl ( type [ GateImplementation ] ) \u2013 GateImplementation class that defines the required parameters. op ( QuantumOp ) \u2013 QuantumOp that impl implements. impl_name ( str ) \u2013 name of the implementation, for error messages. locus ( tuple [ str , ... ] ) \u2013 Locus of the operation ValueError \u2013 there is something wrong with the calibration data None previous iqm.pulse.quantum_ops.QuantumOpTable next iqm.pulse.quantum_ops.validate_op_calibration \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "SinglePulseGate",
    "url": "/iqm-pulse/api/iqm.pulse.gate_implementation.SinglePulseGate.html",
    "description": "Bases: GateImplementation Base class for GateImplementations that play a single pulse on a single channel. The pulse is created in _get_pulse() and the channel is specified in _get_pulse_channel() .\nT...",
    "content": "Bases: GateImplementation Base class for GateImplementations that play a single pulse on a single channel. The pulse is created in _get_pulse() and the channel is specified in _get_pulse_channel() .\nThe base class also implements a basic _call() method that just inserts the specified pulse into the specified\nchannel, and a method for computing the pulse\u2019s duration. All of these methods can be overridden in subclasses. Module: iqm.pulse.gate_implementation Attributes Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs\nin the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox Return the channel for the pulse. The default is the drive channel for a single qubit locus. str Return pulse based on the provided calibration data. Instruction Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.\nSubclasses can reimplement this method in case it makes sense in their context. float previous GateImplementation next gates \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "PRX_DRAGGaussian",
    "url": "/iqm-pulse/api/iqm.pulse.gates.prx.PRX_DRAGGaussian.html",
    "description": "Bases: PRX_CustomWaveforms PRX gate, DRAG / TruncatedGaussian IQ pulse implementation. See PRX_CustomWaveforms . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel wave...",
    "content": "Bases: PRX_CustomWaveforms PRX gate, DRAG / TruncatedGaussian IQ pulse implementation. See PRX_CustomWaveforms . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). parameters Required calibration data, may be nested Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 If set True , the Q channel waveform is considered to depend on the I channel\u2019s waveform\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\nwill be initialised as True . Required calibration data, may be nested alias of TruncatedGaussian alias of TruncatedGaussianDerivative previous PRX_DRAGCosineRiseFallSX next PRX_DRAGGaussianSX \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.playlist.fast_drag.evaluate_fast_drag_q_envelope",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.fast_drag.evaluate_fast_drag_q_envelope.html",
    "description": "Evaluate Q-envelope of FAST DRAG for given coefficients. The Q-envelope is defined as \\(Q(t) = \\sum_{n=1}^{N} c_n n (-1)^n \\sin(2\\pi n t/t_p)]\\) , where \\(N\\) is\nthe number of cosine terms in the seri...",
    "content": "Evaluate Q-envelope of FAST DRAG for given coefficients. The Q-envelope is defined as \\(Q(t) = \\sum_{n=1}^{N} c_n n (-1)^n \\sin(2\\pi n t/t_p)]\\) , where \\(N\\) is\nthe number of cosine terms in the series, \\(\\{c_n\\}\\) are the coefficients, and the pulse is defined on the\ninterval \\(t \\in [-t_p/2, t_p/2]\\) . t_arr ( ndarray ) \u2013 Array of time points, at which the function is to be evaluated pulse_duration ( float ) \u2013 Pulse duration in the same units as t_arr coefficients ( ndarray ) \u2013 Coefficients of a FAST DRAG pulse Q-envelope of a FAST DRAG pulse evaluated at t_arr ndarray previous iqm.pulse.playlist.fast_drag.evaluate_fast_drag_i_envelope next iqm.pulse.playlist.fast_drag.fourier_transform_of_cos_basis_functions_as_tensor \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "ProbePulse_CustomWaveforms_noIntegration",
    "url": "/iqm-pulse/api/iqm.pulse.gates.measure.ProbePulse_CustomWaveforms_noIntegration.html",
    "description": "Bases: CustomIQWaveforms Base class for implementing a probe line probe pulse with custom waveforms in the I and Q channels without\nany integration. Similar to the ProbePulse_CustomWaveforms except th...",
    "content": "Bases: CustomIQWaveforms Base class for implementing a probe line probe pulse with custom waveforms in the I and Q channels without\nany integration. Similar to the ProbePulse_CustomWaveforms except that signal integration is removed. Module: iqm.pulse.gates.measure Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). root_parameters Parameters independent of the of Waveforms. wave_i Waveform for the I channel. wave_q Waveform for the Q channel. Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). get_locus_mapping_name Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. probe_timebox Returns a \"naked\" probe timebox that supports convenient multiplexing through MultiplexedProbeTimeBox.__add__ . parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Parameters independent of the of Waveforms. Inheriting classes may override this to include parameters common\nto all such implementations. Cache for probe_timebox() . Builds a probe pulse and an acquisition method using the calibration data. Subclasses may override this method if needed. waveform_params ( dict [ str , Any ] ) \u2013 root_params ( dict [ str , Any ] ) \u2013 if_freq ( float ) \u2013 IQPulse Returns a \u201cnaked\u201d probe timebox that supports convenient multiplexing through MultiplexedProbeTimeBox.__add__ . This method can be used if the user wants to control the multiplexing explicitly. With two MultiplexedProbeTimeBox``es ``A and B the result A + B has all the ReadoutTrigger instructions\non each probe channel of A and B multiplexed together and played simultaneously. key ( str ) \u2013 The readout results generated on this trigger will be assigned to f\"{qubit}__{key}\" , where qubit goes over the component names in self.locus . If empty,\nthe key \u201creadout.result\u201d will be used to maintain backwards compatibility. feedback_key ( str ) \u2013 The signals generated by this measure operation are routed using this key for\nfast feedback purposes. See __call__() . do_acquisition ( bool ) \u2013 if False, no acquisitions are added. MultiplexedProbeTimeBox containing the ReadoutTrigger instruction. MultiplexedProbeTimeBox Returns a TimeBox containing the multiplexed simultaneous measurement. If len(self.locus) == 1 , the TimeBox contains the measurement for just that component, otherwise\nthe measurements of components that belong to the same probeline are multiplexed together. The returned TimeBox instances behave like any other TimeBox in scheduling and circuit\ngeneration. With measurement TimeBoxes A and B the result A + B first plays the ReadoutTrigger instructions of A and only then those of B in each probe channel. If the multiplexing features of MultiplexedProbeTimeBox are needed, the method probe_timebox() can be used. In scheduling, the returned TimeBox blocks the locus components and the probe\nlines they are associated with. key ( str ) \u2013 Readout results generated on this trigger will be assigned to the acquisition labels f\"{qubit}__{key}\" , where qubit goes over the component names in self.locus .\nIf empty, the key \"readout.result\" will be used to maintain backwards compatibility. feedback_key ( str ) \u2013 If the readout mode is \u201cthreshold\u201d, the results generated by this measure operation\nare routed using the label f\"{qubit}__{feedback_key}\" for fast feedback purposes.\nThe signals are picked up by ConditionalInstruction`s that have the same label. The default value ` \u201d\u201d`` means the signal is not routed anywhere. TODO: currently the HW does not\nsupport multiple feedback keys per drive channel, so the actual key used will be FEEDBACK_KEY whenever any non-empty key is inputted. When the HW is improved, the actual key the user inputs\nshould be passed. TimeBox containing the ReadoutTrigger instruction. TimeBox Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.\nSubclasses can reimplement this method in case it makes sense in their context. float Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. By default, it is \"<operation_name>.<implementation_name>\" . Inheriting classes may\noverride this for different behaviour. operation_name ( str ) \u2013 name of the quantum operation. implementation_name ( str ) \u2013 name of the implementation name of the locus mapping str If set True , the Q channel waveform is considered to depend on the I channel\u2019s waveform\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\nwill be initialised as True . previous ProbePulse_CustomWaveforms next Probe_Constant \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.scheduler.extend_hard_boundary_in_seconds",
    "url": "/iqm-pulse/api/iqm.pulse.scheduler.extend_hard_boundary_in_seconds.html",
    "description": "The same as extend_hard_boundary , but the scheduling is done in seconds. Used when the probe channel sampling rate differs from the other channels\u2019 rate.\nThe incoming schedules measure Instruction du...",
    "content": "The same as extend_hard_boundary , but the scheduling is done in seconds. Used when the probe channel sampling rate differs from the other channels\u2019 rate.\nThe incoming schedules measure Instruction durations in samples, but component_durations is in seconds. schedule ( Schedule ) \u2013 Schedule that should be extended with child_schedule . Modified in place. child_schedule ( Schedule ) \u2013 Child schedule to be added. child_components ( set [ str ] ) \u2013 Components (qubits, couplers, computational_resonators) that have at least\none channel in child_schedule . neighborhood_components ( set [ str ] ) \u2013 Components neighboring the child_components that should\nadditionally be blocked in the scheduling. component_durations ( dict [ str , float ] ) \u2013 Blocked durations for each component in schedule .\nThese act as the earliest starting points for new segment added to any of the channels\nof a given component, but will also block the component even if it has no occupied channels\nin the schedule yet or ever (e.g. a computational resonator).\nThe durations are in seconds. Modified in place. is_alap ( bool ) \u2013 Whether the scheduling strategy is ALAP (As Late As Possible). channel_properties ( dict [ str , ChannelProperties ] ) \u2013 Mapping from channel name to its properties (e.g. the sample rates\nand granularities). None previous iqm.pulse.scheduler.extend_hard_boundary next iqm.pulse.scheduler.extend_schedule \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "ScheduleBuilder",
    "url": "/iqm-pulse/api/iqm.pulse.builder.ScheduleBuilder.html",
    "description": "Bases: object Builds instruction schedules out of quantum circuits or individual quantum operations. Encapsulates known quantum ops, the calibration information for them, QPU components and their\ntopo...",
    "content": "Bases: object Builds instruction schedules out of quantum circuits or individual quantum operations. Encapsulates known quantum ops, the calibration information for them, QPU components and their\ntopology, and controller properties. op_table ( QuantumOpTable ) \u2013 definitions of known quantum ops calibration ( OpCalibrationDataTree ) \u2013 calibration data tree for the quantum ops chip_topology ( ChipTopology ) \u2013 Chip topology derived from the CHAD. channels ( dict [ str , ChannelProperties ] ) \u2013 mapping of controller names to the configurations of their channels component_channels ( dict [ str , dict [ str , str ] ] ) \u2013 Mapping from QPU component name to a mapping of ('drive', 'flux', 'readout') to the name of the control channel responsible for that function of the component. Module: iqm.pulse.builder Attributes composite_cache Cache for the CompositeGate TimeBoxes. Methods build_playlist Build a playlist from a number of instruction schedules. circuit_to_timebox Convert a quantum circuit to a TimeBox. get_calibration Calibration data for the given quantum operation, implementation and locus. get_control_channels Control channels that directly affect quantum operations at the given locus. get_drive_channel Drive channel for the given QPU component. get_flux_channel Flux channel for the given QPU component. get_implementation Provide an implementation for a quantum operation at a given locus. get_implementation_class Implementation class for the given operation. get_probe_channel Probe line channel for the probe line component belongs to. get_virtual_feedback_channel_for Get virtual feedback channel for feedback to a given AWG from a given probe line. get_virtual_feedback_channels All virtual feedback signal channels for the given QPU component. has_calibration Is there calibration data for the given quantum operation, implementation and locus? inject_calibration Inject new calibration data, changing self.calibration after the ScheduleBuilder initialisation. resolve_timebox Resolve a TimeBox. timebox_to_schedule Convert a TimeBox to a finished instruction schedule, ready for execution. timeboxes_to_front_padded_playlist Temporary helper function, for converting a sequence of TimeBoxes to a Playlist. timeboxes_to_playlist Convert a sequence of TimeBoxes to a Playlist. validate_calibration Check that the calibration data matches the known quantum operations. validate_quantum_circuit Validate a sequence of circuit operations constituting a quantum circuit. wait Utility method for applying Block instructions on every channel of the given locus. Cached GateImplementations. The tree has the same structure as OpCalibrationDataTree. Cache for the CompositeGate TimeBoxes. Flushed whenever ANY calibration data is injected into the builder. self.component_channels mapping inverted cached for scheduling algorithm performance. This mapping is\nused in the scheduling to determine the components to block based on their associated channels. Only\nblocking channels are included in this mapping, non-blocking channels (e.g. certain virtual channels) do not\nblock their components, just themselves. Cache the probe and non-probe channel names for the scheduling algorithm performance Whether to require scheduling of probe instructions in seconds instead of in samples. This can happen for two\nreasons: 1) the probe channel has a different sampling rate to the other channels (e.g. with UHFQA) or\n2) the probe channels have a different instruction granularity to some of the other channels (e.g. with\nmixed stations that have the RO device from a different vendor than some of the AWGs). Cache representative channel properties for a probe and a non-probe channel for the scheduling algorithm\nperformance. Inject new calibration data, changing self.calibration after the ScheduleBuilder initialisation. Invalidates the gate_implementation cache for the affected operations/implementations/loci. Also invalidates\nthe cache for any factorizable gate implementation, if any of its locus components was affected. partial_calibration ( dict [ str , dict [ str , dict [ tuple [ str , ... ] | None , dict [ str , Any ] ] ] ] ) \u2013 data to be injected. Must have the same structure as self.calibration but does not\nhave to contain all operations/implementations/loci/values. Only the parts of the data that are\nfound will be merged into self.calibration (including any None values). self._cache will\nbe invalidated for the found operations/implementations/loci and only if the new calibration data\nactually differs from the previous. None Check that the calibration data matches the known quantum operations. ValueError \u2013 there is something wrong with the calibration data None Drive channel for the given QPU component. component ( str ) \u2013 name of a QPU component Name of the drive channel for component , if it exists. KeyError \u2013 if component does not exist or does not have a drive channel str Flux channel for the given QPU component. See get_drive_channel() . component ( str ) \u2013 str Probe line channel for the probe line component belongs to. See get_drive_channel() . component ( str ) \u2013 str All virtual feedback signal channels for the given QPU component. A virtual feedback channel between a source and a destination exists if the station configuration allows it. component can be either the source or the destination of the signal. component ( str ) \u2013 name of a QPU component Names of the virtual channels. list [ str ] Get virtual feedback channel for feedback to a given AWG from a given probe line. awg_name ( str ) \u2013 name of the awg node that receives the feedback bit. feedback_qubit ( str ) \u2013 which qubit\u2019s measurement resulted in the feedback bit The virtual feedback channel name. ValueError \u2013 if the given AWG does not support fast feedback from the given probe line. str Control channel name for the given QPU component and operation. name of the channel KeyError \u2013 if component does not exist or does not have the operation component ( str ) \u2013 operation ( str ) \u2013 str Is there calibration data for the given quantum operation, implementation and locus? op_name ( str ) \u2013 name of the quantum operation impl_name ( str ) \u2013 name of the implementation locus ( tuple [ str , ... ] ) \u2013 locus of the operation True iff requested calibration data was found bool Calibration data for the given quantum operation, implementation and locus. op_name ( str ) \u2013 name of the quantum operation impl_name ( str ) \u2013 name of the implementation locus ( tuple [ str , ... ] ) \u2013 locus of the operation requested calibration data ValueError \u2013 requested calibration data was not found dict [ str , Any ] Control channels that directly affect quantum operations at the given locus. Includes the probe, drive and flux channels of the locus QPU components.\nDoes not include e.g. any neighboring coupler channels, these will have to be added\nseparately in the TimeBox resolution phase. Will only return channels that are known to exist, i.e. are found in ScheduleBuilder.channels . locus ( Iterable [ str ] ) \u2013 locus on which the operation acts names of the control channels that directly affect the operation tuple [ str , \u2026] Utility method for applying Block instructions on every channel of the given locus. The Block instructions guarantee the locus components to idle for the given duration,\nand cannot e.g. be replaced with e.g. dynamical decoupling sequences.\nThey are treated the same as any other TimeBox contents: Blocks on different channels remain aligned in time during scheduling. The actual waiting time on a particular channel may thus be >= duration ,\nif the other channels have less non-blocking space on either side. Note TODO For now, this method can round duration to the nearest value allowed by each\nchannel if requested. This is for the benefit of EXA sweeping over waiting durations.\nIn the future, EXA sweep generation should be responsible for doing the rounding. locus ( Iterable [ str ] ) \u2013 locus components that should experience the wait duration ( float ) \u2013 how long to wait (in seconds) rounding ( bool ) \u2013 Iff True, for each channel separately, duration will be rounded to the\nnearest value allowed by the granularity of that channel. The Waits will start\nsimultaneously. box containing Block instructions on every control channel of locus TimeBox Provide an implementation for a quantum operation at a given locus. op_name ( str ) \u2013 name of the quantum operation locus ( Iterable [ str ] ) \u2013 locus of the operation impl_name ( str | None ) \u2013 name of the implementation ( None means the implementation is chosen automatically\nusing the logic described below) strict_locus ( bool ) \u2013 iff False, for non-symmetric implementations of symmetric ops the locus order may\nbe changed if no calibration data is available for the requested locus order use_priority_order ( bool ) \u2013 Only has an effect if impl_name is None . Iff False , QuantumOp.get_default_implementation_for_locus() is used. Otherwise, the first implementation in\nthe priority order that has calibration data for locus is chosen. The priority order is as follows:\n1. The locus-specific priority defined in QuantumOp.defaults_for_locus[locus] if any.\n2. The global priority order defined in QuantumOp.implementations . priority_calibration ( dict [ str , Any ] | None ) \u2013 Calibration data from which to load the calibration instead of the common calibration\ndata in calibration . If no calibration is found for the given implementation or priority_calibration is None , the common calibration is used. Any non-empty\nvalues found in priority_calibration will be merged to the common calibration. Note:\nusing priority_calibration will prevent saving/loading via the cache. requested implementation ValueError \u2013 requested implementation could not be provided GateImplementation Find an implementation and locus for the given quantum operation instance compatible\nwith the calibration data. op ( QuantumOp ) \u2013 quantum operation impl_name ( str | None ) \u2013 Name of the implementation. None means use the highest-priority implementation for\nwhich we have calibration data. locus ( tuple [ str , ... ] ) \u2013 locus of the operation strict_locus ( bool ) \u2013 iff False, for non-symmetric implementations of symmetric ops the locus order may\nbe changed to an equivalent one if no calibration data is available for the requested locus order chosen implementation name, locus ValueError \u2013 requested implementation could not be found ValueError \u2013 requested implementation had no calibration data for this locus ValueError \u2013 no specific implementation was requested, but no known implementation had\n    calibration data for this locus tuple [ str , tuple [ str , \u2026]] Build a factory class for the given quantum operation, implementation and locus. The GateImplementations are built when they are first requested, and cached for later use. op ( QuantumOp ) \u2013 quantum operation impl_name ( str | None ) \u2013 Name of the implementation. None means use the highest-priority implementation for\nwhich we have calibration data. locus ( tuple [ str , ... ] ) \u2013 locus of the operation strict_locus ( bool ) \u2013 iff False, for non-symmetric implementations of symmetric ops the locus order may\nbe changed if no calibration data is available for the requested locus order priority_calibration ( dict [ str , Any ] | None ) \u2013 Calibration data from which to load the calibration instead of the common\ncalibration data. Priority calibration should be either a dict of the type OILCalibrationData ,\ni.e. containing the operation name, implementation name, and locus, or just a dict containing\nthe calibration data for the locus implied by the args op , impl_name and locus . requested implementation ValueError \u2013 requested implementation could not be provided or had no calibration data for this locus GateImplementation Implementation class for the given operation. op_name ( str ) \u2013 name of the quantum operation impl_name ( str | None ) \u2013 name of the implementation ( None means use the default implementation) requested implementation class type [ GateImplementation ] Validate a sequence of circuit operations constituting a quantum circuit. operations ( Iterable [ CircuitOperation ] ) \u2013 quantum circuit to be validated require_measurements ( bool ) \u2013 iff True the circuit must include at least one measurement operation ValueError \u2013 operations do not constitute a valid quantum circuit None Convert a quantum circuit to a TimeBox. circuit ( Iterable [ CircuitOperation ] ) \u2013 quantum circuit name ( str ) \u2013 name of the circuit scheduling_algorithm ( SchedulingAlgorithm ) \u2013 scheduling algorithm to be used in resolving the TimeBoxes. locus_mapping ( dict [ str , str ] | None ) \u2013 optional mapping of placeholder component names to the physical component names used\nwhile resolving the circuit into a TimeBox. unresolved TimeBox that implements circuit ValueError \u2013 failed to convert circuit to a TimeBox TimeBox Temporary helper function, for converting a sequence of TimeBoxes to a Playlist. Each individual TimeBox in boxes is resolved into a Schedule, and then\neach schedules is front-padded with Wait instructions on each channel\nsuch that the resulting Schedules have equal durations. This is required since\nfor now in Station Control the delay before the final measurement is the same for\nall the Schedules in a Playlist, and we do not wish to lose coherence waiting for\nthe measurement after each Schedule is done. TODO Once Station Control can handle measurements better, this method should be removed,\nand timeboxes_to_playlist() be used instead. boxes ( Iterable [ TimeBox ] ) \u2013 TimeBoxes to include in the playlist neighborhood ( int ) \u2013 During scheduling, block neighboring channels of the used components this far. By default,\nblocks only the defined locus components and any other components which have occupied channels. playlist that implements boxes Playlist Convert a sequence of TimeBoxes to a Playlist. Resolves the boxes, converts them to Schedules, removes unnecessary channels, and then packs\nthe Schedules into a Playlist. Assumes all the TimeBoxes refer to the same QPU and its control channels. boxes ( Iterable [ TimeBox ] ) \u2013 TimeBoxes to include in the playlist neighborhood ( int ) \u2013 During scheduling, block neighboring channels of the used components this far.\nThe default value ensures that quantum operations work as intended, assuming the station\nis properly calibrated. Higher values may help defend against crosstalk, at the expense\nof a longer instruction schedule and thus more decoherence. playlist that implements boxes Playlist Convert a TimeBox to a finished instruction schedule, ready for execution. Resolves the box, then converts the durations of the instructions in the schedule to samples\nat the channel sample_rate. box ( TimeBox ) \u2013 TimeBox to resolve neighborhood ( int ) \u2013 During scheduling, block neighboring channels of the used components this far.\nThe default value ensures that quantum operations work as intended, assuming the station\nis properly calibrated. Higher values may help defend against crosstalk, at the expense\nof a longer instruction schedule and thus more decoherence. finished schedule that implements box Schedule Finishes the instruction schedule. removes channels that only have Waits in them fuses long-distance Rz corrections to the correct drive pulses schedule ( Schedule ) \u2013 schedule to finish finished copy of schedule Schedule Fuse long-distance (i.e. out-of-gate-locus) VirtualRZ corrections with the next drive pulse\nhappening after the FluxPulse they are correcting. schedule ( Schedule ) \u2013 Schedule Resolve a TimeBox. Resolves recursively each of the children of the box, and then concatenates the resulting\nSchedules into a new one using a specific scheduling strategy and algorithm. The supported algorithms are HARD_BOUNDARY , which treats each composite TimeBox as a solid rectangle (the\nlongest channel within defines the duration) and TETRIS , which packs the schedule as tightly as possible\n(solid instructions still cannot overlap) regardless of the TimeBox boundaries. Modifies box so that it becomes atomic, if it isn\u2019t already. box ( TimeBox ) \u2013 TimeBox to resolve neighborhood ( int ) \u2013 During scheduling, block control channels of neighboring QPU components this far\nfrom the locus. Values higher than 0 may help defend against crosstalk, at the expense\nof a longer instruction schedule and thus more decoherence. compute_neighborhood_hard_boundary ( bool ) \u2013 Whether to precompute the neighborhood components while resolving\na composite TimeBox in the HARD_BOUNDARY algorithm. Typically one does not want to do this on\nthe top layer composite TimeBox , since it would be unused. The algorithm sets this True on\nlower layers, where it improves the performance as the neighborhood components are needed in scheduling. instruction schedule that implements box Schedule Resolves a TimeBox using the HARD_BOUNDARY algorithm, which treats each composite TimeBox as a solid\nrectangle (the longest channel within defines the duration). box ( TimeBox ) \u2013 neighborhood ( int ) \u2013 compute_neighborhood ( bool ) \u2013 Schedule Computes and caches the blocking neighborhoods for HARD_BOUNDARY algorithm. box ( TimeBox ) \u2013 Atomic TimeBox whose neighborhood to compute. neighborhood ( int ) \u2013 Return QPU components this far from the locus. QPU components (plus maybe channels?) belonging the the given neighborhood of box . set [ str ] Resolves a TimeBox using the TETRIS algorithm, which packs the schedule as tightly as possible\n(solid instructions still cannot overlap) regardless of the TimeBox boundaries. box ( TimeBox ) \u2013 neighborhood ( int ) \u2013 Schedule Add additional blocked channels to the schedule, preventing their use during the schedule. In the idealized computational model we assume that in a (correctly calibrated) quantum computer\nthere is no effective interaction between QPU components (in the computational frame and subspace) while\na Wait instruction is acting on the flux channel of the coupler connecting those components\n(i.e., the coupler is idling).\nHence a QPU component experiences no effective evolution if Wait instructions are\nacting on its drive, flux and probe channels, and the flux channels of all its couplers. Of course, in reality the QPU will experience at least some decoherence during a Wait, and\npossibly some crosstalk.\nIn some applications, e.g. decoherence experiments, it is essential to Wait for a specific time,\nsince it\u2019s precisely the decoherence that we are interested in. However, if we are only interested in applying well-defined local quantum operations on specific\nloci, it is essential to shut down all unwanted dynamics by adding Block instructions on\ncontrol channels of the unused and neighboring channels.\nThey act like Waits (and are converted into Waits at the end of the scheduling), but are allowed\nto overlap in time, since we are only interested in blocking those channels for the duration of the\nquantum operation. schedule ( Schedule ) \u2013 instruction schedule to modify locus ( set [ str ] ) \u2013 information-carrying QPU components schedule is meant to operate on (does not include couplers) neighborhood ( int ) \u2013 How far should we block neighboring QPU components?\nZero means just the locus qubits, one means neighboring couplers, two means their neighboring\nqubits etc. schedule , with added Block instructions on all the neighbor channels,\nfor the duration of the schedule None Build a playlist from a number of instruction schedules. This involves compressing the schedules so that no duplicate information\nneeds to be transferred to Station Control. All virtual channels are dropped at this point. schedules ( Iterable [ Schedule ] ) \u2013 finished instruction schedules to include in the playlist finish_schedules ( bool ) \u2013 whether to finalise the schedules before building the playlist. Should be set True unless some process has already finalised them before calling this function. playlist containing the schedules ValueError \u2013 if the schedules contain channels with non-uniform sampling rates Playlist Create shortcut for self.get_implementation(<op_name>, \u2026) as self.<op_name>(\u2026) . If there is a name collision with another attribute in self , the shortcut method won\u2019t be added and\na warning is raised. op_name ( str ) \u2013 None previous CircuitOperation next circuit_operations \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "MOVE_TGSS_CRF",
    "url": "/iqm-pulse/api/iqm.pulse.gates.move.MOVE_TGSS_CRF.html",
    "description": "Bases: MOVE_CustomWaveforms Qubit-resonator MOVE gate using the TGSS waveform for the coupler flux pulse and the\nCRF waveform for the qubit flux pulse. Module: iqm.pulse.gates.move Attributes paramete...",
    "content": "Bases: MOVE_CustomWaveforms Qubit-resonator MOVE gate using the TGSS waveform for the coupler flux pulse and the\nCRF waveform for the qubit flux pulse. Module: iqm.pulse.gates.move Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 alias of TruncatedGaussianSmoothedSquare Required calibration data, may be nested alias of CosineRiseFall True iff the implementation is symmetric in its locus components.\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous MOVE_SLEPIAN_CRF next MoveMarker \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "ChannelDescription",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.channel.ChannelDescription.html",
    "description": "Bases: object Channel specific data, including tables for the instructions and waveforms used. name ( str ) \u2013 name of the controller handling the channel, also the name of the channel config ( RealCha...",
    "content": "Bases: object Channel specific data, including tables for the instructions and waveforms used. name ( str ) \u2013 name of the controller handling the channel, also the name of the channel config ( RealChannelConfig ) \u2013 properties of the channel instruction_table \u2013 mapping of the instructions to be executed on this channel. Each\ninstruction should be unique. waveform_table \u2013 Contains mapping of the waveforms to be executed on this channel. Each\nwaveform should be unique. Module: iqm.pulse.playlist.channel Attributes name  config  instruction_table  waveform_table  Methods add_instruction Add an instruction to the channel. Add an instruction to the channel. Each unique instruction in a channel gets assigned an integer index that can be used to refer to it.\nIf the instruction has associated Waveform s, they are indexed in a similar manner. instruction ( Instruction ) \u2013 instruction to be added index of the instruction int previous ChannelConfiguration next ChannelProperties \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "pulse",
    "url": "/iqm-pulse/api/iqm.pulse.html",
    "description": "Control pulses, gates and instruction schedules for quantum computers. Full path: iqm.pulse Subpackages and modules base_utils Base utility functions with no dependencies on other iqm.pulse modules. b...",
    "content": "Control pulses, gates and instruction schedules for quantum computers. Full path: iqm.pulse Subpackages and modules base_utils Base utility functions with no dependencies on other iqm.pulse modules. builder Tools for building instruction schedules. circuit_operations Representing quantum circuits as lists of CircuitOperations. gate_implementation Implementing abstract quantum operations as instruction schedules. gates Implementations of quantum gates. playlist Control pulses and instruction schedules for quantum computers. quantum_ops Quantum operations. scheduler Tools for composing instruction schedules in time. timebox Reserving QPU resources in instruction scheduling. utils Utility functions. validation Validation of playlists and instructions schedules. previous API Reference next base_utils \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "base_utils",
    "url": "/iqm-pulse/api/iqm.pulse.base_utils.html",
    "description": "Base utility functions with no dependencies on other iqm.pulse modules. Full path: iqm.pulse.base_utils Functions merge_dicts (A,\u00a0B[,\u00a0path,\u00a0merge_nones]) Merge two dictionaries recursively, leaving th...",
    "content": "Base utility functions with no dependencies on other iqm.pulse modules. Full path: iqm.pulse.base_utils Functions merge_dicts (A,\u00a0B[,\u00a0path,\u00a0merge_nones]) Merge two dictionaries recursively, leaving the originals unchanged. previous pulse next iqm.pulse.base_utils.merge_dicts \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.gates.reset.RESET_FEEDBACK_KEY",
    "url": "/iqm-pulse/api/iqm.pulse.gates.reset.RESET_FEEDBACK_KEY.html",
    "description": "The feedback key used in fast-feedback reset gate (the double underscore emphasizes the fact that this label should\nnot be manually used in fast feedback). previous iqm.pulse.gates.reset.RESET_MEASURE...",
    "content": "The feedback key used in fast-feedback reset gate (the double underscore emphasizes the fact that this label should\nnot be manually used in fast feedback). previous iqm.pulse.gates.reset.RESET_MEASUREMENT_KEY next Reset_Conditional \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.circuit_operations.get_unitary_from_circuit",
    "url": "/iqm-pulse/api/iqm.pulse.circuit_operations.get_unitary_from_circuit.html",
    "description": "Calculate the overall unitary implemented by a sequence of CircuitOperations. Iterate through the list of operations, skipping over barrier operations, and calculate the unitary\nfor each operation, an...",
    "content": "Calculate the overall unitary implemented by a sequence of CircuitOperations. Iterate through the list of operations, skipping over barrier operations, and calculate the unitary\nfor each operation, and then calculate the matrix product of all of them. The unitary definition must be present\nin the QuantumOpTable given as the second argument. circuit ( list [ CircuitOperation ] ) \u2013 list of CircuitOperations in order table ( dict [ str , QuantumOp ] | None ) \u2013 Table of all registered quantum ops. qubit_names ( list [ str ] | None ) \u2013 Optionally, the ordering of the qubits. Array describing the action of the circuit in big endian convention. ndarray previous circuit_operations next iqm.pulse.circuit_operations.get_unitary_from_op \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.quantum_ops.QuantumOpTable",
    "url": "/iqm-pulse/api/iqm.pulse.quantum_ops.QuantumOpTable.html",
    "description": "Type for representing tables of known quantum operations, maps names of the ops to their definitions. alias of dict [ str , QuantumOp ] previous quantum_ops next iqm.pulse.quantum_ops.validate_locus_c...",
    "content": "Type for representing tables of known quantum operations, maps names of the ops to their definitions. alias of dict [ str , QuantumOp ] previous quantum_ops next iqm.pulse.quantum_ops.validate_locus_calibration \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "PRX_CustomWaveformsSX",
    "url": "/iqm-pulse/api/iqm.pulse.gates.prx.PRX_CustomWaveformsSX.html",
    "description": "Bases: PRX_SinglePulse_GateImplementation , CustomIQWaveforms Base class for PRX gates implemented using SX gate, hot-swappable waveforms and phase manipulation. If the rotation angle \\(\\theta = \\pi/2...",
    "content": "Bases: PRX_SinglePulse_GateImplementation , CustomIQWaveforms Base class for PRX gates implemented using SX gate, hot-swappable waveforms and phase manipulation. If the rotation angle \\(\\theta = \\pi/2\\) , the timebox will consist of just the SX IQ pulse, with phase. If the rotation angle \\(\\theta = 0.0\\) , the timebox will consist of a single zero-amplitude pulse. If not, the timebox will consist of two IQ pulses, with phase. The formula for the PRX gate implemented using SX gates and z rotations is The fusing of z rotations to IQPulses is done inside the _call() method. All parameters in the pulse here is referring to the state of the qubits. Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). root_parameters Parameters independent of the of Waveforms. wave_i Waveform for the I channel. wave_q Waveform for the Q channel. Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Parameters independent of the of Waveforms. Inheriting classes may override this to include parameters common\nto all such implementations. Convert pulses into timebox, via extra Z rotations. There are exceptions while using 0, pi/2 and pi rotation in angle, for calibration reason. The duration of the\ntimebox can be different. angle ( float ) \u2013 phase ( float ) \u2013 TimeBox Builds a single sqrt(X) pulse from the calibration data. amplitude_i ( float ) \u2013 amplitude_q ( float ) \u2013 n_samples ( int ) \u2013 IQPulse If set True , the Q channel waveform is considered to depend on the I channel\u2019s waveform\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\nwill be initialised as True . previous PRX_CustomWaveforms next PRX_DRAGCosineRiseFall \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_FLUX_AWG_LOCUS_MAPPING",
    "url": "/iqm-pulse/api/iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_FLUX_AWG_LOCUS_MAPPING.html",
    "description": "Locus mapping name for mapping all components that have the flux operation defined and the flux controller\nhas an AWG. previous iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_READOUT_LOCUS_MAPPI...",
    "content": "Locus mapping name for mapping all components that have the flux operation defined and the flux controller\nhas an AWG. previous iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_READOUT_LOCUS_MAPPING next iqm.pulse.gate_implementation.PROBE_LINES_LOCUS_MAPPING \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "Chirp",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.waveforms.Chirp.html",
    "description": "Bases: Waveform Linear chirp, defined as where \\(\\omega[\\alpha, N]\\) is a cosine-tapered window. For \\(\\alpha = 1\\) it becomes rectangular,\nand for \\(\\alpha = 0\\) it becomes a Hann (or raised cosine) ...",
    "content": "Bases: Waveform Linear chirp, defined as where \\(\\omega[\\alpha, N]\\) is a cosine-tapered window. For \\(\\alpha = 1\\) it becomes rectangular,\nand for \\(\\alpha = 0\\) it becomes a Hann (or raised cosine) window. The chirp pulse is valued inside the Nyquist zone, such that \\(f_{0}\\) and \\(f_{1}\\) are constrained\nin the range \\([-0.5, 0.5]\\) . freq_start ( float ) \u2013 Initial frequency of the chirp waveform in the Nyquist zone. freq_stop ( float ) \u2013 Final frequency of the chirp waveform in the Nyquist zone. alpha ( float ) \u2013 Alpha parameter of the cosine-tapered window. Defaults to 0.05. phase ( float ) \u2013 Phase of the waveform. Defaults to 0 n_samples ( int ) \u2013 Module: iqm.pulse.playlist.waveforms Attributes alpha  phase  freq_start  freq_stop  n_samples Requested number of samples for the waveform. Methods non_timelike_attributes Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Actually samples the waveform. sample_coords \u2013 coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Used to construct the parameters for the calibration data required by the waveform.\nBy default all the waveform attributes are \u201ctimelike\u201d (the unit for their calibration data is s).\nHowever, some waveform attributes can be dimensionless, e.g. the relative amplitudes in a sum of\nconsisting of multiple terms, or frequency-like (calibration data has the unit \u2018Hz\u2019).\nIf a Waveform subclass has non-timelike attributes, it needs to redefine this method. When the Waveform is constructed, all timelike calibration data is converted to units of the\nsampling window duration, and all frequency-like calibration data into units of inverse sampling\nwindow duration. dict [ str , str ] previous waveforms next ChirpImag \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "RZ_ACStarkShift",
    "url": "/iqm-pulse/api/iqm.pulse.gates.rz.RZ_ACStarkShift.html",
    "description": "Bases: GateImplementation Implementation of the RZ gate using an AC Stark pulse. An AC Stark pulse is a strong off-resonant drive on a qubit. This pulse leads to a frequency shift of the qubit due\nto ...",
    "content": "Bases: GateImplementation Implementation of the RZ gate using an AC Stark pulse. An AC Stark pulse is a strong off-resonant drive on a qubit. This pulse leads to a frequency shift of the qubit due\nto the AC Stark effect. The qubit frequency shift depends on the AC Stark pulse amplitude and frequency. ac_stark_pulse \u2013 AC Stark pulse. channel \u2013 Name of the drive channel on which the AC Stark pulse is played. parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Constructs an instance of the AC Stark pulse for the given locus. Module: iqm.pulse.gates.rz Attributes ac_stark_waveform  Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs\nin the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.\nSubclasses can reimplement this method in case it makes sense in their context. float Returns an AC Stark pulse which consists of a modulated I and modulated Q waveform, where the Q quadrature\nhas an additional phase of -pi/2. n_samples ( int ) \u2013 amplitude ( float ) \u2013 phase_increment ( float ) \u2013 phase ( float ) \u2013 IQPulse previous iqm.pulse.gates.rz.get_unitary_rz next RZ_ACStarkShift_CosineRiseFall \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "flux_multiplexer",
    "url": "/iqm-pulse/api/iqm.pulse.gates.flux_multiplexer.html",
    "description": "GateImplementation for correcting flux crosstalk for a given set of flux-pulse TimeBoxes Full path: iqm.pulse.gates.flux_multiplexer Module Attributes TOLERANCE Tolerance for the maximum absolute valu...",
    "content": "GateImplementation for correcting flux crosstalk for a given set of flux-pulse TimeBoxes Full path: iqm.pulse.gates.flux_multiplexer Module Attributes TOLERANCE Tolerance for the maximum absolute value in a waveform for considering it to be uniformly zero. Classes FluxMultiplexer_SampleLinear Linear flux pulse multiplexed (user for correcting flux crosstalk). Inheritance previous XYGate next iqm.pulse.gates.flux_multiplexer.TOLERANCE \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "u",
    "url": "/iqm-pulse/api/iqm.pulse.gates.u.html",
    "description": "Single-qubit SU(2) gate. The SU(2) matrix in the computational basis is parametrized using Euler angles: where the angles \\(\\theta\\) , \\(\\phi\\) and \\(\\lambda\\) are in radians. They are the angles of s...",
    "content": "Single-qubit SU(2) gate. The SU(2) matrix in the computational basis is parametrized using Euler angles: where the angles \\(\\theta\\) , \\(\\phi\\) and \\(\\lambda\\) are in radians. They are the angles of subsequent\nZ, Y and Z Euler rotations: It rotates the qubit state around an arbitrary axis on the Bloch sphere. Some common single-qubit gates expressed as U gates: References https://openqasm.com/language/gates.html#built-in-gates Full path: iqm.pulse.gates.u Functions get_unitary_u (theta,\u00a0phi,\u00a0lam) Unitary for an SU(2) gate. Classes UGate SU(2) gate implemented using PRX. Inheritance previous SXGate next iqm.pulse.gates.u.get_unitary_u \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "Shelved_Measure_Constant",
    "url": "/iqm-pulse/api/iqm.pulse.gates.measure.Shelved_Measure_Constant.html",
    "description": "Bases: Shelved_Measure_CustomWaveforms Implementation of a shelved readout. A measure gate implemented as a constant waveform is surrounded by two prx_12 gates. Module: iqm.pulse.gates.measure Attribu...",
    "content": "Bases: Shelved_Measure_CustomWaveforms Implementation of a shelved readout. A measure gate implemented as a constant waveform is surrounded by two prx_12 gates. Module: iqm.pulse.gates.measure Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). parameters Required calibration data, may be nested Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 If set True , the Q channel waveform is considered to depend on the I channel\u2019s waveform\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\nwill be initialised as True . Required calibration data, may be nested alias of Constant alias of Constant previous Probe_Constant next Shelved_Measure_CustomWaveforms \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "FastDragQ",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.fast_drag.FastDragQ.html",
    "description": "Bases: FastDrag Q-component of the Fourier Ansatz Spectrum Tuning (FAST) drag pulse. The Q-envelope is defined as where \\(N\\) is the number of cosine terms in the series, \\(\\{c_n\\}\\) are the coefficie...",
    "content": "Bases: FastDrag Q-component of the Fourier Ansatz Spectrum Tuning (FAST) drag pulse. The Q-envelope is defined as where \\(N\\) is the number of cosine terms in the series, \\(\\{c_n\\}\\) are the coefficients, and\nthe pulse is defined on the interval \\(t \\in [-t_p/2, t_p/2]\\) . Module: iqm.pulse.playlist.fast_drag Attributes number_of_cos_terms  suppressed_interval_widths  weights  full_width  coefficients  suppressed_frequencies  compute_coefs_from_frequencies  n_samples Requested number of samples for the waveform. Methods n_samples ( int ) \u2013 full_width ( float ) \u2013 coefficients ( ndarray ) \u2013 suppressed_frequencies ( ndarray ) \u2013 compute_coefs_from_frequencies ( bool ) \u2013 number_of_cos_terms ( int ) \u2013 suppressed_interval_widths ( ndarray ) \u2013 weights ( ndarray ) \u2013 center_offset ( float ) \u2013 Actually samples the waveform. sample_coords ( ndarray ) \u2013 coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) ndarray previous FastDragI next SuppressedPulse \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.scheduler.NONSOLID",
    "url": "/iqm-pulse/api/iqm.pulse.scheduler.NONSOLID.html",
    "description": "Instructions that can be converted to Wait after scheduling. previous scheduler next iqm.pulse.scheduler.BLOCKING \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07....",
    "content": "Instructions that can be converted to Wait after scheduling. previous scheduler next iqm.pulse.scheduler.BLOCKING \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "Wait",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.instructions.Wait.html",
    "description": "Bases: Instruction Behave as if outputting zero-valued samples for the duration of the instruction. Used to idle QPU components. However, may be replaced with a dynamical decoupling sequence\nafter the...",
    "content": "Bases: Instruction Behave as if outputting zero-valued samples for the duration of the instruction. Used to idle QPU components. However, may be replaced with a dynamical decoupling sequence\nafter the scheduling step. If you want to make sure that this does not happen, use Block instead. Module: iqm.pulse.playlist.instructions Attributes duration Time duration of the instruction. Methods duration ( int ) \u2013 previous VirtualRZ next playlist \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "Constant_PRX_with_smooth_rise_fall",
    "url": "/iqm-pulse/api/iqm.pulse.gates.prx.Constant_PRX_with_smooth_rise_fall.html",
    "description": "Bases: ABC_Constant_smooth Constant PRX pulse with cosine rise and fall padding.\nImplemented as a 3-instruction Schedule. Constructs an instance of the AC Stark pulse for the given locus. Module: iqm....",
    "content": "Bases: ABC_Constant_smooth Constant PRX pulse with cosine rise and fall padding.\nImplemented as a 3-instruction Schedule. Constructs an instance of the AC Stark pulse for the given locus. Module: iqm.pulse.gates.prx Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 alias of CosineFall alias of Constant Required calibration data, may be nested alias of CosineRise True iff the implementation is symmetric in its locus components.\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous ABC_Constant_smooth next PRX_CustomWaveforms \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "AWGScheduleValidationData",
    "url": "/iqm-pulse/api/iqm.pulse.validation.AWGScheduleValidationData.html",
    "description": "Bases: object Controller specific validation data Module: iqm.pulse.validation Attributes sampling_rate  granularity  min_number_of_samples  compatible_instructions  Methods sampling_rate ( float ) \u2013 ...",
    "content": "Bases: object Controller specific validation data Module: iqm.pulse.validation Attributes sampling_rate  granularity  min_number_of_samples  compatible_instructions  Methods sampling_rate ( float ) \u2013 granularity ( int ) \u2013 min_number_of_samples ( int ) \u2013 compatible_instructions ( tuple [ type [ Operation ] , ... ] ) \u2013 previous iqm.pulse.validation.validate_playlist_compatibility next iqm.pulse.validation.AWGScheduleValidationError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "CircuitOperation",
    "url": "/iqm-pulse/api/iqm.pulse.builder.CircuitOperation.html",
    "description": "Bases: object Specific quantum operation applied on a specific part of the QPU, e.g. in a quantum circuit. Module: iqm.pulse.builder Attributes implementation name of the implementation name name of t...",
    "content": "Bases: object Specific quantum operation applied on a specific part of the QPU, e.g. in a quantum circuit. Module: iqm.pulse.builder Attributes implementation name of the implementation name name of the quantum operation locus names of the information-bearing QPU components (qubits, computational resonators...) the operation acts on args arguments for the operation Methods validate Validate the operation against a table of operation definitions. name ( str ) \u2013 locus ( tuple [ str , ... ] ) \u2013 args ( dict [ str , Any ] ) \u2013 implementation ( str | None ) \u2013 name of the quantum operation names of the information-bearing QPU components (qubits, computational resonators\u2026) the operation acts on arguments for the operation name of the implementation Validate the operation against a table of operation definitions. op_table ( dict [ str , QuantumOp ] ) \u2013 table containing allowed quantum operations ValueError \u2013 operation is not valid None previous iqm.pulse.builder.validate_quantum_circuit next ScheduleBuilder \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "CZ_TruncatedGaussianSmoothedSquare",
    "url": "/iqm-pulse/api/iqm.pulse.gates.cz.CZ_TruncatedGaussianSmoothedSquare.html",
    "description": "Bases: FluxPulseGate CZ gate using a TruncatedGaussianSmoothedSquare flux pulse on the coupler. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested qubit_wave Flu...",
    "content": "Bases: FluxPulseGate CZ gate using a TruncatedGaussianSmoothedSquare flux pulse on the coupler. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested qubit_wave Flux pulse Waveform to be played in the qubit flux AWG. symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 alias of TruncatedGaussianSmoothedSquare Required calibration data, may be nested Flux pulse Waveform to be played in the qubit flux AWG. True iff the implementation is symmetric in its locus components.\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous CZ_Slepian_CRF next CouplerFluxPulseQubitACStarkPulseGate \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "PRX_CustomWaveforms",
    "url": "/iqm-pulse/api/iqm.pulse.gates.prx.PRX_CustomWaveforms.html",
    "description": "Bases: PRX_SinglePulse_GateImplementation , CustomIQWaveforms Base class for PRX gates implemented using a single IQ pulse and hot-swappable waveforms. Module: iqm.pulse.gates.prx Attributes dependent...",
    "content": "Bases: PRX_SinglePulse_GateImplementation , CustomIQWaveforms Base class for PRX gates implemented using a single IQ pulse and hot-swappable waveforms. Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). root_parameters Parameters independent of the of Waveforms. wave_i Waveform for the I channel. wave_q Waveform for the Q channel. Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Parameters independent of the of Waveforms. Inheriting classes may override this to include parameters common\nto all such implementations. Builds an x_pi pulse out of the calibration data. amplitude_i ( float ) \u2013 amplitude_q ( float ) \u2013 n_samples ( int ) \u2013 IQPulse If set True , the Q channel waveform is considered to depend on the I channel\u2019s waveform\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\nwill be initialised as True . previous Constant_PRX_with_smooth_rise_fall next PRX_CustomWaveformsSX \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.gates.delay.DELAY_MAX_DURATION_SECONDS",
    "url": "/iqm-pulse/api/iqm.pulse.gates.delay.DELAY_MAX_DURATION_SECONDS.html",
    "description": "Maximum duration for individual Delay operations, in seconds. previous delay next Delay \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07....",
    "content": "Maximum duration for individual Delay operations, in seconds. previous delay next Delay \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.scheduler.BLOCKING",
    "url": "/iqm-pulse/api/iqm.pulse.scheduler.BLOCKING.html",
    "description": "Nonsolid Instructions that nevertheless block. previous iqm.pulse.scheduler.NONSOLID next iqm.pulse.scheduler.extend_hard_boundary \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated o...",
    "content": "Nonsolid Instructions that nevertheless block. previous iqm.pulse.scheduler.NONSOLID next iqm.pulse.scheduler.extend_hard_boundary \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.base_utils.merge_dicts",
    "url": "/iqm-pulse/api/iqm.pulse.base_utils.merge_dicts.html",
    "description": "Merge two dictionaries recursively, leaving the originals unchanged. A ( dict ) \u2013 dictionary B ( dict ) \u2013 another dictionary merge_nones ( bool ) \u2013 whether to also merge None and empty Sized values fr...",
    "content": "Merge two dictionaries recursively, leaving the originals unchanged. A ( dict ) \u2013 dictionary B ( dict ) \u2013 another dictionary merge_nones ( bool ) \u2013 whether to also merge None and empty Sized values from B to A. copy of A, with the contents of B merged in (and taking precedence) recursively dict previous base_utils next builder \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "Slepian",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.waveforms.Slepian.html",
    "description": "Bases: Waveform Slepian waveform, which minimizes non-adiabatic errors during a gate. It is assumed that the user has done the minimization in a prior step, such that the optimal \\(\\lambda_n\\) for\na s...",
    "content": "Bases: Waveform Slepian waveform, which minimizes non-adiabatic errors during a gate. It is assumed that the user has done the minimization in a prior step, such that the optimal \\(\\lambda_n\\) for\na specific length \\(\\tau_\\text{pulse}\\) (in the accelerated frame) is known. This class then reconstructs the\nwaveform with the following steps: Calculate \\(\\theta(\\tau)\\) (Slepian in the accelerated frame and in \\(\\theta\\) space) Calculate \\(t(\\tau)\\) (mapping time in the accelerated frame to time in the lab frame) Interpolate \\(\\theta(t)\\) (Slepian in the lab frame and in \\(\\theta\\) space) Calculate \\(f(t)\\) (Slepian in the lab frame and in frequency space) Calculate \\(V(t)\\) (Slepian in the lab frame and in voltage space) Since the waveform is normalized, any voltage pre-factor should go into the pulse amplitude. The user is advised to look up [ 2 ] for further details, since the derivation is mathematically\nheavy. full_width ( float ) \u2013 Duration of the support of the waveform. lambda_1 ( float ) \u2013 First coefficient of Slepian waveform. lambda_2 ( float ) \u2013 Second coefficient of Slepian waveform. frequency_initial_normalized ( float ) \u2013 Initial frequency of the pulsed component (usually coupler),\nnormalized by the maximum frequency of the pulsed component. frequency_to_minimize_normalized ( float ) \u2013 Frequency of the static component (usually qubit) which to\nminimize the leakage from/to, normalized by the maximum frequency of the pulsed component. coupling_strength_normalized ( float ) \u2013 Coupling strength between pulsed component and static component,\nnormalized by the maximum frequency of the pulsed component. center_offset ( float ) \u2013 The waveform is centered at this offset from the midpoint of the sampling window. squid_asymmetry ( float ) \u2013 Squid asymmetry. n_samples ( int ) \u2013 Module: iqm.pulse.playlist.waveforms Attributes center_offset  squid_asymmetry  full_width  lambda_1  lambda_2  frequency_initial_normalized  frequency_to_minimize_normalized  coupling_strength_normalized  n_samples Requested number of samples for the waveform. Methods non_timelike_attributes Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Used to construct the parameters for the calibration data required by the waveform.\nBy default all the waveform attributes are \u201ctimelike\u201d (the unit for their calibration data is s).\nHowever, some waveform attributes can be dimensionless, e.g. the relative amplitudes in a sum of\nconsisting of multiple terms, or frequency-like (calibration data has the unit \u2018Hz\u2019).\nIf a Waveform subclass has non-timelike attributes, it needs to redefine this method. When the Waveform is constructed, all timelike calibration data is converted to units of the\nsampling window duration, and all frequency-like calibration data into units of inverse sampling\nwindow duration. dict [ str , str ] Actually samples the waveform. sample_coords ( ndarray ) \u2013 coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) ndarray Calculate the samples of the actual Slepian waveform. coords ( ndarray ) \u2013 normalized sample coordinates, in \\([0, 1]\\) samples of the Slepian waveform ndarray Convert time in the accelerated frame to the lab frame (real time). Since the conversion is defined via an integral, finding an analytical solution was not possible. Therefore, we\nintegrate the expression numerically with scipy.integrate.romb() . tau ( float | ndarray ) \u2013 Time in the accelerated frame. num_samples ( int ) \u2013 Number of samples for the numerical integration. Must be of the form 2 ** k + 1. tau converted to the lab frame ndarray Parametrization of the Slepian waveform in the accelerated frame. The Slepian waveform is parametrized using Fourier base functions, where we only take the cosine terms into\naccount ( [ 2 ] has shown that this is a reasonable assumption).\nHere, \\(\\lambda_n\\) is the amplitude of the \\(n\\) -th term of the Fourier base function.\nIt is usually sufficient to take only up to second order terms into account, i.e. only \\(\\lambda_1\\) and \\(\\lambda_2\\) are non-zero. tau ( ndarray ) \u2013 Time in the accelerated frame, normalized to [0, 1] with tau_pulse. Slepian waveform in the theta space and accelerated frame. ndarray previous ModulatedCosineRiseFall next quantum_ops \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.playlist.fast_drag.evaluate_fast_drag_i_envelope",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.fast_drag.evaluate_fast_drag_i_envelope.html",
    "description": "Evaluate I-envelope of a FAST DRAG pulse for given coefficients. The I-envelope is defined as \\(I(t) = \\sum_{n=1}^{N} c_n [1 - (-1)^n \\cos(2\\pi n t/t_p)]\\) , where \\(N\\) is\nthe number of cosine terms ...",
    "content": "Evaluate I-envelope of a FAST DRAG pulse for given coefficients. The I-envelope is defined as \\(I(t) = \\sum_{n=1}^{N} c_n [1 - (-1)^n \\cos(2\\pi n t/t_p)]\\) , where \\(N\\) is\nthe number of cosine terms in the series, \\(\\{c_n\\}\\) are the coefficients, and the pulse is defined on the\ninterval \\(t \\in [-t_p/2, t_p/2]\\) . t_arr ( ndarray ) \u2013 Array of time points, at which the function is to be evaluated pulse_duration ( float ) \u2013 Pulse duration in the same units as t_arr coefficients ( ndarray ) \u2013 Coefficients of a FAST DRAG pulse I-envelope of a FAST DRAG pulse evaluated at t_arr ndarray previous iqm.pulse.playlist.fast_drag.compute_matrix_of_summed_fourier_transform_inner_products next iqm.pulse.playlist.fast_drag.evaluate_fast_drag_q_envelope \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.gates.move.validate_move_instructions",
    "url": "/iqm-pulse/api/iqm.pulse.gates.move.validate_move_instructions.html",
    "description": "Circuit-level pass to prepare a circuit containing MOVE gates for compilation. Validates that circuit conforms to the MOVE gate constraints. instructions ( Iterable [ CircuitOperation ] ) \u2013 quantum ci...",
    "content": "Circuit-level pass to prepare a circuit containing MOVE gates for compilation. Validates that circuit conforms to the MOVE gate constraints. instructions ( Iterable [ CircuitOperation ] ) \u2013 quantum circuit to validate builder ( ScheduleBuilder ) \u2013 schedule builder, encapsulating information about the station validate_prx ( bool ) \u2013 whether to validate the circuit for PRX gates between MOVE sandwiches as well instructions , unmodified ValueError \u2013 Circuit does not conform to MOVE constraints. Iterable [ CircuitOperation ] previous iqm.pulse.gates.move.apply_move_gate_phase_corrections next MOVE_CRF_CRF \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "MOVE_CustomWaveforms",
    "url": "/iqm-pulse/api/iqm.pulse.gates.move.MOVE_CustomWaveforms.html",
    "description": "Bases: FluxPulseGate Qubit-resonator MOVE gate using flux pulses on both components. This class implements the extra phase bookkeeping logic required to make the MOVE\ngates work as intended. Due to th...",
    "content": "Bases: FluxPulseGate Qubit-resonator MOVE gate using flux pulses on both components. This class implements the extra phase bookkeeping logic required to make the MOVE\ngates work as intended. Due to the unknown phase in the MOVE gate definition, the MOVEs\nneed to be applied in pairs, i.e. the resonator state is always moved back to the qubit\nit came from. Between this pair of MOVE gates you can apply any number of other two-component\ngates (CZs for example) between the resonator and other qubits. This sequence of\ngates acting on the resonator is called a MOVE sandwich . At the end of a sandwich we have\nto apply a local phase correction (z rotation) on the state that was moved back to the qubit. The __call__() method of this class uses the MoveMarker annotation instruction\nto mark the beginning and end of each MOVE sandwich, in order to enable the calculation of the\nangle of the z rotation to be applied on the moved qubit at the end of the sandwich to\ncounteract the phase accumulation during the sandwich relative to the computational frame of\nthe qubit.\nThe phase accumulation has two sources: Phase due to the frequency detuning between the qubit and the resonator,\nproportional to the time duration the MOVE sandwich. Phase due to the virtual z rotations applied on the resonator as\ngates are applied between it and another qubit, which need to be summed up.\nBy convention the resonator VirtualRZ angle of the MOVE implementation itself is currently\nalways zero (since only the sum of the resonator and qubit z rotation angles matters for MOVE),\nbut we also include it in the sum for completeness. The phases are calculated and applied on the qubits using apply_move_gate_phase_corrections() . Module: iqm.pulse.gates.move Attributes coupler_wave Flux pulse Waveform to be played in the coupler flux AWG. parameters Required calibration data, may be nested qubit_wave Flux pulse Waveform to be played in the qubit flux AWG. root_parameters Include the frequency difference between qubit and resonator in the gate parameters for phase tracking. symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Include the frequency difference between qubit and resonator in the gate parameters for phase tracking. The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs\nin the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox Flux pulse Waveform to be played in the coupler flux AWG. Required calibration data, may be nested Flux pulse Waveform to be played in the qubit flux AWG. True iff the implementation is symmetric in its locus components.\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous MOVE_CRF_CRF next MOVE_SLEPIAN_CRF \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "ModulatedCosineRiseFall",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.waveforms.ModulatedCosineRiseFall.html",
    "description": "Bases: Waveform Modulated Cosine Rise Fall waveform. This waveform takes the waveform CosineRiseFall and modulates it with a cosine signal\nwhich then has parameters frequency and phase , additional to...",
    "content": "Bases: Waveform Modulated Cosine Rise Fall waveform. This waveform takes the waveform CosineRiseFall and modulates it with a cosine signal\nwhich then has parameters frequency and phase , additional to the parameters full_width , rise_time , and center_offset , see description of TruncatedGaussianSmoothedSquare for\nfurther details. full_width ( float ) \u2013 Full width of the pulse, >= 2 * rise_time . rise_time ( float ) \u2013 Duration of the sinusoidal rise (and fall) part of the waveform, >= 0. modulation_frequency ( float ) \u2013 Modulation frequency. phase ( float ) \u2013 Phase of the modulation. center_offset ( float ) \u2013 The waveform is centered around this sampling window coordinate.\nIf zero, the pulse is placed in the middle of the sampling window. n_samples ( int ) \u2013 Module: iqm.pulse.playlist.waveforms Attributes center_offset  modulation_frequency  phase  full_width  rise_time  n_samples Requested number of samples for the waveform. Methods non_timelike_attributes Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Actually samples the waveform. sample_coords ( ndarray ) \u2013 coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) ndarray Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Used to construct the parameters for the calibration data required by the waveform.\nBy default all the waveform attributes are \u201ctimelike\u201d (the unit for their calibration data is s).\nHowever, some waveform attributes can be dimensionless, e.g. the relative amplitudes in a sum of\nconsisting of multiple terms, or frequency-like (calibration data has the unit \u2018Hz\u2019).\nIf a Waveform subclass has non-timelike attributes, it needs to redefine this method. When the Waveform is constructed, all timelike calibration data is converted to units of the\nsampling window duration, and all frequency-like calibration data into units of inverse sampling\nwindow duration. dict [ str , str ] previous CosineRiseFallDerivative next Slepian \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.playlist.hd_drag.COSINE_COEFFICIENTS_DICT",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.hd_drag.COSINE_COEFFICIENTS_DICT.html",
    "description": "Pre-computed coefficients of the cosine terms in the basis envelope (0th derivative). This dictionary contains a\nmapping from the number of suppressed frequencies to the coefficients of the cosine ter...",
    "content": "Pre-computed coefficients of the cosine terms in the basis envelope (0th derivative). This dictionary contains a\nmapping from the number of suppressed frequencies to the coefficients of the cosine terms computed using the\nfunction solve_cosine_coefs_for_hd_drag . previous hd_drag next iqm.pulse.playlist.hd_drag.evaluate_hd_drag_i_envelope \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "quantum_ops",
    "url": "/iqm-pulse/api/iqm.pulse.quantum_ops.html",
    "description": "Quantum operations. Full path: iqm.pulse.quantum_ops Module Attributes QuantumOpTable Type for representing tables of known quantum operations, maps names of the ops to their definitions. Functions va...",
    "content": "Quantum operations. Full path: iqm.pulse.quantum_ops Module Attributes QuantumOpTable Type for representing tables of known quantum operations, maps names of the ops to their definitions. Functions validate_locus_calibration (cal_data,\u00a0impl,\u00a0...) Validates calibration for a particular gate implementation at particular locus. validate_op_calibration (calibration,\u00a0ops) Validates quantum operation calibration data against the known quantum operations. Classes QuantumOp Describes a native quantum operation type. Inheritance previous Slepian next iqm.pulse.quantum_ops.QuantumOpTable \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "FluxPulseGate_CRF_CRF",
    "url": "/iqm-pulse/api/iqm.pulse.gates.cz.FluxPulseGate_CRF_CRF.html",
    "description": "Bases: FluxPulseGate CZ gate using a CosineRiseFall flux pulse on the coupler and on the qubit. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested symmetric True...",
    "content": "Bases: FluxPulseGate CZ gate using a CosineRiseFall flux pulse on the coupler and on the qubit. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 alias of CosineRiseFall Required calibration data, may be nested alias of CosineRiseFall True iff the implementation is symmetric in its locus components.\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous FluxPulseGate next FluxPulseGate_TGSS_CRF \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "sx",
    "url": "/iqm-pulse/api/iqm.pulse.gates.sx.html",
    "description": "Single-qubit sqrt(X) gate. The gate is doing pi/2 X gate, with additional Z rotation to correct phase. It rotates the qubit state in XZ plane (or around Y axis) for 90 degree. Full path: iqm.pulse.gat...",
    "content": "Single-qubit sqrt(X) gate. The gate is doing pi/2 X gate, with additional Z rotation to correct phase. It rotates the qubit state in XZ plane (or around Y axis) for 90 degree. Full path: iqm.pulse.gates.sx Classes SXGate SX gate implementation based on PRX gate, by limiting the angle to pi / 2. Inheritance previous RZ_Virtual next SXGate \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "PrxGateImplementation",
    "url": "/iqm-pulse/api/iqm.pulse.gates.prx.PrxGateImplementation.html",
    "description": "Bases: GateImplementation ABC for different implementations of the PRX gate. Module: iqm.pulse.gates.prx Attributes Methods clifford One-qubit XY Clifford gates. get_locus_mapping_name Get the name of...",
    "content": "Bases: GateImplementation ABC for different implementations of the PRX gate. Module: iqm.pulse.gates.prx Attributes Methods clifford One-qubit XY Clifford gates. get_locus_mapping_name Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. rx X rotation gate. ry Y rotation gate. parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Phased X rotation gate. angle ( float ) \u2013 Rotation angle in radians. phase ( float ) \u2013 Phase angle in radians. Boxed instruction schedule implementing the phased X rotation gate. TimeBox X rotation gate. angle ( float ) \u2013 rotation angle (in radians) boxed instruction schedule implementing the x rotation gate TimeBox Y rotation gate. angle ( float ) \u2013 rotation angle (in radians) boxed instruction schedule implementing the y rotation gate TimeBox One-qubit XY Clifford gates. xy_gate ( XYGate ) \u2013 Clifford gate boxed instruction schedule implementing the requested Clifford gate TimeBox Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. By default, it is \"<operation_name>.<implementation_name>\" . Inheriting classes may\noverride this for different behaviour. operation_name ( str ) \u2013 name of the quantum operation. implementation_name ( str ) \u2013 name of the implementation name of the locus mapping str previous PRX_SinglePulse_GateImplementation next reset \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "SegmentPointer",
    "url": "/iqm-pulse/api/iqm.pulse.scheduler.SegmentPointer.html",
    "description": "Bases: object Tool for working with Segments. Serves as a time pointer inside the Segment. Module: iqm.pulse.scheduler Attributes frac time, in seconds, after the start of the current instruction rema...",
    "content": "Bases: object Tool for working with Segments. Serves as a time pointer inside the Segment. Module: iqm.pulse.scheduler Attributes frac time, in seconds, after the start of the current instruction remainder Remaining duration of the current instruction (in seconds). source contents of the Segment idx index of the current instruction TOL time durations equal or smaller than this tolerance are considered zero (in seconds) Methods cut_tail Cut the source of the pointer at the current index. fastforward Move the pointer forward by duration seconds. get Current instruction. next Move to the beginning of the next instruction. rewind Move the pointer back by duration seconds. tail Instructions from the current index onwards. source ( list [ Instruction ] ) \u2013 idx ( int ) \u2013 TOL ( float ) \u2013 frac ( float ) \u2013 contents of the Segment index of the current instruction time durations equal or smaller than this tolerance are considered zero (in seconds) time, in seconds, after the start of the current instruction Current instruction. Instruction Remaining duration of the current instruction (in seconds). Move to the beginning of the next instruction. bool Cut the source of the pointer at the current index. Truncate source at idx , make self point to\nthe cut tail part only. frac is not changed. Note: modifies source . None Instructions from the current index onwards. Sequence [ Instruction ] Move the pointer back by duration seconds. duration ( float ) \u2013 None Move the pointer forward by duration seconds. duration ( float ) \u2013 bool previous iqm.pulse.scheduler.extend_schedule_new next timebox \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "MOVE_CRF_CRF",
    "url": "/iqm-pulse/api/iqm.pulse.gates.move.MOVE_CRF_CRF.html",
    "description": "Bases: MOVE_CustomWaveforms Qubit-resonator MOVE gate using the CRF waveform for the coupler and the qubit flux pulse. Module: iqm.pulse.gates.move Attributes parameters Required calibration data, may...",
    "content": "Bases: MOVE_CustomWaveforms Qubit-resonator MOVE gate using the CRF waveform for the coupler and the qubit flux pulse. Module: iqm.pulse.gates.move Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 alias of CosineRiseFall Required calibration data, may be nested alias of CosineRiseFall True iff the implementation is symmetric in its locus components.\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous iqm.pulse.gates.move.validate_move_instructions next MOVE_CustomWaveforms \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "CZ_Slepian",
    "url": "/iqm-pulse/api/iqm.pulse.gates.cz.CZ_Slepian.html",
    "description": "Bases: FluxPulseGate CZ gate using a Slepian flux pulse on the coupler. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested qubit_wave Flux pulse Waveform to be p...",
    "content": "Bases: FluxPulseGate CZ gate using a Slepian flux pulse on the coupler. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested qubit_wave Flux pulse Waveform to be played in the qubit flux AWG. symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 alias of Slepian Required calibration data, may be nested Flux pulse Waveform to be played in the qubit flux AWG. True iff the implementation is symmetric in its locus components.\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous CZ_GaussianSmoothedSquare next CZ_Slepian_ACStarkCRF \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "Nothing",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.schedule.Nothing.html",
    "description": "Bases: Instruction Used to extend a control channel in time, without blocking it, during scheduling. Can overlap with any other Instruction.\nConverted to a Wait instruction at the end of scheduling. M...",
    "content": "Bases: Instruction Used to extend a control channel in time, without blocking it, during scheduling. Can overlap with any other Instruction.\nConverted to a Wait instruction at the end of scheduling. Module: iqm.pulse.playlist.schedule Attributes duration Time duration of the instruction. Methods duration ( int ) \u2013 previous iqm.pulse.playlist.schedule.TOLERANCE next Schedule \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "Delay",
    "url": "/iqm-pulse/api/iqm.pulse.gates.delay.Delay.html",
    "description": "Bases: GateImplementation Applies a delay on the control channels of its locus components. This operation applies Wait instructions on all the control channels of all its locus\ncomponents.  The durati...",
    "content": "Bases: GateImplementation Applies a delay on the control channels of its locus components. This operation applies Wait instructions on all the control channels of all its locus\ncomponents.  The duration of all the Waits is the same, and it is given as a parameter for the\noperation, rounded up to the nearest possible duration the hardware can handle. Note We can only guarantee that the delay is at least of the requested duration.  Also, when\nDelay is used in a quantum circuit, the delay between the preceding and following operations is\nagain at least the requested duration, but could be much more depending on the other operations\nin the circuit.  To see why, consider e.g. the circuit [CZ(a, b), Delay(1, a), Delay(10, b), CZ(a, b)] where a and b are qubits.\nIn this case the actual delay between the two CZ gates will be 10 time units rounded up to\nhardware granularity. Module: iqm.pulse.gates.delay Attributes symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 True iff the implementation is symmetric in its locus components.\nOnly meaningful if arity != 1 , and the locus components are of the same type. Delay instruction. duration ( float ) \u2013 Duration of the requested wait (in seconds). Will be rounded up to the nearest\nduration that the hardware enables, with the exception that a duration of zero will\ncause no waiting. However, as usual, during scheduling all channels the TimeBox is\nacting on will be extended to the duration of the longest channel in the TimeBox. TimeBox previous iqm.pulse.gates.delay.DELAY_MAX_DURATION_SECONDS next enums \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "AcquisitionMethod",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.instructions.AcquisitionMethod.html",
    "description": "Bases: object Describes a way to acquire readout data. Module: iqm.pulse.playlist.instructions Attributes label Identifier for the returned data, like QB1__readout.time_trace . delay_samples Delay fro...",
    "content": "Bases: object Describes a way to acquire readout data. Module: iqm.pulse.playlist.instructions Attributes label Identifier for the returned data, like QB1__readout.time_trace . delay_samples Delay from beginning of probe pulse to beginning of acquisition window, in samples. Methods label ( str ) \u2013 delay_samples ( int ) \u2013 Identifier for the returned data, like QB1__readout.time_trace . Delay from beginning of probe pulse to beginning of acquisition window, in samples. previous instructions next Block \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_READOUT_LOCUS_MAPPING",
    "url": "/iqm-pulse/api/iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_READOUT_LOCUS_MAPPING.html",
    "description": "Locus mapping name for mapping all components that have the readout operation defined. previous iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_DRIVE_LOCUS_MAPPING next iqm.pulse.gate_implementat...",
    "content": "Locus mapping name for mapping all components that have the readout operation defined. previous iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_DRIVE_LOCUS_MAPPING next iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_FLUX_AWG_LOCUS_MAPPING \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.scheduler.extend_hard_boundary",
    "url": "/iqm-pulse/api/iqm.pulse.scheduler.extend_hard_boundary.html",
    "description": "Merge two Schedules together such that the timebox boundary is respected. This scheduling algorithm treats the Schedules as hard, rectangular boxes where any ragged edges\nwill be padded with Waits, an...",
    "content": "Merge two Schedules together such that the timebox boundary is respected. This scheduling algorithm treats the Schedules as hard, rectangular boxes where any ragged edges\nwill be padded with Waits, and the boxes are not allowed to overlap. The algorithm is as follows: 1. When adding child_schedule to schedule , the longest channel in schedule that overlaps with the\nchannels present in child determines the earliest possible starting time for the child_schedule , and all other\nchannels in schedule are padded with Wait to the aforementioned max length. 2. An occupied channel in schedule will always occupy all channels of the corresponding component (qubit,\ncoupler, \u2026). This is handled by keeping track of occupied durations for each component (no unnecessary padding\nis added to channels which do not have an actual physical pulse). 3. After the schedules are combined, all the common channels of schedule and child_schedule are blocked\nup to their common maximum length. This algorithm should not be used with variable sampling rates in the schedule channels. In that case, use extend_hard_boundary_in_seconds() instead. schedule ( Schedule ) \u2013 Schedule that should be extended with child_schedule . Modified in place. child_schedule ( Schedule ) \u2013 Child schedule to be added. child_components ( set [ str ] ) \u2013 Components (qubits, couplers, computational_resonators) that have at least\none channel in child_schedule . neighborhood_components ( set [ str ] ) \u2013 QPU components neighboring the child_components that should\nadditionally be blocked in the scheduling. component_durations ( dict [ str , int ] ) \u2013 Blocked durations for each component used by schedule .\nThese act as the earliest starting points for a new segment added to any of the channels\nof the component, but will also block the component even if it has no occupied channels\nin the schedule yet or ever (e.g. a computational resonator).\nModified in place. is_alap ( bool ) \u2013 Whether the scheduling strategy is ALAP (As Late As Possible). None previous iqm.pulse.scheduler.BLOCKING next iqm.pulse.scheduler.extend_hard_boundary_in_seconds \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.gate_implementation.get_waveform_parameters",
    "url": "/iqm-pulse/api/iqm.pulse.gate_implementation.get_waveform_parameters.html",
    "description": "Parameters that are required to initialize the given Waveform class. n_samples is handled separately since it is determined by the Instruction duration\nand channel sample rate, and thus is shared by a...",
    "content": "Parameters that are required to initialize the given Waveform class. n_samples is handled separately since it is determined by the Instruction duration\nand channel sample rate, and thus is shared by all the waveforms of the Instruction. wave ( type [ Waveform ] ) \u2013 waveform class label_prefix ( str ) \u2013 optional prefix for the parameter labels for providing additional information parameters of wave , in the format expected by GateImplementation.parameters . Waveform parameters\nthat have a defined default will be returned as Setting objects and those that do not have default\nas Parameter objects. dict [ str , Setting | Parameter] previous iqm.pulse.gate_implementation.PROBE_LINES_LOCUS_MAPPING next CompositeCache \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "CustomIQWaveforms",
    "url": "/iqm-pulse/api/iqm.pulse.gate_implementation.CustomIQWaveforms.html",
    "description": "Bases: GateImplementation Base class for GateImplementations using custom waveform definition with IQPulses. The class contains logic for automatic gate calibration parameters handling for such gates ...",
    "content": "Bases: GateImplementation Base class for GateImplementations using custom waveform definition with IQPulses. The class contains logic for automatic gate calibration parameters handling for such gates (see the class\nattributes for more info). With given Waveform waveform definitions Something and SomethingElse ,\nan inheriting class may define the waveforms for the I and Q channels like this: class MyGate(CustomIQWaveforms, i_wave=Something, q_wave=SomethingElse) . Module: iqm.pulse.gate_implementation Attributes excluded_parameters Parameters names to be excluded from self.parameters . root_parameters Parameters independent of the of Waveforms. wave_i Waveform for the I channel. wave_q Waveform for the Q channel. dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Waveform for the I channel. Waveform for the Q channel. If set True , the Q channel waveform is considered to depend on the I channel\u2019s waveform\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\nwill be initialised as True . Parameters independent of the of Waveforms. Inheriting classes may override this to include parameters common\nto all such implementations. Parameters names to be excluded from self.parameters . Inheriting classes may override this if certain\nparameters are not wanted in that class (also parameters defined by the waveforms can be excluded). previous CompositeGate next GateImplementation \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.gates.register_implementation",
    "url": "/iqm-pulse/api/iqm.pulse.gates.register_implementation.html",
    "description": "Register a new gate implementation, and a new gate (operation) if needed. operations ( dict [ str , QuantumOp ] ) \u2013 Known operations, mapping gate names to QuantumOps gate_name ( str ) \u2013 The gate name...",
    "content": "Register a new gate implementation, and a new gate (operation) if needed. operations ( dict [ str , QuantumOp ] ) \u2013 Known operations, mapping gate names to QuantumOps gate_name ( str ) \u2013 The gate name to register impl_name ( str ) \u2013 The name for this implementation impl_class ( type [ GateImplementation ] ) \u2013 The implementation class set_as_default ( bool ) \u2013 Whether to set as default implementation overwrite ( bool ) \u2013 If True, allows replacing existing operation/implementation quantum_op_specs ( QuantumOp | dict | None ) \u2013 Specs for creating new quantum op if needed ValueError \u2013 If operation/implementation exists and overwrite=False None previous iqm.pulse.gates.get_implementation_class next barrier \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "CZ_Slepian_CRF",
    "url": "/iqm-pulse/api/iqm.pulse.gates.cz.CZ_Slepian_CRF.html",
    "description": "Bases: FluxPulseGate CZ gate using a Slepian flux pulse on the coupler and a CosineRiseFall flux pulse on the qubit. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be ...",
    "content": "Bases: FluxPulseGate CZ gate using a Slepian flux pulse on the coupler and a CosineRiseFall flux pulse on the qubit. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 alias of Slepian Required calibration data, may be nested alias of CosineRiseFall True iff the implementation is symmetric in its locus components.\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous CZ_Slepian_ACStarkCRF next CZ_TruncatedGaussianSmoothedSquare \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "delay",
    "url": "/iqm-pulse/api/iqm.pulse.gates.delay.html",
    "description": "Force a delay between instructions on the control channels of specific locus components. Ideally the delay corresponds to an identity gate. In reality it of course allows decoherence\nto act on the qua...",
    "content": "Force a delay between instructions on the control channels of specific locus components. Ideally the delay corresponds to an identity gate. In reality it of course allows decoherence\nto act on the quantum state for some time. Full path: iqm.pulse.gates.delay Module Attributes DELAY_MAX_DURATION_SECONDS Maximum duration for individual Delay operations, in seconds. Classes Delay Applies a delay on the control channels of its locus components. Inheritance previous default_gates next iqm.pulse.gates.delay.DELAY_MAX_DURATION_SECONDS \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "Barrier",
    "url": "/iqm-pulse/api/iqm.pulse.gates.barrier.Barrier.html",
    "description": "Bases: GateImplementation GateImplementation for the n-qudit barrier metaoperation. Returns a schedule with zero-duration Block metainstructions.\nWhen this is appended to another Schedule ,\nit causes ...",
    "content": "Bases: GateImplementation GateImplementation for the n-qudit barrier metaoperation. Returns a schedule with zero-duration Block metainstructions.\nWhen this is appended to another Schedule ,\nit causes the affected channels to be padded with Wait instructions to the same length,\nwhich in turn imposes a definite temporal order for the operations on different sides of\nthe barrier (the ones preceding it are always executed first). Note Assumes that all instructions involve either the drive, flux or probe channels of the locus QPU components. channels \u2013 channels related to the locus QPU components, to be blocked parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Module: iqm.pulse.gates.barrier Attributes symmetric True iff the implementation is symmetric in its locus components. Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). True iff the implementation is symmetric in its locus components.\nOnly meaningful if arity != 1 , and the locus components are of the same type. The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs\nin the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.\nSubclasses can reimplement this method in case it makes sense in their context. float previous barrier next conditional \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "PRX_DRAGGaussianSX",
    "url": "/iqm-pulse/api/iqm.pulse.gates.prx.PRX_DRAGGaussianSX.html",
    "description": "Bases: PRX_CustomWaveformsSX PRX gate, DRAG / Gaussian IQ pulse with VZ implementation. See PRX_CustomWaveformsVZ . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel w...",
    "content": "Bases: PRX_CustomWaveformsSX PRX gate, DRAG / Gaussian IQ pulse with VZ implementation. See PRX_CustomWaveformsVZ . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). parameters Required calibration data, may be nested Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 If set True , the Q channel waveform is considered to depend on the I channel\u2019s waveform\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\nwill be initialised as True . Required calibration data, may be nested alias of TruncatedGaussian alias of TruncatedGaussianDerivative previous PRX_DRAGGaussian next PRX_FastDrag \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "RZ_ACStarkShift_CosineRiseFall",
    "url": "/iqm-pulse/api/iqm.pulse.gates.rz.RZ_ACStarkShift_CosineRiseFall.html",
    "description": "Bases: RZ_ACStarkShift AC stark pulse implemented as a modulated cosine rise fall pulse. Constructs an instance of the AC Stark pulse for the given locus. Module: iqm.pulse.gates.rz Attributes paramet...",
    "content": "Bases: RZ_ACStarkShift AC stark pulse implemented as a modulated cosine rise fall pulse. Constructs an instance of the AC Stark pulse for the given locus. Module: iqm.pulse.gates.rz Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 alias of ModulatedCosineRiseFall Required calibration data, may be nested True iff the implementation is symmetric in its locus components.\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous RZ_ACStarkShift next RZ_ACStarkShift_smoothConstant \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "CZ_CRF",
    "url": "/iqm-pulse/api/iqm.pulse.gates.cz.CZ_CRF.html",
    "description": "Bases: FluxPulseGate CZ gate using a CosineRiseFall flux pulse on the coupler. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested qubit_wave Flux pulse Waveform ...",
    "content": "Bases: FluxPulseGate CZ gate using a CosineRiseFall flux pulse on the coupler. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested qubit_wave Flux pulse Waveform to be played in the qubit flux AWG. symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 alias of CosineRiseFall Required calibration data, may be nested Flux pulse Waveform to be played in the qubit flux AWG. True iff the implementation is symmetric in its locus components.\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous cz next CZ_CRF_ACStarkCRF \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "RealPulse",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.instructions.RealPulse.html",
    "description": "Bases: Instruction Play a real-valued pulse. Module: iqm.pulse.playlist.instructions Attributes wave Shape of the pulse. scale Scaling factor for the waveform. duration Time duration of the instructio...",
    "content": "Bases: Instruction Play a real-valued pulse. Module: iqm.pulse.playlist.instructions Attributes wave Shape of the pulse. scale Scaling factor for the waveform. duration Time duration of the instruction. Methods get_waveforms Returns all the waveforms the Instruction contains. validate Validate the instruction attributes. duration ( int ) \u2013 wave ( Waveform ) \u2013 scale ( float ) \u2013 Shape of the pulse. Scaling factor for the waveform. Validate the instruction attributes. ValueError \u2013 something about the instruction is not ok Returns all the waveforms the Instruction contains. tuple [ Waveform , \u2026] previous ReadoutTrigger next ThresholdStateDiscrimination \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "SXGate",
    "url": "/iqm-pulse/api/iqm.pulse.gates.sx.SXGate.html",
    "description": "Bases: CompositeGate SX gate implementation based on PRX gate, by limiting the angle to pi / 2. Module: iqm.pulse.gates.sx Attributes registered_gates Gates that can be calibrated separately from thei...",
    "content": "Bases: CompositeGate SX gate implementation based on PRX gate, by limiting the angle to pi / 2. Module: iqm.pulse.gates.sx Attributes registered_gates Gates that can be calibrated separately from their common calibration existing in self.builder . Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Gates that can be calibrated separately from their common calibration existing in self.builder . The gate\nnames should correspond to the keys in self.builder.op_table . Other gates besides the ones given here can\nalso be constructed via self.builder , but these will always use the common calibration. Call PRX gate with angle equals to pi / 2. TimeBox previous sx next u \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "fast_drag",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.fast_drag.html",
    "description": "Waveform definitions for Fourier Ansatz Spectrum Tuning (FAST) DRAG pulse based on [ 1 ] . Full path: iqm.pulse.playlist.fast_drag Functions compute_matrix_of_summed_fourier_transform_inner_products (...",
    "content": "Waveform definitions for Fourier Ansatz Spectrum Tuning (FAST) DRAG pulse based on [ 1 ] . Full path: iqm.pulse.playlist.fast_drag Functions compute_matrix_of_summed_fourier_transform_inner_products (...) Evaluate matrix \\(A\\) defined in Eq. evaluate_fast_drag_i_envelope (t_arr,\u00a0...) Evaluate I-envelope of a FAST DRAG pulse for given coefficients. evaluate_fast_drag_q_envelope (t_arr,\u00a0...) Evaluate Q-envelope of FAST DRAG for given coefficients. fourier_transform_of_cos_basis_functions_as_tensor (...) Evaluate Fourier transforms of cosine basis functions for given basis function indices and frequencies. solve_fast_coefficients_for_given_weights_and_ranges (...) Solve for optimal coefficients of the basis functions in a FAST DRAG pulse. Classes FastDrag Base class for IQ components of the Fourier Ansatz Spectrum Tuning (FAST) DRAG pulse. FastDragI I-component of the Fourier Ansatz Spectrum Tuning (FAST) drag pulse. FastDragQ Q-component of the Fourier Ansatz Spectrum Tuning (FAST) drag pulse. SuppressedPulse Base class for a control pulse using a series expansion to suppress certain frequencies in its envelope spectrum Inheritance previous RealChannelConfig next iqm.pulse.playlist.fast_drag.compute_matrix_of_summed_fourier_transform_inner_products \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.gates.enums.XYGATE_UNITARIES",
    "url": "/iqm-pulse/api/iqm.pulse.gates.enums.XYGATE_UNITARIES.html",
    "description": "Mapping of XYGates to the corresponding SU(2) matrices previous enums next iqm.pulse.gates.enums.TWO_QUBIT_UNITARIES \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07....",
    "content": "Mapping of XYGates to the corresponding SU(2) matrices previous enums next iqm.pulse.gates.enums.TWO_QUBIT_UNITARIES \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "UGate",
    "url": "/iqm-pulse/api/iqm.pulse.gates.u.UGate.html",
    "description": "Bases: CompositeGate SU(2) gate implemented using PRX. Assumes the chosen PRX implementation uses resonant driving, and that the virtual RZ technique can be used. Module: iqm.pulse.gates.u Attributes ...",
    "content": "Bases: CompositeGate SU(2) gate implemented using PRX. Assumes the chosen PRX implementation uses resonant driving, and that the virtual RZ technique can be used. Module: iqm.pulse.gates.u Attributes registered_gates Gates that can be calibrated separately from their common calibration existing in self.builder . Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Gates that can be calibrated separately from their common calibration existing in self.builder . The gate\nnames should correspond to the keys in self.builder.op_table . Other gates besides the ones given here can\nalso be constructed via self.builder , but these will always use the common calibration. Convert pulses into timebox, via Euler decomposition. theta ( float ) \u2013 phi ( float ) \u2013 lam ( float ) \u2013 TimeBox previous iqm.pulse.gates.u.get_unitary_u next playlist \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "ReadoutTrigger",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.instructions.ReadoutTrigger.html",
    "description": "Bases: Instruction Instruction for playing a probe pulse and acquiring the associated readout results. Module: iqm.pulse.playlist.instructions Attributes probe_pulse Probe pulse to play, usually a Mul...",
    "content": "Bases: Instruction Instruction for playing a probe pulse and acquiring the associated readout results. Module: iqm.pulse.playlist.instructions Attributes probe_pulse Probe pulse to play, usually a MultiplexedIQPulse. acquisitions Active readout acquisition methods associated with this trigger instance. duration Time duration of the instruction. Methods duration ( int ) \u2013 probe_pulse ( MultiplexedIQPulse ) \u2013 acquisitions ( tuple [ AcquisitionMethod , ... ] ) \u2013 Probe pulse to play, usually a MultiplexedIQPulse. Active readout acquisition methods associated with this trigger instance. previous MultiplexedIQPulse next RealPulse \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "Reset_Conditional",
    "url": "/iqm-pulse/api/iqm.pulse.gates.reset.Reset_Conditional.html",
    "description": "Bases: CompositeGate Conditional reset operation. Uses a measurement followed by a conditional PRX gate with angle \\(\\pi\\) .\nIt is assumed the measurement projects the state into the computational bas...",
    "content": "Bases: CompositeGate Conditional reset operation. Uses a measurement followed by a conditional PRX gate with angle \\(\\pi\\) .\nIt is assumed the measurement projects the state into the computational basis. The conditional PRX implementation handles any necessary waits to accommodate for the feedback result propagation\ndelay. This reset implementation is factorizable. It can act upon any set of locus components, and the measurement\nused in the conditional reset will be multiplexed to those components. However, only locus components that have\nreadout and drive can be reset via conditional reset. Otherwise, locus components will just have their channels\nblocked. Module: iqm.pulse.gates.reset Attributes registered_gates Gates that can be calibrated separately from their common calibration existing in self.builder . Methods get_locus_mapping_name Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Gates that can be calibrated separately from their common calibration existing in self.builder . The gate\nnames should correspond to the keys in self.builder.op_table . Other gates besides the ones given here can\nalso be constructed via self.builder , but these will always use the common calibration. The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs\nin the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. By default, it is \"<operation_name>.<implementation_name>\" . Inheriting classes may\noverride this for different behaviour. operation_name ( str ) \u2013 name of the quantum operation. implementation_name ( str ) \u2013 name of the implementation name of the locus mapping str previous iqm.pulse.gates.reset.RESET_FEEDBACK_KEY next Reset_Wait \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.validation.validate_instruction_and_wf_length",
    "url": "/iqm-pulse/api/iqm.pulse.validation.validate_instruction_and_wf_length.html",
    "description": "Validate that instruction and waveform lengths match instruction ( Instruction ) \u2013 The IQPulse or RealPulse to be validated previous iqm.pulse.validation.validate_channel next iqm.pulse.validation.val...",
    "content": "Validate that instruction and waveform lengths match instruction ( Instruction ) \u2013 The IQPulse or RealPulse to be validated previous iqm.pulse.validation.validate_channel next iqm.pulse.validation.validate_playlist_compatibility \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "circuit_operations",
    "url": "/iqm-pulse/api/iqm.pulse.circuit_operations.html",
    "description": "Representing quantum circuits as lists of CircuitOperations. Full path: iqm.pulse.circuit_operations Functions get_unitary_from_circuit (circuit[,\u00a0table,\u00a0...]) Calculate the overall unitary implemente...",
    "content": "Representing quantum circuits as lists of CircuitOperations. Full path: iqm.pulse.circuit_operations Functions get_unitary_from_circuit (circuit[,\u00a0table,\u00a0...]) Calculate the overall unitary implemented by a sequence of CircuitOperations. get_unitary_from_op (op,\u00a0table,\u00a0qubits) Unitary matrix representing an operation within the context of the circuit. reorder (A,\u00a0perm) Permutes the order of the qubits in an n-qubit operator matrix. reshape_unitary (unitary,\u00a0indices,\u00a0n_qubits) Extend a unitary propagator to act on a larger system. Classes CircuitOperationList List of CircuitOperation objects representing a quantum circuit. Inheritance previous ScheduleBuilder next iqm.pulse.circuit_operations.get_unitary_from_circuit \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "Measure_Constant",
    "url": "/iqm-pulse/api/iqm.pulse.gates.measure.Measure_Constant.html",
    "description": "Bases: Measure_CustomWaveforms Implementation of a single-qubit projective, dispersive measurement in the Z basis. Uses a constant probe pulse. Module: iqm.pulse.gates.measure Attributes dependent_wav...",
    "content": "Bases: Measure_CustomWaveforms Implementation of a single-qubit projective, dispersive measurement in the Z basis. Uses a constant probe pulse. Module: iqm.pulse.gates.measure Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). parameters Required calibration data, may be nested Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 If set True , the Q channel waveform is considered to depend on the I channel\u2019s waveform\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\nwill be initialised as True . Required calibration data, may be nested alias of Constant alias of Constant previous measure next Measure_Constant_Qnd \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.validation.validate_awg_and_schedule_compatibility",
    "url": "/iqm-pulse/api/iqm.pulse.validation.validate_awg_and_schedule_compatibility.html",
    "description": "Validates that the given playlist is compatible with the provided AWG data.\nThe following requirements are validated as they are the same for all controllers. Playlist sampling rate vs. Actual control...",
    "content": "Validates that the given playlist is compatible with the provided AWG data.\nThe following requirements are validated as they are the same for all controllers. Playlist sampling rate vs. Actual controller sampling rate Instruction granularity with respect to the controllers granularity requirements Checks that no other than supported instructions are used. Checks that instruction length matches waveform length in IQ and RealPulse Checks that all instructions are at least the length of minimum number of samples Checks that Conditional instruction has the same duration in every child instruction channel_description ( ChannelDescription ) \u2013 Contains instructions used as well as the channel specific configuration from playlist device_constraints ( AWGScheduleValidationData ) \u2013 Contains the actual hardware limitations previous validation next iqm.pulse.validation.validate_channel \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.scheduler.extend_schedule",
    "url": "/iqm-pulse/api/iqm.pulse.scheduler.extend_schedule.html",
    "description": "Extend a Schedule with another Schedule. Extends A with B , modifying both. The extension can add new channels to A . If B has a ragged left side, i.e. some of its channels begin with Nothing instruct...",
    "content": "Extend a Schedule with another Schedule. Extends A with B , modifying both. The extension can add new channels to A . If B has a ragged left side, i.e. some of its channels begin with Nothing instructions,\nthis algorithm will not always produce an optimally short schedule. A ( Schedule ) \u2013 schedule to be extended B ( Schedule ) \u2013 schedule to extend A with channels ( dict [ str , ChannelProperties ] ) \u2013 properties of the control channels TOL ( float ) \u2013 time durations equal or smaller than this are considered zero (in seconds) None previous iqm.pulse.scheduler.extend_hard_boundary_in_seconds next iqm.pulse.scheduler.extend_schedule_new \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.playlist.visualisation.base.inspect_playlist",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.visualisation.base.inspect_playlist.html",
    "description": "Creates an HTML string from the given playlist and segments. The output can be viewed in a browser or in a Jupyter notebook using IPython.core.display.HTML . playlist ( Playlist ) \u2013 The Playlist to be...",
    "content": "Creates an HTML string from the given playlist and segments. The output can be viewed in a browser or in a Jupyter notebook using IPython.core.display.HTML . playlist ( Playlist ) \u2013 The Playlist to be visualised segments ( Sequence [ int ] ) \u2013 Indices of the Playlist segments to inspect. The generated raw HTML string. str previous base next waveforms \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "waveforms",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.waveforms.html",
    "description": "Waveform definitions. This module defines some waveforms that don\u2019t have special serialization, and reimports\nwaveforms that do from iqm.models.playlist.waveforms .\nSee the link for documentation of w...",
    "content": "Waveform definitions. This module defines some waveforms that don\u2019t have special serialization, and reimports\nwaveforms that do from iqm.models.playlist.waveforms .\nSee the link for documentation of waveforms that don\u2019t appear here. Full path: iqm.pulse.playlist.waveforms Classes Chirp Linear chirp, defined as ChirpImag Imaginary part of the linear chirp, which sets the phase to $-pi/2$. Cosine Periodic sinusoidal waveform which defaults to cosine. CosineFall Cosine Rise waveform. CosineRise Cosine Rise waveform. CosineRiseFallDerivative Derivative of a waveform that has a sinusoidal rise and fall, and a constant part in between. ModulatedCosineRiseFall Modulated Cosine Rise Fall waveform. Slepian Slepian waveform, which minimizes non-adiabatic errors during a gate. Inheritance previous iqm.pulse.playlist.visualisation.base.inspect_playlist next Chirp \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "FastDragI",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.fast_drag.FastDragI.html",
    "description": "Bases: FastDrag I-component of the Fourier Ansatz Spectrum Tuning (FAST) drag pulse. The I-envelope is defined as where \\(N\\) is the number of cosine terms in the series, \\(\\{c_n\\}\\) are the coefficie...",
    "content": "Bases: FastDrag I-component of the Fourier Ansatz Spectrum Tuning (FAST) drag pulse. The I-envelope is defined as where \\(N\\) is the number of cosine terms in the series, \\(\\{c_n\\}\\) are the coefficients, and\nthe pulse is defined on the interval \\(t \\in [-t_p/2, t_p/2]\\) . Module: iqm.pulse.playlist.fast_drag Attributes number_of_cos_terms  suppressed_interval_widths  weights  full_width  coefficients  suppressed_frequencies  compute_coefs_from_frequencies  n_samples Requested number of samples for the waveform. Methods n_samples ( int ) \u2013 full_width ( float ) \u2013 coefficients ( ndarray ) \u2013 suppressed_frequencies ( ndarray ) \u2013 compute_coefs_from_frequencies ( bool ) \u2013 number_of_cos_terms ( int ) \u2013 suppressed_interval_widths ( ndarray ) \u2013 weights ( ndarray ) \u2013 center_offset ( float ) \u2013 Actually samples the waveform. sample_coords ( ndarray ) \u2013 coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) ndarray previous FastDrag next FastDragQ \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "ProbePulse_CustomWaveforms",
    "url": "/iqm-pulse/api/iqm.pulse.gates.measure.ProbePulse_CustomWaveforms.html",
    "description": "Bases: CustomIQWaveforms Base class for implementing a probe line measurement pulse with custom waveforms in the I and Q channels. With given Waveform waveform definitions Something and SomethingElse ...",
    "content": "Bases: CustomIQWaveforms Base class for implementing a probe line measurement pulse with custom waveforms in the I and Q channels. With given Waveform waveform definitions Something and SomethingElse ,\nyou may define a measurement implementation that uses them as follows: class MyGate(ProbePulse_CustomWaveforms, i_wave=Something, q_wave=SomethingElse) . Contrary to the Measure_CustomWaveforms class, this implementation acts on proble lines directly (i.e. its locus is a single probe line). The measurement IQPulse instruction will not be automatically modulated\nby any frequency, so any modulations should be included in the I and Q waveforms themselves. Module: iqm.pulse.gates.measure Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). root_parameters Parameters independent of the of Waveforms. wave_i Waveform for the I channel. wave_q Waveform for the Q channel. Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). get_locus_mapping_name Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Parameters independent of the of Waveforms. Inheriting classes may override this to include parameters common\nto all such implementations. Builds a probe pulse and acquisition methods using the calibration data. Subclasses may override this method if needed. waveform_params ( dict [ str , Any ] ) \u2013 root_params ( dict [ str , Any ] ) \u2013 tuple [ IQPulse , tuple [ AcquisitionMethod , AcquisitionMethod ]] Returns a TimeBox containing the probe pulse measurement. In scheduling, the returned TimeBox blocks only the probe line ( self.locus[0] ). key ( str ) \u2013 The time trace results generated on this trigger will be used to assigned to f\"{probe_line}__{key}\" , where probe_line is the one that handles self.locus[0] . If empty,\nthe key \u201creadout.time_trace\u201d is used. TimeBox containing the ReadoutTrigger instruction. TimeBox Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.\nSubclasses can reimplement this method in case it makes sense in their context. float Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. By default, it is \"<operation_name>.<implementation_name>\" . Inheriting classes may\noverride this for different behaviour. operation_name ( str ) \u2013 name of the quantum operation. implementation_name ( str ) \u2013 name of the implementation name of the locus mapping str If set True , the Q channel waveform is considered to depend on the I channel\u2019s waveform\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\nwill be initialised as True . previous Measure_CustomWaveforms next ProbePulse_CustomWaveforms_noIntegration \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "Measure_CustomWaveforms",
    "url": "/iqm-pulse/api/iqm.pulse.gates.measure.Measure_CustomWaveforms.html",
    "description": "Bases: CustomIQWaveforms Base class for implementing dispersive measurement operations with custom probe pulse waveforms. You may define a measurement implementation that uses the Waveform instances S...",
    "content": "Bases: CustomIQWaveforms Base class for implementing dispersive measurement operations with custom probe pulse waveforms. You may define a measurement implementation that uses the Waveform instances Something and SomethingElse as the probe pulse waveforms in the\nI and Q channels as follows: class MyGate(Measure_CustomWaveforms, i_wave=Something, q_wave=SomethingElse) . The measure operation is factorizable, and its arity is 0, which together mean that it can operate\non loci of any dimensionality, but is calibrated only on single component loci. When the gate is constructed in the len(locus) > 1 , case (e.g. builder.get_implementation('measure', ('QB1', 'QB2', 'QB3'))() ) the resulting TimeBox is constructed from the calibrated single-component gates. For each measured component, the readout IQPulse will be modulated with the\nintermediate frequency (IF), computed as the difference between the readout\nfrequency of that component and the probe line center frequency, and offset in phase\nby the readout phase of the component. The measurement is implemented using a ReadoutTrigger instruction, with a duration set by the\nrequirements of the acquisition(s). Note that this is typically different from gates.measure.constant.{locus}.duration , which is the probe pulse duration. Module: iqm.pulse.gates.measure Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). root_parameters Parameters independent of the of Waveforms. wave_i Waveform for the I channel. wave_q Waveform for the Q channel. Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). get_locus_mapping_name Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. probe_timebox Returns a \"naked\" probe timebox that supports convenient multiplexing through MultiplexedProbeTimeBox.__add__ . time_trace Returns a multiplexed simultaneous measurement with an additional time trace acquisition. parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Parameters independent of the of Waveforms. Inheriting classes may override this to include parameters common\nto all such implementations. Cache for probe_timebox() . Cache for time_trace() . Builds a probe pulse and an acquisition method using the calibration data. Subclasses may override this method if needed. waveform_params ( dict [ str , Any ] ) \u2013 root_params ( dict [ str , Any ] ) \u2013 if_freq ( float ) \u2013 tuple [ IQPulse , AcquisitionMethod ] Returns a \u201cnaked\u201d probe timebox that supports convenient multiplexing through MultiplexedProbeTimeBox.__add__ . This method can be used if the user wants to control the multiplexing explicitly. With two MultiplexedProbeTimeBox``es ``A and B the result A + B has all the ReadoutTrigger instructions\non each probe channel of A and B multiplexed together and played simultaneously. key ( str ) \u2013 The readout results generated on this trigger will be assigned to f\"{qubit}__{key}\" , where qubit goes over the component names in self.locus . If empty,\nthe key \u201creadout.result\u201d will be used to maintain backwards compatibility. feedback_key ( str ) \u2013 The signals generated by this measure operation are routed using this key for\nfast feedback purposes. See __call__() . do_acquisition ( bool ) \u2013 if False, no acquisitions are added. MultiplexedProbeTimeBox containing the ReadoutTrigger instruction. MultiplexedProbeTimeBox Returns a TimeBox containing the multiplexed simultaneous measurement. If len(self.locus) == 1 , the TimeBox contains the measurement for just that component, otherwise\nthe measurements of components that belong to the same probeline are multiplexed together. The returned TimeBox instances behave like any other TimeBox in scheduling and circuit\ngeneration. With measurement TimeBoxes A and B the result A + B first plays the ReadoutTrigger instructions of A and only then those of B in each probe channel. If the multiplexing features of MultiplexedProbeTimeBox are needed, the method probe_timebox() can be used. In scheduling, the returned TimeBox blocks the locus components and the probe\nlines they are associated with. key ( str ) \u2013 Readout results generated on this trigger will be assigned to the acquisition labels f\"{qubit}__{key}\" , where qubit goes over the component names in self.locus .\nIf empty, the key \"readout.result\" will be used to maintain backwards compatibility. feedback_key ( str ) \u2013 If the readout mode is \u201cthreshold\u201d, the results generated by this measure operation\nare routed using the label f\"{qubit}__{feedback_key}\" for fast feedback purposes.\nThe signals are picked up by ConditionalInstruction`s that have the same label. The default value ` \u201d\u201d`` means the signal is not routed anywhere. TODO: currently the HW does not\nsupport multiple feedback keys per drive channel, so the actual key used will be FEEDBACK_KEY whenever any non-empty key is inputted. When the HW is improved, the actual key the user inputs\nshould be passed. TimeBox containing the ReadoutTrigger instruction. TimeBox Returns a multiplexed simultaneous measurement with an additional time trace acquisition. The returned TimeBox is the same as the one returned by __call__() except the time trace\nacquisition is appended to the acquisitions of each probe line\u2019s ReadoutTrigger instruction. key ( str ) \u2013 Readout results generated on this trigger will be used to assigned to f\"{qubit}__{key}\" , where qubit goes over the component names in self.locus , whereas\nthe recorded time traces will be assigned to f\"{probe_line}__{key}\" where probe_line goes through all the probe lines associated with self.locus .\nIf empty, the key \"readout.result\" will be used for integrated results and the key \"readout.time_trace\" for the recorded time traces. acquisition_delay ( float | None ) \u2013 optionally override the time trace acquisition delay with this value (given in\nseconds). Does not affect the acqusition delays of the integrated measurements. acquisition_duration ( float | None ) \u2013 optionally override the time trace acquisition duration with this value (given in\nseconds). Does not affect the integration lengths of the integrated measurements. feedback_key ( str ) \u2013 The signals generated by the integration are routed using this label, prefixed by\nthe component. See __call__() . TimeBox containing the ReadoutTrigger instruction. TimeBox Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.\nSubclasses can reimplement this method in case it makes sense in their context. float Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. By default, it is \"<operation_name>.<implementation_name>\" . Inheriting classes may\noverride this for different behaviour. operation_name ( str ) \u2013 name of the quantum operation. implementation_name ( str ) \u2013 name of the implementation name of the locus mapping str If set True , the Q channel waveform is considered to depend on the I channel\u2019s waveform\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\nwill be initialised as True . previous Measure_Constant_Qnd next ProbePulse_CustomWaveforms \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.playlist.fast_drag.fourier_transform_of_cos_basis_functions_as_tensor",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.fast_drag.fourier_transform_of_cos_basis_functions_as_tensor.html",
    "description": "Evaluate Fourier transforms of cosine basis functions for given basis function indices and frequencies. The nth cosine basis function is given by \\(g_n(t) = 1 -  \\cos(2 \\pi n t/t_p)\\) defined on the i...",
    "content": "Evaluate Fourier transforms of cosine basis functions for given basis function indices and frequencies. The nth cosine basis function is given by \\(g_n(t) = 1 -  \\cos(2 \\pi n t/t_p)\\) defined on the interval \\([0, t_p]\\) , where \\(t_p\\) is the pulse duration. The Fourier transform can be analytically evaluated, see\nEq. (A7) of [ 1 ] . We evaluate the Fourier transform for the basis function indices given by n_arr and for the frequencies given by frequency_arr . We store the Fourier transforms as a tensor of dimension 1+dim(frequency_arr) , such that the first dimension corresponds to the basis function indices, and the following\ndimensions to those of frequency_arr . Thus, the Fourier transform is evaluated essentially for the cartesian\nproduct of n_arr and frequency_arr . n_arr ( ndarray ) \u2013 1d array of basis function indices, running typically from 1 to N, where N is the\nnumber of considered basis functions frequencies ( ndarray ) \u2013 N-dimensional array of frequencies (in Hz), at which the Fourier transform is evaluated.\nFor the computation of FAST DRAG coefficients, N=2 . pulse_duration ( float ) \u2013 Pulse duration (in s), without zero padding. Array containing the Fourier transform as a tensor with a shape (len(n_arr), *frequency_arr.shape) ndarray previous iqm.pulse.playlist.fast_drag.evaluate_fast_drag_q_envelope next iqm.pulse.playlist.fast_drag.solve_fast_coefficients_for_given_weights_and_ranges \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "CCPRX_Composite_DRAGGaussian",
    "url": "/iqm-pulse/api/iqm.pulse.gates.conditional.CCPRX_Composite_DRAGGaussian.html",
    "description": "Bases: CCPRX_Composite Conditional drag_gaussian pulse. Module: iqm.pulse.gates.conditional Attributes default_implementations Mapping from operation names to the designated default implementation of ...",
    "content": "Bases: CCPRX_Composite Conditional drag_gaussian pulse. Module: iqm.pulse.gates.conditional Attributes default_implementations Mapping from operation names to the designated default implementation of that operation. Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Mapping from operation names to the designated default implementation of that operation. Filling this attribute\nallows one to define a different default implementation from the common default in self.builder.op_table to\nbe used in he context of this composite gate. If an operation is not found in this dict as a key, this\nCompositeGate will use the common default as the default implementation for it. previous CCPRX_Composite_DRAGCosineRiseFall next cz \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "HdDrag",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.hd_drag.HdDrag.html",
    "description": "Bases: SuppressedPulse Base class for higher-derivative DRAG based on Eqs. (B1) and (B2) of [ 1 ] . Base class for IQ components of the higher derivative (HD) drag pulse. Depending on the value of com...",
    "content": "Bases: SuppressedPulse Base class for higher-derivative DRAG based on Eqs. (B1) and (B2) of [ 1 ] . Base class for IQ components of the higher derivative (HD) drag pulse. Depending on the value of compute_coefs_from_frequencies , we compute the coefficients from the suppressed frequencies during the\npost-initialization or use pre-computed coefficients of the derivative terms (neglecting the suppressed\nfrequencies). See SuppressedPulse . Module: iqm.pulse.playlist.hd_drag Attributes center_offset  full_width  coefficients  suppressed_frequencies  compute_coefs_from_frequencies  n_samples Requested number of samples for the waveform. Methods non_timelike_attributes Mapping from waveform attributes to the units of their calibration data, unless that unit is second. n_samples ( int ) \u2013 full_width ( float ) \u2013 coefficients ( ndarray ) \u2013 suppressed_frequencies ( ndarray ) \u2013 compute_coefs_from_frequencies ( bool ) \u2013 center_offset ( float ) \u2013 Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Used to construct the parameters for the calibration data required by the waveform.\nBy default all the waveform attributes are \u201ctimelike\u201d (the unit for their calibration data is s).\nHowever, some waveform attributes can be dimensionless, e.g. the relative amplitudes in a sum of\nconsisting of multiple terms, or frequency-like (calibration data has the unit \u2018Hz\u2019).\nIf a Waveform subclass has non-timelike attributes, it needs to redefine this method. When the Waveform is constructed, all timelike calibration data is converted to units of the\nsampling window duration, and all frequency-like calibration data into units of inverse sampling\nwindow duration. dict [ str , str ] previous iqm.pulse.playlist.hd_drag.solve_hd_drag_coefficients_from_suppressed_frequencies next HdDragI \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.gates.expose_implementation",
    "url": "/iqm-pulse/api/iqm.pulse.gates.expose_implementation.html",
    "description": "Add the given gate implementation to the list of known implementations. implementation ( type [ GateImplementation ] ) \u2013 GateImplementation to add so that it can be found with get_implementation_class...",
    "content": "Add the given gate implementation to the list of known implementations. implementation ( type [ GateImplementation ] ) \u2013 GateImplementation to add so that it can be found with get_implementation_class() . overwrite ( bool ) \u2013 If True, does not raise an error if implementation already exists. None previous gates next iqm.pulse.gates.get_implementation_class \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "FluxMultiplexer_SampleLinear",
    "url": "/iqm-pulse/api/iqm.pulse.gates.flux_multiplexer.FluxMultiplexer_SampleLinear.html",
    "description": "Bases: GateImplementation Linear flux pulse multiplexed (user for correcting flux crosstalk). The required calibration data is the flux cross-talk correction matrix, where the element \\(C_ij\\) represe...",
    "content": "Bases: GateImplementation Linear flux pulse multiplexed (user for correcting flux crosstalk). The required calibration data is the flux cross-talk correction matrix, where the element \\(C_ij\\) represents\nthe correction needed for flux component i arising from the crosstalk caused by flux component j , so that\nafter the corrections, the flux pulse played at i is \\(f(t) = A_i w_i(t) + \\sum_j C_ij A_j w_j(t)\\) ,\nwhere \\(A_j`\\) is the flux pulse amplitude for j and \\(w_j(t)\\) the (normalized) waveform. The flux crosstalk correction matrix is given in a sparse form via two calibration parameters (we do not support\ndict- or xarray-valued Parameters yet\u2026). Parameter matrix_index lists the relevant (non-zero) elements of the\nmatrix as a flat np.array of strings of the form <flux component i>__<flux component j> . Parameter matrix_elements lists the corresponding matrix values \\(C_ij\\) (the lengths of these arrays must match). TODO: this is for now an experimental R&D implementation, and everything here is subject to change still Module: iqm.pulse.gates.flux_multiplexer Attributes parameters Required calibration data, may be nested Methods get_custom_locus_mapping Locus is \"global\" (the whole QPU) represented by an empty tuple for now. parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Required calibration data, may be nested Locus is \u201cglobal\u201d (the whole QPU) represented by an empty tuple for now. chip_topology ( ChipTopology ) \u2013 component_to_channels ( dict [ str , Iterable [ str ] ] ) \u2013 dict [ tuple [ str , \u2026] | frozenset [ str ], tuple [ str , \u2026]] | None previous iqm.pulse.gates.flux_multiplexer.TOLERANCE next measure \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "RZ_Virtual",
    "url": "/iqm-pulse/api/iqm.pulse.gates.rz.RZ_Virtual.html",
    "description": "Bases: GateImplementation Implementation of the RZ gate using the virtual z rotation technique. Implements the RZ gate on a specific qubit using a VirtualRZ instruction, which\nsimply changes the phase...",
    "content": "Bases: GateImplementation Implementation of the RZ gate using the virtual z rotation technique. Implements the RZ gate on a specific qubit using a VirtualRZ instruction, which\nsimply changes the phase of the local oscillator driving that qubit.\nThis requires no calibration data as of now.\nThe generated VirtualRZ instruction has the shortest possible duration allowed by the instruments. The virtual z rotation method is based on algebraically commuting the RZ gates towards the end\nof the circuit, until they hit a measurement operation, at which point they are eliminated. It assumes that all the multi-qubit gates in the circuit commute with arbitrary RZ gates (this holds e.g. for CZ\nsince it is diagonal), measurements are projective and happen in the z basis, so that RZ gates that immediately\nprecede them do not affect the measurement result or the state after the measurement, and thus\ncan be removed, and conjugating the single-qubit gates in the circuit with RZ is equivalent to incrementing the phase of the drive\n(holds for PRX ), which can be accomplished either by incrementing the phase of\nthe local oscillator of the drive channel, or incrementing the phases of all the IQPulse s\nfollowing it on the drive channel. If all these assumptions hold we may implement an RZ gate using a VirtualRZ instruction,\nwith phase_increment equal to the negated rotation angle. channel \u2013 name of the drive channel on which the VirtualRZ acts duration \u2013 time duration of the VirtualRZ instruction, in seconds parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Module: iqm.pulse.gates.rz Attributes parameters Required calibration data, may be nested Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). get_locus_mapping_name Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. Z rotation gate. angle ( float ) \u2013 rotation angle (in radians) pulse schedule implementing the z rotation gate TimeBox Required calibration data, may be nested Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.\nSubclasses can reimplement this method in case it makes sense in their context. float Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. By default, it is \"<operation_name>.<implementation_name>\" . Inheriting classes may\noverride this for different behaviour. operation_name ( str ) \u2013 name of the quantum operation. implementation_name ( str ) \u2013 name of the implementation name of the locus mapping str previous RZ_PRX_Composite next sx \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "MultiplexedProbeTimeBox",
    "url": "/iqm-pulse/api/iqm.pulse.timebox.MultiplexedProbeTimeBox.html",
    "description": "Bases: TimeBox A TimeBox that contains any number of multiplexed readout pulses for probe channels. A MultiplexedProbeTimeBox \u2019s atom contains exactly one ReadoutTrigger for each probe channel. Module...",
    "content": "Bases: TimeBox A TimeBox that contains any number of multiplexed readout pulses for probe channels. A MultiplexedProbeTimeBox \u2019s atom contains exactly one ReadoutTrigger for each probe channel. Module: iqm.pulse.timebox Attributes label Description the contents of the box for users' convenience. locus_components Names of the QPU components on which this timebox operates. atom Resolved contents of the TimeBox, or None if not resolved. children Further Timeboxes inside this TimeBox. neighborhood_components Dict of neighborhood range integers mapped to sets of components neighboring the locus of this TimeBox . Methods from_readout_trigger Build an atomic MultiplexedProbeTimeBox` from a single ``ReadoutTrigger instruction. label ( str ) \u2013 locus_components ( set [ str ] ) \u2013 atom ( Schedule | None ) \u2013 children ( tuple [ TimeBox , ... ] ) \u2013 scheduling ( SchedulingStrategy ) \u2013 scheduling_algorithm ( SchedulingAlgorithm ) \u2013 neighborhood_components ( dict [ int , set [ str ] ] ) \u2013 Build an atomic MultiplexedProbeTimeBox` from a single ``ReadoutTrigger instruction. readout_trigger ( ReadoutTrigger ) \u2013 Readout trigger instruction. probe_channel ( str ) \u2013 Name of the probe channel to play readout_trigger in. locus_components ( Iterable [ str ] ) \u2013 Locus components. label ( str ) \u2013 Label of the new timebox. block_channels ( Iterable [ str ] ) \u2013 Names of channels to block. block_duration ( int ) \u2013 Duration of the required blocking (in samples). atomic timebox containing readout_trigger in the channel probe_channel . MultiplexedProbeTimeBox previous timebox next SchedulingAlgorithm \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "validation",
    "url": "/iqm-pulse/api/iqm.pulse.validation.html",
    "description": "Validation of playlists and instructions schedules. Full path: iqm.pulse.validation Functions validate_awg_and_schedule_compatibility (...) Validates that the given playlist is compatible with the pro...",
    "content": "Validation of playlists and instructions schedules. Full path: iqm.pulse.validation Functions validate_awg_and_schedule_compatibility (...) Validates that the given playlist is compatible with the provided AWG data. validate_channel (channel_description,\u00a0...) Validate a single channel. validate_instruction_and_wf_length (instruction) Validate that instruction and waveform lengths match validate_playlist_compatibility (playlist,\u00a0...) Validates that the given playlist is compatible with the provided AWG data. Classes AWGScheduleValidationData Controller specific validation data Exceptions AWGScheduleValidationError Error raised when schedule validation for an AWG fails. InvalidInstructionError (instruction[,\u00a0...]) Error raised when encountering an invalid instruction. PlaylistValidationError Error raised when Playlist validation fails. Inheritance previous iqm.pulse.utils.phase_transformation next iqm.pulse.validation.validate_awg_and_schedule_compatibility \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "enums",
    "url": "/iqm-pulse/api/iqm.pulse.gates.enums.html",
    "description": "Enumerations for representing a set of important one- and two-qubit gates. Full path: iqm.pulse.gates.enums Module Attributes XYGATE_UNITARIES Mapping of XYGates to the corresponding SU(2) matrices TW...",
    "content": "Enumerations for representing a set of important one- and two-qubit gates. Full path: iqm.pulse.gates.enums Module Attributes XYGATE_UNITARIES Mapping of XYGates to the corresponding SU(2) matrices TWO_QUBIT_UNITARIES Mapping of TwoQubitGates to the corresponding U(4) matrices Classes TwoQubitGate Enumerates a subset of two-qubit gates. XYGate Enumerate all single-qubit Clifford gates whose rotation axis is in the XY plane. Inheritance previous Delay next iqm.pulse.gates.enums.XYGATE_UNITARIES \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "SuppressedPulse",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.fast_drag.SuppressedPulse.html",
    "description": "Bases: Waveform Base class for a control pulse using a series expansion to suppress certain frequencies in its envelope spectrum The base class describes control pulses, in which the coefficients of t...",
    "content": "Bases: Waveform Base class for a control pulse using a series expansion to suppress certain frequencies in its envelope spectrum The base class describes control pulses, in which the coefficients of the basis functions\nare chosen to suppress specific frequencies or frequency ranges in the frequency spectrum of the pulse envelope.\nExamples include FAST DRAG and HD DRAG. The pulse argument compute_coefs_from_frequencies allows the user to choose whether the basis function\ncoefficients are computed from suppressed_frequencies during the post-initialization of the pulse\n(thus, overriding any pre-computed values in coefficients ), or if the (pre-computed) values in coefficients are directly used and suppressed_frequencies are neglected. The classes deriving from this base class should\nimplement the post-initialization logic specific to the given pulse. full_width ( float ) \u2013 Full width of the pulse corresponding to the pulse duration with non-zero amplitude (in s). coefficients ( ndarray ) \u2013 Pre-computed coefficients of the series expansion. suppressed_frequencies ( ndarray ) \u2013 Frequencies to be suppressed or center frequencies of intervals to be suppressed\n(in Hz). compute_coefs_from_frequencies ( bool ) \u2013 Boolean value indicating whether we compute the coefficients from the\nsuppressed frequencies or whether we use the pre-computed coefficients. If True, suppressed_frequencies are used to compute and override coefficients in the post-initialization. If False, pre-computed coefficients are used, and suppressed_frequencies are ignored. n_samples ( int ) \u2013 Module: iqm.pulse.playlist.fast_drag Attributes full_width  coefficients  suppressed_frequencies  compute_coefs_from_frequencies  n_samples Requested number of samples for the waveform. Methods Scale the pulse samples to the interval (-1, 1) to avoid clipping at the instruments. samples ( ndarray ) \u2013 Array of pulse samples re-scaled Array of pulse samples ndarray previous FastDragQ next hd_drag \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "base",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.visualisation.base.html",
    "description": "Function for visualising playlists. Full path: iqm.pulse.playlist.visualisation.base Functions inspect_playlist (playlist[,\u00a0segments]) Creates an HTML string from the given playlist and segments. prev...",
    "content": "Function for visualising playlists. Full path: iqm.pulse.playlist.visualisation.base Functions inspect_playlist (playlist[,\u00a0segments]) Creates an HTML string from the given playlist and segments. previous visualisation next iqm.pulse.playlist.visualisation.base.inspect_playlist \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "FluxPulseGate",
    "url": "/iqm-pulse/api/iqm.pulse.gates.cz.FluxPulseGate.html",
    "description": "Bases: GateImplementation Discrete two locus component gate implemented using flux pulses, virtual RZs,\nand the interaction mediated by the coupler. Does not take any parameters since it is discrete. ...",
    "content": "Bases: GateImplementation Discrete two locus component gate implemented using flux pulses, virtual RZs,\nand the interaction mediated by the coupler. Does not take any parameters since it is discrete. The two locus components of the gate must be coupled by a tunable coupler. Consists of a flux pulse for the coupler, and possibly another one for the first locus component,\nassumed to be a qubit, both with arbitrary waveforms, and virtual RZs on both components.\nInherit from this class and assign\nwaveforms to the coupler_wave and qubit_wave pulse slots to create a specific implementation. Can be used as a base class for both CZ and MOVE gate implementations. Note: the coupler and qubit pulses typically have the same duration (given in the calibration data), and in the\nspecial case of the duration being zero, the gate implementation will apply Block(0) instructions\nto all the channels where it would otherwise apply flux pulses or virtual z rotations. flux_pulses \u2013 mapping from flux channel name to its flux pulse rz \u2013 mapping from drive channel name to the virtual z rotation angle, in radians, that should be performed on it parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Module: iqm.pulse.gates.cz Attributes excluded_parameters Parameters names to be excluded from self.parameters . root_parameters Parameters shared by all FluxPulseGate classes. coupler_wave Flux pulse Waveform to be played in the coupler flux AWG. qubit_wave Flux pulse Waveform to be played in the qubit flux AWG. Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). get_locus_mapping_name Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. Flux pulse Waveform to be played in the coupler flux AWG. Flux pulse Waveform to be played in the qubit flux AWG. Parameters shared by all FluxPulseGate classes. Inheriting classes may override this if there\u2019s\na need for additional calibration parameters. Parameters names to be excluded from self.parameters . Inheriting classes may override this if certain\nparameters are not wanted in that class (also parameters defined by the waveforms can be excluded). The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs\nin the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.\nSubclasses can reimplement this method in case it makes sense in their context. float Get the name of the locus mapping stored in ScheduleBuilder.ChipTopology for this implementation. By default, it is \"<operation_name>.<implementation_name>\" . Inheriting classes may\noverride this for different behaviour. operation_name ( str ) \u2013 name of the quantum operation. implementation_name ( str ) \u2013 name of the implementation name of the locus mapping str previous CouplerFluxPulseQubitACStarkPulseGate next FluxPulseGate_CRF_CRF \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.scheduler.extend_schedule_new",
    "url": "/iqm-pulse/api/iqm.pulse.scheduler.extend_schedule_new.html",
    "description": "Extend a Schedule with another Schedule. Extends A with B , modifying A . The extension can add new channels to A . Can also handle cases where B has a ragged left side, i.e. some of its channels begi...",
    "content": "Extend a Schedule with another Schedule. Extends A with B , modifying A . The extension can add new channels to A . Can also handle cases where B has a ragged left side, i.e. some of its channels begin\nwith Nothing instructions. A ( Schedule ) \u2013 schedule to be extended B ( Schedule ) \u2013 schedule to extend A with channels ( dict [ str , ChannelProperties ] ) \u2013 properties of the control channels TOL ( float ) \u2013 time durations equal or smaller than this are considered zero (in seconds) None previous iqm.pulse.scheduler.extend_schedule next SegmentPointer \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.gate_implementation.PROBE_LINES_LOCUS_MAPPING",
    "url": "/iqm-pulse/api/iqm.pulse.gate_implementation.PROBE_LINES_LOCUS_MAPPING.html",
    "description": "Locus mapping name for mapping all probe lines. previous iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_FLUX_AWG_LOCUS_MAPPING next iqm.pulse.gate_implementation.get_waveform_parameters \u00a9 Copyri...",
    "content": "Locus mapping name for mapping all probe lines. previous iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_FLUX_AWG_LOCUS_MAPPING next iqm.pulse.gate_implementation.get_waveform_parameters \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "measure",
    "url": "/iqm-pulse/api/iqm.pulse.gates.measure.html",
    "description": "Projective measurement in the Z basis. Full path: iqm.pulse.gates.measure Classes Measure_Constant Implementation of a single-qubit projective, dispersive measurement in the Z basis. Measure_Constant_...",
    "content": "Projective measurement in the Z basis. Full path: iqm.pulse.gates.measure Classes Measure_Constant Implementation of a single-qubit projective, dispersive measurement in the Z basis. Measure_Constant_Qnd Implementation of a single-qubit projective, non quantum demolition, dispersive measurements in the Z basis. Measure_CustomWaveforms Base class for implementing dispersive measurement operations with custom probe pulse waveforms. ProbePulse_CustomWaveforms Base class for implementing a probe line measurement pulse with custom waveforms in the I and Q channels. ProbePulse_CustomWaveforms_noIntegration Base class for implementing a probe line probe pulse with custom waveforms in the I and Q channels without any integration. Probe_Constant Implementation of a single-qubit projective, dispersive measurement in the Z basis. Shelved_Measure_Constant Implementation of a shelved readout. Shelved_Measure_CustomWaveforms Base class for shelved readout. Inheritance previous FluxMultiplexer_SampleLinear next Measure_Constant \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "PRX_FastDragSX",
    "url": "/iqm-pulse/api/iqm.pulse.gates.prx.PRX_FastDragSX.html",
    "description": "Bases: PRX_CustomWaveformsSX PRX gate, FAST DRAG IQ pulse with VZ-based SX-implementation. See PRX_CustomWaveformsSX . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channe...",
    "content": "Bases: PRX_CustomWaveformsSX PRX gate, FAST DRAG IQ pulse with VZ-based SX-implementation. See PRX_CustomWaveformsSX . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). parameters Required calibration data, may be nested Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 If set True , the Q channel waveform is considered to depend on the I channel\u2019s waveform\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\nwill be initialised as True . Required calibration data, may be nested alias of FastDragI alias of FastDragQ previous PRX_FastDrag next PRX_HdDrag \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "Reset_Wait",
    "url": "/iqm-pulse/api/iqm.pulse.gates.reset.Reset_Wait.html",
    "description": "Bases: GateImplementation Reset operation by relaxation (idling for a time comparable to the relaxation time of the component). Adds a Wait pulse for all the (non-virtual) channels of the locus compon...",
    "content": "Bases: GateImplementation Reset operation by relaxation (idling for a time comparable to the relaxation time of the component). Adds a Wait pulse for all the (non-virtual) channels of the locus components. In addition, blocks all the probes\nassociated with the locus and in case the locus is connected via couplers, blocks them as well. The operation\nis factorizable, so that the calibration data it uses (i.e. the wait duration in seconds) is defined for each\ncomponent, and when acting on multiple components, the maximum of the associated wait durations will be applied. Reset by relaxation is intended to be used in the circuit initialisation between shots / segments.\nIt also can be called on specific qubits inside a segment, but as it works by\nwaiting longer than the qubit relaxation time, the states of all the other qubits\nwill likely have been destroyed as well by the time the reset has finished. Module: iqm.pulse.gates.reset Attributes parameters Required calibration data, may be nested Methods duration_in_seconds Duration of the Schedule of the gate implementation (in seconds). get_custom_locus_mapping Supported loci: all components that have channels. wait_box TimeBox that contains Wait instructions for all non-virtual channels associated with self.locus . parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Required calibration data, may be nested TimeBox that contains Wait instructions for all non-virtual channels associated with self.locus . Does not block any additional components beside the locus itself. TimeBox The GateImplementation-specific logic for implementing a quantum operation. Inheriting classes may override this method if the default __call__() caching (based on the args & kwargs\nin the signature) is sufficient. Any additional caching may also be implemented inside this function if needed. TimeBox Duration of the Schedule of the gate implementation (in seconds). Can be left unimplemented if the duration e.g. depends on the gate arguments.\nSubclasses can reimplement this method in case it makes sense in their context. float Supported loci: all components that have channels. chip_topology ( ChipTopology ) \u2013 component_to_channels ( dict [ str , Iterable [ str ] ] ) \u2013 dict [ tuple [ str , \u2026] | frozenset [ str ], tuple [ str , \u2026]] | None previous Reset_Conditional next rz \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.gate_implementation.OpCalibrationDataTree",
    "url": "/iqm-pulse/api/iqm.pulse.gate_implementation.OpCalibrationDataTree.html",
    "description": "Maps quantum operation names to their calibration data. alias of dict [ str , dict [ str , dict [ tuple [ str , \u2026] | None , dict [ str , Any ]]]] previous iqm.pulse.gate_implementation.OCalibrationDat...",
    "content": "Maps quantum operation names to their calibration data. alias of dict [ str , dict [ str , dict [ tuple [ str , \u2026] | None , dict [ str , Any ]]]] previous iqm.pulse.gate_implementation.OCalibrationData next iqm.pulse.gate_implementation.NestedParams \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "utils",
    "url": "/iqm-pulse/api/iqm.pulse.utils.html",
    "description": "Utility functions. Full path: iqm.pulse.utils Functions map_waveform_param_types (type_hint) Map a python typehint into EXA Parameter's (DataType, CollectionType) tuple. normalize_angle (angle) Normal...",
    "content": "Utility functions. Full path: iqm.pulse.utils Functions map_waveform_param_types (type_hint) Map a python typehint into EXA Parameter's (DataType, CollectionType) tuple. normalize_angle (angle) Normalize the given angle to (-pi, pi]. phase_transformation ([psi_1,\u00a0psi_2]) Implement an arbitrary (RZ, PRX, RZ) gate sequence by modifying the parameters of the IQ pulse implementing the PRX. previous TimeBox next iqm.pulse.utils.map_waveform_param_types \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.gate_implementation.OICalibrationData",
    "url": "/iqm-pulse/api/iqm.pulse.gate_implementation.OICalibrationData.html",
    "description": "For a particular implementation of a particular quantum operation, maps operation loci to their calibration data. alias of dict [ tuple [ str , \u2026] | None , dict [ str , Any ]] previous iqm.pulse.gate_...",
    "content": "For a particular implementation of a particular quantum operation, maps operation loci to their calibration data. alias of dict [ tuple [ str , \u2026] | None , dict [ str , Any ]] previous iqm.pulse.gate_implementation.OILCalibrationData next iqm.pulse.gate_implementation.OCalibrationData \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "CompositeGate",
    "url": "/iqm-pulse/api/iqm.pulse.gate_implementation.CompositeGate.html",
    "description": "Bases: GateImplementation Utility base class for creating gate implementations that are defined in terms of other gate implementations. Gates can be implemented using other pre-existing gate implement...",
    "content": "Bases: GateImplementation Utility base class for creating gate implementations that are defined in terms of other gate implementations. Gates can be implemented using other pre-existing gate implementations by just utilizing the ScheduleBuilder in builder in the __call__() method (e.g. by calling self.builder.get_implementation(<some gate>, <some locus>) . In this way, any such \u201cmember gates\u201d will use\nthe common calibration that exists in builder . In order for a composite gate\nimplementation to be able to calibrate its member gates with different calibration values from the common\ncalibration, it needs to know what gates it considers as its \u201cmembers\u201d. This is what the CompositeGate ABC is for. Inheriting from this class and defining e.g. registered_gates = [\"prx\", \"cz\"] allows one to calibrate the\nmember operations (i.e. \"prx\" and \"cz\" in this example) inside this composite gate differently from the\ncommon calibration. However, if no specific calibration data is provided, the gate implementation will be calibrated\nwith the common calibration. Module: iqm.pulse.gate_implementation Attributes default_implementations Mapping from operation names to the designated default implementation of that operation. registered_gates Gates that can be calibrated separately from their common calibration existing in self.builder . Methods build Construct a member gate implementation. parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Gates that can be calibrated separately from their common calibration existing in self.builder . The gate\nnames should correspond to the keys in self.builder.op_table . Other gates besides the ones given here can\nalso be constructed via self.builder , but these will always use the common calibration. Mapping from operation names to the designated default implementation of that operation. Filling this attribute\nallows one to define a different default implementation from the common default in self.builder.op_table to\nbe used in he context of this composite gate. If an operation is not found in this dict as a key, this\nCompositeGate will use the common default as the default implementation for it. Construct a member gate implementation. If the gate op_name is registered, a specific calibration for it in the context of this CompositeGate\nwill be sought for from self.builder.calibration . If any (non-empty) calibration values are found in self.builder.calibration[self.name][op_name][<impl_name>] they will be merged to the common calibration\n(only non-empty values will be merged). If there are no values found, the\ncommon calibration will be used. op_name ( str ) \u2013 operation name locus ( tuple [ str , ... ] ) \u2013 locus the operation acts on impl_name ( str | None ) \u2013 Implementation name. If not given, uses the default implementation defined in the class instance\nif any, and otherwise the common default in self.builder.op_table strict_locus ( bool ) \u2013 iff False, for non-symmetric implementations of symmetric ops the locus order may\nbe changed if no calibration data is available for the requested locus order Calibrated gate implementation. GateImplementation previous CompositeCache next CustomIQWaveforms \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.gates.get_implementation_class",
    "url": "/iqm-pulse/api/iqm.pulse.gates.get_implementation_class.html",
    "description": "Get gate implementation class by class name. class_name ( str ) \u2013 type [ GateImplementation ] | None previous iqm.pulse.gates.expose_implementation next iqm.pulse.gates.register_implementation \u00a9 Copyr...",
    "content": "Get gate implementation class by class name. class_name ( str ) \u2013 type [ GateImplementation ] | None previous iqm.pulse.gates.expose_implementation next iqm.pulse.gates.register_implementation \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "playlist",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.html",
    "description": "Control pulses and instruction schedules for quantum computers. Full path: iqm.pulse.playlist Subpackages and modules channel Control channel properties. fast_drag Waveform definitions for Fourier Ans...",
    "content": "Control pulses and instruction schedules for quantum computers. Full path: iqm.pulse.playlist Subpackages and modules channel Control channel properties. fast_drag Waveform definitions for Fourier Ansatz Spectrum Tuning (FAST) DRAG pulse based on [ 1 ] . hd_drag Waveform definitions for a higher-derivative (HD) DRAG pulse based on Appendix B of [ 1 ] . instructions Instructions for control instruments. playlist Sequences of instruction schedules to execute. schedule Instruction schedules for controlling the instruments. visualisation  waveforms Waveform definitions. previous UGate next channel \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "PRX_DRAGCosineRiseFall",
    "url": "/iqm-pulse/api/iqm.pulse.gates.prx.PRX_DRAGCosineRiseFall.html",
    "description": "Bases: PRX_CustomWaveforms PRX gate, DRAG / CosineRiseFall IQ pulse implementation. See PRX_CustomWaveforms . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel wavefor...",
    "content": "Bases: PRX_CustomWaveforms PRX gate, DRAG / CosineRiseFall IQ pulse implementation. See PRX_CustomWaveforms . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). excluded_parameters Parameters names to be excluded from self.parameters . parameters Required calibration data, may be nested Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Parameters names to be excluded from self.parameters . Inheriting classes may override this if certain\nparameters are not wanted in that class (also parameters defined by the waveforms can be excluded). Builds an x_pi pulse out of the calibration data. IQPulse If set True , the Q channel waveform is considered to depend on the I channel\u2019s waveform\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\nwill be initialised as True . Required calibration data, may be nested alias of CosineRiseFall alias of CosineRiseFallDerivative previous PRX_CustomWaveformsSX next PRX_DRAGCosineRiseFallSX \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "CZ_GaussianSmoothedSquare",
    "url": "/iqm-pulse/api/iqm.pulse.gates.cz.CZ_GaussianSmoothedSquare.html",
    "description": "Bases: FluxPulseGate CZ gate using a GaussianSmoothedSquare flux pulse on the coupler. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested qubit_wave Flux pulse W...",
    "content": "Bases: FluxPulseGate CZ gate using a GaussianSmoothedSquare flux pulse on the coupler. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested qubit_wave Flux pulse Waveform to be played in the qubit flux AWG. symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 alias of GaussianSmoothedSquare Required calibration data, may be nested Flux pulse Waveform to be played in the qubit flux AWG. True iff the implementation is symmetric in its locus components.\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous CZ_CRF_ACStarkCRF next CZ_Slepian \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.builder.build_quantum_ops",
    "url": "/iqm-pulse/api/iqm.pulse.builder.build_quantum_ops.html",
    "description": "Builds the table of known quantum operations. Hardcoded default native ops table is extended by the ones in ops .\nIn case of name collisions, the content of ops takes priority over the defaults. ops (...",
    "content": "Builds the table of known quantum operations. Hardcoded default native ops table is extended by the ones in ops .\nIn case of name collisions, the content of ops takes priority over the defaults. ops ( dict [ str , Any ] ) \u2013 Contents of the gate_definitions section defining file. ( the quantum operations in the configuration YAML ) \u2013 function. ( Modified by the ) \u2013 Mapping from quantum operation name to its definition dict [ str , QuantumOp ] previous builder next iqm.pulse.builder.load_config \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.playlist.hd_drag.evaluate_nth_derivative_of_basis_envelope",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.hd_drag.evaluate_nth_derivative_of_basis_envelope.html",
    "description": "Evaluate nth derivative of the basis envelope for HD DRAG based on a cosine series. The basis envelope is given by \\(g(t) = \\sum_{k=1}^{K+1} d_k (1 - \\cos(2\\pi k t/t_p + k\\pi))\\) , where the\npulse is ...",
    "content": "Evaluate nth derivative of the basis envelope for HD DRAG based on a cosine series. The basis envelope is given by \\(g(t) = \\sum_{k=1}^{K+1} d_k (1 - \\cos(2\\pi k t/t_p + k\\pi))\\) , where the\npulse is defined on the interval \\(t \\in [-t_p/2, t_p/2]\\) . The returned derivatives are normalized\nvia multiplication by \\(((t_p/(2\\pi))^n\\) , where \\(n\\) is the order of the derivative. t_arr ( ndarray ) \u2013 Array of time points, at which the function is to be evaluated pulse_duration ( float ) \u2013 Pulse duration in the same units as t_arr cosine_coefs_arr ( ndarray ) \u2013 Coefficients of the cosine terms in the basis envelope n ( int ) \u2013 order of derivative Array containing the nth derivative of the basis envelope evaluated at t_arr ndarray previous iqm.pulse.playlist.hd_drag.evaluate_hd_drag_q_envelope next iqm.pulse.playlist.hd_drag.solve_cosine_coefs_for_hd_drag \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "FastDrag",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.fast_drag.FastDrag.html",
    "description": "Bases: SuppressedPulse Base class for IQ components of the Fourier Ansatz Spectrum Tuning (FAST) DRAG pulse. The FAST DRAG pulse shapes the I-envelope in the frequency domain to suppress specified fre...",
    "content": "Bases: SuppressedPulse Base class for IQ components of the Fourier Ansatz Spectrum Tuning (FAST) DRAG pulse. The FAST DRAG pulse shapes the I-envelope in the frequency domain to suppress specified frequency intervals\naccording to given weights. Furthermore, the Q-envelope is obtained as a derivative of the I-envelope\nsimilarly to ordinary DRAG. This class represents a base class for an implementation using cosine functions\nas the I-envelope basis functions. See [ 1 ] for more details on FAST DRAG. number_of_cos_terms ( int ) \u2013 Number of cosine terms in the Fourier series expression of the I-component suppressed_interval_widths ( ndarray ) \u2013 Widths of the suppressed frequency intervals (in Hz). The last element corresponds\nto the width of a potential cutoff interval. weights ( ndarray ) \u2013 Weights corresponding to the suppressed frequency intervals n_samples ( int ) \u2013 full_width ( float ) \u2013 coefficients ( ndarray ) \u2013 suppressed_frequencies ( ndarray ) \u2013 compute_coefs_from_frequencies ( bool ) \u2013 center_offset ( float ) \u2013 Module: iqm.pulse.playlist.fast_drag Attributes center_offset  number_of_cos_terms  suppressed_interval_widths  weights  full_width  coefficients  suppressed_frequencies  compute_coefs_from_frequencies  n_samples Requested number of samples for the waveform. Methods non_timelike_attributes Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Used to construct the parameters for the calibration data required by the waveform.\nBy default all the waveform attributes are \u201ctimelike\u201d (the unit for their calibration data is s).\nHowever, some waveform attributes can be dimensionless, e.g. the relative amplitudes in a sum of\nconsisting of multiple terms, or frequency-like (calibration data has the unit \u2018Hz\u2019).\nIf a Waveform subclass has non-timelike attributes, it needs to redefine this method. When the Waveform is constructed, all timelike calibration data is converted to units of the\nsampling window duration, and all frequency-like calibration data into units of inverse sampling\nwindow duration. dict [ str , str ] previous iqm.pulse.playlist.fast_drag.solve_fast_coefficients_for_given_weights_and_ranges next FastDragI \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "HdDragQ",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.hd_drag.HdDragQ.html",
    "description": "Bases: HdDrag Q-component of the higher derivative (HD) drag pulse. The Q-component is defined according to Eq. (B1) of [ 1 ] , where \\(\\{\\beta_{2n}\\}\\) are the coefficients, and \\(g(t)\\) is the basis...",
    "content": "Bases: HdDrag Q-component of the higher derivative (HD) drag pulse. The Q-component is defined according to Eq. (B1) of [ 1 ] , where \\(\\{\\beta_{2n}\\}\\) are the coefficients, and \\(g(t)\\) is the basis envelope given by where \\(d_k\\) are pre-computed to ensure continuous derivatives up to order \\(2K + 1\\) , \\(t_p\\) denotes the pulse duration, and the pulse is defined across \\(t \\in (-t_p/2, t_p/2)\\) . The sampled pulse is always normalized to have a maximum value of slightly below 1.0. Module: iqm.pulse.playlist.hd_drag Attributes full_width  coefficients  suppressed_frequencies  compute_coefs_from_frequencies  n_samples Requested number of samples for the waveform. Methods n_samples ( int ) \u2013 full_width ( float ) \u2013 coefficients ( ndarray ) \u2013 suppressed_frequencies ( ndarray ) \u2013 compute_coefs_from_frequencies ( bool ) \u2013 center_offset ( float ) \u2013 Actually samples the waveform. sample_coords ( ndarray ) \u2013 coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) ndarray previous HdDragI next instructions \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.playlist.hd_drag.solve_hd_drag_coefficients_from_suppressed_frequencies",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.hd_drag.solve_hd_drag_coefficients_from_suppressed_frequencies.html",
    "description": "Solve coefficients of the derivative terms in a HD DRAG pulse given pulse duration and frequencies to suppress. The coefficients \\(\\{\\beta_{2n}}_{n=0}^{K}\\) of the derivative terms are solved using Eq...",
    "content": "Solve coefficients of the derivative terms in a HD DRAG pulse given pulse duration and frequencies to suppress. The coefficients \\(\\{\\beta_{2n}}_{n=0}^{K}\\) of the derivative terms are solved using Eq. (B5) of [ 1 ] assuming that \\(\\beta_0 = 1\\) . Here, \\(K\\) is the number of suppressed frequencies. Note that the duration and frequencies must have matching units, e.g., s and Hz, or ns and GHz. pulse_duration ( float ) \u2013 Pulse duration (in s). suppressed_freq_arr ( tuple [ float , ... ] ) \u2013 Frequencies to be suppressed relative to the center drive frequency (in Hz). Coefficient array of length len(suppressed_freq_arr) + 1 ndarray previous iqm.pulse.playlist.hd_drag.solve_cosine_coefs_for_hd_drag next HdDrag \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.playlist.fast_drag.solve_fast_coefficients_for_given_weights_and_ranges",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.fast_drag.solve_fast_coefficients_for_given_weights_and_ranges.html",
    "description": "Solve for optimal coefficients of the basis functions in a FAST DRAG pulse. Computes the optimal coefficients \\(\\{c_n\\}_{n=1}^N\\) for a FAST DRAG pulse with \\(N\\) basis functions\nsuch that the pulse s...",
    "content": "Solve for optimal coefficients of the basis functions in a FAST DRAG pulse. Computes the optimal coefficients \\(\\{c_n\\}_{n=1}^N\\) for a FAST DRAG pulse with \\(N\\) basis functions\nsuch that the pulse spectrum is suppressed across the given frequency ranges according to the provided weights.\nThe computation is based on  Eqs. (A5), (A7), (A12) and (A13) of [ 1 ] . Note that this function essentially computes the mapping from frequency-domain parameters of a FAST DRAG pulse\nto time-domain parameters. The results must be cached to allow efficient generation of playlists containing a large number of pulses with\nsame parameters, as in RB. number_of_cosines ( int ) \u2013 Number of cosine basis functions used in the FAST DRAG pulse pulse_duration ( float ) \u2013 Pulse duration (in s) without zero padding. weights_tuple ( tuple [ float , ... ] ) \u2013 1d tuple of weights for each suppressed frequency interval used in the objective function suppressed_freq_ranges_2d_tuple ( tuple [ tuple [ float , ... ] , ... ] ) \u2013 2d tuple describing the frequency ranges (in Hz), over which we want to\nsuppress the Fourier transform. Each element of the outer tuple should be a tuple of two floats, the first\nsetting the starting frequency for the given range and the second setting the ending frequency for the\ngiven range. n_points_for_integration ( int ) \u2013 Number of points at which the integrand is evaluated for each interval. At least 50\npoints are recommended for the numerical approximation error to be low. Coefficients of the basis functions as a 1d array. ndarray previous iqm.pulse.playlist.fast_drag.fourier_transform_of_cos_basis_functions_as_tensor next FastDrag \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.gates.reset.RESET_MEASUREMENT_KEY",
    "url": "/iqm-pulse/api/iqm.pulse.gates.reset.RESET_MEASUREMENT_KEY.html",
    "description": "Constant measurement key for the measure operation required in the fast-feedback reset gate (the double underscore\nemphasizes the fact that this label should not be manually used in fast feedback). pr...",
    "content": "Constant measurement key for the measure operation required in the fast-feedback reset gate (the double underscore\nemphasizes the fact that this label should not be manually used in fast feedback). previous reset next iqm.pulse.gates.reset.RESET_FEEDBACK_KEY \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "CosineFall",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.waveforms.CosineFall.html",
    "description": "Bases: Waveform Cosine Rise waveform. This waveform assumes that during its duration, the only thing occurring is signal falling to 0.\nThe waveform is made for pairing with \u2018Constant\u2019 waveform to enab...",
    "content": "Bases: Waveform Cosine Rise waveform. This waveform assumes that during its duration, the only thing occurring is signal falling to 0.\nThe waveform is made for pairing with \u2018Constant\u2019 waveform to enable arbitrarily long pulses with smooth fall part.\nThe fall time is equal to pulse duration. Module: iqm.pulse.playlist.waveforms Attributes n_samples Requested number of samples for the waveform. Methods n_samples ( int ) \u2013 Actually samples the waveform. sample_coords ( ndarray ) \u2013 coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) ndarray previous Cosine next CosineRise \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "cz",
    "url": "/iqm-pulse/api/iqm.pulse.gates.cz.html",
    "description": "Two-qubit controlled-Z (CZ) gate. The CZ gate flips the relative phase of the \\(|11\u27e9\\) state.\nIt can be represented by the unitary matrix Full path: iqm.pulse.gates.cz Classes CZ_CRF CZ gate using a C...",
    "content": "Two-qubit controlled-Z (CZ) gate. The CZ gate flips the relative phase of the \\(|11\u27e9\\) state.\nIt can be represented by the unitary matrix Full path: iqm.pulse.gates.cz Classes CZ_CRF CZ gate using a CosineRiseFall flux pulse on the coupler. CZ_CRF_ACStarkCRF Controlled-Z two-qubit gate. CZ_GaussianSmoothedSquare CZ gate using a GaussianSmoothedSquare flux pulse on the coupler. CZ_Slepian CZ gate using a Slepian flux pulse on the coupler. CZ_Slepian_ACStarkCRF Controlled-Z two-qubit gate. CZ_Slepian_CRF CZ gate using a Slepian flux pulse on the coupler and a CosineRiseFall flux pulse on the qubit. CZ_TruncatedGaussianSmoothedSquare CZ gate using a TruncatedGaussianSmoothedSquare flux pulse on the coupler. CouplerFluxPulseQubitACStarkPulseGate Base class for CZ gates with coupler flux pulse and a qubit AC Stark pulse. FluxPulseGate Discrete two locus component gate implemented using flux pulses, virtual RZs, and the interaction mediated by the coupler. FluxPulseGate_CRF_CRF CZ gate using a CosineRiseFall flux pulse on the coupler and on the qubit. FluxPulseGate_TGSS_CRF CZ gate using a TruncatedGaussianSmoothedSquare flux pulse on the coupler and a CosineRiseFall flux pulse on the qubit. Inheritance previous CCPRX_Composite_DRAGGaussian next CZ_CRF \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "ThresholdStateDiscrimination",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.instructions.ThresholdStateDiscrimination.html",
    "description": "Bases: ComplexIntegration Perform a weighted integration of the IQ raw signal and compare the real part of the result\nagainst a threshold value, resulting in a boolean. Module: iqm.pulse.playlist.inst...",
    "content": "Bases: ComplexIntegration Perform a weighted integration of the IQ raw signal and compare the real part of the result\nagainst a threshold value, resulting in a boolean. Module: iqm.pulse.playlist.instructions Attributes feedback_signal_label In fast feedback routing, the transmitted signals are associated with this label. threshold The real part of the integration result is compared against this. weights Integration weights. label Identifier for the returned data, like QB1__readout.time_trace . delay_samples Delay from beginning of probe pulse to beginning of acquisition window, in samples. Methods label ( str ) \u2013 delay_samples ( int ) \u2013 weights ( IQPulse ) \u2013 threshold ( float ) \u2013 feedback_signal_label ( str ) \u2013 The real part of the integration result is compared against this. In fast feedback routing, the transmitted signals are associated with this label.\nConditionalInstructions whose \u201ccondition\u201d field has the string value of feedback_signal_label will receive the signal from this ThresholdStateDiscrimination.\nEmpty string (default) means the signal is not routed anywhere.\nThe same feedback_signal_label may not be used multiple times within the same ReadoutTrigger.\nThe same feedback_signal_label can be used in different ReadoutTriggers and different segments. previous RealPulse next TimeTrace \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.playlist.channel.get_channel_properties_from_station_settings",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.channel.get_channel_properties_from_station_settings.html",
    "description": "Get channel properties from Station Control controller settings following the standard convention. settings ( SettingNode ) \u2013 Flat tree of all controllers. chip_topology ( ChipTopology ) \u2013 Chip topolo...",
    "content": "Get channel properties from Station Control controller settings following the standard convention. settings ( SettingNode ) \u2013 Flat tree of all controllers. chip_topology ( ChipTopology ) \u2013 Chip topology. mapping from channel name to its properties\ncomponent_to_channel: mapping from chip component to function name to channel name. channel_properties previous iqm.pulse.playlist.channel.get_channel_properties next iqm.pulse.playlist.channel.round_duration_to_granularity_samples \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.playlist.schedule.TOLERANCE",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.schedule.TOLERANCE.html",
    "description": "remove when COMP-1281 is done. TODO previous schedule next Nothing \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07....",
    "content": "remove when COMP-1281 is done. TODO previous schedule next Nothing \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "move",
    "url": "/iqm-pulse/api/iqm.pulse.gates.move.html",
    "description": "Two-qubit MOVE gate. The MOVE gate is a population exchange operation between a qubit and a resonator,\nmediated by a coupler, that has the following properties: MOVE is unitary. The effect of MOVE is ...",
    "content": "Two-qubit MOVE gate. The MOVE gate is a population exchange operation between a qubit and a resonator,\nmediated by a coupler, that has the following properties: MOVE is unitary. The effect of MOVE is only defined in the invariant\nsubspace \\(S = \\text{span}\\{|00\\rangle, |01\\rangle, |10\\rangle\\}\\) , where it swaps the populations of the states \\(|01\\rangle\\) and \\(|10\\rangle\\) . Anything may happen in the orthogonal subspace as long as it is unitary and\ninvariant. In the subspace where it is defined, MOVE is an involution: \\(\\text{MOVE}_S^2 = I_S\\) . Thus MOVE has the following presentation in the subspace \\(S\\) : where \\(a\\) is an undefined complex phase. This degree of freedom (in addition to the undefined effect of the gate\nin the orthogonal subspace) means there is a continuum of different MOVE gates, all equally valid.\nThe phase \\(a\\) is canceled when the MOVE gate is applied a second time due to the involution property. Full path: iqm.pulse.gates.move Functions apply_move_gate_phase_corrections (schedule,\u00a0...) Schedule-level pass applying resonator-related phase corrections in MOVE sandwiches to the moved qubit. validate_move_instructions (instructions,\u00a0builder) Circuit-level pass to prepare a circuit containing MOVE gates for compilation. Classes MOVE_CRF_CRF Qubit-resonator MOVE gate using the CRF waveform for the coupler and the qubit flux pulse. MOVE_CustomWaveforms Qubit-resonator MOVE gate using flux pulses on both components. MOVE_SLEPIAN_CRF Qubit-resonator MOVE gate using the Slepian waveform for the coupler flux pulse and the CRF waveform for the qubit flux pulse. MOVE_TGSS_CRF Qubit-resonator MOVE gate using the TGSS waveform for the coupler flux pulse and the CRF waveform for the qubit flux pulse. MoveMarker Special annotation instruction to indicate the beginning and ending of MOVE gates. Inheritance previous Shelved_Measure_CustomWaveforms next iqm.pulse.gates.move.apply_move_gate_phase_corrections \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "default_gates",
    "url": "/iqm-pulse/api/iqm.pulse.gates.default_gates.html",
    "description": "This file defines the default quantum gates and operations for IQM\u2019s pulse control system Full path: iqm.pulse.gates.default_gates previous FluxPulseGate_TGSS_CRF next delay \u00a9 Copyright 2019-2025, IQM...",
    "content": "This file defines the default quantum gates and operations for IQM\u2019s pulse control system Full path: iqm.pulse.gates.default_gates previous FluxPulseGate_TGSS_CRF next delay \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "prx",
    "url": "/iqm-pulse/api/iqm.pulse.gates.prx.html",
    "description": "Single-qubit PRX gate. The phased x rotation (PRX) gate is defined as where the rotation angle \\(\\theta\\) and the phase angle \\(\\phi\\) are in radians. It rotates the qubit state around an axis that li...",
    "content": "Single-qubit PRX gate. The phased x rotation (PRX) gate is defined as where the rotation angle \\(\\theta\\) and the phase angle \\(\\phi\\) are in radians. It rotates the qubit state around an axis that lies in the XY plane of the Bloch sphere. Full path: iqm.pulse.gates.prx Functions get_unitary_prx (angle,\u00a0phase) Unitary for a PRX gate. Classes ABC_Constant_smooth Base class for creating gates with an arbitrarily long Constant pulses with smooth rise and fall. Constant_PRX_with_smooth_rise_fall Constant PRX pulse with cosine rise and fall padding. PRX_CustomWaveforms Base class for PRX gates implemented using a single IQ pulse and hot-swappable waveforms. PRX_CustomWaveformsSX Base class for PRX gates implemented using SX gate, hot-swappable waveforms and phase manipulation. PRX_DRAGCosineRiseFall PRX gate, DRAG / CosineRiseFall IQ pulse implementation. PRX_DRAGCosineRiseFallSX PRX gate, DRAG / CosineRiseFall IQ pulse with VZ implementation. PRX_DRAGGaussian PRX gate, DRAG / TruncatedGaussian IQ pulse implementation. PRX_DRAGGaussianSX PRX gate, DRAG / Gaussian IQ pulse with VZ implementation. PRX_FastDrag PRX gate, FAST DRAG IQ pulse based on amplitude scaling. PRX_FastDragSX PRX gate, FAST DRAG IQ pulse with VZ-based SX-implementation. PRX_HdDrag PRX gate, HD DRAG IQ pulse based on amplitude scaling PRX_HdDragSX PRX gate, HD DRAG IQ pulse with VZ-based SX-implementation. PRX_ModulatedCustomWaveForms Base class for PRX gates with modulated frequency, hot-swappable waveforms. PRX_ModulatedDRAGCosineRiseFall Modulated PRX pulse with cosine rise fall waveform PRX_SinglePulse_GateImplementation Base class for PRX gates implemented using a single IQ pulse. PrxGateImplementation ABC for different implementations of the PRX gate. Inheritance previous MoveMarker next iqm.pulse.gates.prx.get_unitary_prx \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "ChannelConfiguration",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.channel.ChannelConfiguration.html",
    "description": "Bases: object Base class for configuring channels. Module: iqm.pulse.playlist.channel Methods previous iqm.pulse.playlist.channel.round_duration_to_granularity_samples next ChannelDescription \u00a9 Copyri...",
    "content": "Bases: object Base class for configuring channels. Module: iqm.pulse.playlist.channel Methods previous iqm.pulse.playlist.channel.round_duration_to_granularity_samples next ChannelDescription \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "CompositeCache",
    "url": "/iqm-pulse/api/iqm.pulse.gate_implementation.CompositeCache.html",
    "description": "Bases: object Cache for CompositeGate TimeBoxes. Result from CompositeGate.__call__`() (or other methods returning a TimeBox) cannot be stored in the normal\ncache GateImplementation._timebox_cache as ...",
    "content": "Bases: object Cache for CompositeGate TimeBoxes. Result from CompositeGate.__call__`() (or other methods returning a TimeBox) cannot be stored in the normal\ncache GateImplementation._timebox_cache as composites can include any gates in their calls, and we cannot trust\nthat the cache is flushed correctly just based on if the composite itself has its own calibration data changed\n(we would have to flush also when any of the composite\u2019s members get new calibration, and this cannot consistently\nbe deduced). For this reason, CompositeCache will be flushed whenever ANY gate implementation gets new calibration\ndata. Module: iqm.pulse.gate_implementation Methods flush Flush the CompositeCache. get Get a TimeBox from the cache. set Set a TimeBox into the cache. Set a TimeBox into the cache. gate_implementation ( GateImplementation ) \u2013 gate implementation that created the TimeBox. cache_key ( tuple [ Any , ... ] ) \u2013 hashable key identifying the TimeBox (usually the CompositeGate.__call__() arguments cast\ninto a tuple). timebox ( TimeBox ) \u2013 TimeBox that will be added to the cache. extra_id ( str ) \u2013 extra string id for further identifying the result if needed (for example if the TimeBox did not\ncome from the call method, but some other method, this could be the method\u2019s name). None Get a TimeBox from the cache. gate_implementation ( GateImplementation ) \u2013 gate implementation that created the TimeBox. cache_key ( tuple [ Any , ... ] ) \u2013 hashable key identifying the TimeBox (usually the CompositeGate.__call__() arguments cast\ninto a tuple). extra_id ( str ) \u2013 extra string id for further identifying the result (for example if the TimeBox did not come\nfrom the call method, but some other method, this could be the method\u2019s name). The cached TimeBox or None if not fund for this gate_implementation , cache_key , and extra_id . TimeBox | None Flush the CompositeCache. None previous iqm.pulse.gate_implementation.get_waveform_parameters next CompositeGate \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.validation.validate_playlist_compatibility",
    "url": "/iqm-pulse/api/iqm.pulse.validation.validate_playlist_compatibility.html",
    "description": "Validates that the given playlist is compatible with the provided AWG data. The following requirements are validated as they are the same for all controllers. Playlist sample rate vs. Actual controlle...",
    "content": "Validates that the given playlist is compatible with the provided AWG data. The following requirements are validated as they are the same for all controllers. Playlist sample rate vs. Actual controller sample rate Instruction granularity with respect to the controllers granularity requirements Checks that no other than supported instructions are used. Checks that instruction length matches waveform length in IQ and RealPulse Checks that all instructions are at least the length of minimum number of samples Checks that Conditional instruction has the same duration in every child instruction playlist ( Playlist ) \u2013 instructions used on each channel, as well as the channel configurations device_constraints ( dict [ str , ChannelProperties ] ) \u2013 actual hardware limitations of the channels None previous iqm.pulse.validation.validate_instruction_and_wf_length next AWGScheduleValidationData \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "SchedulingStrategy",
    "url": "/iqm-pulse/api/iqm.pulse.timebox.SchedulingStrategy.html",
    "description": "Bases: Enum Different scheduling strategies for the contents of composite TimeBoxes. Module: iqm.pulse.timebox Attributes ASAP TimeBox contents are scheduled as soon as possible within the box. ALAP T...",
    "content": "Bases: Enum Different scheduling strategies for the contents of composite TimeBoxes. Module: iqm.pulse.timebox Attributes ASAP TimeBox contents are scheduled as soon as possible within the box. ALAP TimeBox contents are scheduled as late as possible within the box. Methods TimeBox contents are scheduled as soon as possible within the box. TimeBox contents are scheduled as late as possible within the box. previous SchedulingAlgorithm next TimeBox \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "reset",
    "url": "/iqm-pulse/api/iqm.pulse.gates.reset.html",
    "description": "Resetting qubits to the zero state. The reset operation is a non-unitary quantum channel that sets the state of a qubit to \\(|0\\rangle\\) . Full path: iqm.pulse.gates.reset Module Attributes RESET_MEAS...",
    "content": "Resetting qubits to the zero state. The reset operation is a non-unitary quantum channel that sets the state of a qubit to \\(|0\\rangle\\) . Full path: iqm.pulse.gates.reset Module Attributes RESET_MEASUREMENT_KEY Constant measurement key for the measure operation required in the fast-feedback reset gate (the double underscore emphasizes the fact that this label should not be manually used in fast feedback). RESET_FEEDBACK_KEY The feedback key used in fast-feedback reset gate (the double underscore emphasizes the fact that this label should not be manually used in fast feedback). Classes Reset_Conditional Conditional reset operation. Reset_Wait Reset operation by relaxation (idling for a time comparable to the relaxation time of the component). Inheritance previous PrxGateImplementation next iqm.pulse.gates.reset.RESET_MEASUREMENT_KEY \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "playlist",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.playlist.html",
    "description": "Sequences of instruction schedules to execute. Full path: iqm.pulse.playlist.playlist previous Wait next schedule \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07....",
    "content": "Sequences of instruction schedules to execute. Full path: iqm.pulse.playlist.playlist previous Wait next schedule \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.utils.phase_transformation",
    "url": "/iqm-pulse/api/iqm.pulse.utils.phase_transformation.html",
    "description": "Implement an arbitrary (RZ, PRX, RZ) gate sequence by modifying the parameters of the\nIQ pulse implementing the PRX. By commutation rules we have Hence an arbitrary (RZ, PRX, RZ) gate sequence is equi...",
    "content": "Implement an arbitrary (RZ, PRX, RZ) gate sequence by modifying the parameters of the\nIQ pulse implementing the PRX. By commutation rules we have Hence an arbitrary (RZ, PRX, RZ) gate sequence is equivalent to (RZ, PRX) with adjusted angles. Use case: with resonant driving, the PRX gate can be implemented using an IQPulse instance,\nand the preceding RZ can be handled by decrementing the local oscillator phase beforehand (something\nthe IQPulse instruction can also do), which is equivalent to rotating the local computational frame\naround the z axis in the opposite direction of the required quantum state rotation. psi_1 ( float ) \u2013 RZ angle before the PRX (in rad) psi_2 ( float ) \u2013 RZ angle after the PRX (in rad) change to the PRX phase angle (in rad),\nphase increment for the IQ pulse that implements the remaining RZ (in rad) tuple [ float , float ] previous iqm.pulse.utils.normalize_angle next validation \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.playlist.fast_drag.compute_matrix_of_summed_fourier_transform_inner_products",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.fast_drag.compute_matrix_of_summed_fourier_transform_inner_products.html",
    "description": "Evaluate matrix \\(A\\) defined in Eq. (5) of [ 1 ] . The matrix element \\(A_{nm}\\) is defined as where n,m are the row and column indices starting from 1 and extending to \\(N\\) denoting the\nnumber of b...",
    "content": "Evaluate matrix \\(A\\) defined in Eq. (5) of [ 1 ] . The matrix element \\(A_{nm}\\) is defined as where n,m are the row and column indices starting from 1 and extending to \\(N\\) denoting the\nnumber of basis functions, \\(f_{l,j}\\) and \\(f_{h,j}\\) denote the starting and ending frequency of the\nj\u2019th frequency range to suppress, \\(\\hat{g}_n(f)\\) denotes the Fourier transform of \\(g_n(f) = 1 -  \\cos(2 \\pi n t/t_p)\\) with \\(t_p\\) being the pulse duration. Importantly, the computations are fully vectorized for fast evaluation. n_arr ( ndarray ) \u2013 1d array containing indices of basis functions used in the series expansion,\ntypically ranging from 1 to N weights ( ndarray ) \u2013 1d array of weights corresponding to the suppressed frequency ranges suppressed_freq_ranges_2darr ( ndarray ) \u2013 2d array describing the frequency ranges (in Hz), over which we want to suppress\nthe Fourier transform. The array should have two columns, the first giving the starting frequency\nfor each range and the second giving the ending frequency for each range.\nNote that frequencies will be symmetrically suppressed around the center frequency. pulse_duration ( float ) \u2013 Pulse duration (in s) without zero padding. time_scaling_factor ( float ) \u2013 Scaling factor for time to avoid excessively large or small values in the matrix. Scaling\nfactor of frequency is obtained as the inverse. n_points_for_integration ( int ) \u2013 Number of points at which the integrand is evaluated for each interval. At least 50\npoints are recommended for the numerical approximation error to be low. 2d array representing the A matrix with dimensions (len(n_arr), len(n_arr)) ndarray previous fast_drag next iqm.pulse.playlist.fast_drag.evaluate_fast_drag_i_envelope \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "hd_drag",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.hd_drag.html",
    "description": "Waveform definitions for a higher-derivative (HD) DRAG pulse based on Appendix B of [ 1 ] . Full path: iqm.pulse.playlist.hd_drag Module Attributes COSINE_COEFFICIENTS_DICT Pre-computed coefficients o...",
    "content": "Waveform definitions for a higher-derivative (HD) DRAG pulse based on Appendix B of [ 1 ] . Full path: iqm.pulse.playlist.hd_drag Module Attributes COSINE_COEFFICIENTS_DICT Pre-computed coefficients of the cosine terms in the basis envelope (0th derivative). Functions evaluate_hd_drag_i_envelope (t_arr,\u00a0...) Evaluate I-envelope of HD DRAG given the coefficients of the derivative terms and the cosine terms. evaluate_hd_drag_q_envelope (t_arr,\u00a0...) Evaluate Q-envelope of HD DRAG given the coefficients of the derivative terms and the cosine terms. evaluate_nth_derivative_of_basis_envelope (...) Evaluate nth derivative of the basis envelope for HD DRAG based on a cosine series. solve_cosine_coefs_for_hd_drag (...) Solve cosine coefficients of the basis envelope given the number of suppressed frequencies. solve_hd_drag_coefficients_from_suppressed_frequencies (...) Solve coefficients of the derivative terms in a HD DRAG pulse given pulse duration and frequencies to suppress. Classes HdDrag Base class for higher-derivative DRAG based on Eqs. HdDragI I-component of the higher derivative (HD) drag pulse. HdDragQ Q-component of the higher derivative (HD) drag pulse. Inheritance previous SuppressedPulse next iqm.pulse.playlist.hd_drag.COSINE_COEFFICIENTS_DICT \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.builder.validate_quantum_circuit",
    "url": "/iqm-pulse/api/iqm.pulse.builder.validate_quantum_circuit.html",
    "description": "Validate a sequence of circuit operations constituting a quantum circuit. operations ( Iterable [ CircuitOperation ] ) \u2013 quantum circuit to be validated op_table ( dict [ str , QuantumOp ] ) \u2013 table c...",
    "content": "Validate a sequence of circuit operations constituting a quantum circuit. operations ( Iterable [ CircuitOperation ] ) \u2013 quantum circuit to be validated op_table ( dict [ str , QuantumOp ] ) \u2013 table containing allowed/calibrated quantum operations require_measurements ( bool ) \u2013 iff True the circuit must include at least one measurement operation ValueError \u2013 operations do not constitute a valid quantum circuit None previous iqm.pulse.builder.load_config next CircuitOperation \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "TwoQubitGate",
    "url": "/iqm-pulse/api/iqm.pulse.gates.enums.TwoQubitGate.html",
    "description": "Bases: Enum Enumerates a subset of two-qubit gates. Members of this enum can be mapped to the corresponding unitary propagator using\nthe dictionary returned by TWO_QUBIT_UNITARIES . Module: iqm.pulse....",
    "content": "Bases: Enum Enumerates a subset of two-qubit gates. Members of this enum can be mapped to the corresponding unitary propagator using\nthe dictionary returned by TWO_QUBIT_UNITARIES . Module: iqm.pulse.gates.enums Attributes CZ Controlled-Z gate. ISWAP iSWAP gate. SQRT_ISWAP Square root of the iSWAP gate. Methods Controlled-Z gate. iSWAP gate. Square root of the iSWAP gate. previous iqm.pulse.gates.enums.TWO_QUBIT_UNITARIES next XYGate \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "Cosine",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.waveforms.Cosine.html",
    "description": "Bases: Waveform Periodic sinusoidal waveform which defaults to cosine. The use case for this waveform is to do manual modulation of other waveforms. where \\(f\\) is the frequency, and \\(\\phi\\) the phas...",
    "content": "Bases: Waveform Periodic sinusoidal waveform which defaults to cosine. The use case for this waveform is to do manual modulation of other waveforms. where \\(f\\) is the frequency, and \\(\\phi\\) the phase of the wave. frequency ( float ) \u2013 frequency of the wave, in units of inverse sampling window duration phase ( float ) \u2013 phase of the wave, in radians n_samples ( int ) \u2013 Module: iqm.pulse.playlist.waveforms Attributes phase  frequency  n_samples Requested number of samples for the waveform. Methods non_timelike_attributes Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Actually samples the waveform. sample_coords ( ndarray ) \u2013 coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) ndarray Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Used to construct the parameters for the calibration data required by the waveform.\nBy default all the waveform attributes are \u201ctimelike\u201d (the unit for their calibration data is s).\nHowever, some waveform attributes can be dimensionless, e.g. the relative amplitudes in a sum of\nconsisting of multiple terms, or frequency-like (calibration data has the unit \u2018Hz\u2019).\nIf a Waveform subclass has non-timelike attributes, it needs to redefine this method. When the Waveform is constructed, all timelike calibration data is converted to units of the\nsampling window duration, and all frequency-like calibration data into units of inverse sampling\nwindow duration. dict [ str , str ] previous ChirpImag next CosineFall \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "gate_implementation",
    "url": "/iqm-pulse/api/iqm.pulse.gate_implementation.html",
    "description": "Implementing abstract quantum operations as instruction schedules. Note Note the conceptual difference between quantum operations (ops) and instruction schedules . Ops represent abstract, ideal comput...",
    "content": "Implementing abstract quantum operations as instruction schedules. Note Note the conceptual difference between quantum operations (ops) and instruction schedules . Ops represent abstract, ideal computational\noperations, whereas instruction schedules represent concrete control signal sequences for the\nquantum computer. One can (approximately) implement an op using a number of different\ninstruction schedules. Full path: iqm.pulse.gate_implementation Module Attributes Locus Sequence of QPU component physical names a quantum operation is acting on. OILCalibrationData Calibration data for a particular implementation of a particular quantum operation at a particular locus. OICalibrationData For a particular implementation of a particular quantum operation, maps operation loci to their calibration data. OCalibrationData For a particular quantum operation, maps implementation names to their calibration data. OpCalibrationDataTree Maps quantum operation names to their calibration data. NestedParams Nested dict defining the parameters required by GateImplementation classes. SINGLE_COMPONENTS_WITH_DRIVE_LOCUS_MAPPING Locus mapping name for mapping all components that have the drive operation defined. SINGLE_COMPONENTS_WITH_READOUT_LOCUS_MAPPING Locus mapping name for mapping all components that have the readout operation defined. SINGLE_COMPONENTS_WITH_FLUX_AWG_LOCUS_MAPPING Locus mapping name for mapping all components that have the flux operation defined and the flux controller has an AWG. PROBE_LINES_LOCUS_MAPPING Locus mapping name for mapping all probe lines. Functions get_waveform_parameters (wave[,\u00a0label_prefix]) Parameters that are required to initialize the given Waveform class. Classes CompositeCache Cache for CompositeGate TimeBoxes. CompositeGate Utility base class for creating gate implementations that are defined in terms of other gate implementations. CustomIQWaveforms Base class for GateImplementations using custom waveform definition with IQPulses. GateImplementation ABC for implementing quantum gates and other quantum operations using instruction schedules. SinglePulseGate Base class for GateImplementations that play a single pulse on a single channel. Inheritance previous CircuitOperationList next iqm.pulse.gate_implementation.Locus \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.validation.PlaylistValidationError",
    "url": "/iqm-pulse/api/iqm.pulse.validation.PlaylistValidationError.html",
    "description": "Error raised when Playlist validation fails. previous iqm.pulse.validation.InvalidInstructionError next Changelog \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07....",
    "content": "Error raised when Playlist validation fails. previous iqm.pulse.validation.InvalidInstructionError next Changelog \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "Schedule",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.schedule.Schedule.html",
    "description": "Bases: object Set of synchronously executed AWG/readout programs that start on a single trigger. Consists of a number of channels , each containing a Segment of Instruction s for a specific controller...",
    "content": "Bases: object Set of synchronously executed AWG/readout programs that start on a single trigger. Consists of a number of channels , each containing a Segment of Instruction s for a specific controller.  For each channel, maps the channel name to\nits Segment of Instructions. Mutable. To make an independent copy, use copy() . contents ( Mapping [ str , Iterable [ Instruction ] ] | None ) \u2013 mapping from channel name to a list of Instructions for that channel duration ( int | None ) \u2013 Optional precomputed duration (in samples). In cases where the duration is known and performance\nis critical, the duration can be given in the constructor, allowing one to skip computing it. Module: iqm.pulse.playlist.schedule Attributes duration The maximum duration of the Schedule's channels, in samples. Methods add_channels Add new empty channels to the schedule. append Append a single Instruction to a specific channel in the Schedule. channels The channels occupied in self . cleanup Cleans up the schedule by removing things that do not affect the execution. copy Make an independent copy of the schedule. duration_in_seconds Schedule duration in seconds, taking into account the sample rates of the channels. extend Append given Instruction to a specific channel in the Schedule. front_pad Modifies the schedule in place by front-padding it with Wait instructions. front_pad_in_seconds Modifies the schedule in place by front-padding it with Wait instructions. has_content_in Returns True if self has content in any of the given channels, otherwise False . items Iterator over the schedule channel names and segments. pad_to_hard_box Pad channels in self to the maximum channel length found within with Wait instructions. pad_to_hard_box_in_seconds Pad channels in self to the maximum channel length (seconds) found within with Wait instructions. pprint Fixed-width character graphics representation of the Schedule. reverse Copy of the schedule with the order of the instructions in each channel reversed. reverse_hard_box Copy of the schedule with the order of the instructions in each channel reversed. validate Validate the contents of the schedule. The maximum duration of the Schedule\u2019s channels, in samples. Computed only when needed and cached for performance. Schedule duration in seconds, taking into account the sample rates of the channels. channel_properties ( dict [ str , ChannelProperties ] ) \u2013 channel properties. schedule duration (in seconds) float Fixed-width character graphics representation of the Schedule. Assumes the Instruction.duration s are in samples. time_unit ( int ) \u2013 unit of time represented by a single symbol (in samples) str Iterator over the schedule channel names and segments. The channels occupied in self . KeysView Make an independent copy of the schedule. Mutating the original must not affect the copy, or vice versa.\nInstructions are immutable, so they need not be copied. copy of the schedule Schedule Add new empty channels to the schedule. If a given channel (identified by its controller name) already exist in the schedule,\nit is unchanged. Modifies self . channel_names ( Iterable [ str ] ) \u2013 names of the controllers for which empty channels are added None Append a single Instruction to a specific channel in the Schedule. channel ( str ) \u2013 name of the channel to append the instruction to instruction ( Instruction ) \u2013 instruction to append None Append given Instruction to a specific channel in the Schedule. channel ( str ) \u2013 name of the channel to append the instructions to instructions ( Iterable [ Instruction ] ) \u2013 instructions to append None Modifies the schedule in place by front-padding it with Wait instructions. NOTE: this method cannot be used when there are variable sampling rates present in the schedule. In that\ncase, use the method front_pad_in_seconds . to_duration ( int ) \u2013 duration of the resulting schedule, in samples self , with the padding Schedule Modifies the schedule in place by front-padding it with Wait instructions. The new duration is given in seconds, and this method works also with variable sample rates. channel_properties ( dict [ str , ChannelProperties ] ) \u2013 channel properties. to_duration ( float ) \u2013 self , with the padding Pad channels in self to the maximum channel length found within with Wait instructions. The Wait``s are appended to the end of the segments. NOTE: this method cannot be used when there are variable sampling rates present in the schedule. In that case, use the method ``pad_to_hard_box_in_seconds . None Pad channels in self to the maximum channel length (seconds) found within with Wait instructions. The Waits are appended to the end of the segments. The segment durations are compared in seconds, so this\nmethod works in the case of variable sampling rates as well. The padding is added to a channel only if the\ndifference between the channel\u2019s duration and the maximum duration is larger than the smallest possible\ninstruction duration for that channel. channel_properties ( dict [ str , ChannelProperties ] ) \u2013 channel properties (containing the sampling rates and granularities). None Copy of the schedule with the order of the instructions in each channel reversed. NOTE: this method cannot be used when there are variable sampling rates present in the schedule. To preserve synchronization of the channels, the channels are first rear-padded\nwith Nothing instructions. Schedule Copy of the schedule with the order of the instructions in each channel reversed. No additional time-synchronisation logic is implemented, so this method will break the synchronisation\nif self is not a schedule with matching durations in all segments. Schedule Cleans up the schedule by removing things that do not affect the execution. Removes empty channels, and channels that only have idling instructions. Modifies self . Schedule Validate the contents of the schedule. path ( tuple [ str , ... ] ) \u2013 None Returns True if self has content in any of the given channels, otherwise False . channel_names ( Iterable [ str ] ) \u2013 bool previous Nothing next Segment \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "ChirpImag",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.waveforms.ChirpImag.html",
    "description": "Bases: Chirp Imaginary part of the linear chirp, which sets the phase to $-pi/2$. n_samples ( int ) \u2013 freq_start ( float ) \u2013 freq_stop ( float ) \u2013 alpha ( float ) \u2013 phase ( float ) \u2013 Phase of the puls...",
    "content": "Bases: Chirp Imaginary part of the linear chirp, which sets the phase to $-pi/2$. n_samples ( int ) \u2013 freq_start ( float ) \u2013 freq_stop ( float ) \u2013 alpha ( float ) \u2013 phase ( float ) \u2013 Phase of the pulse. Defaults to $pi/2$ float Module: iqm.pulse.playlist.waveforms Attributes phase  freq_start  freq_stop  n_samples Requested number of samples for the waveform. Methods previous Chirp next Cosine \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "PRX_DRAGCosineRiseFallSX",
    "url": "/iqm-pulse/api/iqm.pulse.gates.prx.PRX_DRAGCosineRiseFallSX.html",
    "description": "Bases: PRX_CustomWaveformsSX PRX gate, DRAG / CosineRiseFall IQ pulse with VZ implementation. See PRX_CustomWaveformsVZ . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q cha...",
    "content": "Bases: PRX_CustomWaveformsSX PRX gate, DRAG / CosineRiseFall IQ pulse with VZ implementation. See PRX_CustomWaveformsVZ . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). excluded_parameters Parameters names to be excluded from self.parameters . parameters Required calibration data, may be nested Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Parameters names to be excluded from self.parameters . Inheriting classes may override this if certain\nparameters are not wanted in that class (also parameters defined by the waveforms can be excluded). Builds a single sqrt(X) pulse from the calibration data. IQPulse If set True , the Q channel waveform is considered to depend on the I channel\u2019s waveform\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\nwill be initialised as True . Required calibration data, may be nested alias of CosineRiseFall alias of CosineRiseFallDerivative previous PRX_DRAGCosineRiseFall next PRX_DRAGGaussian \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "TimeBox",
    "url": "/iqm-pulse/api/iqm.pulse.timebox.TimeBox.html",
    "description": "Bases: object Container for one or more instruction schedule fragments, to be scheduled according to a given strategy. Each TimeBox can be labeled using a human-readable label describing it, and opera...",
    "content": "Bases: object Container for one or more instruction schedule fragments, to be scheduled according to a given strategy. Each TimeBox can be labeled using a human-readable label describing it, and operates on a number\nof locus components , using some of their control channels.  It can be either atomic or composite . An atomic box only contains a single Schedule . A composite box contains a sequence of other TimeBoxes as its children.\nThe locus components are the union of the locus components of the children.\nIf two children use the same channel so that they cannot happen simultaneously, they must\nhappen in the order they occur in the sequence. A box can be made atomic by resolving it using ScheduleBuilder.resolve_timebox .\nThe time duration of the box is determined by its contents and the way they are scheduled during the resolution. TimeBoxes can be concatenated with the following rules: Addition concatenates the children of the operands into a single TimeBox. The pipe operation groups two TimeBoxes together without concatenating. Iterables of Boxes are treated as the sum of the elements. Let a, b, c, d be TimeBoxes. Then Module: iqm.pulse.timebox Attributes scheduling Determines how the contents of a composite TimeBox are scheduled by ScheduleBuilder. scheduling_algorithm Determines the algorithm used in converting the TimeBox to a Schedule. label Description the contents of the box for users' convenience. locus_components Names of the QPU components on which this timebox operates. atom Resolved contents of the TimeBox, or None if not resolved. children Further Timeboxes inside this TimeBox. neighborhood_components Dict of neighborhood range integers mapped to sets of components neighboring the locus of this TimeBox . Methods atomic Build an atomic timebox from a schedule. composite Build a composite timebox from a sequence of timeboxes. print Print a simple representation of the contents of this box. set_alap Set the scheduling strategy to As late as possible (ALAP). set_asap Set the scheduling strategy to As soon as possible (ASAP). validate Validate the contents of the TimeBox. label ( str ) \u2013 locus_components ( set [ str ] ) \u2013 atom ( Schedule | None ) \u2013 children ( tuple [ TimeBox , ... ] ) \u2013 scheduling ( SchedulingStrategy ) \u2013 scheduling_algorithm ( SchedulingAlgorithm ) \u2013 neighborhood_components ( dict [ int , set [ str ] ] ) \u2013 Description the contents of the box for users\u2019 convenience. Has no functional effect. Names of the QPU components on which this timebox operates. These can include additional components\nto the ones included in one of the channels occupied by this TimeBox . The components included in this\nattribute will be blocked in scheduling, in addition to the ones dictated by the neighborhood range (see neighborhood_components ). Resolved contents of the TimeBox, or None if not resolved. Further Timeboxes inside this TimeBox. Determines how the contents of a composite TimeBox are scheduled by ScheduleBuilder.\nHas no meaning for an atomic TimeBox. Determines the algorithm used in converting the TimeBox to a Schedule. Dict of neighborhood range integers mapped to sets of components neighboring the locus of this TimeBox .\nThese are used in the scheduling when the corresponding neighborhood range is used.\nThe scheduling algorithm computes the neighborhood components (unless it has been already precomputed by\ne.g. the GateImplementation ) and caches them under this attribute. Neighborhood range 0 means just the components\naffected by one of the channels in self.atom + self.locus , 1 means also neighboring couplers, 2 the\ncomponents connected to those couplers, and so on. Note: range 0 may differ from self.locus_components : it can\nhave additional components that have occupied channels in self but are not defined as a part of the \u2018locus\u2019 of\nthis TimeBox for any reason. Build a composite timebox from a sequence of timeboxes. boxes ( Iterable [ TimeBox | Iterable [ TimeBox ] ] ) \u2013 contents of the new timebox. Any iterables of timeboxes will be flattened (recursively) and extended\nto the contents in the same order. label ( str ) \u2013 label of the new timebox scheduling ( SchedulingStrategy ) \u2013 scheduling strategy to use when resolving the new timebox scheduling_algorithm ( SchedulingAlgorithm ) \u2013 scheduling algorithm to use when resolving the new timebox composite timebox containing boxes as its children TimeBox Build an atomic timebox from a schedule. schedule ( Schedule ) \u2013 contents of the new timebox locus_components ( Iterable [ str ] ) \u2013 names QPU components schedule operates on label ( str ) \u2013 label of the new timebox atomic timebox containing schedule TimeBox Validate the contents of the TimeBox. path ( tuple [ str , ... ] ) \u2013 Labels of ancestor boxes, to generate a better error message. None Set the scheduling strategy to As soon as possible (ASAP). TimeBox Set the scheduling strategy to As late as possible (ALAP). TimeBox Print a simple representation of the contents of this box. _idxs ( tuple [ int , ... ] ) \u2013 None previous SchedulingStrategy next utils \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "VirtualRZ",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.instructions.VirtualRZ.html",
    "description": "Bases: Instruction Change the upconversion phase reference. The phase change can be done either by updating the phase of the local oscillator directly using\na hardware instruction, or algebraically by...",
    "content": "Bases: Instruction Change the upconversion phase reference. The phase change can be done either by updating the phase of the local oscillator directly using\na hardware instruction, or algebraically by incrementing IQPulse.phase of all the IQPulses\nfollowing the VirtualRZ instruction in the Segment . Module: iqm.pulse.playlist.instructions Attributes phase_increment Phase increment for the local oscillator of a drive channel, in radians. duration Time duration of the instruction. Methods duration ( int ) \u2013 phase_increment ( float ) \u2013 Phase increment for the local oscillator of a drive channel, in radians. previous TimeTrace next Wait \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.gates.flux_multiplexer.TOLERANCE",
    "url": "/iqm-pulse/api/iqm.pulse.gates.flux_multiplexer.TOLERANCE.html",
    "description": "Tolerance for the maximum absolute value in a waveform for considering it to be uniformly zero. previous flux_multiplexer next FluxMultiplexer_SampleLinear \u00a9 Copyright 2019-2025, IQM Finland Oy, Relea...",
    "content": "Tolerance for the maximum absolute value in a waveform for considering it to be uniformly zero. previous flux_multiplexer next FluxMultiplexer_SampleLinear \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.gates.u.get_unitary_u",
    "url": "/iqm-pulse/api/iqm.pulse.gates.u.get_unitary_u.html",
    "description": "Unitary for an SU(2) gate. See iqm.pulse.gates.u for the definition of the gate parameters. theta ( float ) \u2013 y rotation angle phi ( float ) \u2013 z rotation angle lam ( float ) \u2013 another z rotation angle...",
    "content": "Unitary for an SU(2) gate. See iqm.pulse.gates.u for the definition of the gate parameters. theta ( float ) \u2013 y rotation angle phi ( float ) \u2013 z rotation angle lam ( float ) \u2013 another z rotation angle 2x2 unitary representing u(theta, phi, lam) . ndarray previous u next UGate \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "ProbeChannelProperties",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.channel.ProbeChannelProperties.html",
    "description": "Bases: ChannelProperties ChannelProperties for probe line channels. Module: iqm.pulse.playlist.channel Attributes center_frequency Center frequency for the channel. integration_start_dead_time Dead ti...",
    "content": "Bases: ChannelProperties ChannelProperties for probe line channels. Module: iqm.pulse.playlist.channel Attributes center_frequency Center frequency for the channel. integration_start_dead_time Dead time samples before integration. integration_stop_dead_time Dead time samples after integration. sample_rate sample rate of the instrument responsible for the channel (in Hz) instruction_duration_granularity all instruction durations on this channel must be multiples of this granularity (in samples) instruction_duration_min all instruction durations on this channel must at least this long (in samples) compatible_instructions instruction types that are allowed on this channel Methods sample_rate ( float ) \u2013 instruction_duration_granularity ( int ) \u2013 instruction_duration_min ( int ) \u2013 compatible_instructions ( tuple [ type [ Instruction ] , ... ] ) \u2013 is_iq ( bool ) \u2013 is_virtual ( bool ) \u2013 blocks_component ( bool ) \u2013 center_frequency ( float ) \u2013 integration_start_dead_time ( int ) \u2013 integration_stop_dead_time ( int ) \u2013 Center frequency for the channel. Dead time samples before integration. Dead time samples after integration. previous IQChannelConfig next RealChannelConfig \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "RZ_PRX_Composite",
    "url": "/iqm-pulse/api/iqm.pulse.gates.rz.RZ_PRX_Composite.html",
    "description": "Bases: CompositeGate RZ gate implemented as a sequence of PRX gates. Module: iqm.pulse.gates.rz Attributes registered_gates Gates that can be calibrated separately from their common calibration existi...",
    "content": "Bases: CompositeGate RZ gate implemented as a sequence of PRX gates. Module: iqm.pulse.gates.rz Attributes registered_gates Gates that can be calibrated separately from their common calibration existing in self.builder . Methods Gates that can be calibrated separately from their common calibration existing in self.builder . The gate\nnames should correspond to the keys in self.builder.op_table . Other gates besides the ones given here can\nalso be constructed via self.builder , but these will always use the common calibration. previous RZ_ACStarkShift_smoothConstant next RZ_Virtual \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "conditional",
    "url": "/iqm-pulse/api/iqm.pulse.gates.conditional.html",
    "description": "Classically controlled gates. Full path: iqm.pulse.gates.conditional Classes CCPRX_Composite Classically controlled PRX gate. CCPRX_Composite_DRAGCosineRiseFall Conditional drag_crf pulse. CCPRX_Compo...",
    "content": "Classically controlled gates. Full path: iqm.pulse.gates.conditional Classes CCPRX_Composite Classically controlled PRX gate. CCPRX_Composite_DRAGCosineRiseFall Conditional drag_crf pulse. CCPRX_Composite_DRAGGaussian Conditional drag_gaussian pulse. Inheritance previous Barrier next CCPRX_Composite \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "PRX_FastDrag",
    "url": "/iqm-pulse/api/iqm.pulse.gates.prx.PRX_FastDrag.html",
    "description": "Bases: PRX_CustomWaveforms PRX gate, FAST DRAG IQ pulse based on amplitude scaling. See PRX_CustomWaveforms . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel wavefor...",
    "content": "Bases: PRX_CustomWaveforms PRX gate, FAST DRAG IQ pulse based on amplitude scaling. See PRX_CustomWaveforms . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). parameters Required calibration data, may be nested Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 If set True , the Q channel waveform is considered to depend on the I channel\u2019s waveform\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\nwill be initialised as True . Required calibration data, may be nested alias of FastDragI alias of FastDragQ previous PRX_DRAGGaussianSX next PRX_FastDragSX \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "FluxPulseGate_TGSS_CRF",
    "url": "/iqm-pulse/api/iqm.pulse.gates.cz.FluxPulseGate_TGSS_CRF.html",
    "description": "Bases: FluxPulseGate CZ gate using a TruncatedGaussianSmoothedSquare flux pulse on the coupler and a CosineRiseFall\nflux pulse on the qubit. Module: iqm.pulse.gates.cz Attributes parameters Required c...",
    "content": "Bases: FluxPulseGate CZ gate using a TruncatedGaussianSmoothedSquare flux pulse on the coupler and a CosineRiseFall\nflux pulse on the qubit. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 alias of TruncatedGaussianSmoothedSquare Required calibration data, may be nested alias of CosineRiseFall True iff the implementation is symmetric in its locus components.\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous FluxPulseGate_CRF_CRF next default_gates \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "CircuitOperationList",
    "url": "/iqm-pulse/api/iqm.pulse.circuit_operations.CircuitOperationList.html",
    "description": "Bases: list List of CircuitOperation objects representing a quantum circuit. The class is used to work with CircuitOperations directly. It is mostly meant as\nconvenience to enable easy creation of cir...",
    "content": "Bases: list List of CircuitOperation objects representing a quantum circuit. The class is used to work with CircuitOperations directly. It is mostly meant as\nconvenience to enable easy creation of circuits, calculations of their properties, and mapping them onto physical\nqubits. In addition to the circuit contents, this class has two important attributes: qubits and table . qubits defines the list of qubits which are allowed to be in the loci of all the\nCircuitOperations present in the list. Think about it as Qiskit\u2019s QuantumRegister. table is a QuantumOpTable , which contains all the QuantumOp s which are allowed in the circuit. In most cases, the table is\nsimply taken to contain all the default operations defined in iqm.pulse .\nWhen you use this class with a ScheduleBuilder , it is good practice to set table = builder.op_table . The QuantumOpTable is mutable, so any additional registered\ngates can automatically be usable in any CircuitOperationList associated with that\nScheduleBuilder instance. The fundamental use of the class would be to first define a new instance: The num_qubits parameter populates the qubits attribute with qubits QB1-QBn,\nin this case ['QB1', 'QB2'] . Alternatively, you can provide qubits directly: To add your own QuantumOpTable, initialize like this: Remembering that the table is mutable. If you already have a list of CircuitOperations, you can initialize with it: Calling the find_qubits() method populates the qubits attribute with the qubits found in loci of\nthe operations in the original circuit. If the list is empty, it will set qubits to an empty list,\nwhich most of the time is not what you want to do. The class has the __add__ , __mul__ and __getitem__ methods redefined, which means circuit * 3 , circuit1 + circuit2 and circuit[0:4] will produce a CircuitOperationList\nwith the same qubits and table attributes as the original. To add a prx operation to the list, call: The class also has shortcut methods defined, so the above can be shortened to which is exactly the same syntax as in Qiskit, with the addition of the implementation name\nwhich usually does not need to be used. The names of the shortcut methods are taken from the\nattached table at init. All the operations with non-zero arity\nwill be added as shortcuts. If all the operations in the circuit are unitary, you can calculate the unitary propagator of\nthe entire circuit by calling: The dimension of the unitary will always be defined by the qubits attribute. In particular, if your circuit\ncontains 3 qubits, 'QB1', 'QB2', 'QB3' , but you only add gates to the first two, the resulting unitary will\nstill be an 8x8 matrix, corresponding to the three qubits 'QB1', 'QB2', 'QB3' , in the big endian convention.\nWith no operations affecting 'QB3' , the action of the unitary on this qubit is identity. To map the circuit onto physical qubits, all you need to do is call: This will create a copy of the circuit, with all the placeholder qubits replaced by the physical qubits, with the\norder defined by the qubits attribute. For example, if qubits = ['QB1', 'Alice', 'ZZZ'] , and physical_qubits = ['QB2', 'QB5', 'QB10'] , all occurrences of 'QB1' will be mapped to 'QB2' , 'Alice' to 'QB5' and 'ZZZ' to 'QB10' . The original circuit is not modified, so you can create many copies with\ndifferent physical qubits, which is helpful when running parallel experiments on a large chip. contents ( Iterable [ CircuitOperation ] ) \u2013 Circuit operations to initialize the circuit with. Can be left out. qubits ( list [ str ] ) \u2013 Qubits allowed to be used in operation loci in the circuit. num_qubits ( int ) \u2013 Number of qubits in the circuit, will initialize qubits with ['QB1', 'QB2', ...] .\nIgnored if qubits is given. table ( QuantumOpTable | None ) \u2013 Allowed quantum operations. Module: iqm.pulse.circuit_operations Attributes qubits  Methods add_op Adds a new CircuitOperation to the circuit. add_qubits Adds generic placeholder qubits from 1 to n. barrier Add barrier to the circuit compose A safer way to add circuits together, but will probably take time. count_ops Count each type of operation in the circuit. find_qubits Set attribute qubits to qubits in the loci of operations in the list. get_unitary Calculate the overall unitary implemented by a sequence of CircuitOperations. map_loci Creates a new list of CircuitOperation s with locus mapped onto physical qubits. Set attribute qubits to qubits in the loci of operations in the list. None Adds generic placeholder qubits from 1 to n. n ( int ) \u2013 None Calculate the overall unitary implemented by a sequence of CircuitOperations. self \u2013 list of CircuitOperations in order qubit_names ( list [ str ] | None ) \u2013 Optionally, the ordering of the qubits. Array describing the action of the circuit in big endian convention. ndarray Adds a new CircuitOperation to the circuit. Appends a new CircuitOperation at the end of the list. The CircuitOperation is created using a QuantumOp name from the\nQuantumOpTable attached to the CircuitOperationList. The locus of that CircuitOperation is built from the qubits stored in qubits , by selecting\nthe qubits at indices given by locus_indices . For example, if qubits is ['QB1', 'QB2', 'QB4'] , and the locus_indices is [2, 1] , the locus of the new CircuitOperation will be ('QB4', 'QB2') . All arguments for the values of the\nparams of the requested QuantumOp need to be provided. name ( str ) \u2013 Name of the QuantumOp which will generate a new CircuitOperation . locus_indices ( Sequence [ int ] ) \u2013 Indices of the qubits in the attribute .qubits which will become the locus of the operation. args \u2013 Any arguments the CircuitOperation needs, must correspond to the params of the QuantumOp . impl_name ( str | None ) \u2013 Name of the implementation to use when converting the CircuitOperation into\na Timebox later. None Add barrier to the circuit None A safer way to add circuits together, but will probably take time. All the CircuitOperation s from the 'other' list are appended to the end of\nthis list. The wire k of the second circuit is connected to wire locus_indices[k] of the first. This\nis achieved by mapping the locus of each operation in the second circuit onto the qubits of the first. For example, if the qubits of the first list are ['QB1', 'QB2'] , the second list has ['QB3', 'QB4'] , and the locus_indices argument is [1,0] , all the operations in the second list will have\ntheir 'QB3' mapped to 'QB2' and 'QB4' mapped to 'QB1' . other \u2013 Second CircuitOperationList. Must have less or equal qubits than this one. locus_indices ( list [ int ] | None ) \u2013 Indices of the qubits in this CircuitOperationList onto which the qubits in the second\ncircuit ar mapped. Self, with new operations added. Self Count each type of operation in the circuit. Counter mapping operation names to numbers of times they occur in the circuit. Counter Creates a new list of CircuitOperation s with locus mapped onto physical qubits. Creates a fresh list of fresh CircuitOperation s with fresh arguments. If locus is provided, it needs to have the same length as the total number of qubits across the circuit,\nand the qubits will then be mapped onto the new locus. If it is not provided, this is identical to a deepcopy\nof the original list. locus ( list [ str ] | None ) \u2013 List of new qubits to replace the qubits in the loci of the operations in the circuit. make_circuit ( bool ) \u2013 If True, creates a CircuitOperationList . If False, it is just a list. New CircuitOperationList with loci mapped onto new locus. CircuitOperationList | list [ CircuitOperation ] Add the convenience methods for adding new operations, based on the default QuantumOpTable . name ( str ) \u2013 None previous iqm.pulse.circuit_operations.reshape_unitary next gate_implementation \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.gates.enums.TWO_QUBIT_UNITARIES",
    "url": "/iqm-pulse/api/iqm.pulse.gates.enums.TWO_QUBIT_UNITARIES.html",
    "description": "Mapping of TwoQubitGates to the corresponding U(4) matrices previous iqm.pulse.gates.enums.XYGATE_UNITARIES next TwoQubitGate \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 202...",
    "content": "Mapping of TwoQubitGates to the corresponding U(4) matrices previous iqm.pulse.gates.enums.XYGATE_UNITARIES next TwoQubitGate \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "SchedulingAlgorithm",
    "url": "/iqm-pulse/api/iqm.pulse.timebox.SchedulingAlgorithm.html",
    "description": "Bases: Enum Algorithms for resolving composite TimeBoxes into atomic ones. Module: iqm.pulse.timebox Attributes HARD_BOUNDARY Respects the TimeBox boundary such that the longest channel with a box def...",
    "content": "Bases: Enum Algorithms for resolving composite TimeBoxes into atomic ones. Module: iqm.pulse.timebox Attributes HARD_BOUNDARY Respects the TimeBox boundary such that the longest channel with a box defines its boundary and all other channels are padded to this length (using the specified SchedulingStrategy ). TETRIS Will pack the schedule as tightly as possible while respecting the defined scheduling neighborhood. Methods Respects the TimeBox boundary such that the longest channel with a box defines\nits boundary and all other channels are padded to this length (using the specified SchedulingStrategy ). Will pack the schedule as tightly as possible while respecting the defined scheduling neighborhood. previous MultiplexedProbeTimeBox next SchedulingStrategy \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "CZ_CRF_ACStarkCRF",
    "url": "/iqm-pulse/api/iqm.pulse.gates.cz.CZ_CRF_ACStarkCRF.html",
    "description": "Bases: CouplerFluxPulseQubitACStarkPulseGate Controlled-Z two-qubit gate. CZ gate implemented using a cosine rise fall flux pulse for the coupler and a modulated\ncosine rise fall (CRF) AC Stark pulse ...",
    "content": "Bases: CouplerFluxPulseQubitACStarkPulseGate Controlled-Z two-qubit gate. CZ gate implemented using a cosine rise fall flux pulse for the coupler and a modulated\ncosine rise fall (CRF) AC Stark pulse on one qubit. Module: iqm.pulse.gates.cz Attributes parameters Required calibration data, may be nested symmetric True iff the implementation is symmetric in its locus components. Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 alias of CosineRiseFall Required calibration data, may be nested alias of ModulatedCosineRiseFall True iff the implementation is symmetric in its locus components.\nOnly meaningful if arity != 1 , and the locus components are of the same type. previous CZ_CRF next CZ_GaussianSmoothedSquare \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "FluxPulse",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.instructions.FluxPulse.html",
    "description": "Bases: RealPulse RealPulse representing a flux pulse. Can store RZ angles for correcting local phase shifts from the computational frame due to flux crosstalk. Module: iqm.pulse.playlist.instructions ...",
    "content": "Bases: RealPulse RealPulse representing a flux pulse. Can store RZ angles for correcting local phase shifts from the computational frame due to flux crosstalk. Module: iqm.pulse.playlist.instructions Attributes rzs Collection of (drive) channel names and RZ angles. wave Shape of the pulse. scale Scaling factor for the waveform. duration Time duration of the instruction. Methods duration ( int ) \u2013 wave ( Waveform ) \u2013 scale ( float ) \u2013 rzs ( tuple [ tuple [ str , float ] , ... ] ) \u2013 Collection of (drive) channel names and RZ angles. previous ConditionalInstruction next IQPulse \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "PRX_ModulatedDRAGCosineRiseFall",
    "url": "/iqm-pulse/api/iqm.pulse.gates.prx.PRX_ModulatedDRAGCosineRiseFall.html",
    "description": "Bases: PRX_ModulatedCustomWaveForms Modulated PRX pulse with cosine rise fall waveform Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depe...",
    "content": "Bases: PRX_ModulatedCustomWaveForms Modulated PRX pulse with cosine rise fall waveform Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). excluded_parameters Parameters names to be excluded from self.parameters . parameters Required calibration data, may be nested Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 If set True , the Q channel waveform is considered to depend on the I channel\u2019s waveform\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\nwill be initialised as True . Required calibration data, may be nested alias of CosineRiseFall alias of CosineRiseFallDerivative Parameters names to be excluded from self.parameters . Inheriting classes may override this if certain\nparameters are not wanted in that class (also parameters defined by the waveforms can be excluded). Return the IQPulse with modulated arbitrary waveform based on the calibration data. IQPulse previous PRX_ModulatedCustomWaveForms next PRX_SinglePulse_GateImplementation \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "scheduler",
    "url": "/iqm-pulse/api/iqm.pulse.scheduler.html",
    "description": "Tools for composing instruction schedules in time. Under the idealized, noiseless, crosstalk-less computational model, the scheduling algorithms\nshould preserve the effect of the schedules on the comp...",
    "content": "Tools for composing instruction schedules in time. Under the idealized, noiseless, crosstalk-less computational model, the scheduling algorithms\nshould preserve the effect of the schedules on the computational subspace, i.e.\nexecuting Schedule A immediately followed by B should be equivalent to\nexecuting the composed schedule A+B . The composing is always done so that in A+B all the channels of B start\ntheir execution simultaneously, and remain in sync. Nothing instructions can be added\nas spacers between the channels of A and B as necessary to make this happen. Typically the scheduling algorithms also try to minimize the total duration of the composed schedule. Full path: iqm.pulse.scheduler Module Attributes NONSOLID Instructions that can be converted to Wait after scheduling. BLOCKING Nonsolid Instructions that nevertheless block. Functions extend_hard_boundary (schedule,\u00a0...) Merge two Schedules together such that the timebox boundary is respected. extend_hard_boundary_in_seconds (schedule,\u00a0...) The same as extend_hard_boundary , but the scheduling is done in seconds. extend_schedule (A,\u00a0B,\u00a0channels,\u00a0*[,\u00a0TOL]) Extend a Schedule with another Schedule. extend_schedule_new (A,\u00a0B,\u00a0channels,\u00a0*[,\u00a0TOL]) Extend a Schedule with another Schedule. Classes SegmentPointer Tool for working with Segments. Inheritance previous QuantumOp next iqm.pulse.scheduler.NONSOLID \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "ChannelProperties",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.channel.ChannelProperties.html",
    "description": "Bases: object Defines the properties of a control or measurement channel. All ZI instruments (HDAWG, UHFQA, SHFSG, SHFQA) can handle control pulses and waits where the\nnumber of samples is 32 + n * 16...",
    "content": "Bases: object Defines the properties of a control or measurement channel. All ZI instruments (HDAWG, UHFQA, SHFSG, SHFQA) can handle control pulses and waits where the\nnumber of samples is 32 + n * 16 , where n in {0, 1, 2, ...} . Module: iqm.pulse.playlist.channel Attributes blocks_component Whether content in this channel should block the entire component that it is associated with in the scheduling. is_iq HACK, True iff this is an IQ channel. is_virtual Virtual channels are only used on the frontend side during compilation and scheduling. sample_rate sample rate of the instrument responsible for the channel (in Hz) instruction_duration_granularity all instruction durations on this channel must be multiples of this granularity (in samples) instruction_duration_min all instruction durations on this channel must at least this long (in samples) compatible_instructions instruction types that are allowed on this channel Methods duration_to_int_samples Convert a time duration to an integer number of samples at the channel sample rate. duration_to_samples Convert a time duration to number of samples at the channel sample rate. duration_to_seconds Convert a time duration in samples at the channel sample rate to seconds. round_duration_to_granularity Round a time duration to the channel granularity. sample_rate ( float ) \u2013 instruction_duration_granularity ( int ) \u2013 instruction_duration_min ( int ) \u2013 compatible_instructions ( tuple [ type [ Instruction ] , ... ] ) \u2013 is_iq ( bool ) \u2013 is_virtual ( bool ) \u2013 blocks_component ( bool ) \u2013 sample rate of the instrument responsible for the channel (in Hz) all instruction durations on this channel must be multiples of this granularity (in samples) all instruction durations on this channel must at least this long (in samples) instruction types that are allowed on this channel HACK, True iff this is an IQ channel. TODO do better Virtual channels are only used on the frontend side during compilation and scheduling.\nThey are removed from the Schedule before it is sent to Station\nControl. For example, virtual drive channels of computational resonators. Whether content in this channel should block the entire component that it is associated with in the scheduling.\nTypically all physical channels should block their components, but certain virtual channels might not\nrequire this. Convert a time duration to number of samples at the channel sample rate. duration ( float ) \u2013 time duration in s duration in samples float Convert a time duration in samples at the channel sample rate to seconds. duration ( float ) \u2013 time duration in samples duration in seconds float Convert a time duration to an integer number of samples at the channel sample rate. duration must be sufficiently close to an integer number of samples, and\nthat number must be something the channel can handle. duration ( float ) \u2013 time duration in s message ( str ) \u2013 message identifying the duration we are testing check_min_samples ( bool ) \u2013 If True, check that the output is at least instruction_duration_min . duration as an integer number of samples ValueError \u2013 duration is not close to an integer number of samples, or is\n    otherwise unacceptable to the channel int Round a time duration to the channel granularity. duration ( float ) \u2013 time duration in s round_up ( bool ) \u2013 whether to round the durations up, or to the closest granularity force_min_duration ( bool ) \u2013 whether to force the duration to be at least instruction_duration_min duration rounded to channel granularity, in s float previous ChannelDescription next IQChannelConfig \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "PRX_HdDrag",
    "url": "/iqm-pulse/api/iqm.pulse.gates.prx.PRX_HdDrag.html",
    "description": "Bases: PRX_CustomWaveforms PRX gate, HD DRAG IQ pulse based on amplitude scaling See PRX_CustomWaveforms . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform i...",
    "content": "Bases: PRX_CustomWaveforms PRX gate, HD DRAG IQ pulse based on amplitude scaling See PRX_CustomWaveforms . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). parameters Required calibration data, may be nested Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 If set True , the Q channel waveform is considered to depend on the I channel\u2019s waveform\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\nwill be initialised as True . Required calibration data, may be nested alias of HdDragI alias of HdDragQ previous PRX_FastDragSX next PRX_HdDragSX \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.gate_implementation.NestedParams",
    "url": "/iqm-pulse/api/iqm.pulse.gate_implementation.NestedParams.html",
    "description": "Nested dict defining the parameters required by GateImplementation classes. alias of dict [ str , Parameter | Setting | dict ] previous iqm.pulse.gate_implementation.OpCalibrationDataTree next iqm.pul...",
    "content": "Nested dict defining the parameters required by GateImplementation classes. alias of dict [ str , Parameter | Setting | dict ] previous iqm.pulse.gate_implementation.OpCalibrationDataTree next iqm.pulse.gate_implementation.SINGLE_COMPONENTS_WITH_DRIVE_LOCUS_MAPPING \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "HdDragI",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.hd_drag.HdDragI.html",
    "description": "Bases: HdDrag I-component of the higher derivative (HD) drag pulse. The I-component is defined according to Eq. (B1) of [ 1 ] , where \\(\\{\\beta_{2n}\\}_{n=0}^K\\) are the coefficients of the derivative ...",
    "content": "Bases: HdDrag I-component of the higher derivative (HD) drag pulse. The I-component is defined according to Eq. (B1) of [ 1 ] , where \\(\\{\\beta_{2n}\\}_{n=0}^K\\) are the coefficients of the derivative terms, \\(K\\) is the number of\nsuppressed frequencies, and \\(g(t)\\) is the basis envelope given by where \\(d_k\\) are pre-computed to ensure continuous derivatives up to order \\(2K + 1\\) , \\(t_p\\) denotes the pulse duration, and the pulse is defined across \\(t \\in (-t_p/2, t_p/2)\\) . The sampled pulse is always normalized to have a maximum value slightly below 1.0. Module: iqm.pulse.playlist.hd_drag Attributes full_width  coefficients  suppressed_frequencies  compute_coefs_from_frequencies  n_samples Requested number of samples for the waveform. Methods n_samples ( int ) \u2013 full_width ( float ) \u2013 coefficients ( ndarray ) \u2013 suppressed_frequencies ( ndarray ) \u2013 compute_coefs_from_frequencies ( bool ) \u2013 center_offset ( float ) \u2013 Actually samples the waveform. sample_coords ( ndarray ) \u2013 coordinates of the samples to be returned array of samples (same shape as sample_coords , dtype == float ) ndarray previous HdDrag next HdDragQ \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "timebox",
    "url": "/iqm-pulse/api/iqm.pulse.timebox.html",
    "description": "Reserving QPU resources in instruction scheduling. Full path: iqm.pulse.timebox Classes MultiplexedProbeTimeBox A TimeBox that contains any number of multiplexed readout pulses for probe channels. Sch...",
    "content": "Reserving QPU resources in instruction scheduling. Full path: iqm.pulse.timebox Classes MultiplexedProbeTimeBox A TimeBox that contains any number of multiplexed readout pulses for probe channels. SchedulingAlgorithm Algorithms for resolving composite TimeBoxes into atomic ones. SchedulingStrategy Different scheduling strategies for the contents of composite TimeBoxes. TimeBox Container for one or more instruction schedule fragments, to be scheduled according to a given strategy. Inheritance previous SegmentPointer next MultiplexedProbeTimeBox \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.playlist.hd_drag.evaluate_hd_drag_i_envelope",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.hd_drag.evaluate_hd_drag_i_envelope.html",
    "description": "Evaluate I-envelope of HD DRAG given the coefficients of the derivative terms and the cosine terms. The I-envelope is defined as \\(I(t) = \\sum_{n=0}^{K} \\beta_{2n} g^{(2n)}(t)\\) , where \\(K\\) is the n...",
    "content": "Evaluate I-envelope of HD DRAG given the coefficients of the derivative terms and the cosine terms. The I-envelope is defined as \\(I(t) = \\sum_{n=0}^{K} \\beta_{2n} g^{(2n)}(t)\\) , where \\(K\\) is the number\nof suppressed frequency ranges, \\(\\{beta_{2n}\\}\\) are the coefficients of the derivative terms, and \\(g(t)\\) is the basis envelope. The pulse is assumed to start at time -pulse_duration/2 ,\nand end at time pulse_duration/2 . t_arr ( ndarray ) \u2013 Array of time points, at which the function is to be evaluated pulse_duration ( float ) \u2013 Pulse duration in the same units as t_arr derivative_coefs_arr ( ndarray ) \u2013 Coefficients of the even derivatives cosine_coefs_arr ( ndarray ) \u2013 Coefficients of the cosine terms in the basis envelope I-envelope of a HD DRAG pulse evaluated at t_arr ndarray previous iqm.pulse.playlist.hd_drag.COSINE_COEFFICIENTS_DICT next iqm.pulse.playlist.hd_drag.evaluate_hd_drag_q_envelope \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.quantum_ops.validate_op_calibration",
    "url": "/iqm-pulse/api/iqm.pulse.quantum_ops.validate_op_calibration.html",
    "description": "Validates quantum operation calibration data against the known quantum operations. NOTE: calibration data parameters that have a defined default value are not required to be in the calibration data. c...",
    "content": "Validates quantum operation calibration data against the known quantum operations. NOTE: calibration data parameters that have a defined default value are not required to be in the calibration data. calibration ( OpCalibrationDataTree ) \u2013 quantum operation calibration data tree to validate ops ( QuantumOpTable ) \u2013 known quantum operations and their implementations ValueError \u2013 there is something wrong with the calibration data None previous iqm.pulse.quantum_ops.validate_locus_calibration next QuantumOp \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.utils.normalize_angle",
    "url": "/iqm-pulse/api/iqm.pulse.utils.normalize_angle.html",
    "description": "Normalize the given angle to (-pi, pi]. angle ( float ) \u2013 angle to normalize (in radians) angle normalized to (-pi, pi] float previous iqm.pulse.utils.map_waveform_param_types next iqm.pulse.utils.pha...",
    "content": "Normalize the given angle to (-pi, pi]. angle ( float ) \u2013 angle to normalize (in radians) angle normalized to (-pi, pi] float previous iqm.pulse.utils.map_waveform_param_types next iqm.pulse.utils.phase_transformation \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "PRX_ModulatedCustomWaveForms",
    "url": "/iqm-pulse/api/iqm.pulse.gates.prx.PRX_ModulatedCustomWaveForms.html",
    "description": "Bases: PRX_CustomWaveforms Base class for PRX gates with modulated frequency, hot-swappable waveforms. The class takes baseband I and Q waveform as input, and modulates them with frequency in the root...",
    "content": "Bases: PRX_CustomWaveforms Base class for PRX gates with modulated frequency, hot-swappable waveforms. The class takes baseband I and Q waveform as input, and modulates them with frequency in the root_parameters.\nThe final pulse shape after modulation is: where \\(A_I\\) is amplitude_i , \\(A_Q\\) is amplitude_q , \\(\\Omega\\) is arbitrary waveform in\nbaseband, \\(\\omega_d/2\\pi\\) is the drive frequency and \\(\\delta/2\\pi\\) is the modulated frequency . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). root_parameters Parameters independent of the of Waveforms. wave_i Waveform for the I channel. wave_q Waveform for the Q channel. Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Parameters independent of the of Waveforms. Inheriting classes may override this to include parameters common\nto all such implementations. Return the IQPulse with modulated arbitrary waveform based on the calibration data. amplitude_i ( float ) \u2013 amplitude_q ( float ) \u2013 n_samples ( int ) \u2013 IQPulse If set True , the Q channel waveform is considered to depend on the I channel\u2019s waveform\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\nwill be initialised as True . previous PRX_HdDragSX next PRX_ModulatedDRAGCosineRiseFall \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "QuantumOp",
    "url": "/iqm-pulse/api/iqm.pulse.quantum_ops.QuantumOp.html",
    "description": "Bases: object Describes a native quantum operation type. Quantum operations (or \u201cops\u201d in short), are simple, abstract, self-contained actions one can\nexecute on a station as parts of a quantum circuit...",
    "content": "Bases: object Describes a native quantum operation type. Quantum operations (or \u201cops\u201d in short), are simple, abstract, self-contained actions one can\nexecute on a station as parts of a quantum circuit. They include quantum gates, measurements,\nand resets. They must have an unambiguous definition in terms of their intended effect on the\ncomputational subspace of the quantum subsystems (qubits, qudits, qumodes\u2026) they act on.\nThey are implemented on the hardware using instruction schedules . A QuantumOp can also be a metaoperation , which (in an idealized picture) has no effect on the\nquantum state, but affects the scheduling of the other ops. Execution barriers are an example of a metaoperation. The ops can have any number of named parameters. For example, PRX is a two-parameter\nquantum gate family, whereas CZ is a single gate with no parameters. A locus (plural: loci) is a tuple[str, ...] (an ordered sequence) of CHAD component names\nan instance of a quantum operation acts on. The locus consists of those QPU components that store the\nquantum information the operation acts on. For example, a CZ gate implemented using a flux\npulse on the coupler connecting the qubits does not include the coupler in its locus, since the\ncoupler is simply an implementation detail. In a quantum circuit each operation type normally has several different loci. For example, you\ncould have a PRX gate being used on qubits {('QB1',), ('QB2',), ('QB5',)} , or a CZ gate used on qubit pairs {('QB1', 'QB3'), ('QB3', 'QB5',), ('QB1', 'QB5',)} . Each quantum operation can have any number of named implementations , each represented by a GateImplementation subclass. For example, we may have two implementations of the CZ gate,\none with just a single flux pulse applied to the coupler, and another one with additional flux\npulses applied to the qubits as well. operation defines the abstract intention (what) implementation defines the concrete method (how) locus defines the target of the operation (where) The quantum operations are typically calibrated using specific calibration experiments that\noutput the required calibration data. Each implementation of each operation can require\nits own, independent set of calibration data for each locus. Module: iqm.pulse.quantum_ops Attributes default_implementation Name of the default implementation (the global default). factorizable True iff the operation is always factorizable to independent single-subsystem operations, which is also how it is implemented, for example parallel single-qubit measurements. params Names of required operation parameters, if any. symmetric True iff the effect of operation is symmetric in the quantum subsystems it acts on. unitary Unitary matrix that represents the effect of this quantum operation in the computational basis, or None if the quantum operation is not unitary or the exact unitary is not known. name Unique name of the operation. arity Number of locus components the operation acts on. implementations Maps implementation names to GateImplementation classes that provide them. defaults_for_locus Optionally define the implementation default individually per each locus. Methods copy Make a copy of self with the given changes applied to the contents. get_default_implementation_for_locus Get the default (highest priority) implementation for the given locus. set_default_implementation Sets the given implementation as the default. set_default_implementation_for_locus Set the locus-specific default implementation. name ( str ) \u2013 arity ( int ) \u2013 params ( tuple [ str , ... ] ) \u2013 implementations ( dict [ str , type [ GateImplementation ] ] ) \u2013 symmetric ( bool ) \u2013 factorizable ( bool ) \u2013 defaults_for_locus ( dict [ tuple [ str , ... ] , str ] ) \u2013 unitary ( Callable [ ... , np.ndarray ] | None ) \u2013 Unique name of the operation. Number of locus components the operation acts on.\nEach locus component corresponds to a quantum subsystem in the definition of the operation.\nThe computational subspace always consists of the lowest two levels of the subsystem.\nZero means the operation can be applied on any number of locus components. Names of required operation parameters, if any. Maps implementation names to GateImplementation classes that provide them.\nEach such class should describe the implementation in detail in its docstring.\nThe implementations are in the dict in priority order, highest-priority (default) first. This global priority\norder can be overridden per locus by the attribute defaults_for_locus . True iff the effect of operation is symmetric in the quantum subsystems it acts on.\nOnly meaningful if self.arity != 1 . True iff the operation is always factorizable to independent single-subsystem operations, which\nis also how it is implemented, for example parallel single-qubit measurements.\nIn this case the operation calibration data is for individual subsystems as well. Optionally define the implementation default individually per each locus. Maps the locus to the default\ngate implementation name. If a locus is not found in this dict (by default, the dict is empty), falls back to the\nglobal order defined in implementations . The implementations must be first registered in implementations . Unitary matrix that represents the effect of this quantum operation in the computational basis, or None if the quantum operation is not unitary or the exact unitary is not known.\nThe Callable needs to take exactly the arguments given in params , for example if params=('angle','phase') , the function must have signature f(angle:float, phase: float) -> np.ndarray .\nFor operations acting on more than 1 qubit, unitary should be given in the big-endian order, i.e. in the basis np.kron(first_qubit_basis_ket, second_qubit_basis_ket) . Make a copy of self with the given changes applied to the contents. QuantumOp Name of the default implementation (the global default). Sets the given implementation as the default. default ( str ) \u2013 name of the new default implementation ValueError \u2013 default is unknown or is a special implementation. None Get the default (highest priority) implementation for the given locus. If no locus-specific priority is defined, returns the global default. locus ( Iterable [ str ] ) \u2013 tuple of component names defining the locus. The default implementation name. str Set the locus-specific default implementation. default ( str ) \u2013 name of the new default implementation for locus . locus ( Iterable [ str ] ) \u2013 tuple of component names defining the locus. ValueError \u2013 if there is no implementation defined with the name default or default is a special\n    implementation. None previous iqm.pulse.quantum_ops.validate_op_calibration next scheduler \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "PRX_HdDragSX",
    "url": "/iqm-pulse/api/iqm.pulse.gates.prx.PRX_HdDragSX.html",
    "description": "Bases: PRX_CustomWaveformsSX PRX gate, HD DRAG IQ pulse with VZ-based SX-implementation. See PRX_CustomWaveformsSX . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel ...",
    "content": "Bases: PRX_CustomWaveformsSX PRX gate, HD DRAG IQ pulse with VZ-based SX-implementation. See PRX_CustomWaveformsSX . Module: iqm.pulse.gates.prx Attributes dependent_waves If set True , the Q channel waveform is considered to depend on the I channel's waveform so that they share the waveform parameters, (e.g. a DRAG PRX implementation). parameters Required calibration data, may be nested Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 If set True , the Q channel waveform is considered to depend on the I channel\u2019s waveform\nso that they share the waveform parameters, (e.g. a DRAG PRX implementation). If not provided,\nwill be initialised as True . Required calibration data, may be nested alias of HdDragI alias of HdDragQ previous PRX_HdDrag next PRX_ModulatedCustomWaveForms \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "iqm.pulse.validation.validate_channel",
    "url": "/iqm-pulse/api/iqm.pulse.validation.validate_channel.html",
    "description": "Validate a single channel. channel_description ( ChannelDescription ) \u2013 device_constraints ( ChannelProperties ) \u2013 None previous iqm.pulse.validation.validate_awg_and_schedule_compatibility next iqm.p...",
    "content": "Validate a single channel. channel_description ( ChannelDescription ) \u2013 device_constraints ( ChannelProperties ) \u2013 None previous iqm.pulse.validation.validate_awg_and_schedule_compatibility next iqm.pulse.validation.validate_instruction_and_wf_length \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "CCPRX_Composite",
    "url": "/iqm-pulse/api/iqm.pulse.gates.conditional.CCPRX_Composite.html",
    "description": "Bases: CompositeGate Classically controlled PRX gate. Applies a PRX gate conditioned on a discriminated readout result obtained in the same segment (active feedback).\nApplies a PRX gate if the result ...",
    "content": "Bases: CompositeGate Classically controlled PRX gate. Applies a PRX gate conditioned on a discriminated readout result obtained in the same segment (active feedback).\nApplies a PRX gate if the result is 1, and a Wait of equal duration if the result is 0.\nUses the default implementation of PRX underneath, so no extra calibration is needed. Module: iqm.pulse.gates.conditional Attributes parameters control_delays contains the times it takes for the classical control signal from each probe line (readout instrument) to become usable for the drive AWG implementing the PRX gate. Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 control_delays contains the times it takes for the classical control signal from each\nprobe line (readout instrument) to become usable for the drive AWG implementing the PRX gate.\nThe delays must be in the same order as the probe lines are listed in\nthe {drive_controller}.awg.feedback_sources station setting. Two TimeBoxes that together implement the classically controlled PRX gate. The first Timebox is for the control signal delay, and the second has a ConditionalInstruction.\nThe delay TimeBox operates only on a virtual channel and is used to block the pulse TimeBox\nuntil there has been enough time for the control signal to arrive.\nThe delay is specified by the control_delays gate parameter. In normal operation, the boxes can be placed sequentially without causing unnecessary delays.\nTo care of the timing yourself, simply ignore the first TimeBox. angle ( float ) \u2013 The PRX rotation angle (rad). phase ( float ) \u2013 The PRX rotation phase (rad). feedback_qubit ( str ) \u2013 The qubit that was measured to create the feedback bit. feedback_key ( str ) \u2013 Identifies the feedback signal if feedback_qubit was measured multiple times.\nThe feedback label is then f\"{feedback_qubit}__{feedback_key}\" .\nTODO: currently the HW does not support multiple feedback keys per drive channel, so this argument has\nno effect. The conditional prx will always listen feedback from the label f\"{feedback_qubit}__{FEEDBACK_KEY}\" . When the HW is improved, the actual key the user inputs\nshould be used. A TimeBox for the signal delay, and a TimeBox with a ConditionalInstruction inside. list [ TimeBox ] previous conditional next CCPRX_Composite_DRAGCosineRiseFall \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "TimeTrace",
    "url": "/iqm-pulse/api/iqm.pulse.playlist.instructions.TimeTrace.html",
    "description": "Bases: AcquisitionMethod Capture the raw IQ signal without integration. Module: iqm.pulse.playlist.instructions Attributes duration_samples Length of the capture window, in samples. label Identifier f...",
    "content": "Bases: AcquisitionMethod Capture the raw IQ signal without integration. Module: iqm.pulse.playlist.instructions Attributes duration_samples Length of the capture window, in samples. label Identifier for the returned data, like QB1__readout.time_trace . delay_samples Delay from beginning of probe pulse to beginning of acquisition window, in samples. Methods label ( str ) \u2013 delay_samples ( int ) \u2013 duration_samples ( int ) \u2013 Length of the capture window, in samples. previous ThresholdStateDiscrimination next VirtualRZ \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-pulse",
    "title": "CCPRX_Composite_DRAGCosineRiseFall",
    "url": "/iqm-pulse/api/iqm.pulse.gates.conditional.CCPRX_Composite_DRAGCosineRiseFall.html",
    "description": "Bases: CCPRX_Composite Conditional drag_crf pulse. Module: iqm.pulse.gates.conditional Attributes default_implementations Mapping from operation names to the designated default implementation of that ...",
    "content": "Bases: CCPRX_Composite Conditional drag_crf pulse. Module: iqm.pulse.gates.conditional Attributes default_implementations Mapping from operation names to the designated default implementation of that operation. Methods parent ( QuantumOp ) \u2013 name ( str ) \u2013 locus ( Locus ) \u2013 calibration_data ( OILCalibrationData ) \u2013 builder ( ScheduleBuilder ) \u2013 Mapping from operation names to the designated default implementation of that operation. Filling this attribute\nallows one to define a different default implementation from the common default in self.builder.op_table to\nbe used in he context of this composite gate. If an operation is not found in this dict as a key, this\nCompositeGate will use the common default as the default implementation for it. previous CCPRX_Composite next CCPRX_Composite_DRAGGaussian \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.18.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "API Reference",
    "url": "/iqm-station-control-client/API.html",
    "description": "iqm.station_control.client Station control client implementation. iqm.station_control.interface Station control interface. previous API documentation: station-control-client next client \u00a9 Copyright 20...",
    "content": "iqm.station_control.client Station control client implementation. iqm.station_control.interface Station control interface. previous API documentation: station-control-client next client \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "API documentation: station-control-client",
    "url": "/iqm-station-control-client/index.html",
    "description": "9.4.0 2025-07-07 This is the documentation of the IQM station-control client library. Index Module Index Search Page next API Reference \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updat...",
    "content": "9.4.0 2025-07-07 This is the documentation of the IQM station-control client library. Index Module Index Search Page next API Reference \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.utils.init_station_control",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.utils.init_station_control.html",
    "description": "Initialize a new station control instance connected to the given remote. Client implementation is selected automatically based on the remote station: if the remote station\nis running the IQM Server so...",
    "content": "Initialize a new station control instance connected to the given remote. Client implementation is selected automatically based on the remote station: if the remote station\nis running the IQM Server software stack, then the IQM Server client implementation (with a limited\nfeature set) is chosen. If the remote station is running the SC software stack, then the Station\nControl client implementation (with the full feature set) is chosen. root_url ( str ) \u2013 Remote station control service URL. For IQM Server remotes, this is the \u201cQuantum Computer URL\u201d\nvalue from the web dashboard. get_token_callback ( Callable [ [ ] , str ] | None ) \u2013 A callback function that returns a token (str) which will be passed in Authorization\nheader in all requests. StationControlInterface previous iqm.station_control.client.utils.get_progress_bar_callback next interface \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "ObservationSetBase",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.observation_set.ObservationSetBase.html",
    "description": "Bases: PydanticBase Abstract base class of the observation set definition and data. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_...",
    "content": "Bases: PydanticBase Abstract base class of the observation set definition and data. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.observation_set Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. observation_set_type Indicates the type (i.e. purpose) of the observation set. observation_ids Database IDs of the observations belonging to the observation set. describes_id Unique identifier of the observation set this observation set describes. invalid Flag indicating if the object is invalid. Methods observation_set_type ( Literal [ 'calibration-set' , 'characterization-set' , 'generic-set' , 'quality-metric-set' ] ) \u2013 observation_ids ( list [ int ] ) \u2013 describes_id ( UUID | None ) \u2013 invalid ( bool ) \u2013 Indicates the type (i.e. purpose) of the observation set. Database IDs of the observations belonging to the observation set. Unique identifier of the observation set this observation set describes. Flag indicating if the object is invalid. Automated systems must not use invalid objects. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous observation_set next ObservationSetData \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "RunData",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.run.RunData.html",
    "description": "Bases: RunWithTimestamps , RunConfigurationBase The content of the run and its configuration stored in the database. Module: iqm.station_control.interface.models.run Attributes sweep_data The content ...",
    "content": "Bases: RunWithTimestamps , RunConfigurationBase The content of the run and its configuration stored in the database. Module: iqm.station_control.interface.models.run Attributes sweep_data The content of the associated sweep stored in the database. created_timestamp Time when the object was created in the database. modified_timestamp Time when the object was last modified in the database. begin_timestamp Time when the run began in the station control. end_timestamp Time when the run ended in the station control. run_id Unique identifier of the run. username User who defined the run. experiment_name Identifier of the Experiment ( Experiment.name ). experiment_label Freeform label of the Experiment. options Experiment-specific options or toggles that generated the run. software_version_set_id Unique identifier of the software version set of the current Python runtime. additional_run_properties A free-form dictionary of data, used to store information that does not fall into other categories. hard_sweeps Maps SweepBase.return_parameters to \"hardware sweep specification\" which specifies how the data measured at each spot should be interpreted and shaped. components Components that participate in this run. default_data_parameters The subset of SweepBase.return_parameters that were added by default, not by the user. default_sweep_parameters The subset of SweepBase.sweeps parameters were added by default, not by the user. Methods additional_run_properties ( dict [ str , Any ] | None ) \u2013 hard_sweeps ( dict [ str , list [ tuple [ Sweep , ... ] ] ] | None ) \u2013 components ( list [ str ] ) \u2013 default_data_parameters ( list [ str ] ) \u2013 default_sweep_parameters ( list [ str ] ) \u2013 run_id ( UUID ) \u2013 username ( str ) \u2013 experiment_name ( str ) \u2013 experiment_label ( str ) \u2013 options ( dict [ str , Any ] | None ) \u2013 software_version_set_id ( int | None ) \u2013 created_timestamp ( datetime ) \u2013 modified_timestamp ( datetime ) \u2013 begin_timestamp ( datetime ) \u2013 end_timestamp ( datetime | None ) \u2013 sweep_data ( SweepData ) \u2013 The content of the associated sweep stored in the database. previous RunConfigurationBase next RunDefinition \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.serializers.playlist_serializers.unpack_playlist",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.playlist_serializers.unpack_playlist.html",
    "description": "Unpack a protobuf representation of a playlist into its runtime representation. proto_playlist ( Playlist ) \u2013 serialized playlist proto_playlist in runtime representation Playlist previous iqm.station...",
    "content": "Unpack a protobuf representation of a playlist into its runtime representation. proto_playlist ( Playlist ) \u2013 serialized playlist proto_playlist in runtime representation Playlist previous iqm.station_control.client.serializers.playlist_serializers.pack_playlist next run_serializers \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "JobResult",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.jobs.JobResult.html",
    "description": "Bases: PydanticBase Progress information about a running job. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] ...",
    "content": "Bases: PydanticBase Progress information about a running job. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.jobs Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. job_id  parallel_sweep_progress  interrupted  Methods job_id ( UUID ) \u2013 parallel_sweep_progress ( list [ tuple [ str , int , int ] ] ) \u2013 interrupted ( bool ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous JobExecutorStatus next TimelineEntry \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.serializers.run_serializers.deserialize_run_data",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.run_serializers.deserialize_run_data.html",
    "description": "Convert a JSON serializable dictionary to RunData object. data ( dict ) \u2013 RunData previous run_serializers next iqm.station_control.client.serializers.run_serializers.deserialize_run_definition \u00a9 Copy...",
    "content": "Convert a JSON serializable dictionary to RunData object. data ( dict ) \u2013 RunData previous run_serializers next iqm.station_control.client.serializers.run_serializers.deserialize_run_definition \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "QuantumComputersServicer",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.qc_pb2_grpc.QuantumComputersServicer.html",
    "description": "Bases: object Quantum Computer management APIs. Module: iqm.station_control.client.iqm_server.proto.qc_pb2_grpc Methods GetQuantumComputerResourceV1  GetQuantumComputerV1 Returns the details for the r...",
    "content": "Bases: object Quantum Computer management APIs. Module: iqm.station_control.client.iqm_server.proto.qc_pb2_grpc Methods GetQuantumComputerResourceV1  GetQuantumComputerV1 Returns the details for the requested quantum computer. ListQuantumComputersV1 Returns a list of quantum computers matching the given filters. Returns the details for the requested quantum computer. The quantum computer\ncan be queried by its id or alias. If the given lookup does not match any\nexisting quantum computer, the RPC call returns an error with a GRPC status NOT_FOUND . Returns a list of quantum computers matching the given filters. Returns the contents of a given resource by name and QC id (e.g. chip design record, static architecture, etc).\nSee the full list of available resources at app/backend/lib/iqm-core-client/src/station_control_http_client/resources.rs .\nEach resource is an opaque binary blob, the interpretation of which is up to the client. previous QuantumComputers next QuantumComputersStub \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "TimelineEntry",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.jobs.TimelineEntry.html",
    "description": "Bases: PydanticBase Status and timestamp pair as described in a job timeline. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.V...",
    "content": "Bases: PydanticBase Status and timestamp pair as described in a job timeline. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.jobs Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. status  timestamp  Methods status ( JobExecutorStatus ) \u2013 timestamp ( datetime ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous JobResult next monitor \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "common_pb2_grpc",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.common_pb2_grpc.html",
    "description": "Client and server classes corresponding to protobuf-defined services. Full path: iqm.station_control.client.iqm_server.proto.common_pb2_grpc previous common_pb2 next job_pb2 \u00a9 Copyright 2019-2025, IQM...",
    "content": "Client and server classes corresponding to protobuf-defined services. Full path: iqm.station_control.client.iqm_server.proto.common_pb2_grpc previous common_pb2 next job_pb2 \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.utils.get_progress_bar_callback",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.utils.get_progress_bar_callback.html",
    "description": "Returns a callback function that creates or updates existing progressbars when called. Callable [[ list [ tuple [ str , int , int ]]], None ] previous utils next iqm.station_control.client.utils.init_...",
    "content": "Returns a callback function that creates or updates existing progressbars when called. Callable [[ list [ tuple [ str , int , int ]]], None ] previous utils next iqm.station_control.client.utils.init_station_control \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "ObservationSetWithObservations",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.observation_set.ObservationSetWithObservations.html",
    "description": "Bases: ObservationSetData The content of the observation set stored in the database, with a list of observations. Create a new model by parsing and validating input data from keyword arguments. Raises...",
    "content": "Bases: ObservationSetData The content of the observation set stored in the database, with a list of observations. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.observation_set Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. observations Observations belonging to the observation set. dut_label String representation of the DUT the observation set is associated with. observation_set_id Unique identifier of the observation set. created_timestamp Time when the object was created in the database. end_timestamp Time when the observation set was finalized. observation_set_type Indicates the type (i.e. purpose) of the observation set. observation_ids Database IDs of the observations belonging to the observation set. describes_id Unique identifier of the observation set this observation set describes. invalid Flag indicating if the object is invalid. Methods observation_set_type ( Literal [ 'calibration-set' , 'characterization-set' , 'generic-set' , 'quality-metric-set' ] ) \u2013 observation_ids ( list [ int ] ) \u2013 describes_id ( UUID | None ) \u2013 invalid ( bool ) \u2013 dut_label ( str | None ) \u2013 observation_set_id ( UUID ) \u2013 created_timestamp ( datetime ) \u2013 end_timestamp ( datetime | None ) \u2013 observations ( list [ ObservationLite ] ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Observations belonging to the observation set. previous ObservationSetUpdate next QualityMetrics \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "RunBase",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.run.RunBase.html",
    "description": "Bases: object Abstract base class of run data. Module: iqm.station_control.interface.models.run Attributes run_id Unique identifier of the run. username User who defined the run. experiment_name Ident...",
    "content": "Bases: object Abstract base class of run data. Module: iqm.station_control.interface.models.run Attributes run_id Unique identifier of the run. username User who defined the run. experiment_name Identifier of the Experiment ( Experiment.name ). experiment_label Freeform label of the Experiment. options Experiment-specific options or toggles that generated the run. software_version_set_id Unique identifier of the software version set of the current Python runtime. Methods run_id ( UUID ) \u2013 username ( str ) \u2013 experiment_name ( str ) \u2013 experiment_label ( str ) \u2013 options ( dict [ str , Any ] | None ) \u2013 software_version_set_id ( int | None ) \u2013 Unique identifier of the run. User who defined the run. Identifier of the Experiment ( Experiment.name ). Freeform label of the Experiment. As opposed to experiment_name , no core logic relies on this value. Experiment-specific options or toggles that generated the run. Unique identifier of the software version set of the current Python runtime. previous run next RunConfigurationBase \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "QuantumComputers",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.qc_pb2_grpc.QuantumComputers.html",
    "description": "Bases: object Quantum Computer management APIs. Module: iqm.station_control.client.iqm_server.proto.qc_pb2_grpc Methods GetQuantumComputerResourceV1  GetQuantumComputerV1  ListQuantumComputersV1  prev...",
    "content": "Bases: object Quantum Computer management APIs. Module: iqm.station_control.client.iqm_server.proto.qc_pb2_grpc Methods GetQuantumComputerResourceV1  GetQuantumComputerV1  ListQuantumComputersV1  previous iqm.station_control.client.iqm_server.proto.qc_pb2_grpc.add_QuantumComputersServicer_to_server next QuantumComputersServicer \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "models",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.html",
    "description": "Station control interface models. Full path: iqm.station_control.interface.models Subpackages and modules dut DUT related interface models. dynamic_quantum_architecture Dynamic quantum architecture (D...",
    "content": "Station control interface models. Full path: iqm.station_control.interface.models Subpackages and modules dut DUT related interface models. dynamic_quantum_architecture Dynamic quantum architecture (DQA) related interface models. jobs Job executor artifact and state models. monitor job executor artifact and state models. observation Observation related station control interface models. observation_set Observation set related station control interface models. run Run related station control interface models. sequence Sequence related station control interface models. static_quantum_architecture Static quantum architecture (SQA) related interface models. sweep Sweep related station control interface models. type_aliases Type hint aliases used in the station control interface. previous Meta next dut \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "ObservationData",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.observation.ObservationData.html",
    "description": "Bases: ObservationLite , ObservationDefinition The content of the observation stored in the database. Create a new model by parsing and validating input data from keyword arguments. Raises [ Validatio...",
    "content": "Bases: ObservationLite , ObservationDefinition The content of the observation stored in the database. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.observation Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. observation_set_ids List of observation set UUIDs this observation belongs to. observation_id Unique identifier of the observation. created_timestamp Time when the object was created in the database. modified_timestamp Time when the object was last modified in the database. dut_label DUT label of the device the observation is about. source How the observation was made, e.g. experiment analysis or manual specification. tags Human-readable tags of the observation. dut_field Name of the property the observation is about. value Value of the observation. unit SI unit of the value. uncertainty Uncertainty of the observation value. invalid Flag indicating if the object is invalid. Methods dut_field ( str ) \u2013 value ( bool | str | int | float | complex | ndarray ) \u2013 unit ( str ) \u2013 uncertainty ( int | float | complex | ndarray | None ) \u2013 invalid ( bool ) \u2013 dut_label ( str ) \u2013 source ( dict [ str , Any ] ) \u2013 tags ( list [ str ] ) \u2013 observation_id ( int ) \u2013 created_timestamp ( datetime ) \u2013 modified_timestamp ( datetime ) \u2013 observation_set_ids ( list [ UUID ] ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. List of observation set UUIDs this observation belongs to. previous ObservationBase next ObservationDefinition \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "StationControlInterface",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.station_control.StationControlInterface.html",
    "description": "Bases: ABC Station control interface. Station control interface implementation should implement generic query methods for certain objects,\nlike query_observations() , query_observation_sets() , and qu...",
    "content": "Bases: ABC Station control interface. Station control interface implementation should implement generic query methods for certain objects,\nlike query_observations() , query_observation_sets() , and query_sequence_metadatas() .\nThese methods accept only keyword arguments as parameters, which are based on the syntax field__lookup=value .\nNote double-underscore in the name, to separate field names like dut_field from lookup types like in .\nThe syntax is based on Django implementation, documented here and here . As a convenience, when no lookup type is provided (like in dut_label=\"foo\" ),\nthe lookup type is assumed to be exact ( dut_label__exact=\"foo\" ). Other supported lookup types are: For example, created_timestamp__range=(datetime(2023, 10, 12), datetime(2024, 10, 14)) For example, dut_field__in=[\"QB1.frequency\", \"gates.measure.constant.QB2.frequency\"] For example, origin_uri__icontains=\"local\" For example, tags__overlap=[\"calibration=good\", \"2023-12-04\"] For example, tags__contains=[\"calibration=good\", \"2023-12-04\"] For example, end_timestamp__isnull=False In addition to model fields (like \u201cdut_label\u201d, \u201cdut_field\u201d, \u201ccreated_timestamp\u201d, \u201cinvalid\u201d, etc.),\nall of our generic query methods accept also following shared query parameters: For example, latest=\"invalid\" would return only one result (latest \u201ccreated_timestamp\u201d)\nfor each different \u201cinvalid\u201d value in the database. Thus, maximum three results would be returned,\none for each invalid value of True , False , and None . order_by: str. Prefix with \u201c-\u201d for descending order, for example \u201c-created_timestamp\u201d. limit: int: Default 20. If 0 (or negative number) is given, then pagination is not used, i.e. limit=infinity. offset: int. Default 0. Our generic query methods are not fully generalized yet, thus not all fields and lookup types are supported.\nCheck query methods own documentation for details about currently supported query parameters. Generic query methods will return a list of objects, but with additional (optional) \u201cmeta\u201d attribute,\nwhich contains metadata, like pagination details. The client can ignore this data,\nor use it to implement pagination logic for example to fetch all results available. Module: iqm.station_control.interface.station_control Methods abort_job Either remove a job from the queue, or abort it gracefully if it's already executing. create_observation_set Create an observation set in the database. create_observations Create observations in the database. create_sequence_metadata Create sequence metadata in the database. delete_sweep Delete sweep in the database. finalize_observation_set Finalize an observation set in the database. get_about Return information about the station control. get_calibration_set_quality_metrics Get the latest quality metrics for the given calibration set ID. get_channel_properties Get channel properties from the station. get_chip_design_record Get a raw chip design record matching the given chip label. get_configuration Return the configuration of the station control. get_default_calibration_set Get default calibration set from the database. get_default_calibration_set_observations Get default calibration set observations from the database. get_default_calibration_set_quality_metrics Get the latest quality metrics for the current default calibration set. get_default_dynamic_quantum_architecture Get dynamic quantum architecture for the default calibration set. get_dut_fields Get DUT fields for the specified DUT label from the database. get_duts Get DUTs of the station control. get_dynamic_quantum_architecture Get dynamic quantum architecture for the given calibration set ID. get_exa_configuration Return the recommended EXA configuration from the server. get_health Return the status of the station control service. get_job Get job data. get_observation_set Get an observation set from the database. get_observation_set_observations Get the constituent observations of an observation set from the database. get_observations Get observations from the database. get_or_create_software_version_set Get software version set ID from the database, or create one if it doesn't exist. get_run Get run data from the database. get_sequence_result Get sequence result from the database. get_settings Return a tree representation of the default settings as defined in the configuration file. get_static_quantum_architecture Get static quantum architecture of the station for the given DUT label. get_sweep Get N-dimensional sweep data from the database. get_sweep_results Get N-dimensional sweep results from the database. query_observation_sets Query observation sets from the database. query_observations Query observations from the database. query_runs Query runs from the database. query_sequence_metadatas Query sequence metadatas from the database. run Execute an N-dimensional sweep of selected variables and save run, sweep and results. save_sequence_result Save sequence result in the database. sweep Execute an N-dimensional sweep of selected variables and save sweep and results. update_observation_set Update an observation set in the database. update_observations Update observations in the database. Return information about the station control. dict Return the status of the station control service. dict Return the configuration of the station control. dict Return the recommended EXA configuration from the server. str Get software version set ID from the database, or create one if it doesn\u2019t exist. software_version_set ( dict [ str , str ] ) \u2013 int Return a tree representation of the default settings as defined in the configuration file. SettingNode Get a raw chip design record matching the given chip label. dut_label ( str ) \u2013 dict Get channel properties from the station. Channel properties contain information regarding hardware limitations e.g. sampling rate, granularity\nand supported instructions. Mapping from channel name to AWGProperties or ReadoutProperties. dict [ str , ChannelProperties ] Execute an N-dimensional sweep of selected variables and save sweep and results. The raw data for each spot in the sweep is saved as numpy arrays,\nand the complete data for the whole sweep is saved as an x-array dataset\nwhich has the sweep_definition.sweeps as coordinates and\ndata of sweep_definition.return_parameters data as DataArrays. The values of sweep_definition.playlist will be uploaded to the controllers given by the keys of sweep_definition.playlist . sweep_definition ( SweepDefinition ) \u2013 The content of the sweep to be created. Dict containing the task ID  and sweep ID, and corresponding hrefs, of a successful sweep execution\nin monolithic mode or successful submission to the task queue in remote mode. ExaError if submitting a sweep failed. \u2013 dict Get N-dimensional sweep data from the database. sweep_id ( UUID ) \u2013 SweepData Delete sweep in the database. sweep_id ( UUID ) \u2013 None Get N-dimensional sweep results from the database. sweep_id ( UUID ) \u2013 dict [ str , list [ ndarray ]] Execute an N-dimensional sweep of selected variables and save run, sweep and results. run_definition ( RunDefinition ) \u2013 update_progress_callback ( Callable [ [ list [ tuple [ str , int , int ] ] ] , None ] | None ) \u2013 wait_job_completion ( bool ) \u2013 bool Get run data from the database. run_id ( UUID ) \u2013 RunData Query runs from the database. run_id: uuid.UUID run_id__in: list[uuid.UUID] sweep_id: uuid.UUID sweep_id__in: list[uuid.UUID] username: str username__in: list[str] username__contains: str username__icontains: str experiment_label: str experiment_label__in: list[str] experiment_label__contains: str experiment_label__icontains: str experiment_name: str experiment_name__in: list[str] experiment_name__contains: str experiment_name__icontains: str software_version_set_id: int software_version_set_id__in: list[int] begin_timestamp__range: tuple[datetime, datetime] end_timestamp__range: tuple[datetime, datetime] end_timestamp__isnull: bool Queried runs with some query related metadata. ListWithMeta [ RunLite ] Create observations in the database. observation_definitions ( Sequence [ ObservationDefinition ] ) \u2013 A sequence of observation definitions,\neach containing the content of the observation which will be created. Created observations, each including also the database created fields like ID and timestamps. ListWithMeta [ ObservationData ] Get observations from the database. Observations are queried by the given query parameters. mode ( Literal [ 'all_latest' , 'tags_and' , 'tags_or' , 'sequence' ] ) \u2013 The \u201cmode\u201d used to query the observations. Possible values \u201call_latest\u201d, \u201ctags_and\u201d, or \u201ctags_or\u201d. \u201dall_latest\u201d:Query all the latest observations for the given dut_label .\nNo other query parameters are accepted. \u201dtags_and\u201d: Query observations. Query all the observations that have all the given tags .\nBy default, only valid observations are included.\nAll other query parameters can be used to narrow down the query,\nexpect \u201crun_ids\u201d and \u201csequence_ids\u201d. \u201dtags_or\u201d: Query all the latest observations that have at least one of the given tags .\nAdditionally, dut_label must be given. No other query parameters are used. \u201dsequence\u201d: Query observations originating from a list of run and/or sequence IDs.\nNo other query parameters are accepted. The \u201cmode\u201d used to query the observations. Possible values \u201call_latest\u201d, \u201ctags_and\u201d, or \u201ctags_or\u201d. \u201dall_latest\u201d:Query all the latest observations for the given dut_label .\nNo other query parameters are accepted. \u201dtags_and\u201d: Query observations. Query all the observations that have all the given tags .\nBy default, only valid observations are included.\nAll other query parameters can be used to narrow down the query,\nexpect \u201crun_ids\u201d and \u201csequence_ids\u201d. \u201dtags_or\u201d: Query all the latest observations that have at least one of the given tags .\nAdditionally, dut_label must be given. No other query parameters are used. \u201dsequence\u201d: Query observations originating from a list of run and/or sequence IDs.\nNo other query parameters are accepted. dut_label ( str | None ) \u2013 DUT label of the device the observations pertain to. dut_field ( str | None ) \u2013 Name of the property the observation is about. tags ( list [ str ] | None ) \u2013 Human-readable tags of the observation. invalid ( bool | None ) \u2013 Flag indicating if the object is invalid. Automated systems must not use invalid objects.\nIf None , both valid and invalid objects are included. run_ids ( list [ UUID ] | None ) \u2013 The run IDs for which to query the observations. sequence_ids ( list [ UUID ] | None ) \u2013 The sequence IDs for which to query the observations. limit ( int | None ) \u2013 Indicates the maximum number of items to return. Observations, each including also the database created fields like ID and timestamps. list [ ObservationData ] Query observations from the database. observation_id: int observation_id__in: list[int] dut_label: str dut_field: str dut_field__in: list[str] tags__overlap: list[str] tags__contains: list[str] invalid: bool source__run_id__in: list[uuid.UUID] source__sequence_id__in: list[uuid.UUID] source__type: str uncertainty__isnull: bool created_timestamp__range: tuple[datetime, datetime] observation_set_ids__overlap: list[uuid.UUID] observation_set_ids__contains: list[uuid.UUID] Queried observations with some query related metadata. ListWithMeta [ ObservationData ] Update observations in the database. observation_updates ( Sequence [ ObservationUpdate ] ) \u2013 A sequence of observation updates,\neach containing the content of the observation which will be updated. Updated observations, each including also the database created fields like ID and timestamps. list [ ObservationData ] Query observation sets from the database. observation_set_id: UUID observation_set_id__in: list[UUID] observation_set_type: Literal[\u201ccalibration-set\u201d, \u201cgeneric-set\u201d, \u201cquality-metric-set\u201d] observation_ids__overlap: list[int] observation_ids__contains: list[int] describes_id: UUID describes_id__in: list[UUID] invalid: bool created_timestamp__range: tuple[datetime, datetime] end_timestamp__isnull: bool dut_label: str dut_label__in: list[str] Queried observation sets with some query related metadata ListWithMeta [ ObservationSetData ] Create an observation set in the database. observation_set_definition ( ObservationSetDefinition ) \u2013 The content of the observation set to be created. The content of the observation set. ExaError \u2013 If creation failed. ObservationSetData Get an observation set from the database. observation_set_id ( UUID ) \u2013 Observation set to retrieve. The content of the observation set. ExaError \u2013 If retrieval failed. ObservationSetData Update an observation set in the database. observation_set_update ( ObservationSetUpdate ) \u2013 The content of the observation set to be updated. The content of the observation set. ExaError \u2013 If updating failed. ObservationSetData Finalize an observation set in the database. A finalized set is nearly immutable, allowing to change only invalid flag after finalization. observation_set_id ( UUID ) \u2013 Observation set to finalize. ExaError \u2013 If finalization failed. None Get the constituent observations of an observation set from the database. observation_set_id ( UUID ) \u2013 UUID of the observation set to retrieve. Observations belonging to the given observation set. list [ ObservationLite ] Get default calibration set from the database. ObservationSetData Get default calibration set observations from the database. list [ ObservationLite ] Get dynamic quantum architecture for the default calibration set. DynamicQuantumArchitecture Get dynamic quantum architecture for the given calibration set ID. Dynamic quantum architecture of the station for the given calibration set ID. calibration_set_id ( UUID ) \u2013 DynamicQuantumArchitecture Get the latest quality metrics for the current default calibration set. QualityMetrics Get the latest quality metrics for the given calibration set ID. calibration_set_id ( UUID ) \u2013 QualityMetrics Get DUTs of the station control. list [ DutData ] Get DUT fields for the specified DUT label from the database. dut_label ( str ) \u2013 list [ DutFieldData ] Query sequence metadatas from the database. origin_id: str origin_id__in: list[str] origin_uri: str origin_uri__icontains: str created_timestamp__range: tuple[datetime, datetime] Sequence metadatas with some query related metadata. ListWithMeta [ SequenceMetadataData ] Create sequence metadata in the database. sequence_metadata_definition ( SequenceMetadataDefinition ) \u2013 SequenceMetadataData Save sequence result in the database. This method creates the object if it doesn\u2019t exist and completely replaces the \u201cdata\u201d and \u201cfinal\u201d if it does.\nTimestamps are assigned by the database. \u201cmodified_timestamp\u201d is not set on initial creation,\nbut it\u2019s updated on each subsequent call. sequence_result_definition ( SequenceResultDefinition ) \u2013 SequenceResultData Get sequence result from the database. sequence_id ( UUID ) \u2013 SequenceResultData Get static quantum architecture of the station for the given DUT label. Static quantum architecture of the station for the given DUT label. dut_label ( str ) \u2013 StaticQuantumArchitecture Get job data. job_id ( UUID ) \u2013 JobData Either remove a job from the queue, or abort it gracefully if it\u2019s already executing. The status of the job will be set to JobStatus.ABORTED .\nIf the job is not found or is already finished nothing happens. job_id ( UUID ) \u2013 None previous station_control next Changelog \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "datetime_serializers",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.datetime_serializers.html",
    "description": "Serializers and deserializers for datetime related models. Full path: iqm.station_control.client.serializers.datetime_serializers Functions deserialize_datetime (timestamp) Convert a string formatted ...",
    "content": "Serializers and deserializers for datetime related models. Full path: iqm.station_control.client.serializers.datetime_serializers Functions deserialize_datetime (timestamp) Convert a string formatted according to ISO to a datetime object. serialize_datetime (timestamp) Convert a datetime object to a string formatted according to ISO. previous iqm.station_control.client.serializers.channel_property_serializer.unpack_channel_properties next iqm.station_control.client.serializers.datetime_serializers.deserialize_datetime \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "setting_node_serializer",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.setting_node_serializer.html",
    "description": "Serializers and deserializers for setting node related models. Full path: iqm.station_control.client.serializers.setting_node_serializer Functions deserialize_setting_node (setting_node_str) Convert b...",
    "content": "Serializers and deserializers for setting node related models. Full path: iqm.station_control.client.serializers.setting_node_serializer Functions deserialize_setting_node (setting_node_str) Convert binary string into SettingNode. previous iqm.station_control.client.serializers.run_serializers.serialize_run_definition next iqm.station_control.client.serializers.setting_node_serializer.deserialize_setting_node \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.serializers.datetime_serializers.serialize_datetime",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.datetime_serializers.serialize_datetime.html",
    "description": "Convert a datetime object to a string formatted according to ISO. timestamp ( datetime | None ) \u2013 str | None previous iqm.station_control.client.serializers.datetime_serializers.deserialize_datetime n...",
    "content": "Convert a datetime object to a string formatted according to ISO. timestamp ( datetime | None ) \u2013 str | None previous iqm.station_control.client.serializers.datetime_serializers.deserialize_datetime next playlist_serializers \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "JobsInQueue",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.monitor.JobsInQueue.html",
    "description": "Bases: PydanticBase List of jobs in a particular queue, corresponding to some job state. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pyda...",
    "content": "Bases: PydanticBase List of jobs in a particular queue, corresponding to some job state. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.monitor Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. jobs  job_count  Methods jobs ( list [ JobStateTimestamp ] ) \u2013 job_count ( int ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous JobStateTimestamp next QueueState \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.serializers.task_serializers.serialize_run_job_request",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.task_serializers.serialize_run_job_request.html",
    "description": "Wrap run_definition and queue_name into a protobuf message and serialize into a bitstring. run_definition ( RunDefinition ) \u2013 The content of the run. queue_name ( str ) \u2013 Name of the destination queue...",
    "content": "Wrap run_definition and queue_name into a protobuf message and serialize into a bitstring. run_definition ( RunDefinition ) \u2013 The content of the run. queue_name ( str ) \u2013 Name of the destination queue. SweepTaskRequest encoded into a bitstring. bytes previous iqm.station_control.client.serializers.task_serializers.deserialize_sweep_job_request next iqm.station_control.client.serializers.task_serializers.serialize_sweep_job_request \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "ObservationBase",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.observation.ObservationBase.html",
    "description": "Bases: PydanticBase Abstract base class of the observation models. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationEr...",
    "content": "Bases: PydanticBase Abstract base class of the observation models. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.observation Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. dut_field Name of the property the observation is about. value Value of the observation. unit SI unit of the value. uncertainty Uncertainty of the observation value. invalid Flag indicating if the object is invalid. Methods dut_field ( str ) \u2013 value ( bool | str | int | float | complex | ndarray ) \u2013 unit ( str ) \u2013 uncertainty ( int | float | complex | ndarray | None ) \u2013 invalid ( bool ) \u2013 Name of the property the observation is about. Value of the observation. SI unit of the value. Empty string means the value is dimensionless. Uncertainty of the observation value. None means unknown. Flag indicating if the object is invalid. Automated systems must not use invalid objects. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous observation next ObservationData \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.iqm_server.iqm_server_client.wrap_error",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.iqm_server_client.wrap_error.html",
    "description": "title ( str ) \u2013 previous iqm.station_control.client.iqm_server.iqm_server_client.to_string_job_status next IqmServerClient \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07...",
    "content": "title ( str ) \u2013 previous iqm.station_control.client.iqm_server.iqm_server_client.to_string_job_status next IqmServerClient \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.serializers.task_serializers.deserialize_sweep_job_request",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.task_serializers.deserialize_sweep_job_request.html",
    "description": "Deserializes sweep_definition and queue_name from the serialized bitstring. data ( bytes ) \u2013 The serialized data class: ` ~iqm.station_control.interface.model.SweepDefinition\nand queue name (string). ...",
    "content": "Deserializes sweep_definition and queue_name from the serialized bitstring. data ( bytes ) \u2013 The serialized data class: ` ~iqm.station_control.interface.model.SweepDefinition\nand queue name (string). Deserialized tuple previous task_serializers next iqm.station_control.client.serializers.task_serializers.serialize_run_job_request \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.serializers.channel_property_serializer.serialize_channel_properties",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.channel_property_serializer.serialize_channel_properties.html",
    "description": "Pack the given dictionary of channel properties into a protobuf format for further serialization. channel_properties \u2013 channel properties to pack channel_property_dictionary ( dict [ str , ChannelProp...",
    "content": "Pack the given dictionary of channel properties into a protobuf format for further serialization. channel_properties \u2013 channel properties to pack channel_property_dictionary ( dict [ str , ChannelProperties ] ) \u2013 ChannelPropertyDictionary ChannelPropertyDictionary previous iqm.station_control.client.serializers.channel_property_serializer.deserialize_instructions next iqm.station_control.client.serializers.channel_property_serializer.unpack_channel_properties \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "SequenceResultDefinition",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.sequence.SequenceResultDefinition.html",
    "description": "Bases: SequenceResultBase The content of the sequence result object when creating it. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydanti...",
    "content": "Bases: SequenceResultBase The content of the sequence result object when creating it. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.sequence Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. sequence_id Unique identifier of the sequence result. data JSON serializable dict. final Indicates whether this result was marked as final. Methods sequence_id ( UUID ) \u2013 data ( dict [ str , Any ] ) \u2013 final ( bool ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous SequenceResultData next static_quantum_architecture \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.serializers.struct_serializer.serialize_struct",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.struct_serializer.serialize_struct.html",
    "description": "Serialize a free-form dict into a Struct protobuf representation. data ( dict ) \u2013 Struct previous iqm.station_control.client.serializers.struct_serializer.deserialize_struct next sweep_serializers \u00a9 C...",
    "content": "Serialize a free-form dict into a Struct protobuf representation. data ( dict ) \u2013 Struct previous iqm.station_control.client.serializers.struct_serializer.deserialize_struct next sweep_serializers \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_definition",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_definition.html",
    "description": "Convert SweepDefinition into sweep proto. sweep_definition ( SweepDefinition ) \u2013 SweepRequest previous iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_data next iqm.station_co...",
    "content": "Convert SweepDefinition into sweep proto. sweep_definition ( SweepDefinition ) \u2013 SweepRequest previous iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_data next iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_results \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "uuid_pb2_grpc",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.uuid_pb2_grpc.html",
    "description": "Client and server classes corresponding to protobuf-defined services. Full path: iqm.station_control.client.iqm_server.proto.uuid_pb2_grpc previous uuid_pb2 next testing \u00a9 Copyright 2019-2025, IQM Fin...",
    "content": "Client and server classes corresponding to protobuf-defined services. Full path: iqm.station_control.client.iqm_server.proto.uuid_pb2_grpc previous uuid_pb2 next testing \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_data",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_data.html",
    "description": "Convert JSON serializable dictionary into SweepData. data ( dict ) \u2013 SweepData previous sweep_serializers next iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_definition \u00a9 C...",
    "content": "Convert JSON serializable dictionary into SweepData. data ( dict ) \u2013 SweepData previous sweep_serializers next iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_definition \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "ListModel",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.list_models.ListModel.html",
    "description": "Bases: RootModel A Pydantic BaseModel for a container model of a list of objects. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_co...",
    "content": "Bases: RootModel A Pydantic BaseModel for a container model of a list of objects. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.client.list_models Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. root  Methods root ( RootModelRootType ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous DutList next ObservationDataList \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "DutFieldDataList",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.list_models.DutFieldDataList.html",
    "description": "alias of ListModel[list[DutFieldData]] previous list_models next DutList \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07....",
    "content": "alias of ListModel[list[DutFieldData]] previous list_models next DutList \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "job_pb2",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.job_pb2.html",
    "description": "Generated protocol buffer code. Full path: iqm.station_control.client.iqm_server.proto.job_pb2 previous common_pb2_grpc next job_pb2_grpc \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last upd...",
    "content": "Generated protocol buffer code. Full path: iqm.station_control.client.iqm_server.proto.job_pb2 previous common_pb2_grpc next job_pb2_grpc \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "interface",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.html",
    "description": "Station control interface. A StationControlInterface administers a set of control and measurement instruments\nattached to a quantum device, and connects to the database and related external services. ...",
    "content": "Station control interface. A StationControlInterface administers a set of control and measurement instruments\nattached to a quantum device, and connects to the database and related external services. Full path: iqm.station_control.interface Subpackages and modules list_with_meta Models to extend standard list with metadata. models Station control interface models. pydantic_base Pydantic related models and types. station_control Station control interface. previous iqm.station_control.client.utils.init_station_control next list_with_meta \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "monitor",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.monitor.html",
    "description": "job executor artifact and state models. Full path: iqm.station_control.interface.models.monitor Classes JobStateTimestamp Represents a single timestamped state for a job. JobsInQueue List of jobs in a...",
    "content": "job executor artifact and state models. Full path: iqm.station_control.interface.models.monitor Classes JobStateTimestamp Represents a single timestamped state for a job. JobsInQueue List of jobs in a particular queue, corresponding to some job state. QueueState Describes the state of a single job queue. Inheritance previous TimelineEntry next JobStateTimestamp \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.iqm_server.proto.qc_pb2_grpc.add_QuantumComputersServicer_to_server",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.qc_pb2_grpc.add_QuantumComputersServicer_to_server.html",
    "description": "previous qc_pb2_grpc next QuantumComputers \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07....",
    "content": "previous qc_pb2_grpc next QuantumComputers \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "sequence",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.sequence.html",
    "description": "Sequence related station control interface models. Full path: iqm.station_control.interface.models.sequence Classes SequenceMetadataBase Abstract base class of the sequence metadata definition and dat...",
    "content": "Sequence related station control interface models. Full path: iqm.station_control.interface.models.sequence Classes SequenceMetadataBase Abstract base class of the sequence metadata definition and data. SequenceMetadataData The content of the sequence metadata stored in the database. SequenceMetadataDefinition The content of the sequence metadata object when creating it. SequenceResultBase Abstract base class of the sequence result definition and data. SequenceResultData The content of the sequence result stored in the database. SequenceResultDefinition The content of the sequence result object when creating it. Inheritance previous RunWithTimestamps next SequenceMetadataBase \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.serializers.run_serializers.serialize_run_data",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.run_serializers.serialize_run_data.html",
    "description": "Convert RunData object to a JSON serializable dictionary. run_data ( RunData ) \u2013 dict previous iqm.station_control.client.serializers.run_serializers.deserialize_run_definition next iqm.station_contro...",
    "content": "Convert RunData object to a JSON serializable dictionary. run_data ( RunData ) \u2013 dict previous iqm.station_control.client.serializers.run_serializers.deserialize_run_definition next iqm.station_control.client.serializers.run_serializers.serialize_run_definition \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "ObservationLite",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.observation.ObservationLite.html",
    "description": "Bases: ObservationBase The lightweight version of the observation data. This model can be used when not all observation data is needed, to speed up retrieval. Create a new model by parsing and validat...",
    "content": "Bases: ObservationBase The lightweight version of the observation data. This model can be used when not all observation data is needed, to speed up retrieval. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.observation Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. observation_id Unique identifier of the observation. created_timestamp Time when the object was created in the database. modified_timestamp Time when the object was last modified in the database. dut_field Name of the property the observation is about. value Value of the observation. unit SI unit of the value. uncertainty Uncertainty of the observation value. invalid Flag indicating if the object is invalid. Methods dut_field ( str ) \u2013 value ( bool | str | int | float | complex | ndarray ) \u2013 unit ( str ) \u2013 uncertainty ( int | float | complex | ndarray | None ) \u2013 invalid ( bool ) \u2013 observation_id ( int ) \u2013 created_timestamp ( datetime ) \u2013 modified_timestamp ( datetime ) \u2013 Unique identifier of the observation. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Time when the object was created in the database. Time when the object was last modified in the database. previous ObservationDefinition next ObservationUpdate \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "serializers",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.html",
    "description": "Module for station control client serialization and deserialization. Full path: iqm.station_control.client.serializers Subpackages and modules channel_property_serializer Serializers and deserializers...",
    "content": "Module for station control client serialization and deserialization. Full path: iqm.station_control.client.serializers Subpackages and modules channel_property_serializer Serializers and deserializers for ChannelProperties datetime_serializers Serializers and deserializers for datetime related models. playlist_serializers Serializers and deserializers for Playlist run_serializers Serializers and deserializers for run related models. setting_node_serializer Serializers and deserializers for setting node related models. struct_serializer Serializers and deserializers for struct related models. sweep_serializers Serializers and deserializers for sweep related models. task_serializers Serializers and deserializers for task related models. previous SequenceMetadataDataList next channel_property_serializer \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "sweep",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.sweep.html",
    "description": "Sweep related station control interface models. Full path: iqm.station_control.interface.models.sweep Classes SweepBase Abstract base class of the sweep definition and data. SweepData The content of t...",
    "content": "Sweep related station control interface models. Full path: iqm.station_control.interface.models.sweep Classes SweepBase Abstract base class of the sweep definition and data. SweepData The content of the sweep stored in the database. SweepDefinition The content of the sweep object when creating it. Inheritance previous StaticQuantumArchitecture next SweepBase \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.serializers.setting_node_serializer.deserialize_setting_node",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.setting_node_serializer.deserialize_setting_node.html",
    "description": "Convert binary string into SettingNode. setting_node_str ( bytes ) \u2013 SettingNode previous setting_node_serializer next struct_serializer \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last upda...",
    "content": "Convert binary string into SettingNode. setting_node_str ( bytes ) \u2013 SettingNode previous setting_node_serializer next struct_serializer \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "DutData",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.dut.DutData.html",
    "description": "Bases: PydanticBase Represents a Device Under Test, or DUT, for short. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.Validati...",
    "content": "Bases: PydanticBase Represents a Device Under Test, or DUT, for short. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.dut Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. label DUT label of the device. dut_type String indicating the DUT type of the device Can be either 'chip' or 'twpa'. Methods label ( str ) \u2013 dut_type ( Literal [ 'chip' , 'twpa' ] ) \u2013 DUT label of the device. String indicating the DUT type of the device\nCan be either \u2018chip\u2019 or \u2018twpa\u2019. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous dut next DutFieldData \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "client",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.html",
    "description": "Station control client implementation. Full path: iqm.station_control.client Subpackages and modules iqm_server StationControlClient implementation for IQM Server list_models Station control client li...",
    "content": "Station control client implementation. Full path: iqm.station_control.client Subpackages and modules iqm_server StationControlClient implementation for IQM Server list_models Station control client list types for different models. serializers Module for station control client serialization and deserialization. station_control Client implementation for station control service REST API. utils Utility functions for IQM Station Control Client. previous API Reference next iqm_server \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "grpc_utils",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.grpc_utils.html",
    "description": "Internal utility functions used by IqmServerClient. Full path: iqm.station_control.client.iqm_server.grpc_utils Functions create_channel (connection_params[,\u00a0...])  extract_error (error[,\u00a0title])  fro...",
    "content": "Internal utility functions used by IqmServerClient. Full path: iqm.station_control.client.iqm_server.grpc_utils Functions create_channel (connection_params[,\u00a0...])  extract_error (error[,\u00a0title])  from_proto_uuid (value)  load_all (chunks)  parse_connection_params (qc_url)  to_datetime (timestamp)  to_proto_uuid (value)  Classes ApiTokenAuth  ClientCallDetails  ConnectionParameters  Inheritance previous iqm.station_control.client.iqm_server.error.IqmServerError next iqm.station_control.client.iqm_server.grpc_utils.create_channel \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc.add_CalibrationsServicer_to_server",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc.add_CalibrationsServicer_to_server.html",
    "description": "previous calibration_pb2_grpc next Calibrations \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07....",
    "content": "previous calibration_pb2_grpc next Calibrations \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "qc_pb2_grpc",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.qc_pb2_grpc.html",
    "description": "Client and server classes corresponding to protobuf-defined services. Full path: iqm.station_control.client.iqm_server.proto.qc_pb2_grpc Functions add_QuantumComputersServicer_to_server (...)  Classes...",
    "content": "Client and server classes corresponding to protobuf-defined services. Full path: iqm.station_control.client.iqm_server.proto.qc_pb2_grpc Functions add_QuantumComputersServicer_to_server (...)  Classes QuantumComputers Quantum Computer management APIs. QuantumComputersServicer Quantum Computer management APIs. QuantumComputersStub Quantum Computer management APIs. Inheritance previous qc_pb2 next iqm.station_control.client.iqm_server.proto.qc_pb2_grpc.add_QuantumComputersServicer_to_server \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "DutList",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.list_models.DutList.html",
    "description": "alias of ListModel[list[DutData]] previous DutFieldDataList next ListModel \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07....",
    "content": "alias of ListModel[list[DutData]] previous DutFieldDataList next ListModel \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "SequenceMetadataDefinition",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.sequence.SequenceMetadataDefinition.html",
    "description": "Bases: SequenceMetadataBase The content of the sequence metadata object when creating it. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pyd...",
    "content": "Bases: SequenceMetadataBase The content of the sequence metadata object when creating it. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.sequence Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. sequence_id Unique identifier of the sequence. origin_id Unique identifier of the creator. origin_uri Uniform resource identifier (weak reference) for the creator. Methods sequence_id ( UUID ) \u2013 origin_id ( str ) \u2013 origin_uri ( str ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous SequenceMetadataData next SequenceResultBase \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_results",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_results.html",
    "description": "Convert binary string into SweepResults. sweep_results_str ( bytes ) \u2013 dict [ str , list [ ndarray ]] previous iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_definition nex...",
    "content": "Convert binary string into SweepResults. sweep_results_str ( bytes ) \u2013 dict [ str , list [ ndarray ]] previous iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_definition next iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_data \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.serializers.channel_property_serializer.deserialize_channel_properties",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.channel_property_serializer.deserialize_channel_properties.html",
    "description": "Convert the given protobuf dictionary of channel properties into a dictionary of ChannelProperties . channel_properties_dictionary \u2013 channel property dictionary in protobuf format convert_instructions...",
    "content": "Convert the given protobuf dictionary of channel properties into a dictionary of ChannelProperties . channel_properties_dictionary \u2013 channel property dictionary in protobuf format convert_instructions ( bool ) \u2013 whether to convert string representation of instruction types to actual\npython types. channel_property_dictionary ( ChannelPropertyDictionary ) \u2013 dictionary of channel properties dict [ str , ChannelProperties ] previous channel_property_serializer next iqm.station_control.client.serializers.channel_property_serializer.deserialize_instructions \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "qc_pb2",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.qc_pb2.html",
    "description": "Generated protocol buffer code. Full path: iqm.station_control.client.iqm_server.proto.qc_pb2 previous JobsStub next qc_pb2_grpc \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2...",
    "content": "Generated protocol buffer code. Full path: iqm.station_control.client.iqm_server.proto.qc_pb2 previous JobsStub next qc_pb2_grpc \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.iqm_server.grpc_utils.load_all",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.grpc_utils.load_all.html",
    "description": "chunks ( Iterable [ DataChunk ] ) \u2013 bytes previous iqm.station_control.client.iqm_server.grpc_utils.from_proto_uuid next iqm.station_control.client.iqm_server.grpc_utils.parse_connection_params \u00a9 Copy...",
    "content": "chunks ( Iterable [ DataChunk ] ) \u2013 bytes previous iqm.station_control.client.iqm_server.grpc_utils.from_proto_uuid next iqm.station_control.client.iqm_server.grpc_utils.parse_connection_params \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.iqm_server.iqm_server_client.to_job_status",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.iqm_server_client.to_job_status.html",
    "description": "job_status ( <google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x7f5b77646090> ) \u2013 JobExecutorStatus previous iqm.station_control.client.iqm_server.iqm_server_client.subscribe_to_j...",
    "content": "job_status ( <google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x7f5b77646090> ) \u2013 JobExecutorStatus previous iqm.station_control.client.iqm_server.iqm_server_client.subscribe_to_job_events next iqm.station_control.client.iqm_server.iqm_server_client.to_string_job_status \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "CalibrationsStub",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc.CalibrationsStub.html",
    "description": "Bases: object Missing associated documentation comment in .proto file. Constructor. channel \u2013 A grpc.Channel. Module: iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc Methods previous ...",
    "content": "Bases: object Missing associated documentation comment in .proto file. Constructor. channel \u2013 A grpc.Channel. Module: iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc Methods previous CalibrationsServicer next common_pb2 \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "ObservationUpdate",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.observation.ObservationUpdate.html",
    "description": "Bases: PydanticBase The observation data to be updated in the database. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.Validat...",
    "content": "Bases: PydanticBase The observation data to be updated in the database. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.observation Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. observation_id Unique identifier of the observation. invalid Flag indicating if the object is invalid. Methods observation_id ( int ) \u2013 invalid ( bool ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Unique identifier of the observation. Flag indicating if the object is invalid. Automated systems must not use invalid objects. previous ObservationLite next observation_set \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "ObservationLiteList",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.list_models.ObservationLiteList.html",
    "description": "alias of ListModel[list[ObservationLite]] previous ObservationDefinitionList next ObservationSetDataList \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07....",
    "content": "alias of ListModel[list[ObservationLite]] previous ObservationDefinitionList next ObservationSetDataList \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "station_control",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.station_control.html",
    "description": "Client implementation for station control service REST API. Full path: iqm.station_control.client.station_control Classes StationControlClient Client implementation for station control service REST AP...",
    "content": "Client implementation for station control service REST API. Full path: iqm.station_control.client.station_control Classes StationControlClient Client implementation for station control service REST API. Inheritance previous iqm.station_control.client.serializers.task_serializers.serialize_sweep_job_request next StationControlClient \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "IqmServerClient",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.iqm_server_client.IqmServerClient.html",
    "description": "Bases: _StationControlClientBase Module: iqm.station_control.client.iqm_server.iqm_server_client Methods abort_job Either remove a job from the queue, or abort it gracefully if it's already executing....",
    "content": "Bases: _StationControlClientBase Module: iqm.station_control.client.iqm_server.iqm_server_client Methods abort_job Either remove a job from the queue, or abort it gracefully if it's already executing. create_observation_set Create an observation set in the database. create_observations Create observations in the database. create_sequence_metadata Create sequence metadata in the database. delete_sweep Delete sweep in the database. finalize_observation_set Finalize an observation set in the database. get_about Return information about the station control. get_calibration_set_quality_metrics Get the latest quality metrics for the given calibration set ID. get_calibration_set_values  get_channel_properties Get channel properties from the station. get_chip_design_record Get a raw chip design record matching the given chip label. get_configuration Return the configuration of the station control. get_default_calibration_set Get default calibration set from the database. get_default_calibration_set_observations Get default calibration set observations from the database. get_default_calibration_set_quality_metrics Get the latest quality metrics for the current default calibration set. get_default_dynamic_quantum_architecture Get dynamic quantum architecture for the default calibration set. get_dut_fields Get DUT fields for the specified DUT label from the database. get_duts Get DUTs of the station control. get_dynamic_quantum_architecture Get dynamic quantum architecture for the given calibration set ID. get_exa_configuration Return the recommended EXA configuration from the server. get_health Return the status of the station control service. get_job Get job data. get_latest_calibration_set_id  get_observation_set Get an observation set from the database. get_observation_set_observations Get the constituent observations of an observation set from the database. get_observations Get observations from the database. get_or_create_software_version_set Get software version set ID from the database, or create one if it doesn't exist. get_run Get run data from the database. get_sequence_result Get sequence result from the database. get_settings Return a tree representation of the default settings as defined in the configuration file. get_static_quantum_architecture Get static quantum architecture of the station for the given DUT label. get_sweep Get N-dimensional sweep data from the database. get_sweep_results Get N-dimensional sweep results from the database. query_observation_sets Query observation sets from the database. query_observations Query observations from the database. query_runs Query runs from the database. query_sequence_metadatas Query sequence metadatas from the database. run Execute an N-dimensional sweep of selected variables and save run, sweep and results. save_sequence_result Save sequence result in the database. sweep Execute an N-dimensional sweep of selected variables and save sweep and results. update_observation_set Update an observation set in the database. update_observations Update observations in the database. root_url ( str ) \u2013 get_token_callback ( Callable [ [ ] , str ] | None ) \u2013 client_signature ( str | None ) \u2013 grpc_channel ( Channel | None ) \u2013 Return information about the station control. dict Return the status of the station control service. dict Return the configuration of the station control. dict Return the recommended EXA configuration from the server. str Get software version set ID from the database, or create one if it doesn\u2019t exist. software_version_set ( dict [ str , str ] ) \u2013 int Return a tree representation of the default settings as defined in the configuration file. SettingNode Get a raw chip design record matching the given chip label. dut_label ( str ) \u2013 dict Get channel properties from the station. Channel properties contain information regarding hardware limitations e.g. sampling rate, granularity\nand supported instructions. Mapping from channel name to AWGProperties or ReadoutProperties. dict [ str , ChannelProperties ] Execute an N-dimensional sweep of selected variables and save sweep and results. The raw data for each spot in the sweep is saved as numpy arrays,\nand the complete data for the whole sweep is saved as an x-array dataset\nwhich has the sweep_definition.sweeps as coordinates and\ndata of sweep_definition.return_parameters data as DataArrays. The values of sweep_definition.playlist will be uploaded to the controllers given by the keys of sweep_definition.playlist . sweep_definition ( SweepDefinition ) \u2013 The content of the sweep to be created. Dict containing the task ID  and sweep ID, and corresponding hrefs, of a successful sweep execution\nin monolithic mode or successful submission to the task queue in remote mode. ExaError if submitting a sweep failed. \u2013 dict Get N-dimensional sweep data from the database. sweep_id ( UUID ) \u2013 SweepData Delete sweep in the database. sweep_id ( UUID ) \u2013 None Get N-dimensional sweep results from the database. sweep_id ( UUID ) \u2013 dict [ str , list [ ndarray ]] Execute an N-dimensional sweep of selected variables and save run, sweep and results. run_definition ( RunDefinition ) \u2013 update_progress_callback ( Callable [ [ list [ tuple [ str , int , int ] ] ] , None ] | None ) \u2013 wait_job_completion ( bool ) \u2013 bool Get run data from the database. run_id ( UUID ) \u2013 RunData Query runs from the database. run_id: uuid.UUID run_id__in: list[uuid.UUID] sweep_id: uuid.UUID sweep_id__in: list[uuid.UUID] username: str username__in: list[str] username__contains: str username__icontains: str experiment_label: str experiment_label__in: list[str] experiment_label__contains: str experiment_label__icontains: str experiment_name: str experiment_name__in: list[str] experiment_name__contains: str experiment_name__icontains: str software_version_set_id: int software_version_set_id__in: list[int] begin_timestamp__range: tuple[datetime, datetime] end_timestamp__range: tuple[datetime, datetime] end_timestamp__isnull: bool Queried runs with some query related metadata. ListWithMeta [ RunLite ] Create observations in the database. observation_definitions ( Sequence [ ObservationDefinition ] ) \u2013 A sequence of observation definitions,\neach containing the content of the observation which will be created. Created observations, each including also the database created fields like ID and timestamps. ListWithMeta [ ObservationData ] Get observations from the database. Observations are queried by the given query parameters. mode ( Literal [ 'all_latest' , 'tags_and' , 'tags_or' , 'sequence' ] ) \u2013 The \u201cmode\u201d used to query the observations. Possible values \u201call_latest\u201d, \u201ctags_and\u201d, or \u201ctags_or\u201d. \u201dall_latest\u201d:Query all the latest observations for the given dut_label .\nNo other query parameters are accepted. \u201dtags_and\u201d: Query observations. Query all the observations that have all the given tags .\nBy default, only valid observations are included.\nAll other query parameters can be used to narrow down the query,\nexpect \u201crun_ids\u201d and \u201csequence_ids\u201d. \u201dtags_or\u201d: Query all the latest observations that have at least one of the given tags .\nAdditionally, dut_label must be given. No other query parameters are used. \u201dsequence\u201d: Query observations originating from a list of run and/or sequence IDs.\nNo other query parameters are accepted. The \u201cmode\u201d used to query the observations. Possible values \u201call_latest\u201d, \u201ctags_and\u201d, or \u201ctags_or\u201d. \u201dall_latest\u201d:Query all the latest observations for the given dut_label .\nNo other query parameters are accepted. \u201dtags_and\u201d: Query observations. Query all the observations that have all the given tags .\nBy default, only valid observations are included.\nAll other query parameters can be used to narrow down the query,\nexpect \u201crun_ids\u201d and \u201csequence_ids\u201d. \u201dtags_or\u201d: Query all the latest observations that have at least one of the given tags .\nAdditionally, dut_label must be given. No other query parameters are used. \u201dsequence\u201d: Query observations originating from a list of run and/or sequence IDs.\nNo other query parameters are accepted. dut_label ( str | None ) \u2013 DUT label of the device the observations pertain to. dut_field ( str | None ) \u2013 Name of the property the observation is about. tags ( list [ str ] | None ) \u2013 Human-readable tags of the observation. invalid ( bool | None ) \u2013 Flag indicating if the object is invalid. Automated systems must not use invalid objects.\nIf None , both valid and invalid objects are included. run_ids ( list [ UUID ] | None ) \u2013 The run IDs for which to query the observations. sequence_ids ( list [ UUID ] | None ) \u2013 The sequence IDs for which to query the observations. limit ( int | None ) \u2013 Indicates the maximum number of items to return. Observations, each including also the database created fields like ID and timestamps. list [ ObservationData ] Query observations from the database. observation_id: int observation_id__in: list[int] dut_label: str dut_field: str dut_field__in: list[str] tags__overlap: list[str] tags__contains: list[str] invalid: bool source__run_id__in: list[uuid.UUID] source__sequence_id__in: list[uuid.UUID] source__type: str uncertainty__isnull: bool created_timestamp__range: tuple[datetime, datetime] observation_set_ids__overlap: list[uuid.UUID] observation_set_ids__contains: list[uuid.UUID] Queried observations with some query related metadata. ListWithMeta [ ObservationData ] Update observations in the database. observation_updates ( Sequence [ ObservationUpdate ] ) \u2013 A sequence of observation updates,\neach containing the content of the observation which will be updated. Updated observations, each including also the database created fields like ID and timestamps. list [ ObservationData ] Query observation sets from the database. observation_set_id: UUID observation_set_id__in: list[UUID] observation_set_type: Literal[\u201ccalibration-set\u201d, \u201cgeneric-set\u201d, \u201cquality-metric-set\u201d] observation_ids__overlap: list[int] observation_ids__contains: list[int] describes_id: UUID describes_id__in: list[UUID] invalid: bool created_timestamp__range: tuple[datetime, datetime] end_timestamp__isnull: bool dut_label: str dut_label__in: list[str] Queried observation sets with some query related metadata ListWithMeta [ ObservationSetData ] Create an observation set in the database. observation_set_definition ( ObservationSetDefinition ) \u2013 The content of the observation set to be created. The content of the observation set. ExaError \u2013 If creation failed. ObservationSetData Get an observation set from the database. observation_set_id ( UUID ) \u2013 Observation set to retrieve. The content of the observation set. ExaError \u2013 If retrieval failed. ObservationSetData Update an observation set in the database. observation_set_update ( ObservationSetUpdate ) \u2013 The content of the observation set to be updated. The content of the observation set. ExaError \u2013 If updating failed. ObservationSetData Finalize an observation set in the database. A finalized set is nearly immutable, allowing to change only invalid flag after finalization. observation_set_id ( UUID ) \u2013 Observation set to finalize. ExaError \u2013 If finalization failed. None Get the constituent observations of an observation set from the database. observation_set_id ( UUID ) \u2013 UUID of the observation set to retrieve. Observations belonging to the given observation set. list [ ObservationLite ] Get default calibration set from the database. ObservationSetData Get default calibration set observations from the database. list [ ObservationLite ] Get dynamic quantum architecture for the given calibration set ID. Dynamic quantum architecture of the station for the given calibration set ID. calibration_set_id ( UUID ) \u2013 DynamicQuantumArchitecture Get dynamic quantum architecture for the default calibration set. DynamicQuantumArchitecture Get the latest quality metrics for the current default calibration set. QualityMetrics Get the latest quality metrics for the given calibration set ID. calibration_set_id ( UUID ) \u2013 QualityMetrics Get DUTs of the station control. list [ DutData ] Get DUT fields for the specified DUT label from the database. dut_label ( str ) \u2013 list [ DutFieldData ] Query sequence metadatas from the database. origin_id: str origin_id__in: list[str] origin_uri: str origin_uri__icontains: str created_timestamp__range: tuple[datetime, datetime] Sequence metadatas with some query related metadata. ListWithMeta [ SequenceMetadataData ] Create sequence metadata in the database. sequence_metadata_definition ( SequenceMetadataDefinition ) \u2013 SequenceMetadataData Save sequence result in the database. This method creates the object if it doesn\u2019t exist and completely replaces the \u201cdata\u201d and \u201cfinal\u201d if it does.\nTimestamps are assigned by the database. \u201cmodified_timestamp\u201d is not set on initial creation,\nbut it\u2019s updated on each subsequent call. sequence_result_definition ( SequenceResultDefinition ) \u2013 SequenceResultData Get sequence result from the database. sequence_id ( UUID ) \u2013 SequenceResultData Get static quantum architecture of the station for the given DUT label. Static quantum architecture of the station for the given DUT label. dut_label ( str ) \u2013 StaticQuantumArchitecture Get job data. job_id ( str | UUID ) \u2013 JobData Either remove a job from the queue, or abort it gracefully if it\u2019s already executing. The status of the job will be set to JobStatus.ABORTED .\nIf the job is not found or is already finished nothing happens. job_id ( str | UUID ) \u2013 None previous iqm.station_control.client.iqm_server.iqm_server_client.wrap_error next proto \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "DynamicQuantumArchitecture",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.dynamic_quantum_architecture.DynamicQuantumArchitecture.html",
    "description": "Bases: PydanticBase The dynamic quantum architecture (DQA). Describes gates/operations for which calibration data exists in the calibration set. Create a new model by parsing and validating input data...",
    "content": "Bases: PydanticBase The dynamic quantum architecture (DQA). Describes gates/operations for which calibration data exists in the calibration set. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.dynamic_quantum_architecture Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. calibration_set_id ID of the calibration set from which this DQA was generated. qubits Qubits that appear in at least one gate locus in the calibration set. computational_resonators Computational resonators that appear in at least one gate locus in the calibration set. gates Mapping of gate names to information about the gates. Methods calibration_set_id ( UUID ) \u2013 qubits ( list [ str ] ) \u2013 computational_resonators ( list [ str ] ) \u2013 gates ( dict [ str , GateInfo ] ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. ID of the calibration set from which this DQA was generated. Qubits that appear in at least one gate locus in the calibration set. Computational resonators that appear in at least one gate locus in the calibration set. Mapping of gate names to information about the gates. previous iqm.station_control.interface.models.dynamic_quantum_architecture.Locus next GateImplementationInfo \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "ClientCallDetails",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.grpc_utils.ClientCallDetails.html",
    "description": "Bases: ClientCallDetails Module: iqm.station_control.client.iqm_server.grpc_utils Methods previous ApiTokenAuth next ConnectionParameters \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last upd...",
    "content": "Bases: ClientCallDetails Module: iqm.station_control.client.iqm_server.grpc_utils Methods previous ApiTokenAuth next ConnectionParameters \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "proto",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.html",
    "description": "Full path: iqm.station_control.client.iqm_server.proto Subpackages and modules calibration_pb2 Generated protocol buffer code. calibration_pb2_grpc Client and server classes corresponding to protobuf-...",
    "content": "Full path: iqm.station_control.client.iqm_server.proto Subpackages and modules calibration_pb2 Generated protocol buffer code. calibration_pb2_grpc Client and server classes corresponding to protobuf-defined services. common_pb2 Generated protocol buffer code. common_pb2_grpc Client and server classes corresponding to protobuf-defined services. job_pb2 Generated protocol buffer code. job_pb2_grpc Client and server classes corresponding to protobuf-defined services. qc_pb2 Generated protocol buffer code. qc_pb2_grpc Client and server classes corresponding to protobuf-defined services. uuid_pb2 Generated protocol buffer code. uuid_pb2_grpc Client and server classes corresponding to protobuf-defined services. previous IqmServerClient next calibration_pb2 \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.iqm_server.grpc_utils.to_proto_uuid",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.grpc_utils.to_proto_uuid.html",
    "description": "value ( str | UUID ) \u2013 Uuid previous iqm.station_control.client.iqm_server.grpc_utils.to_datetime next ApiTokenAuth \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07....",
    "content": "value ( str | UUID ) \u2013 Uuid previous iqm.station_control.client.iqm_server.grpc_utils.to_datetime next ApiTokenAuth \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "ObservationSetUpdate",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.observation_set.ObservationSetUpdate.html",
    "description": "Bases: PydanticBase The observation set data to be updated in the database. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.Val...",
    "content": "Bases: PydanticBase The observation set data to be updated in the database. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.observation_set Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. observation_set_id Unique identifier of the observation set. observation_ids Database IDs of the observations belonging to the observation set. invalid Flag indicating if the object is invalid. Methods observation_set_id ( UUID ) \u2013 observation_ids ( list [ int ] | None ) \u2013 invalid ( bool ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Unique identifier of the observation set. Database IDs of the observations belonging to the observation set. This will only add new observations to the observation set, deleting existing ones is not possible.\nSetting this to None or omitting it will leave existing observation_ids as is with no changes. Flag indicating if the object is invalid. Automated systems must not use invalid objects. previous ObservationSetDefinition next ObservationSetWithObservations \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "JobExecutorStatus",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.jobs.JobExecutorStatus.html",
    "description": "Bases: Enum Enumeration of different states a job can be in. The ordering of these statuses is important,\nand execution logic relies on it. Thus, if a new status is added, ensure that it is slotted\nin...",
    "content": "Bases: Enum Enumeration of different states a job can be in. The ordering of these statuses is important,\nand execution logic relies on it. Thus, if a new status is added, ensure that it is slotted\nin at the appropriate place. See the __lt__() implementation for further details. Module: iqm.station_control.interface.models.jobs Attributes RECEIVED  VALIDATION_STARTED  VALIDATION_ENDED  FETCH_CALIBRATION_STARTED  FETCH_CALIBRATION_ENDED  COMPILATION_STARTED  COMPILATION_ENDED  SAVE_SWEEP_METADATA_STARTED  SAVE_SWEEP_METADATA_ENDED  PENDING_EXECUTION  EXECUTION_STARTED  EXECUTION_ENDED  POST_PROCESSING_PENDING  POST_PROCESSING_STARTED  POST_PROCESSING_ENDED  READY  FAILED  ABORTED  Methods terminal_statuses Statuses from which the execution can't continue. Statuses from which the execution can\u2019t continue. set [ JobExecutorStatus ] previous JobError next JobResult \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.serializers.datetime_serializers.deserialize_datetime",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.datetime_serializers.deserialize_datetime.html",
    "description": "Convert a string formatted according to ISO to a datetime object. timestamp ( str | None ) \u2013 datetime | None previous datetime_serializers next iqm.station_control.client.serializers.datetime_serializ...",
    "content": "Convert a string formatted according to ISO to a datetime object. timestamp ( str | None ) \u2013 datetime | None previous datetime_serializers next iqm.station_control.client.serializers.datetime_serializers.serialize_datetime \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "run",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.run.html",
    "description": "Run related station control interface models. Full path: iqm.station_control.interface.models.run Classes RunBase Abstract base class of run data. RunConfigurationBase Abstract base class of the run c...",
    "content": "Run related station control interface models. Full path: iqm.station_control.interface.models.run Classes RunBase Abstract base class of run data. RunConfigurationBase Abstract base class of the run configuration data. RunData The content of the run and its configuration stored in the database. RunDefinition The content of the run object when creating it. RunLite The data of the run stored in the database, excluding run configuration data. RunWithTimestamps Abstract base class of run data including timestamps. Inheritance previous QualityMetrics next RunBase \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "task_serializers",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.task_serializers.html",
    "description": "Serializers and deserializers for task related models. Full path: iqm.station_control.client.serializers.task_serializers Functions deserialize_sweep_job_request (data) Deserializes sweep_definition a...",
    "content": "Serializers and deserializers for task related models. Full path: iqm.station_control.client.serializers.task_serializers Functions deserialize_sweep_job_request (data) Deserializes sweep_definition and queue_name from the serialized bitstring. serialize_run_job_request (run_definition,\u00a0...) Wrap run_definition and queue_name into a protobuf message and serialize into a bitstring. serialize_sweep_job_request (...) Wrap sweep_definition and queue_name into a protobuf message and serialize into a bitstring. previous iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_results next iqm.station_control.client.serializers.task_serializers.deserialize_sweep_job_request \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "list_models",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.list_models.html",
    "description": "Station control client list types for different models. These are used mainly for easy serialization and deserialization of list of objects. Full path: iqm.station_control.client.list_models Classes D...",
    "content": "Station control client list types for different models. These are used mainly for easy serialization and deserialization of list of objects. Full path: iqm.station_control.client.list_models Classes DutFieldDataList alias of ListModel[list[DutFieldData]] DutList alias of ListModel[list[DutData]] ListModel A Pydantic BaseModel for a container model of a list of objects. ListModel[list[DutData]] A Pydantic BaseModel for a container model of a list of objects. ListModel[list[DutFieldData]] A Pydantic BaseModel for a container model of a list of objects. ListModel[list[ObservationData]] A Pydantic BaseModel for a container model of a list of objects. ListModel[list[ObservationDefinition]] A Pydantic BaseModel for a container model of a list of objects. ListModel[list[ObservationLite]] A Pydantic BaseModel for a container model of a list of objects. ListModel[list[ObservationSetData]] A Pydantic BaseModel for a container model of a list of objects. ListModel[list[ObservationUpdate]] A Pydantic BaseModel for a container model of a list of objects. ListModel[list[RunLite]] A Pydantic BaseModel for a container model of a list of objects. ListModel[list[SequenceMetadataData]] A Pydantic BaseModel for a container model of a list of objects. ObservationDataList alias of ListModel[list[ObservationData]] ObservationDefinitionList alias of ListModel[list[ObservationDefinition]] ObservationLiteList alias of ListModel[list[ObservationLite]] ObservationSetDataList alias of ListModel[list[ObservationSetData]] ObservationUpdateList alias of ListModel[list[ObservationUpdate]] ResponseWithMeta Class used for query endpoints to return metadata in addition to the returned items. RunLiteList alias of ListModel[list[RunLite]] SequenceMetadataDataList alias of ListModel[list[SequenceMetadataData]] Inheritance previous IqmServerMockBase next DutFieldDataList \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.iqm_server.grpc_utils.create_channel",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.grpc_utils.create_channel.html",
    "description": "connection_params ( ConnectionParameters ) \u2013 get_token_callback ( Callable [ [ ] , str ] | None ) \u2013 enable_compression ( bool ) \u2013 Channel previous grpc_utils next iqm.station_control.client.iqm_server...",
    "content": "connection_params ( ConnectionParameters ) \u2013 get_token_callback ( Callable [ [ ] , str ] | None ) \u2013 enable_compression ( bool ) \u2013 Channel previous grpc_utils next iqm.station_control.client.iqm_server.grpc_utils.extract_error \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "dynamic_quantum_architecture",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.dynamic_quantum_architecture.html",
    "description": "Dynamic quantum architecture (DQA) related interface models. Full path: iqm.station_control.interface.models.dynamic_quantum_architecture Module Attributes Locus Names of the QPU components (typically...",
    "content": "Dynamic quantum architecture (DQA) related interface models. Full path: iqm.station_control.interface.models.dynamic_quantum_architecture Module Attributes Locus Names of the QPU components (typically qubits) a quantum operation instance is acting on, e.g. (\"QB1\", \"QB2\") . Classes DynamicQuantumArchitecture The dynamic quantum architecture (DQA). GateImplementationInfo Information about an implementation of a quantum gate/operation. GateInfo Information about a quantum gate/operation. Inheritance previous DutFieldData next iqm.station_control.interface.models.dynamic_quantum_architecture.Locus \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "SequenceMetadataData",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.sequence.SequenceMetadataData.html",
    "description": "Bases: SequenceMetadataBase The content of the sequence metadata stored in the database. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pyda...",
    "content": "Bases: SequenceMetadataBase The content of the sequence metadata stored in the database. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.sequence Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. created_timestamp Time when the object was created in the database. sequence_id Unique identifier of the sequence. origin_id Unique identifier of the creator. origin_uri Uniform resource identifier (weak reference) for the creator. Methods sequence_id ( UUID ) \u2013 origin_id ( str ) \u2013 origin_uri ( str ) \u2013 created_timestamp ( datetime ) \u2013 Time when the object was created in the database. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous SequenceMetadataBase next SequenceMetadataDefinition \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.iqm_server.iqm_server_client.subscribe_to_job_events",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.iqm_server_client.subscribe_to_job_events.html",
    "description": "channel ( Channel ) \u2013 job_id ( UUID ) \u2013 Iterable [ JobV1 ] previous iqm.station_control.client.iqm_server.iqm_server_client.resolve_current_qc next iqm.station_control.client.iqm_server.iqm_server_cli...",
    "content": "channel ( Channel ) \u2013 job_id ( UUID ) \u2013 Iterable [ JobV1 ] previous iqm.station_control.client.iqm_server.iqm_server_client.resolve_current_qc next iqm.station_control.client.iqm_server.iqm_server_client.to_job_status \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.iqm_server.error.IqmServerError",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.error.IqmServerError.html",
    "description": "message ( str ) \u2013 status_code ( str ) \u2013 error_code ( str | None ) \u2013 details ( dict | None ) \u2013 previous error next grpc_utils \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-...",
    "content": "message ( str ) \u2013 status_code ( str ) \u2013 error_code ( str | None ) \u2013 details ( dict | None ) \u2013 previous error next grpc_utils \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "JobsServicer",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.job_pb2_grpc.JobsServicer.html",
    "description": "Bases: object User job management APIs. Module: iqm.station_control.client.iqm_server.proto.job_pb2_grpc Methods CancelJobV1 Cancel a queued job by JobLookup. GetJobPayloadV1 Get job payload as GRPC d...",
    "content": "Bases: object User job management APIs. Module: iqm.station_control.client.iqm_server.proto.job_pb2_grpc Methods CancelJobV1 Cancel a queued job by JobLookup. GetJobPayloadV1 Get job payload as GRPC data chunk streams by JobLookup . GetJobResultsV1 Get job result as GRPC data chunk streams by JobLookup. GetJobV1 Get job details by JobLookup. SubmitJobV1 Submits a new job to the quantum computer. SubscribeToJobV1 Subscribes to the job changes. Submits a new job to the quantum computer. If the submit succeeds, returns\nthe handle for the submitted job. ## Errors\nIn case of an error, a GRPC error status is returned with some optional additional\ndetails. The possible error cases are described below: ### Invalid payload\nThis error is returned if the given job payload is not accepted by the\ntarget quantum computer. Note that different quantum computers might\naccept different payloads. ` Code = \"INVALID_ARGUMENT\" Metadata.error_code = \"invalid_payload\" Details = https://protobuf.dev/reference/protobuf/google.protobuf/#value { \"errors\": [<list-of-error-messages>] } ` ### Job type not supported\nThis error is returned if the target quantum computer does not support the\ngiven job type (circuit, pulse). ` Code = \"INVALID_ARGUMENT\" Metadata.error_code = \"job_type_not_supported\" ` ### User job quota exceeded\nThis error is returned if the user has already submitted the maximum allowed\namount of jobs to the queue. Quota can be freed by either waiting for existing\njobs to finish or manually cancelling them (either via the API or the web). ` Code = \"RESOURCE_EXHAUSTED\" Metadata.error_code = \"quota_exceeded\" ` ### Account does not have any active or upcoming timeslots\nThis error is returned if the job is submitted with the use_timeslot flag enabled,\nbut the user\u2019s account does not have active or upcoming timeslots booked. ` Code = \"FAILED_PRECONDITION\" Metadata.error_code = \"no_booked_timeslots\" ` ### Timeslot is required to execute job\nThis error is returned if the target quantum computer requires timeslot to execute\njobs but use_timeslot was unset (or set to false ). ` Code = \"FAILED_PRECONDITION\" Metadata.error_code = \"timeslot_required\" ` ### Quantum computer not found\nThis error is returned if the qc_id does not match any existing quantum computer. ` Code = \"NOT_FOUND\" Metadata.error_code = \"not_found\" ` Get job details by JobLookup. Returns the job if the user job exists.\nUser needs to be authorised to access the job data, i.e. the job must be created by the user. ## Errors\nIn case of an error, a GRPC error status is returned with some optional additional\ndetails. The possible error cases are described below: ### Job not found\nThis error is returned if the JobLookup does not match any existing job. ` Code = \"NOT_FOUND\" Metadata.error_code = \"not_found\" ` ### Quantum computer not found\nThis error is returned if quantum computer associated with the job does not match any existing quantum computer. ` Code = \"NOT_FOUND\" Metadata.error_code = \"not_found\" ` Subscribes to the job changes. Returns a stream that emits the job at subscription\nmoment and after that the changed job every time when the job state changes. The stream\nwill end automatically when the job is considered as \u201cfinal\u201d and won\u2019t be updated\nanymore in the future (cancelled, interrupted, failed, completed). The stream may also emit empty Keepalive messages to indicate that job is still being\nprocessed but hasn\u2019t been updated. Clients may ignore these keepalive messages. ## Errors ### Job not found\nIf the job does not exist with the given lookup, the following error is\nreturned upon the subscription. ` Code = \"NOT_FOUND\" Metadata.error_code = \"not_found\" ` ### Job deleted during the subscription\nIf the job gets deleted during the open subscription, the subscription stream will\nemit the following error and close immediately after that. ` Code = \"ABORTED\" Metadata.error_code = \"job_deleted\" ` ### Server cancellation\nIf server wants to cancel the subscription (e.g. due to restarts or maintenance), the\nsubscription stream will emit the following error and close immediately after that. ` Code = \"ABORTED\" Metadata.error_code = \"server_cancel\" ` Get job payload as GRPC data chunk streams by JobLookup . Returns the job input data if the user job exists.\nUser needs to be authorised to access the job. ## Errors\nIn case of an error, a GRPC error status is returned with some optional additional\ndetails. The possible error cases are described below: ### Job not found\nThis error is returned if the JobLookup does not match any existing job. ` Code = \"NOT_FOUND\" Metadata.error_code = \"not_found\" ` ### Job payload not found\nThis error is returned if the job payload is not found. ` Code = \"NOT_FOUND\" Metadata.error_code = \"not_found\" ` Get job result as GRPC data chunk streams by JobLookup. Returns the job measurements data if the user job exists.\nUser needs to be authorised to access the job. ## Errors\nIn case of an error, a GRPC error status is returned with some optional additional\ndetails. The possible error cases are described below: ### Job not found\nThis error is returned if the JobLookup does not match any existing job. ` Code = \"NOT_FOUND\" Metadata.error_code = \"not_found\" ` ### Job results not found\nThis error is returned if the job results is not found. ` Code = \"NOT_FOUND\" Metadata.error_code = \"not_found\" ` Cancel a queued job by JobLookup. Returns the updated job when cancelled.\nUser needs to be authorised to access the job. ## Errors\nIn case of an error, a GRPC error status is returned with some optional additional\ndetails. The possible error cases are described below: ### Job not found\nThis error is returned if the JobLookup does not match any existing user job. ` Code = \"NOT_FOUND\" Metadata.error_code = \"not_found\" ` ### Can\u2019t cancel job from QC because it\u2019s already in final state\nThis error is returned if the job measurements is not found. ` Code = \"FAILED_PRECONDITION\" Metadata.error_code = \"job_not_submitted_to_qc\" ` ### Quantum computer not found\nThis error is returned if quantum computer associated with the job does not match any existing quantum computer. ` Code = \"NOT_FOUND\" Metadata.error_code = \"not_found\" ` previous Jobs next JobsStub \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "struct_serializer",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.struct_serializer.html",
    "description": "Serializers and deserializers for struct related models. We use custom Struct model instead of standard Struct from protobuf,\nsince standard Struct doesn\u2019t support integers but instead casts them alwa...",
    "content": "Serializers and deserializers for struct related models. We use custom Struct model instead of standard Struct from protobuf,\nsince standard Struct doesn\u2019t support integers but instead casts them always to floats. Full path: iqm.station_control.client.serializers.struct_serializer Functions deserialize_struct (proto) Deserialize a Struct protobuf representation into a free-form dict. serialize_struct (data) Serialize a free-form dict into a Struct protobuf representation. previous iqm.station_control.client.serializers.setting_node_serializer.deserialize_setting_node next iqm.station_control.client.serializers.struct_serializer.deserialize_struct \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "ObservationDataList",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.list_models.ObservationDataList.html",
    "description": "alias of ListModel[list[ObservationData]] previous ListModel next ObservationDefinitionList \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07....",
    "content": "alias of ListModel[list[ObservationData]] previous ListModel next ObservationDefinitionList \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "SequenceMetadataDataList",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.list_models.SequenceMetadataDataList.html",
    "description": "alias of ListModel[list[SequenceMetadataData]] previous RunLiteList next serializers \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07....",
    "content": "alias of ListModel[list[SequenceMetadataData]] previous RunLiteList next serializers \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.iqm_server.iqm_server_client.to_string_job_status",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.iqm_server_client.to_string_job_status.html",
    "description": "job_status ( <google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x7f5b77646090> ) \u2013 str previous iqm.station_control.client.iqm_server.iqm_server_client.to_job_status next iqm.stati...",
    "content": "job_status ( <google.protobuf.internal.enum_type_wrapper.EnumTypeWrapper object at 0x7f5b77646090> ) \u2013 str previous iqm.station_control.client.iqm_server.iqm_server_client.to_job_status next iqm.station_control.client.iqm_server.iqm_server_client.wrap_error \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "QueueState",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.monitor.QueueState.html",
    "description": "Bases: PydanticBase Describes the state of a single job queue. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError]...",
    "content": "Bases: PydanticBase Describes the state of a single job queue. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.monitor Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. queue  jobs_in_queue  completed_jobs  Methods queue ( JobExecutorStatus ) \u2013 jobs_in_queue ( int ) \u2013 completed_jobs ( int ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous JobsInQueue next observation \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "RunConfigurationBase",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.run.RunConfigurationBase.html",
    "description": "Bases: object Abstract base class of the run configuration data. Module: iqm.station_control.interface.models.run Attributes additional_run_properties A free-form dictionary of data, used to store inf...",
    "content": "Bases: object Abstract base class of the run configuration data. Module: iqm.station_control.interface.models.run Attributes additional_run_properties A free-form dictionary of data, used to store information that does not fall into other categories. hard_sweeps Maps SweepBase.return_parameters to \"hardware sweep specification\" which specifies how the data measured at each spot should be interpreted and shaped. components Components that participate in this run. default_data_parameters The subset of SweepBase.return_parameters that were added by default, not by the user. default_sweep_parameters The subset of SweepBase.sweeps parameters were added by default, not by the user. Methods additional_run_properties ( dict [ str , Any ] | None ) \u2013 hard_sweeps ( dict [ str , list [ tuple [ Sweep , ... ] ] ] | None ) \u2013 components ( list [ str ] ) \u2013 default_data_parameters ( list [ str ] ) \u2013 default_sweep_parameters ( list [ str ] ) \u2013 A free-form dictionary of data, used to store information that does not fall into other categories. Maps SweepBase.return_parameters to \u201chardware sweep specification\u201d which specifies\nhow the data measured at each spot should be interpreted and shaped.\nThe hard sweep specification is in the same format as SweepBase.sweeps ,\nwhich means that the returned data can be interpreted as an N-dimensional sweep inside the spot.\nAn empty list is interpreted such that the return parameter is a scalar.\nThe hard sweep specification can also be None ,\nin which case the shape will be whatever the instrument returns. Components that participate in this run. The subset of SweepBase.return_parameters that were added by default, not by the user.\nUsed to select which data to analyze and plot. The subset of SweepBase.sweeps parameters were added by default, not by the user.\nUsed to select which data to analyze and plot. previous RunBase next RunData \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "RunDefinition",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.run.RunDefinition.html",
    "description": "Bases: RunBase , RunConfigurationBase The content of the run object when creating it. Module: iqm.station_control.interface.models.run Attributes sweep_definition The content of the associated sweep s...",
    "content": "Bases: RunBase , RunConfigurationBase The content of the run object when creating it. Module: iqm.station_control.interface.models.run Attributes sweep_definition The content of the associated sweep stored in the database. run_id Unique identifier of the run. username User who defined the run. experiment_name Identifier of the Experiment ( Experiment.name ). experiment_label Freeform label of the Experiment. options Experiment-specific options or toggles that generated the run. software_version_set_id Unique identifier of the software version set of the current Python runtime. additional_run_properties A free-form dictionary of data, used to store information that does not fall into other categories. hard_sweeps Maps SweepBase.return_parameters to \"hardware sweep specification\" which specifies how the data measured at each spot should be interpreted and shaped. components Components that participate in this run. default_data_parameters The subset of SweepBase.return_parameters that were added by default, not by the user. default_sweep_parameters The subset of SweepBase.sweeps parameters were added by default, not by the user. Methods additional_run_properties ( dict [ str , Any ] | None ) \u2013 hard_sweeps ( dict [ str , list [ tuple [ Sweep , ... ] ] ] | None ) \u2013 components ( list [ str ] ) \u2013 default_data_parameters ( list [ str ] ) \u2013 default_sweep_parameters ( list [ str ] ) \u2013 run_id ( UUID ) \u2013 username ( str ) \u2013 experiment_name ( str ) \u2013 experiment_label ( str ) \u2013 options ( dict [ str , Any ] | None ) \u2013 software_version_set_id ( int | None ) \u2013 sweep_definition ( SweepDefinition ) \u2013 The content of the associated sweep stored in the database. previous RunData next RunLite \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "CalibrationsServicer",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc.CalibrationsServicer.html",
    "description": "Bases: object Missing associated documentation comment in .proto file. Module: iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc Methods GetCalibrationV1 Missing associated documentatio...",
    "content": "Bases: object Missing associated documentation comment in .proto file. Module: iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc Methods GetCalibrationV1 Missing associated documentation comment in .proto file. GetFullCalibrationDataV1  GetLatestQuantumComputerCalibrationV1 Missing associated documentation comment in .proto file. Missing associated documentation comment in .proto file. Missing associated documentation comment in .proto file. Get the calibration set for a given QC. The calibration set is returned as bytes data that contains the JSON\nrepresentation of the calibration set data. If the calibration set is\nnot found, a NOT_FOUND error status is returned. previous Calibrations next CalibrationsStub \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "uuid_pb2",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.uuid_pb2.html",
    "description": "Generated protocol buffer code. Full path: iqm.station_control.client.iqm_server.proto.uuid_pb2 previous QuantumComputersStub next uuid_pb2_grpc \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. L...",
    "content": "Generated protocol buffer code. Full path: iqm.station_control.client.iqm_server.proto.uuid_pb2 previous QuantumComputersStub next uuid_pb2_grpc \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "QuantumComputersStub",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.qc_pb2_grpc.QuantumComputersStub.html",
    "description": "Bases: object Quantum Computer management APIs. Constructor. channel \u2013 A grpc.Channel. Module: iqm.station_control.client.iqm_server.proto.qc_pb2_grpc Methods previous QuantumComputersServicer next uu...",
    "content": "Bases: object Quantum Computer management APIs. Constructor. channel \u2013 A grpc.Channel. Module: iqm.station_control.client.iqm_server.proto.qc_pb2_grpc Methods previous QuantumComputersServicer next uuid_pb2 \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "SequenceResultData",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.sequence.SequenceResultData.html",
    "description": "Bases: SequenceResultBase The content of the sequence result stored in the database. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic...",
    "content": "Bases: SequenceResultBase The content of the sequence result stored in the database. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.sequence Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. created_timestamp Time when the object was created in the database. modified_timestamp Time when the object was last modified in the database. sequence_id Unique identifier of the sequence result. data JSON serializable dict. final Indicates whether this result was marked as final. Methods sequence_id ( UUID ) \u2013 data ( dict [ str , Any ] ) \u2013 final ( bool ) \u2013 created_timestamp ( datetime ) \u2013 modified_timestamp ( datetime | None ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Time when the object was created in the database. Time when the object was last modified in the database. previous SequenceResultBase next SequenceResultDefinition \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_data",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_data.html",
    "description": "Convert SweepData into JSON serializable dictionary. sweep_data ( SweepData ) \u2013 dict previous iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_results next iqm.station_contro...",
    "content": "Convert SweepData into JSON serializable dictionary. sweep_data ( SweepData ) \u2013 dict previous iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_results next iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_definition \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "utils",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.utils.html",
    "description": "Utility functions for IQM Station Control Client. Full path: iqm.station_control.client.utils Functions get_progress_bar_callback () Returns a callback function that creates or updates existing progre...",
    "content": "Utility functions for IQM Station Control Client. Full path: iqm.station_control.client.utils Functions get_progress_bar_callback () Returns a callback function that creates or updates existing progressbars when called. init_station_control (root_url[,\u00a0...]) Initialize a new station control instance connected to the given remote. previous StationControlClient next iqm.station_control.client.utils.get_progress_bar_callback \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "StaticQuantumArchitecture",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.static_quantum_architecture.StaticQuantumArchitecture.html",
    "description": "Bases: PydanticBase The static quantum architecture (SQA) provides information about the QPU. For example, the names of its components and the connections between them. Create a new model by parsing a...",
    "content": "Bases: PydanticBase The static quantum architecture (SQA) provides information about the QPU. For example, the names of its components and the connections between them. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.static_quantum_architecture Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. qubits Names of the qubits on the QPU, sorted. computational_resonators Names of the computational resonators on the QPU, sorted. connectivity Components (qubits and computational resonators) connected by a coupler on the QPU, sorted. Methods qubits ( list [ str ] ) \u2013 computational_resonators ( list [ str ] ) \u2013 connectivity ( list [ tuple [ str , ... ] ] ) \u2013 Names of the qubits on the QPU, sorted. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Names of the computational resonators on the QPU, sorted. Components (qubits and computational resonators) connected by a coupler on the QPU, sorted. previous static_quantum_architecture next sweep \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "GateInfo",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.dynamic_quantum_architecture.GateInfo.html",
    "description": "Bases: PydanticBase Information about a quantum gate/operation. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError...",
    "content": "Bases: PydanticBase Information about a quantum gate/operation. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.dynamic_quantum_architecture Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. implementations Mapping of available implementation names to information about the implementations. default_implementation Default implementation for the gate. override_default_implementation Mapping of loci to implementation names that override default_implementation for those loci. Methods override_default_implementation_validator Converts locus keys to tuples if they are encoded as strings. implementations ( dict [ str , GateImplementationInfo ] ) \u2013 default_implementation ( str ) \u2013 override_default_implementation ( dict [ tuple [ str , ... ] , str ] ) \u2013 Mapping of available implementation names to information about the implementations. Default implementation for the gate. Used unless overridden by override_default_implementation ,\nor unless the user requests a specific implementation for a particular gate in the circuit using iqm.cocos.app.api.request_models.Instruction.implementation . Mapping of loci to implementation names that override default_implementation for those loci. Converts locus keys to tuples if they are encoded as strings. value ( Any ) \u2013 dict [ tuple [ str , \u2026], str ] Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous GateImplementationInfo next jobs \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "ObservationSetDataList",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.list_models.ObservationSetDataList.html",
    "description": "alias of ListModel[list[ObservationSetData]] previous ObservationLiteList next ObservationUpdateList \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07....",
    "content": "alias of ListModel[list[ObservationSetData]] previous ObservationLiteList next ObservationUpdateList \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.serializers.run_serializers.deserialize_run_definition",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.run_serializers.deserialize_run_definition.html",
    "description": "Convert run proto into RunDefinition. run_definition_proto ( RunDefinition ) \u2013 RunDefinition previous iqm.station_control.client.serializers.run_serializers.deserialize_run_data next iqm.station_contr...",
    "content": "Convert run proto into RunDefinition. run_definition_proto ( RunDefinition ) \u2013 RunDefinition previous iqm.station_control.client.serializers.run_serializers.deserialize_run_data next iqm.station_control.client.serializers.run_serializers.serialize_run_data \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm_server",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.html",
    "description": "StationControlClient implementation for IQM Server Full path: iqm.station_control.client.iqm_server Subpackages and modules error  grpc_utils Internal utility functions used by IqmServerClient. iqm_se...",
    "content": "StationControlClient implementation for IQM Server Full path: iqm.station_control.client.iqm_server Subpackages and modules error  grpc_utils Internal utility functions used by IqmServerClient. iqm_server_client Client implementation for IQM Server. proto  testing  previous client next error \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_results",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_results.html",
    "description": "Convert SweepResults into binary string. sweep_id ( UUID ) \u2013 sweep_results ( dict [ str , list [ ndarray ] ] ) \u2013 bytes previous iqm.station_control.client.serializers.sweep_serializers.serialize_sweep...",
    "content": "Convert SweepResults into binary string. sweep_id ( UUID ) \u2013 sweep_results ( dict [ str , list [ ndarray ] ] ) \u2013 bytes previous iqm.station_control.client.serializers.sweep_serializers.serialize_sweep_definition next task_serializers \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "common_pb2",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.common_pb2.html",
    "description": "Generated protocol buffer code. Full path: iqm.station_control.client.iqm_server.proto.common_pb2 previous CalibrationsStub next common_pb2_grpc \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. L...",
    "content": "Generated protocol buffer code. Full path: iqm.station_control.client.iqm_server.proto.common_pb2 previous CalibrationsStub next common_pb2_grpc \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "list_with_meta",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.list_with_meta.html",
    "description": "Models to extend standard list with metadata. Full path: iqm.station_control.interface.list_with_meta Classes ListWithMeta Standard list extension holding optional metadata as well. Meta Class holding...",
    "content": "Models to extend standard list with metadata. Full path: iqm.station_control.interface.list_with_meta Classes ListWithMeta Standard list extension holding optional metadata as well. Meta Class holding metadata for list return values, like pagination related data. Inheritance previous interface next ListWithMeta \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "DutFieldData",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.dut.DutFieldData.html",
    "description": "Bases: PydanticBase A DUT field or path and its unit. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the i...",
    "content": "Bases: PydanticBase A DUT field or path and its unit. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.dut Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. path DUT field or path. unit SI unit of the value. Methods path ( str ) \u2013 unit ( str ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. DUT field or path. SI unit of the value. Empty string means the value is dimensionless. previous DutData next dynamic_quantum_architecture \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.serializers.channel_property_serializer.deserialize_instructions",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.channel_property_serializer.deserialize_instructions.html",
    "description": "Convert a repeated scalar container of instruction type strings into a tuple of python types. instructions ( Iterable [ str ] ) \u2013 tuple [ Operation , \u2026] previous iqm.station_control.client.serializers...",
    "content": "Convert a repeated scalar container of instruction type strings into a tuple of python types. instructions ( Iterable [ str ] ) \u2013 tuple [ Operation , \u2026] previous iqm.station_control.client.serializers.channel_property_serializer.deserialize_channel_properties next iqm.station_control.client.serializers.channel_property_serializer.serialize_channel_properties \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.serializers.struct_serializer.deserialize_struct",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.struct_serializer.deserialize_struct.html",
    "description": "Deserialize a Struct protobuf representation into a free-form dict. proto ( Struct ) \u2013 dict previous struct_serializer next iqm.station_control.client.serializers.struct_serializer.serialize_struct \u00a9 ...",
    "content": "Deserialize a Struct protobuf representation into a free-form dict. proto ( Struct ) \u2013 dict previous struct_serializer next iqm.station_control.client.serializers.struct_serializer.serialize_struct \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "SweepData",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.sweep.SweepData.html",
    "description": "Bases: SweepBase The content of the sweep stored in the database. Module: iqm.station_control.interface.models.sweep Attributes created_timestamp Time when the object was created in the database. modi...",
    "content": "Bases: SweepBase The content of the sweep stored in the database. Module: iqm.station_control.interface.models.sweep Attributes created_timestamp Time when the object was created in the database. modified_timestamp Time when the object was last modified in the database. begin_timestamp Time when the sweep began in the station control. end_timestamp Time when the sweep ended in the station control. job_status Status of sweep execution. sweep_id Unique identifier of the sweep. dut_label DUT label of the device being used. settings A tree representation of the initial settings to set before the sweep. sweeps Sweeps that define the swept parameters, i.e. a list of parallel sweeps, where the data values of all sweeps in the tuple are interleaved, and updated simultaneously during the sweep. return_parameters Parameters that will be queried from devices and saved for each spot (variable-tuple) of the N-dimensional sweep. Methods sweep_id ( UUID ) \u2013 dut_label ( str ) \u2013 settings ( SettingNode ) \u2013 sweeps ( list [ tuple [ Sweep , ... ] ] ) \u2013 return_parameters ( list [ str ] ) \u2013 created_timestamp ( datetime ) \u2013 modified_timestamp ( datetime ) \u2013 begin_timestamp ( datetime | None ) \u2013 end_timestamp ( datetime | None ) \u2013 job_status ( JobExecutorStatus ) \u2013 Time when the object was created in the database. Time when the object was last modified in the database. Time when the sweep began in the station control. Time when the sweep ended in the station control. Status of sweep execution. previous SweepBase next SweepDefinition \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "SweepDefinition",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.sweep.SweepDefinition.html",
    "description": "Bases: SweepBase The content of the sweep object when creating it. Module: iqm.station_control.interface.models.sweep Attributes playlist A Playlist that should be uploaded to the controllers. sweep_i...",
    "content": "Bases: SweepBase The content of the sweep object when creating it. Module: iqm.station_control.interface.models.sweep Attributes playlist A Playlist that should be uploaded to the controllers. sweep_id Unique identifier of the sweep. dut_label DUT label of the device being used. settings A tree representation of the initial settings to set before the sweep. sweeps Sweeps that define the swept parameters, i.e. a list of parallel sweeps, where the data values of all sweeps in the tuple are interleaved, and updated simultaneously during the sweep. return_parameters Parameters that will be queried from devices and saved for each spot (variable-tuple) of the N-dimensional sweep. Methods sweep_id ( UUID ) \u2013 dut_label ( str ) \u2013 settings ( SettingNode ) \u2013 sweeps ( list [ tuple [ Sweep , ... ] ] ) \u2013 return_parameters ( list [ str ] ) \u2013 playlist ( Playlist | None ) \u2013 A Playlist that should be uploaded to the controllers. previous SweepData next type_aliases \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "SequenceResultBase",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.sequence.SequenceResultBase.html",
    "description": "Bases: PydanticBase Abstract base class of the sequence result definition and data. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_...",
    "content": "Bases: PydanticBase Abstract base class of the sequence result definition and data. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.sequence Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. sequence_id Unique identifier of the sequence result. data JSON serializable dict. final Indicates whether this result was marked as final. Methods sequence_id ( UUID ) \u2013 data ( dict [ str , Any ] ) \u2013 final ( bool ) \u2013 Unique identifier of the sequence result. JSON serializable dict. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Indicates whether this result was marked as final. previous SequenceMetadataDefinition next SequenceResultData \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "observation_set",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.observation_set.html",
    "description": "Observation set related station control interface models. Full path: iqm.station_control.interface.models.observation_set Classes ObservationSetBase Abstract base class of the observation set definiti...",
    "content": "Observation set related station control interface models. Full path: iqm.station_control.interface.models.observation_set Classes ObservationSetBase Abstract base class of the observation set definition and data. ObservationSetData The content of the observation set stored in the database. ObservationSetDefinition The content of the observation set object when creating it. ObservationSetUpdate The observation set data to be updated in the database. ObservationSetWithObservations The content of the observation set stored in the database, with a list of observations. QualityMetrics The content of the quality metric set stored in the database, with a list of observations and calibration set. Inheritance previous ObservationUpdate next ObservationSetBase \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "SequenceMetadataBase",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.sequence.SequenceMetadataBase.html",
    "description": "Bases: PydanticBase Abstract base class of the sequence metadata definition and data. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydanti...",
    "content": "Bases: PydanticBase Abstract base class of the sequence metadata definition and data. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.sequence Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. sequence_id Unique identifier of the sequence. origin_id Unique identifier of the creator. origin_uri Uniform resource identifier (weak reference) for the creator. Methods sequence_id ( UUID ) \u2013 origin_id ( str ) \u2013 origin_uri ( str ) \u2013 Unique identifier of the sequence. Unique identifier of the creator. E.g. notebook researcher username, or calibration service ID. Uniform resource identifier (weak reference) for the creator. E.g. calibration service ID. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous sequence next SequenceMetadataData \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.iqm_server.proto.job_pb2_grpc.add_JobsServicer_to_server",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.job_pb2_grpc.add_JobsServicer_to_server.html",
    "description": "previous job_pb2_grpc next Jobs \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07....",
    "content": "previous job_pb2_grpc next Jobs \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.iqm_server.iqm_server_client.parse_calibration_set",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.iqm_server_client.parse_calibration_set.html",
    "description": "cal_set_data ( bytes ) \u2013 tuple [ UUID , dict [ str , bool | str | int | float | complex | ndarray ]] previous iqm_server_client next iqm.station_control.client.iqm_server.iqm_server_client.parse_json ...",
    "content": "cal_set_data ( bytes ) \u2013 tuple [ UUID , dict [ str , bool | str | int | float | complex | ndarray ]] previous iqm_server_client next iqm.station_control.client.iqm_server.iqm_server_client.parse_json \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "ObservationSetData",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.observation_set.ObservationSetData.html",
    "description": "Bases: ObservationSetBase The content of the observation set stored in the database. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic...",
    "content": "Bases: ObservationSetBase The content of the observation set stored in the database. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.observation_set Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. dut_label String representation of the DUT the observation set is associated with. observation_set_id Unique identifier of the observation set. created_timestamp Time when the object was created in the database. end_timestamp Time when the observation set was finalized. observation_set_type Indicates the type (i.e. purpose) of the observation set. observation_ids Database IDs of the observations belonging to the observation set. describes_id Unique identifier of the observation set this observation set describes. invalid Flag indicating if the object is invalid. Methods observation_set_type ( Literal [ 'calibration-set' , 'characterization-set' , 'generic-set' , 'quality-metric-set' ] ) \u2013 observation_ids ( list [ int ] ) \u2013 describes_id ( UUID | None ) \u2013 invalid ( bool ) \u2013 dut_label ( str | None ) \u2013 observation_set_id ( UUID ) \u2013 created_timestamp ( datetime ) \u2013 end_timestamp ( datetime | None ) \u2013 String representation of the DUT the observation set is associated with. Can only be None for generic sets. Unique identifier of the observation set. Time when the object was created in the database. Time when the observation set was finalized. If None , the set is not finalized yet. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous ObservationSetBase next ObservationSetDefinition \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "RunWithTimestamps",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.run.RunWithTimestamps.html",
    "description": "Bases: RunBase Abstract base class of run data including timestamps. Module: iqm.station_control.interface.models.run Attributes created_timestamp Time when the object was created in the database. mod...",
    "content": "Bases: RunBase Abstract base class of run data including timestamps. Module: iqm.station_control.interface.models.run Attributes created_timestamp Time when the object was created in the database. modified_timestamp Time when the object was last modified in the database. begin_timestamp Time when the run began in the station control. end_timestamp Time when the run ended in the station control. run_id Unique identifier of the run. username User who defined the run. experiment_name Identifier of the Experiment ( Experiment.name ). experiment_label Freeform label of the Experiment. options Experiment-specific options or toggles that generated the run. software_version_set_id Unique identifier of the software version set of the current Python runtime. Methods run_id ( UUID ) \u2013 username ( str ) \u2013 experiment_name ( str ) \u2013 experiment_label ( str ) \u2013 options ( dict [ str , Any ] | None ) \u2013 software_version_set_id ( int | None ) \u2013 created_timestamp ( datetime ) \u2013 modified_timestamp ( datetime ) \u2013 begin_timestamp ( datetime ) \u2013 end_timestamp ( datetime | None ) \u2013 Time when the object was created in the database. Time when the object was last modified in the database. Time when the run began in the station control. Time when the run ended in the station control. previous RunLite next sequence \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.iqm_server.grpc_utils.to_datetime",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.grpc_utils.to_datetime.html",
    "description": "timestamp ( Timestamp ) \u2013 datetime previous iqm.station_control.client.iqm_server.grpc_utils.parse_connection_params next iqm.station_control.client.iqm_server.grpc_utils.to_proto_uuid \u00a9 Copyright 201...",
    "content": "timestamp ( Timestamp ) \u2013 datetime previous iqm.station_control.client.iqm_server.grpc_utils.parse_connection_params next iqm.station_control.client.iqm_server.grpc_utils.to_proto_uuid \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "JobsStub",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.job_pb2_grpc.JobsStub.html",
    "description": "Bases: object User job management APIs. Constructor. channel \u2013 A grpc.Channel. Module: iqm.station_control.client.iqm_server.proto.job_pb2_grpc Methods previous JobsServicer next qc_pb2 \u00a9 Copyright 20...",
    "content": "Bases: object User job management APIs. Constructor. channel \u2013 A grpc.Channel. Module: iqm.station_control.client.iqm_server.proto.job_pb2_grpc Methods previous JobsServicer next qc_pb2 \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "testing",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.testing.html",
    "description": "Full path: iqm.station_control.client.iqm_server.testing Subpackages and modules iqm_server_mock Internal testing utilities for IqmServerClient previous uuid_pb2_grpc next iqm_server_mock \u00a9 Copyright ...",
    "content": "Full path: iqm.station_control.client.iqm_server.testing Subpackages and modules iqm_server_mock Internal testing utilities for IqmServerClient previous uuid_pb2_grpc next iqm_server_mock \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "ConnectionParameters",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.grpc_utils.ConnectionParameters.html",
    "description": "Bases: object Module: iqm.station_control.client.iqm_server.grpc_utils Attributes server_address  is_secure  quantum_computer  use_timeslot  Methods server_address ( str ) \u2013 is_secure ( bool ) \u2013 quant...",
    "content": "Bases: object Module: iqm.station_control.client.iqm_server.grpc_utils Attributes server_address  is_secure  quantum_computer  use_timeslot  Methods server_address ( str ) \u2013 is_secure ( bool ) \u2013 quantum_computer ( str ) \u2013 use_timeslot ( bool ) \u2013 previous ClientCallDetails next iqm_server_client \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "ObservationSetDefinition",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.observation_set.ObservationSetDefinition.html",
    "description": "Bases: ObservationSetBase The content of the observation set object when creating it. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydanti...",
    "content": "Bases: ObservationSetBase The content of the observation set object when creating it. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.observation_set Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. observation_set_type Indicates the type (i.e. purpose) of the observation set. observation_ids Database IDs of the observations belonging to the observation set. describes_id Unique identifier of the observation set this observation set describes. invalid Flag indicating if the object is invalid. Methods observation_set_type ( Literal [ 'calibration-set' , 'characterization-set' , 'generic-set' , 'quality-metric-set' ] ) \u2013 observation_ids ( list [ int ] ) \u2013 describes_id ( UUID | None ) \u2013 invalid ( bool ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous ObservationSetData next ObservationSetUpdate \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "playlist_serializers",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.playlist_serializers.html",
    "description": "Serializers and deserializers for Playlist Full path: iqm.station_control.client.serializers.playlist_serializers Functions pack_playlist (playlist) Pack the given playlist into a protobuf format for ...",
    "content": "Serializers and deserializers for Playlist Full path: iqm.station_control.client.serializers.playlist_serializers Functions pack_playlist (playlist) Pack the given playlist into a protobuf format for further serialization. unpack_playlist (proto_playlist) Unpack a protobuf representation of a playlist into its runtime representation. previous iqm.station_control.client.serializers.datetime_serializers.serialize_datetime next iqm.station_control.client.serializers.playlist_serializers.pack_playlist \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "ObservationUpdateList",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.list_models.ObservationUpdateList.html",
    "description": "alias of ListModel[list[ObservationUpdate]] previous ObservationSetDataList next ResponseWithMeta \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07....",
    "content": "alias of ListModel[list[ObservationUpdate]] previous ObservationSetDataList next ResponseWithMeta \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "error",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.error.html",
    "description": "Full path: iqm.station_control.client.iqm_server.error Exceptions IqmServerError (message,\u00a0status_code[,\u00a0...])  previous iqm_server next iqm.station_control.client.iqm_server.error.IqmServerError \u00a9 Co...",
    "content": "Full path: iqm.station_control.client.iqm_server.error Exceptions IqmServerError (message,\u00a0status_code[,\u00a0...])  previous iqm_server next iqm.station_control.client.iqm_server.error.IqmServerError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "Meta",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.list_with_meta.Meta.html",
    "description": "Bases: object Class holding metadata for list return values, like pagination related data. Module: iqm.station_control.interface.list_with_meta Attributes count  errors  limit  offset  order_by  Metho...",
    "content": "Bases: object Class holding metadata for list return values, like pagination related data. Module: iqm.station_control.interface.list_with_meta Attributes count  errors  limit  offset  order_by  Methods count ( int | None ) \u2013 order_by ( str | None ) \u2013 limit ( int | None ) \u2013 offset ( int | None ) \u2013 errors ( list [ str ] | None ) \u2013 previous ListWithMeta next models \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "JobData",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.jobs.JobData.html",
    "description": "Bases: PydanticBase Job response data model Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data ...",
    "content": "Bases: PydanticBase Job response data model Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.jobs Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. job_id  job_status  job_result  job_error  position  Methods job_id ( UUID ) \u2013 job_status ( JobExecutorStatus ) \u2013 job_result ( JobResult ) \u2013 job_error ( JobError | None ) \u2013 position ( int | None ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous jobs next JobError \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "StationControlClient",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.station_control.StationControlClient.html",
    "description": "Bases: _StationControlClientBase Client implementation for station control service REST API. root_url ( str ) \u2013 Remote station control service URL. get_token_callback ( Callable [ [ ] , str ] | None )...",
    "content": "Bases: _StationControlClientBase Client implementation for station control service REST API. root_url ( str ) \u2013 Remote station control service URL. get_token_callback ( Callable [ [ ] , str ] | None ) \u2013 A callback function that returns a token (str)\nwhich will be passed in Authorization header in all requests. client_signature ( str | None ) \u2013 String that is added to the User-Agent header of requests\nsent to the server. Module: iqm.station_control.client.station_control Attributes version Return the version of the station control API this client is using. Methods abort_job Either remove a job from the queue, or abort it gracefully if it's already executing. create_observation_set Create an observation set in the database. create_observations Create observations in the database. create_sequence_metadata Create sequence metadata in the database. delete_sweep Delete sweep in the database. finalize_observation_set Finalize an observation set in the database. get_about Return information about the station control. get_calibration_set_quality_metrics Get the latest quality metrics for the given calibration set ID. get_channel_properties Get channel properties from the station. get_chip_design_record Get a raw chip design record matching the given chip label. get_configuration Return the configuration of the station control. get_default_calibration_set Get default calibration set from the database. get_default_calibration_set_observations Get default calibration set observations from the database. get_default_calibration_set_quality_metrics Get the latest quality metrics for the current default calibration set. get_default_dynamic_quantum_architecture Get dynamic quantum architecture for the default calibration set. get_dut_fields Get DUT fields for the specified DUT label from the database. get_duts Get DUTs of the station control. get_dynamic_quantum_architecture Get dynamic quantum architecture for the given calibration set ID. get_exa_configuration Return the recommended EXA configuration from the server. get_health Return the status of the station control service. get_job Get job data. get_observation_set Get an observation set from the database. get_observation_set_observations Get the constituent observations of an observation set from the database. get_observations Get observations from the database. get_or_create_software_version_set Get software version set ID from the database, or create one if it doesn't exist. get_run Get run data from the database. get_sequence_result Get sequence result from the database. get_settings Return a tree representation of the default settings as defined in the configuration file. get_static_quantum_architecture Get static quantum architecture of the station for the given DUT label. get_sweep Get N-dimensional sweep data from the database. get_sweep_results Get N-dimensional sweep results from the database. query_observation_sets Query observation sets from the database. query_observations Query observations from the database. query_runs Query runs from the database. query_sequence_metadatas Query sequence metadatas from the database. run Execute an N-dimensional sweep of selected variables and save run, sweep and results. save_sequence_result Save sequence result in the database. sweep Execute an N-dimensional sweep of selected variables and save sweep and results. update_observation_set Update an observation set in the database. update_observations Update observations in the database. Return the version of the station control API this client is using. Return information about the station control. dict Return the status of the station control service. dict Return the configuration of the station control. dict Return the recommended EXA configuration from the server. str Get software version set ID from the database, or create one if it doesn\u2019t exist. software_version_set ( dict [ str , str ] ) \u2013 int Return a tree representation of the default settings as defined in the configuration file. SettingNode Get a raw chip design record matching the given chip label. dut_label ( str ) \u2013 dict Get channel properties from the station. Channel properties contain information regarding hardware limitations e.g. sampling rate, granularity\nand supported instructions. Mapping from channel name to AWGProperties or ReadoutProperties. dict [ str , ChannelProperties ] Execute an N-dimensional sweep of selected variables and save sweep and results. The raw data for each spot in the sweep is saved as numpy arrays,\nand the complete data for the whole sweep is saved as an x-array dataset\nwhich has the sweep_definition.sweeps as coordinates and\ndata of sweep_definition.return_parameters data as DataArrays. The values of sweep_definition.playlist will be uploaded to the controllers given by the keys of sweep_definition.playlist . sweep_definition ( SweepDefinition ) \u2013 The content of the sweep to be created. Dict containing the task ID  and sweep ID, and corresponding hrefs, of a successful sweep execution\nin monolithic mode or successful submission to the task queue in remote mode. ExaError if submitting a sweep failed. \u2013 dict Get N-dimensional sweep data from the database. sweep_id ( str | UUID ) \u2013 SweepData Delete sweep in the database. sweep_id ( str | UUID ) \u2013 None Get N-dimensional sweep results from the database. sweep_id ( str | UUID ) \u2013 dict [ str , list [ ndarray ]] Execute an N-dimensional sweep of selected variables and save run, sweep and results. run_definition ( RunDefinition ) \u2013 update_progress_callback ( Callable [ [ list [ tuple [ str , int , int ] ] ] , None ] | None ) \u2013 wait_job_completion ( bool ) \u2013 bool Get run data from the database. run_id ( str | UUID ) \u2013 RunData Query runs from the database. run_id: uuid.UUID run_id__in: list[uuid.UUID] sweep_id: uuid.UUID sweep_id__in: list[uuid.UUID] username: str username__in: list[str] username__contains: str username__icontains: str experiment_label: str experiment_label__in: list[str] experiment_label__contains: str experiment_label__icontains: str experiment_name: str experiment_name__in: list[str] experiment_name__contains: str experiment_name__icontains: str software_version_set_id: int software_version_set_id__in: list[int] begin_timestamp__range: tuple[datetime, datetime] end_timestamp__range: tuple[datetime, datetime] end_timestamp__isnull: bool Queried runs with some query related metadata. ListWithMeta [ RunLite ] Create observations in the database. observation_definitions ( Sequence [ ObservationDefinition ] ) \u2013 A sequence of observation definitions,\neach containing the content of the observation which will be created. Created observations, each including also the database created fields like ID and timestamps. ListWithMeta [ ObservationData ] Get observations from the database. Observations are queried by the given query parameters. mode ( Literal [ 'all_latest' , 'tags_and' , 'tags_or' , 'sequence' ] ) \u2013 The \u201cmode\u201d used to query the observations. Possible values \u201call_latest\u201d, \u201ctags_and\u201d, or \u201ctags_or\u201d. \u201dall_latest\u201d:Query all the latest observations for the given dut_label .\nNo other query parameters are accepted. \u201dtags_and\u201d: Query observations. Query all the observations that have all the given tags .\nBy default, only valid observations are included.\nAll other query parameters can be used to narrow down the query,\nexpect \u201crun_ids\u201d and \u201csequence_ids\u201d. \u201dtags_or\u201d: Query all the latest observations that have at least one of the given tags .\nAdditionally, dut_label must be given. No other query parameters are used. \u201dsequence\u201d: Query observations originating from a list of run and/or sequence IDs.\nNo other query parameters are accepted. The \u201cmode\u201d used to query the observations. Possible values \u201call_latest\u201d, \u201ctags_and\u201d, or \u201ctags_or\u201d. \u201dall_latest\u201d:Query all the latest observations for the given dut_label .\nNo other query parameters are accepted. \u201dtags_and\u201d: Query observations. Query all the observations that have all the given tags .\nBy default, only valid observations are included.\nAll other query parameters can be used to narrow down the query,\nexpect \u201crun_ids\u201d and \u201csequence_ids\u201d. \u201dtags_or\u201d: Query all the latest observations that have at least one of the given tags .\nAdditionally, dut_label must be given. No other query parameters are used. \u201dsequence\u201d: Query observations originating from a list of run and/or sequence IDs.\nNo other query parameters are accepted. dut_label ( str | None ) \u2013 DUT label of the device the observations pertain to. dut_field ( str | None ) \u2013 Name of the property the observation is about. tags ( list [ str ] | None ) \u2013 Human-readable tags of the observation. invalid ( bool | None ) \u2013 Flag indicating if the object is invalid. Automated systems must not use invalid objects.\nIf None , both valid and invalid objects are included. run_ids ( list [ str | UUID ] | None ) \u2013 The run IDs for which to query the observations. sequence_ids ( list [ str | UUID ] | None ) \u2013 The sequence IDs for which to query the observations. limit ( int | None ) \u2013 Indicates the maximum number of items to return. Observations, each including also the database created fields like ID and timestamps. list [ ObservationData ] Query observations from the database. observation_id: int observation_id__in: list[int] dut_label: str dut_field: str dut_field__in: list[str] tags__overlap: list[str] tags__contains: list[str] invalid: bool source__run_id__in: list[uuid.UUID] source__sequence_id__in: list[uuid.UUID] source__type: str uncertainty__isnull: bool created_timestamp__range: tuple[datetime, datetime] observation_set_ids__overlap: list[uuid.UUID] observation_set_ids__contains: list[uuid.UUID] Queried observations with some query related metadata. ListWithMeta [ ObservationData ] Update observations in the database. observation_updates ( Sequence [ ObservationUpdate ] ) \u2013 A sequence of observation updates,\neach containing the content of the observation which will be updated. Updated observations, each including also the database created fields like ID and timestamps. list [ ObservationData ] Query observation sets from the database. observation_set_id: UUID observation_set_id__in: list[UUID] observation_set_type: Literal[\u201ccalibration-set\u201d, \u201cgeneric-set\u201d, \u201cquality-metric-set\u201d] observation_ids__overlap: list[int] observation_ids__contains: list[int] describes_id: UUID describes_id__in: list[UUID] invalid: bool created_timestamp__range: tuple[datetime, datetime] end_timestamp__isnull: bool dut_label: str dut_label__in: list[str] Queried observation sets with some query related metadata ListWithMeta [ ObservationSetData ] Create an observation set in the database. observation_set_definition ( ObservationSetDefinition ) \u2013 The content of the observation set to be created. The content of the observation set. ExaError \u2013 If creation failed. ObservationSetData Get an observation set from the database. observation_set_id ( str | UUID ) \u2013 Observation set to retrieve. The content of the observation set. ExaError \u2013 If retrieval failed. ObservationSetData Update an observation set in the database. observation_set_update ( ObservationSetUpdate ) \u2013 The content of the observation set to be updated. The content of the observation set. ExaError \u2013 If updating failed. ObservationSetData Finalize an observation set in the database. A finalized set is nearly immutable, allowing to change only invalid flag after finalization. observation_set_id ( str | UUID ) \u2013 Observation set to finalize. ExaError \u2013 If finalization failed. None Get the constituent observations of an observation set from the database. observation_set_id ( str | UUID ) \u2013 UUID of the observation set to retrieve. Observations belonging to the given observation set. list [ ObservationLite ] Get default calibration set from the database. ObservationSetData Get default calibration set observations from the database. list [ ObservationLite ] Get dynamic quantum architecture for the default calibration set. DynamicQuantumArchitecture Get dynamic quantum architecture for the given calibration set ID. Dynamic quantum architecture of the station for the given calibration set ID. calibration_set_id ( str | UUID ) \u2013 DynamicQuantumArchitecture Get the latest quality metrics for the current default calibration set. QualityMetrics Get the latest quality metrics for the given calibration set ID. calibration_set_id ( str | UUID ) \u2013 QualityMetrics Get DUTs of the station control. list [ DutData ] Get DUT fields for the specified DUT label from the database. dut_label ( str ) \u2013 list [ DutFieldData ] Query sequence metadatas from the database. origin_id: str origin_id__in: list[str] origin_uri: str origin_uri__icontains: str created_timestamp__range: tuple[datetime, datetime] Sequence metadatas with some query related metadata. ListWithMeta [ SequenceMetadataData ] Create sequence metadata in the database. sequence_metadata_definition ( SequenceMetadataDefinition ) \u2013 SequenceMetadataData Save sequence result in the database. This method creates the object if it doesn\u2019t exist and completely replaces the \u201cdata\u201d and \u201cfinal\u201d if it does.\nTimestamps are assigned by the database. \u201cmodified_timestamp\u201d is not set on initial creation,\nbut it\u2019s updated on each subsequent call. sequence_result_definition ( SequenceResultDefinition ) \u2013 SequenceResultData Get sequence result from the database. sequence_id ( str | UUID ) \u2013 SequenceResultData Get static quantum architecture of the station for the given DUT label. Static quantum architecture of the station for the given DUT label. dut_label ( str ) \u2013 StaticQuantumArchitecture Get job data. job_id ( str | UUID ) \u2013 JobData Either remove a job from the queue, or abort it gracefully if it\u2019s already executing. The status of the job will be set to JobStatus.ABORTED .\nIf the job is not found or is already finished nothing happens. job_id ( str | UUID ) \u2013 None Serialize a Pydantic model into a JSON string. All Pydantic models should be serialized using this method, to keep the client behavior uniform. model ( BaseModel ) \u2013 Pydantic model to JSON-serialize. Corresponding JSON string, may contain arbitrary Unicode characters. str previous station_control next utils \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "Calibrations",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc.Calibrations.html",
    "description": "Bases: object Missing associated documentation comment in .proto file. Module: iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc Methods GetCalibrationV1  GetFullCalibrationDataV1  GetL...",
    "content": "Bases: object Missing associated documentation comment in .proto file. Module: iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc Methods GetCalibrationV1  GetFullCalibrationDataV1  GetLatestQuantumComputerCalibrationV1  previous iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc.add_CalibrationsServicer_to_server next CalibrationsServicer \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "ListWithMeta",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.list_with_meta.ListWithMeta.html",
    "description": "Bases: list Standard list extension holding optional metadata as well. Module: iqm.station_control.interface.list_with_meta Methods items ( Iterable ) \u2013 meta ( Meta ) \u2013 previous list_with_meta next Me...",
    "content": "Bases: list Standard list extension holding optional metadata as well. Module: iqm.station_control.interface.list_with_meta Methods items ( Iterable ) \u2013 meta ( Meta ) \u2013 previous list_with_meta next Meta \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "static_quantum_architecture",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.static_quantum_architecture.html",
    "description": "Static quantum architecture (SQA) related interface models. Full path: iqm.station_control.interface.models.static_quantum_architecture Classes StaticQuantumArchitecture The static quantum architectur...",
    "content": "Static quantum architecture (SQA) related interface models. Full path: iqm.station_control.interface.models.static_quantum_architecture Classes StaticQuantumArchitecture The static quantum architecture (SQA) provides information about the QPU. Inheritance previous SequenceResultDefinition next StaticQuantumArchitecture \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "RunLite",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.run.RunLite.html",
    "description": "Bases: RunWithTimestamps The data of the run stored in the database, excluding run configuration data. Module: iqm.station_control.interface.models.run Attributes sweep_id Unique identifier of the ass...",
    "content": "Bases: RunWithTimestamps The data of the run stored in the database, excluding run configuration data. Module: iqm.station_control.interface.models.run Attributes sweep_id Unique identifier of the associated sweep. created_timestamp Time when the object was created in the database. modified_timestamp Time when the object was last modified in the database. begin_timestamp Time when the run began in the station control. end_timestamp Time when the run ended in the station control. run_id Unique identifier of the run. username User who defined the run. experiment_name Identifier of the Experiment ( Experiment.name ). experiment_label Freeform label of the Experiment. options Experiment-specific options or toggles that generated the run. software_version_set_id Unique identifier of the software version set of the current Python runtime. Methods run_id ( UUID ) \u2013 username ( str ) \u2013 experiment_name ( str ) \u2013 experiment_label ( str ) \u2013 options ( dict [ str , Any ] | None ) \u2013 software_version_set_id ( int | None ) \u2013 created_timestamp ( datetime ) \u2013 modified_timestamp ( datetime ) \u2013 begin_timestamp ( datetime ) \u2013 end_timestamp ( datetime | None ) \u2013 sweep_id ( UUID | None ) \u2013 Unique identifier of the associated sweep. previous RunDefinition next RunWithTimestamps \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "run_serializers",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.run_serializers.html",
    "description": "Serializers and deserializers for run related models. Full path: iqm.station_control.client.serializers.run_serializers Functions deserialize_run_data (data) Convert a JSON serializable dictionary to ...",
    "content": "Serializers and deserializers for run related models. Full path: iqm.station_control.client.serializers.run_serializers Functions deserialize_run_data (data) Convert a JSON serializable dictionary to RunData object. deserialize_run_definition (run_definition_proto) Convert run proto into RunDefinition. serialize_run_data (run_data) Convert RunData object to a JSON serializable dictionary. serialize_run_definition (run_definition) Convert RunDefinition into run proto. previous iqm.station_control.client.serializers.playlist_serializers.unpack_playlist next iqm.station_control.client.serializers.run_serializers.deserialize_run_data \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm_server_client",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.iqm_server_client.html",
    "description": "Client implementation for IQM Server. Full path: iqm.station_control.client.iqm_server.iqm_server_client Functions parse_calibration_set (cal_set_data)  parse_json (data)  payload_to_sweep (job_payloa...",
    "content": "Client implementation for IQM Server. Full path: iqm.station_control.client.iqm_server.iqm_server_client Functions parse_calibration_set (cal_set_data)  parse_json (data)  payload_to_sweep (job_payload)  resolve_current_qc (channel,\u00a0alias)  subscribe_to_job_events (channel,\u00a0job_id)  to_job_status (job_status)  to_string_job_status (job_status)  wrap_error (title)  Classes IqmServerClient  Inheritance previous ConnectionParameters next iqm.station_control.client.iqm_server.iqm_server_client.parse_calibration_set \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "JobError",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.jobs.JobError.html",
    "description": "Bases: PydanticBase Error log for a job. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data can...",
    "content": "Bases: PydanticBase Error log for a job. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.jobs Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. full_error_log  user_error_message  Methods full_error_log ( str ) \u2013 user_error_message ( str ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous JobData next JobExecutorStatus \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "ApiTokenAuth",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.grpc_utils.ApiTokenAuth.html",
    "description": "Bases: UnaryUnaryClientInterceptor , UnaryStreamClientInterceptor Module: iqm.station_control.client.iqm_server.grpc_utils Methods intercept_unary_stream Intercepts a unary-stream invocation. intercep...",
    "content": "Bases: UnaryUnaryClientInterceptor , UnaryStreamClientInterceptor Module: iqm.station_control.client.iqm_server.grpc_utils Methods intercept_unary_stream Intercepts a unary-stream invocation. intercept_unary_unary Intercepts a unary-unary invocation asynchronously. get_token_callback ( Callable [ [ ] , str ] ) \u2013 Intercepts a unary-stream invocation. continuation \u2013 A function that proceeds with the invocation by\nexecuting the next interceptor in chain or invoking the\nactual RPC on the underlying Channel. It is the interceptor\u2019s\nresponsibility to call it if it decides to move the RPC forward.\nThe interceptor can use response_iterator = continuation(client_call_details, request) to continue with the RPC. continuation returns an object that is\nboth a Call for the RPC and an iterator for response values.\nDrawing response values from the returned Call-iterator may\nraise RpcError indicating termination of the RPC with non-OK\nstatus. client_call_details \u2013 A ClientCallDetails object describing the\noutgoing RPC. request \u2013 The request value for the RPC. An object that is both a Call for the RPC and an iterator of\nresponse values. Drawing response values from the returned\nCall-iterator may raise RpcError indicating termination of\nthe RPC with non-OK status. This object should also fulfill the\nFuture interface, though it may not. Intercepts a unary-unary invocation asynchronously. continuation \u2013 A function that proceeds with the invocation by\nexecuting the next interceptor in chain or invoking the\nactual RPC on the underlying Channel. It is the interceptor\u2019s\nresponsibility to call it if it decides to move the RPC forward.\nThe interceptor can use response_future = continuation(client_call_details, request) to continue with the RPC. continuation returns an object that is\nboth a Call for the RPC and a Future. In the event of RPC\ncompletion, the return Call-Future\u2019s result value will be\nthe response message of the RPC. Should the event terminate\nwith non-OK status, the returned Call-Future\u2019s exception value\nwill be an RpcError. client_call_details \u2013 A ClientCallDetails object describing the\noutgoing RPC. request \u2013 The request value for the RPC. An object that is both a Call for the RPC and a Future.\nIn the event of RPC completion, the return Call-Future\u2019s\nresult value will be the response message of the RPC.\nShould the event terminate with non-OK status, the returned\nCall-Future\u2019s exception value will be an RpcError. previous iqm.station_control.client.iqm_server.grpc_utils.to_proto_uuid next ClientCallDetails \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "ResponseWithMeta",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.list_models.ResponseWithMeta.html",
    "description": "Bases: PydanticBase , Generic [ T ] Class used for query endpoints to return metadata in addition to the returned items. Create a new model by parsing and validating input data from keyword arguments....",
    "content": "Bases: PydanticBase , Generic [ T ] Class used for query endpoints to return metadata in addition to the returned items. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.client.list_models Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. items  meta  Methods items ( list [ T ] ) \u2013 meta ( Meta | None ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous ObservationUpdateList next RunLiteList \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "pydantic_base",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.pydantic_base.html",
    "description": "Pydantic related models and types. Full path: iqm.station_control.interface.pydantic_base Classes PydanticBase Pydantic base model to change the behaviour of pydantic globally. Inheritance previous ty...",
    "content": "Pydantic related models and types. Full path: iqm.station_control.interface.pydantic_base Classes PydanticBase Pydantic base model to change the behaviour of pydantic globally. Inheritance previous type_aliases next PydanticBase \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "jobs",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.jobs.html",
    "description": "Job executor artifact and state models. Full path: iqm.station_control.interface.models.jobs Classes JobData Job response data model JobError Error log for a job. JobExecutorStatus Enumeration of diff...",
    "content": "Job executor artifact and state models. Full path: iqm.station_control.interface.models.jobs Classes JobData Job response data model JobError Error log for a job. JobExecutorStatus Enumeration of different states a job can be in. JobResult Progress information about a running job. TimelineEntry Status and timestamp pair as described in a job timeline. Inheritance previous GateInfo next JobData \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.iqm_server.iqm_server_client.parse_json",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.iqm_server_client.parse_json.html",
    "description": "data ( bytes ) \u2013 Any previous iqm.station_control.client.iqm_server.iqm_server_client.parse_calibration_set next iqm.station_control.client.iqm_server.iqm_server_client.payload_to_sweep \u00a9 Copyright 20...",
    "content": "data ( bytes ) \u2013 Any previous iqm.station_control.client.iqm_server.iqm_server_client.parse_calibration_set next iqm.station_control.client.iqm_server.iqm_server_client.payload_to_sweep \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.iqm_server.grpc_utils.from_proto_uuid",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.grpc_utils.from_proto_uuid.html",
    "description": "value ( Uuid ) \u2013 UUID previous iqm.station_control.client.iqm_server.grpc_utils.extract_error next iqm.station_control.client.iqm_server.grpc_utils.load_all \u00a9 Copyright 2019-2025, IQM Finland Oy, Rele...",
    "content": "value ( Uuid ) \u2013 UUID previous iqm.station_control.client.iqm_server.grpc_utils.extract_error next iqm.station_control.client.iqm_server.grpc_utils.load_all \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.serializers.run_serializers.serialize_run_definition",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.run_serializers.serialize_run_definition.html",
    "description": "Convert RunDefinition into run proto. run_definition ( RunDefinition ) \u2013 RunDefinition previous iqm.station_control.client.serializers.run_serializers.serialize_run_data next setting_node_serializer \u00a9...",
    "content": "Convert RunDefinition into run proto. run_definition ( RunDefinition ) \u2013 RunDefinition previous iqm.station_control.client.serializers.run_serializers.serialize_run_data next setting_node_serializer \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "Jobs",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.job_pb2_grpc.Jobs.html",
    "description": "Bases: object User job management APIs. Module: iqm.station_control.client.iqm_server.proto.job_pb2_grpc Methods CancelJobV1  GetJobPayloadV1  GetJobResultsV1  GetJobV1  SubmitJobV1  SubscribeToJobV1 ...",
    "content": "Bases: object User job management APIs. Module: iqm.station_control.client.iqm_server.proto.job_pb2_grpc Methods CancelJobV1  GetJobPayloadV1  GetJobResultsV1  GetJobV1  SubmitJobV1  SubscribeToJobV1  previous iqm.station_control.client.iqm_server.proto.job_pb2_grpc.add_JobsServicer_to_server next JobsServicer \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "dut",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.dut.html",
    "description": "DUT related interface models. Full path: iqm.station_control.interface.models.dut Classes DutData Represents a Device Under Test, or DUT, for short. DutFieldData A DUT field or path and its unit. Inhe...",
    "content": "DUT related interface models. Full path: iqm.station_control.interface.models.dut Classes DutData Represents a Device Under Test, or DUT, for short. DutFieldData A DUT field or path and its unit. Inheritance previous models next DutData \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "QualityMetrics",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.observation_set.QualityMetrics.html",
    "description": "Bases: ObservationSetWithObservations The content of the quality metric set stored in the database, with a list of observations and calibration set. Create a new model by parsing and validating input ...",
    "content": "Bases: ObservationSetWithObservations The content of the quality metric set stored in the database, with a list of observations and calibration set. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.observation_set Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. calibration_set  observations Observations belonging to the observation set. dut_label String representation of the DUT the observation set is associated with. observation_set_id Unique identifier of the observation set. created_timestamp Time when the object was created in the database. end_timestamp Time when the observation set was finalized. observation_set_type Indicates the type (i.e. purpose) of the observation set. observation_ids Database IDs of the observations belonging to the observation set. describes_id Unique identifier of the observation set this observation set describes. invalid Flag indicating if the object is invalid. Methods observation_set_type ( Literal [ 'calibration-set' , 'characterization-set' , 'generic-set' , 'quality-metric-set' ] ) \u2013 observation_ids ( list [ int ] ) \u2013 describes_id ( UUID | None ) \u2013 invalid ( bool ) \u2013 dut_label ( str | None ) \u2013 observation_set_id ( UUID ) \u2013 created_timestamp ( datetime ) \u2013 end_timestamp ( datetime | None ) \u2013 observations ( list [ ObservationLite ] ) \u2013 calibration_set ( ObservationSetData ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous ObservationSetWithObservations next run \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.iqm_server.iqm_server_client.payload_to_sweep",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.iqm_server_client.payload_to_sweep.html",
    "description": "job_payload ( bytes ) \u2013 SweepDefinition previous iqm.station_control.client.iqm_server.iqm_server_client.parse_json next iqm.station_control.client.iqm_server.iqm_server_client.resolve_current_qc \u00a9 Co...",
    "content": "job_payload ( bytes ) \u2013 SweepDefinition previous iqm.station_control.client.iqm_server.iqm_server_client.parse_json next iqm.station_control.client.iqm_server.iqm_server_client.resolve_current_qc \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "channel_property_serializer",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.channel_property_serializer.html",
    "description": "Serializers and deserializers for ChannelProperties Full path: iqm.station_control.client.serializers.channel_property_serializer Functions deserialize_channel_properties (...[,\u00a0...]) Convert the give...",
    "content": "Serializers and deserializers for ChannelProperties Full path: iqm.station_control.client.serializers.channel_property_serializer Functions deserialize_channel_properties (...[,\u00a0...]) Convert the given protobuf dictionary of channel properties into a dictionary of ChannelProperties . deserialize_instructions (instructions) Convert a repeated scalar container of instruction type strings into a tuple of python types. serialize_channel_properties (...) Pack the given dictionary of channel properties into a protobuf format for further serialization. unpack_channel_properties (payload[,\u00a0...]) Parse the Channel Property Dictionary from a string serialised protobuf payload. previous serializers next iqm.station_control.client.serializers.channel_property_serializer.deserialize_channel_properties \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "PydanticBase",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.pydantic_base.PydanticBase.html",
    "description": "Bases: BaseModel Pydantic base model to change the behaviour of pydantic globally.\nNote that setting model_config in child classes will merge the configs rather than override this one. https://docs.py...",
    "content": "Bases: BaseModel Pydantic base model to change the behaviour of pydantic globally.\nNote that setting model_config in child classes will merge the configs rather than override this one. https://docs.pydantic.dev/latest/concepts/config/#change-behaviour-globally Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.pydantic_base Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Methods Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous pydantic_base next station_control \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "JobStateTimestamp",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.monitor.JobStateTimestamp.html",
    "description": "Bases: PydanticBase Represents a single timestamped state for a job. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.Validation...",
    "content": "Bases: PydanticBase Represents a single timestamped state for a job. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.monitor Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. job_id  status  timestamp  Methods job_id ( UUID ) \u2013 status ( JobExecutorStatus ) \u2013 timestamp ( datetime ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous monitor next JobsInQueue \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "job_pb2_grpc",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.job_pb2_grpc.html",
    "description": "Client and server classes corresponding to protobuf-defined services. Full path: iqm.station_control.client.iqm_server.proto.job_pb2_grpc Functions add_JobsServicer_to_server (servicer,\u00a0server)  Class...",
    "content": "Client and server classes corresponding to protobuf-defined services. Full path: iqm.station_control.client.iqm_server.proto.job_pb2_grpc Functions add_JobsServicer_to_server (servicer,\u00a0server)  Classes Jobs User job management APIs. JobsServicer User job management APIs. JobsStub User job management APIs. Inheritance previous job_pb2 next iqm.station_control.client.iqm_server.proto.job_pb2_grpc.add_JobsServicer_to_server \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "IqmServerMockBase",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.testing.iqm_server_mock.IqmServerMockBase.html",
    "description": "Bases: QuantumComputersServicer , CalibrationsServicer , JobsServicer Base class for IQM server mocks. Only meant for testing IQM library packages, do not use outside of tests! Module: iqm.station_con...",
    "content": "Bases: QuantumComputersServicer , CalibrationsServicer , JobsServicer Base class for IQM server mocks. Only meant for testing IQM library packages, do not use outside of tests! Module: iqm.station_control.client.iqm_server.testing.iqm_server_mock Methods channel Gets a grpc.Channel that connects to this mock server instance. chunk_stream A utility function for converting a binary data blob into a`(stream DataChunk)`. parse_uuid Helper function for generating protobuf UUIDs proto_timestamp Helper function for generating protobuf timestamps proto_uuid Helper function for generating protobuf UUIDs Helper function for generating protobuf UUIDs base ( UUID | None ) \u2013 Uuid Helper function for generating protobuf UUIDs value ( Uuid ) \u2013 UUID Helper function for generating protobuf timestamps base ( datetime | None ) \u2013 Timestamp Gets a grpc.Channel that connects to this mock server instance. Can be used to initialize\na new IqmServerClient that uses this mock server instance as a backend for the\ninvoked GRPC calls. Channel A utility function for converting a binary data blob into a`(stream DataChunk)`. data ( bytes ) \u2013 Iterator [ DataChunk ] previous iqm_server_mock next list_models \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_definition",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_definition.html",
    "description": "Convert sweep proto into SweepDefinition. sweep_definition_proto ( SweepRequest ) \u2013 SweepDefinition previous iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_data next iqm.st...",
    "content": "Convert sweep proto into SweepDefinition. sweep_definition_proto ( SweepRequest ) \u2013 SweepDefinition previous iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_data next iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_results \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "calibration_pb2",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.calibration_pb2.html",
    "description": "Generated protocol buffer code. Full path: iqm.station_control.client.iqm_server.proto.calibration_pb2 previous proto next calibration_pb2_grpc \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. La...",
    "content": "Generated protocol buffer code. Full path: iqm.station_control.client.iqm_server.proto.calibration_pb2 previous proto next calibration_pb2_grpc \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.iqm_server.grpc_utils.extract_error",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.grpc_utils.extract_error.html",
    "description": "error ( RpcError ) \u2013 title ( str | None ) \u2013 IqmServerError previous iqm.station_control.client.iqm_server.grpc_utils.create_channel next iqm.station_control.client.iqm_server.grpc_utils.from_proto_uui...",
    "content": "error ( RpcError ) \u2013 title ( str | None ) \u2013 IqmServerError previous iqm.station_control.client.iqm_server.grpc_utils.create_channel next iqm.station_control.client.iqm_server.grpc_utils.from_proto_uuid \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.serializers.task_serializers.serialize_sweep_job_request",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.task_serializers.serialize_sweep_job_request.html",
    "description": "Wrap sweep_definition and queue_name into a protobuf message and serialize into a bitstring. sweep_definition ( SweepDefinition ) \u2013 The content of the sweep. queue_name ( str ) \u2013 Name of the destinati...",
    "content": "Wrap sweep_definition and queue_name into a protobuf message and serialize into a bitstring. sweep_definition ( SweepDefinition ) \u2013 The content of the sweep. queue_name ( str ) \u2013 Name of the destination queue. SweepTaskRequest encoded into a bitstring. bytes previous iqm.station_control.client.serializers.task_serializers.serialize_run_job_request next station_control \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "calibration_pb2_grpc",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc.html",
    "description": "Client and server classes corresponding to protobuf-defined services. Full path: iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc Functions add_CalibrationsServicer_to_server (servicer...",
    "content": "Client and server classes corresponding to protobuf-defined services. Full path: iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc Functions add_CalibrationsServicer_to_server (servicer,\u00a0...)  Classes Calibrations Missing associated documentation comment in .proto file. CalibrationsServicer Missing associated documentation comment in .proto file. CalibrationsStub Missing associated documentation comment in .proto file. Inheritance previous calibration_pb2 next iqm.station_control.client.iqm_server.proto.calibration_pb2_grpc.add_CalibrationsServicer_to_server \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.serializers.playlist_serializers.pack_playlist",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.playlist_serializers.pack_playlist.html",
    "description": "Pack the given playlist into a protobuf format for further serialization. playlist ( Playlist ) \u2013 playlist to pack playlist in protobuf format Playlist previous playlist_serializers next iqm.station_c...",
    "content": "Pack the given playlist into a protobuf format for further serialization. playlist ( Playlist ) \u2013 playlist to pack playlist in protobuf format Playlist previous playlist_serializers next iqm.station_control.client.serializers.playlist_serializers.unpack_playlist \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.serializers.channel_property_serializer.unpack_channel_properties",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.channel_property_serializer.unpack_channel_properties.html",
    "description": "Parse the Channel Property Dictionary from a string serialised protobuf payload. payload ( bytes ) \u2013 protobuf serialised payload of channel property dictionary. convert_instructions ( bool ) \u2013 whether...",
    "content": "Parse the Channel Property Dictionary from a string serialised protobuf payload. payload ( bytes ) \u2013 protobuf serialised payload of channel property dictionary. convert_instructions ( bool ) \u2013 whether to convert string representation of instruction types to actual\npython types. dict [ str , ChannelProperties ] previous iqm.station_control.client.serializers.channel_property_serializer.serialize_channel_properties next datetime_serializers \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "station_control",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.station_control.html",
    "description": "Station control interface. Full path: iqm.station_control.interface.station_control Classes StationControlInterface Station control interface. Inheritance previous PydanticBase next StationControlInte...",
    "content": "Station control interface. Full path: iqm.station_control.interface.station_control Classes StationControlInterface Station control interface. Inheritance previous PydanticBase next StationControlInterface \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.iqm_server.iqm_server_client.resolve_current_qc",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.iqm_server_client.resolve_current_qc.html",
    "description": "channel ( Channel ) \u2013 alias ( str ) \u2013 QuantumComputerV1 previous iqm.station_control.client.iqm_server.iqm_server_client.payload_to_sweep next iqm.station_control.client.iqm_server.iqm_server_client.s...",
    "content": "channel ( Channel ) \u2013 alias ( str ) \u2013 QuantumComputerV1 previous iqm.station_control.client.iqm_server.iqm_server_client.payload_to_sweep next iqm.station_control.client.iqm_server.iqm_server_client.subscribe_to_job_events \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "ObservationDefinition",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.observation.ObservationDefinition.html",
    "description": "Bases: ObservationBase The content of the observation definition. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationErr...",
    "content": "Bases: ObservationBase The content of the observation definition. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.observation Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. dut_label DUT label of the device the observation is about. source How the observation was made, e.g. experiment analysis or manual specification. tags Human-readable tags of the observation. dut_field Name of the property the observation is about. value Value of the observation. unit SI unit of the value. uncertainty Uncertainty of the observation value. invalid Flag indicating if the object is invalid. Methods dut_field ( str ) \u2013 value ( bool | str | int | float | complex | ndarray ) \u2013 unit ( str ) \u2013 uncertainty ( int | float | complex | ndarray | None ) \u2013 invalid ( bool ) \u2013 dut_label ( str ) \u2013 source ( dict [ str , Any ] ) \u2013 tags ( list [ str ] ) \u2013 DUT label of the device the observation is about. How the observation was made, e.g. experiment analysis or manual specification. source always has the key \"type\" whose str value determines the other contents of the dict.\nThe currently supported source types are:\n- analysis_source\n- configuration_source\n- measurement_source\n- sequence_analysis_source\n- specification_source Human-readable tags of the observation. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous ObservationData next ObservationLite \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "SweepBase",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.sweep.SweepBase.html",
    "description": "Bases: object Abstract base class of the sweep definition and data. Module: iqm.station_control.interface.models.sweep Attributes sweep_id Unique identifier of the sweep. dut_label DUT label of the de...",
    "content": "Bases: object Abstract base class of the sweep definition and data. Module: iqm.station_control.interface.models.sweep Attributes sweep_id Unique identifier of the sweep. dut_label DUT label of the device being used. settings A tree representation of the initial settings to set before the sweep. sweeps Sweeps that define the swept parameters, i.e. a list of parallel sweeps, where the data values of all sweeps in the tuple are interleaved, and updated simultaneously during the sweep. return_parameters Parameters that will be queried from devices and saved for each spot (variable-tuple) of the N-dimensional sweep. Methods sweep_id ( UUID ) \u2013 dut_label ( str ) \u2013 settings ( SettingNode ) \u2013 sweeps ( list [ tuple [ Sweep , ... ] ] ) \u2013 return_parameters ( list [ str ] ) \u2013 Unique identifier of the sweep. DUT label of the device being used. A tree representation of the initial settings to set before the sweep. Sweeps that define the swept parameters, i.e. a list of parallel sweeps,\nwhere the data values of all sweeps in the tuple are interleaved, and updated simultaneously during the sweep. Parameters that will be queried from devices and saved for each spot (variable-tuple)\nof the N-dimensional sweep. Each item must correspond to a setting name in settings . previous sweep next SweepData \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "sweep_serializers",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.serializers.sweep_serializers.html",
    "description": "Serializers and deserializers for sweep related models. Full path: iqm.station_control.client.serializers.sweep_serializers Functions deserialize_sweep_data (data) Convert JSON serializable dictionary...",
    "content": "Serializers and deserializers for sweep related models. Full path: iqm.station_control.client.serializers.sweep_serializers Functions deserialize_sweep_data (data) Convert JSON serializable dictionary into SweepData. deserialize_sweep_definition (...) Convert sweep proto into SweepDefinition. deserialize_sweep_results (sweep_results_str) Convert binary string into SweepResults. serialize_sweep_data (sweep_data) Convert SweepData into JSON serializable dictionary. serialize_sweep_definition (sweep_definition) Convert SweepDefinition into sweep proto. serialize_sweep_results (sweep_id,\u00a0sweep_results) Convert SweepResults into binary string. previous iqm.station_control.client.serializers.struct_serializer.serialize_struct next iqm.station_control.client.serializers.sweep_serializers.deserialize_sweep_data \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm_server_mock",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.testing.iqm_server_mock.html",
    "description": "Internal testing utilities for IqmServerClient Full path: iqm.station_control.client.iqm_server.testing.iqm_server_mock Classes IqmServerMockBase Base class for IQM server mocks. Inheritance previous ...",
    "content": "Internal testing utilities for IqmServerClient Full path: iqm.station_control.client.iqm_server.testing.iqm_server_mock Classes IqmServerMockBase Base class for IQM server mocks. Inheritance previous testing next IqmServerMockBase \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.interface.models.dynamic_quantum_architecture.Locus",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.dynamic_quantum_architecture.Locus.html",
    "description": "Names of the QPU components (typically qubits) a quantum operation instance is acting on, e.g. (\u201cQB1\u201d, \u201cQB2\u201d) . alias of tuple [ Annotated [ str ], \u2026] previous dynamic_quantum_architecture next Dynami...",
    "content": "Names of the QPU components (typically qubits) a quantum operation instance is acting on, e.g. (\u201cQB1\u201d, \u201cQB2\u201d) . alias of tuple [ Annotated [ str ], \u2026] previous dynamic_quantum_architecture next DynamicQuantumArchitecture \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "type_aliases",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.type_aliases.html",
    "description": "Type hint aliases used in the station control interface. Full path: iqm.station_control.interface.models.type_aliases previous SweepDefinition next pydantic_base \u00a9 Copyright 2019-2025, IQM Finland Oy,...",
    "content": "Type hint aliases used in the station control interface. Full path: iqm.station_control.interface.models.type_aliases previous SweepDefinition next pydantic_base \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "RunLiteList",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.list_models.RunLiteList.html",
    "description": "alias of ListModel[list[RunLite]] previous ResponseWithMeta next SequenceMetadataDataList \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07....",
    "content": "alias of ListModel[list[RunLite]] previous ResponseWithMeta next SequenceMetadataDataList \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "iqm.station_control.client.iqm_server.grpc_utils.parse_connection_params",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.iqm_server.grpc_utils.parse_connection_params.html",
    "description": "qc_url ( str ) \u2013 ConnectionParameters previous iqm.station_control.client.iqm_server.grpc_utils.load_all next iqm.station_control.client.iqm_server.grpc_utils.to_datetime \u00a9 Copyright 2019-2025, IQM Fi...",
    "content": "qc_url ( str ) \u2013 ConnectionParameters previous iqm.station_control.client.iqm_server.grpc_utils.load_all next iqm.station_control.client.iqm_server.grpc_utils.to_datetime \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "GateImplementationInfo",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.dynamic_quantum_architecture.GateImplementationInfo.html",
    "description": "Bases: PydanticBase Information about an implementation of a quantum gate/operation. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic...",
    "content": "Bases: PydanticBase Information about an implementation of a quantum gate/operation. Create a new model by parsing and validating input data from keyword arguments. Raises [ ValidationError ][pydantic_core.ValidationError] if the input data cannot be\nvalidated to form a valid model. self is explicitly positional-only to allow self as a field name. Module: iqm.station_control.interface.models.dynamic_quantum_architecture Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. loci Loci for which this gate implementation has been calibrated. Methods loci ( tuple [ tuple [ str , ... ] , ... ] ) \u2013 Loci for which this gate implementation has been calibrated. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous DynamicQuantumArchitecture next GateInfo \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "observation",
    "url": "/iqm-station-control-client/api/iqm.station_control.interface.models.observation.html",
    "description": "Observation related station control interface models. Full path: iqm.station_control.interface.models.observation Classes ObservationBase Abstract base class of the observation models. ObservationData...",
    "content": "Observation related station control interface models. Full path: iqm.station_control.interface.models.observation Classes ObservationBase Abstract base class of the observation models. ObservationData The content of the observation stored in the database. ObservationDefinition The content of the observation definition. ObservationLite The lightweight version of the observation data. ObservationUpdate The observation data to be updated in the database. Inheritance previous QueueState next ObservationBase \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-station-control-client",
    "title": "ObservationDefinitionList",
    "url": "/iqm-station-control-client/api/iqm.station_control.client.list_models.ObservationDefinitionList.html",
    "description": "alias of ListModel[list[ObservationDefinition]] previous ObservationDataList next ObservationLiteList \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07....",
    "content": "alias of ListModel[list[ObservationDefinition]] previous ObservationDataList next ObservationLiteList \u00a9 Copyright 2019-2025, IQM Finland Oy, Release 9.4.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "Training the QAOA",
    "url": "/iqm-qaoa/Training the QAOA.html",
    "description": "In this notebook we showcase (and compare) various strategies of training the QAOA, that is finding the optimal values for the variational parameters (also known as QAOA angles ). We start by generati...",
    "content": "In this notebook we showcase (and compare) various strategies of training the QAOA, that is finding the optimal values for the variational parameters (also known as QAOA angles ). We start by generating a quasi-random instance of the maxcut problem (with 10 nodes). Generate a QAOA instance from the problem instance. We use the TreeQAOA class, which is identical to the QUBOQAOA class, but it contains one extra way to \u201ctrain\u201d the QAOA parameters. For training the QAOA, we will use various estimators . An estimator is a function (technically a class with a method) which takes a QAOA object and calculates/estimates the expectation value of the Hamiltonian. Similarly, a sampler takes a QAOA object and generates samples (measurement results) of possible solutions. Here we also set up a variable results to store the results of our experiments, for comparison. It\u2019s a dictionary of dictionaries, keyed first by the training method and then by the QAOA number of layers. We start with EstimatorSingleLayer . For single-layer QAOA, the expectation values of 1- and 2-qubit operators can be calculated analytically. This estimator does the calculation. Next, we train using EstimatorStateVector . This estimator runs the statevector simulation of the QAOA circuit to calculate the expectation value of the Hamiltonian. Next, we train using EstimatorFromSampler together with SamplerSimulation . This estimator calls a given sampler and uses the obtained samples to estimate the expectation value (by calculating the energy of each of the samples and averaging them out). The SamplerSimulation runs the simulation of the QAOA circuit, including the measurements. Next, we again use EstimatorFromSampler together with SamplerSimulation . But this time we calculate not the expectation value , but the conditional value at risk at 0.1 level. We use this value in training the QAOA, possibly changing the performance. Next, we train using EstimatorFromSampler again, but this time together with SamplerResonance . This sampler actually runs the circuit via Resonance, IQM\u2019s cloud quantum computing platform. WARNING When running training using this estimator, Resonance is used for every training cycle, potentially taking a lot of time (even when using a mock QC)! The if clause surrounding the cell makes sure that it\u2019s skipped during testing (because it\u2019s too slow). Now we \u201ctrain\u201d the angles by setting them to the Tree QAOA angles. The Tree QAOA angles are the optimal angles for problems on regular infinite random graphs, where the neighborhood of each node is a tree graph. These angles are pre-calculated for various values of graph regularity and parameters of the Hamiltonian. The method set_tree_angles looks at the parameters of our problem and sets the QAOA angles to the corresponding Tree QAOA angles. While these angles aren\u2019t likely the most optimal angles for our problem, they are likely to produce good results and it allows us to skip conventional QAOA training completely. More reading on Tree QAOA For comparison we now repeat all of the above (except for EstimatorSingleLayer ) for QAOA with 2 layers and summarize the data in a table. We expect the Statevector , Simulated Samples and the Single Layer methods to perform the best (although none of them is scalable). Using CVaR instead of the mean gives better results, but this is expected, given that we\u2019re looking at a tail of a distribution. Whether it actually helps in training the QAOA is not clear. We expect all methods to improve with increasing p . previous Portfolio Optimization next API Reference By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "Sparse Maxcut",
    "url": "/iqm-qaoa/Sparse Maxcut.html",
    "description": "The purpose of this notebook is to showcase the QAOA library working from the problem definition all the way to execution on a real hardware. In particular, here we use QAOA to solve an instance of a ...",
    "content": "The purpose of this notebook is to showcase the QAOA library working from the problem definition all the way to execution on a real hardware. In particular, here we use QAOA to solve an instance of a random sparsely-connected max-cut problem. Maxcut is a graph problem, but internally the QAOA library converts it to a quadratic binary optimization problem (QUBO). We will solve a problem of size problem_size , i.e., this will be the size of the graph, the number of binary variables and also the number of qubits that we use. The number of shots is set to default maximum on Resonance. We create an instance of the max-cut problem of size problem_size , on a 3-regular random graph.\nWe print out the largest, lowest and average energy of the model, calculated by brute-forcing over all possible bitstrings of length problem_size . This may be slow if problem_size has been set higher than ~30. In the following, we set up the connection to Resonance and define a simulator backend of the Garnet and Sirius QPUs. We will run the QAOA on both and compare the results. Note: in general, you also need to specify the \u2018usage mode\u2019. For running on a real machine (in pay-as-you-go usage mode), the url would change to https://cocos.resonance.meetiqm.com/garnet. For a specific timeslot the url would change to https://cocos.resonance.meetiqm.com/garnet:timeslot Create the QUBO QAOA instance from the problem instance and train it. The train method has several possible parameters, but here the default setting is used (which uses analytical formulas since the QAOA has one layer). Once the QAOA is trained, we can use the QPU to sample from it and to use the samples for estimating the expected value of the Hamiltonian. For that we need to define a sampler and an estimator . There are several other samplers and estimators available in the QAOA library. Here we use the sampler which samples from a given QPU (via Resonance) and the estimator which uses this sampler to provide samples from which the expected value of the Hamiltonian is calculated. We don\u2019t need the samples here for anything, so we\u2019ll discard them. Same as the above, except on the star QPU. Running circuits on the star uses fewer 2QB gates, but requires considerably larger circuit depth (because only one 2QB gate can be done at a time). previous SK Model and Transpilation next Portfolio Optimization By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "Contributors",
    "url": "/iqm-qaoa/authors.html",
    "description": "Jiri Guth Jarkovsky < jiri . guthjarkovsky @ meetiqm . com > Elisabeth Wybo < elisabeth . wybo @ meetiqm . com > Martin Leib < martin . leib @ meetiqm . com > Jalil Khatibi Moqadam < jalil . khatibi @...",
    "content": "Jiri Guth Jarkovsky < jiri . guthjarkovsky @ meetiqm . com > Elisabeth Wybo < elisabeth . wybo @ meetiqm . com > Martin Leib < martin . leib @ meetiqm . com > Jalil Khatibi Moqadam < jalil . khatibi @ meetiqm . com > Ricardas Brazinkas < ricardas . brazinkas @ meetiqm . com > Jami R\u00f6nkk\u00f6 < jami @ meetiqm . com > previous License next Changelog By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "API Reference",
    "url": "/iqm-qaoa/API.html",
    "description": "iqm.applications Classes and tools for defining problem instances. iqm.qaoa IQM QAOA previous Training the QAOA next iqm.applications By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on...",
    "content": "iqm.applications Classes and tools for defining problem instances. iqm.qaoa IQM QAOA previous Training the QAOA next iqm.applications By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "Portfolio Optimization",
    "url": "/iqm-qaoa/Portfolio Optimization.html",
    "description": "The purpose of this notebook is to showcase the QAOA library working from the problem definition all the way to execution on a real hardware. In particular, here we use QAOA to solve a particular inst...",
    "content": "The purpose of this notebook is to showcase the QAOA library working from the problem definition all the way to execution on a real hardware. In particular, here we use QAOA to solve a particular instance of portfolio optimization. First, we describe the problem: we have n_assets assets, each with an expected_return . The variable containing the covariances and variances is called cov_mat . The goal is to choose a set of assets which maximize the yield, while minimizing the covariance, weighted by the investor\u2019s risk_aversion (the higher, the more likely the investor is to avoid risk). The budget says how many assets we can buy. Within the QAOA library, quadratic binary optimization problems are represented as objects of BinaryQuadraticModel or ConstrainedQuadraticModel from the dimod package ( read more about the models here ). In order to define a custom constrained problem in our QAOA library ( ConstrainedQuadraticInstance ), we need to create a custom object of ConstrainedQuadraticModel , by defining the objective and the constraint. The objective is the expected return minus the variance of the portfolio weighted by the risk aversion. The constraint has the identity matrix on the left-hand side (i.e., the number of selected assets) and the budget on the right-hand side. In the following, we set up the connection to Resonance and define a simulator backend of the Garnet QPU. Note: in general, you also need to specify the \u2018usage mode\u2019. For running on a real machine (in pay-as-you-go usage mode), the url would change to https://cocos.resonance.meetiqm.com/garnet. For a specific timeslot the url would change to https://cocos.resonance.meetiqm.com/garnet:timeslot Create the QUBO QAOA instance from the problem instance and train it. The train method has several possible parameters, but here the default setting is used (which uses analytical formulas since the QAOA has one layer). Sample for a solution from the QAOA and post-process the result (removing the samples violating the constraint). The sample method of my_qaoa typically expects a number of shots. By omitting this parameter, it defaults to 20 000, the default maximum number on Resonance. The format of the samples is a dictionary whose keys are bitstrings (the individual samples that were taken) and whose values are integers (the number of times each sample was taken). We may now examine the found solutions. previous Sparse Maxcut next Training the QAOA By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "IQM QAOA",
    "url": "/iqm-qaoa/index.html",
    "description": "1.6.0 2025-07-07 Python implementation of the Quantum Approximate Optimization Algorithm (QAOA), compatible with IQM quantum computers. Index Module Index Search Page next IQM QAOA By IQM QAOA develop...",
    "content": "1.6.0 2025-07-07 Python implementation of the Quantum Approximate Optimization Algorithm (QAOA), compatible with IQM quantum computers. Index Module Index Search Page next IQM QAOA By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "References",
    "url": "/iqm-qaoa/references.html",
    "description": "Michel\u00a0X. Goemans and David\u00a0P. Williamson. Improved approximation algorithms for maximum cut and satisfiability problems using semidefinite programming. J. ACM , 42(6):1115\u20131145, November 1995. URL: h...",
    "content": "Michel\u00a0X. Goemans and David\u00a0P. Williamson. Improved approximation algorithms for maximum cut and satisfiability problems using semidefinite programming. J. ACM , 42(6):1115\u20131145, November 1995. URL: https://doi.org/10.1145/227683.227684 , doi:10.1145/227683.227684 . Asier Ozaeta, Wim van Dam, and Peter\u00a0L McMahon. Expectation values from the single-layer quantum approximate optimization algorithm on ising problems. Quantum Science and Technology , Dec 2020. arXiv:2012.03421 . J.\u00a0A. Montanez-Barrera and Kristel Michielsen. Towards a universal QAOA protocol: evidence of a scaling advantage in solving some combinatorial optimization problems. https://arxiv.org/abs/2405.09169 , May 2024. Johannes Weidenfeller, Lucia\u00a0C. Valor, Julien Gacon, Caroline Tornow, Luciano Bello, Stefan Woerner, and Daniel\u00a0J. Egger. Scaling of the quantum approximate optimization algorithm on superconducting qubit based hardware. Quantum , 6:870, Dec 2022. URL: http://dx.doi.org/10.22331/q-2022-12-07-870 , doi:10.22331/q-2022-12-07-870 . J.\u00a0Misra and David Gries. A constructive proof of vizing's theorem. Information Processing Letters , 41(3):131\u2013133, 1992. URL: https://www.sciencedirect.com/science/article/pii/002001909290041S , doi:https://doi.org/10.1016/0020-0190(92)90041-S . Ayse Kotil, Fedor Simkovic, and Martin Leib. Improved qubit routing for QAOA circuits. https://arxiv.org/abs/2312.15982 , Dec 2023. Elisabeth Wybo and Martin Leib. Missing puzzle pieces in the performance landscape of the quantum approximate optimization algorithm. 2024. URL: https://arxiv.org/abs/2406.14618 , arXiv:2406.14618 . previous Changelog By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "IQM QAOA",
    "url": "/iqm-qaoa/readme.html",
    "description": "Usually it makes sense to use a new Python environment, to isolate your setup from the global Python installation. That way, you can play around without messing the rest of your system. Using uv in te...",
    "content": "Usually it makes sense to use a new Python environment, to isolate your setup from the global Python installation. That way, you can play around without messing the rest of your system. Using uv in terminal: Using Conda in terminal: In Visual Studio Code: Open the list of commands Ctrl + Shift + p . Select Python: Create Environment . Select Venv . Select the correct Python version. Then run If you have already installed the QAOA library and want to get the latest release you can add the --upgrade flag Documentation for the latest version is available online . previous IQM QAOA next Usage Examples By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "SK Model and Transpilation",
    "url": "/iqm-qaoa/SK Model and Transpilation.html",
    "description": "The purpose of this notebook is to showcase the QAOA library working from the problem definition all the way to execution on a real hardware. In particular, here we use QAOA to solve an instance of th...",
    "content": "The purpose of this notebook is to showcase the QAOA library working from the problem definition all the way to execution on a real hardware. In particular, here we use QAOA to solve an instance of the Sherrington-Kirkpatrick (SK) model, a very densely connected problem, to illustrate the advantage of using our custom transpiler over the Qiskit default transpiler. The SK model describes a number of binary variables, every pair of which interacts with a random interaction strength. We will solve a problem of size problem_size , i.e., this will be the number of binary variables and also the number of qubits that we use. The number of shots is set to default maximum on Resonance. We create an instance of the SK model of size problem_size . We specify the random distribution of the interactions between the variables to be \u201cgaussian\u201d (with mean 0 and variance 1). A few other distributions are possible (e.g., \u201cuniform\u201d or \u201crademacher\u201d). We print out the largest, lowest and average energy of the model, calculated by brute-forcing over all possible bitstrings of length problem_size . This may be slow if problem_size has been set higher than ~30. In the following, we set up the connection to Resonance and define a simulator backend of the Garnet QPU. Note: in general, you also need to specify the \u2018usage mode\u2019. For running on a real machine (in pay-as-you-go usage mode), the url would change to https://cocos.resonance.meetiqm.com/garnet. For a specific timeslot the url would change to https://cocos.resonance.meetiqm.com/garnet:timeslot Create the QUBO QAOA instance from the problem instance, train it and then construct the QAOA circuits using 4 different methods: The perfect circuit without any transpilation. The circuit transpiled for IQM hardware, using Qiskit default transpilation function. The circuit transpiled for IQM hardware, using our custom transpiler. The circuit transpiled for IQM hardware, using the swap network strategy. The train method has several possible parameters, but here the default setting is used (which uses analytical formulas since the QAOA has one layer). Run the perfect circuit on perfect (noiseless simulator), print out the average energy of the samples. Run the Qiskit-transpiled circuit on our hardware, print out the average energy of the samples and the number of gates used. Run the custom-transpiled circuit on our hardware, print out the average energy of the samples and the number of gates used. Run the swap-network-transpiled circuit on our hardware, print out the average energy of the samples and the number of gates used. If everything went as expected, the hardwired transpiler and the swap network transpiler should perform better than the qiskit default transpiler. The hardwired transpiler minimizes the number of 2QB gates used whereas the swap network transpiler minimizes the overall depth of the circuit. Based on the average energy obtained with the two approaches, we can judge which is better for our hardware (and this particular problem size). previous Usage Examples next Sparse Maxcut By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "Usage Examples",
    "url": "/iqm-qaoa/examples.html",
    "description": "previous IQM QAOA next SK Model and Transpilation By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07....",
    "content": "previous IQM QAOA next SK Model and Transpilation By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "plot_edge_coloring",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.sparse.edge_coloring.plot_edge_coloring.html",
    "description": "A method that plots the edge coloring of a graph. Careful! Here the variable color_palette is a list of strings, to convey the colors for plotting the graph.\nIt maps the colors as integers (i.e., indi...",
    "content": "A method that plots the edge coloring of a graph. Careful! Here the variable color_palette is a list of strings, to convey the colors for plotting the graph.\nIt maps the colors as integers (i.e., indices of the list) into strings which actually describe the color to plot,\ne.g., \u2018r\u2019 for red. This is different from other function in this module where color_palette is a set of\nintegers. graph ( Graph ) \u2013 A Graph whose edge coloring we want to plot. pos ( dict [ int , tuple [ float , float ] ] | None ) \u2013 A dictionary of positions for drawing graph (i.e., the layout). If not provided, it defaults to\nthe circular layout. color_palette ( list [ str ] | None ) \u2013 A list of strings describing the colors to use in the plot. default_color ( str ) \u2013 The color to use for edges that don\u2019t have a color assigned to them yet. None previous find_edge_coloring next iqm.qaoa.transpiler.sparse.greedy_router By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "greedy_max_cut",
    "url": "/iqm-qaoa/api/iqm.applications.maxcut.greedy_max_cut.html",
    "description": "Standard greedy algorithm for maxcut problem class. Steps: Start with a random assignment of nodes in two groups. Iterate over all nodes For each node, switch it to the other group if it improves the ...",
    "content": "Standard greedy algorithm for maxcut problem class. Steps: Start with a random assignment of nodes in two groups. Iterate over all nodes For each node, switch it to the other group if it improves the cost function. Repeat steps 2-3 until no node can be switched. Return the final assignment. max_cut_problem ( MaxCutInstance | Graph ) \u2013 A problem instance of maxcut or a Graph . A bitstring solution. str previous goemans_williamson next maxcut_generator By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa.transpiler.sparse",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.sparse.html",
    "description": "The submodule for greedy transpilation for sparse QAOA circuits. Subpackages and modules edge_coloring The module for the edge-coloring of the graph. greedy_router The main module of the greedy routin...",
    "content": "The submodule for greedy transpilation for sparse QAOA circuits. Subpackages and modules edge_coloring The module for the edge-coloring of the graph. greedy_router The main module of the greedy routing algorithm. two_color_mapper This file contains the two_color_mapper() function which creates the initial Mapping . previous sn_router next iqm.qaoa.transpiler.sparse.edge_coloring By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "ProblemInstance",
    "url": "/iqm-qaoa/api/iqm.applications.applications.ProblemInstance.html",
    "description": "Bases: ABC The abstract base class for defining problem instances. Currently, only problems with binary variables are supported. Any possible candidate solution is therefore\nrepresented by a bitstring...",
    "content": "Bases: ABC The abstract base class for defining problem instances. Currently, only problems with binary variables are supported. Any possible candidate solution is therefore\nrepresented by a bitstring (a string of 1\u2019s and 0\u2019s). The abstract methods dim() and quality() are meant to be overridden by children classes, depending on\nhow the dimension of the problem and the quality of the solution are understood. The upper/lower bound, average/best quality attributes start as None . The first time one of them is called, it\ncalls the method initialize_properties() , which calculates all of them by brute-forcing over all bitstrings\nrepresenting solution candidates. Attributes average_quality The average quality value over all possible bitstrings. best_quality The best quality value over all possible bitstrings. dim The dimension of the problem (e.g., the number of nodes in a problem graph). lower_bound The lowest quality value among all possible bitstrings. upper_bound The highest quality value among all possible bitstrings. Methods average_quality_counts (counts) Accepts a dictionary and returns the average quality of the keys weighted by their values. average_quality_renormalized (counts) Accepts a dictionary and returns the renormalized quality of the keys weighted by their values. cvar (counts[,\u00a0quantile]) Calculates the Conditional Value at Risk (CVaR) of the given dictionary of counts at the given quantile. fix_variables (variables) Fixes (assigns) some of the problem variables. initialize_properties ([max_size]) The initialization method for upper/lower bound of the cost function and its average/best value. local_bitflip_bitstring (bit_str) Post-processing which takes a bitstring and replaces it with its lowest-energy unit Hamming distance neighbor. local_bitflip_postprocessing (counts) Postprocessing method for checking a unit Hamming distance neighborhood of the dictionary of counts. percentile_counts (counts,\u00a0quantile[,\u00a0...]) A method that selects only the best / worst quantile of given counts , measured by quality() . quality (bit_str) Accepts a bitstring and returns its quality / energy (the smaller the better). quality_renormalized (bit_str) Accepts a bitstring and returns renormalized quality of that bitstring. restore_fixed_variables (counts) Postprocessing method for restoring fixed variables to the measurement bitstrings. The dimension of the problem (e.g., the number of nodes in a problem graph). Accepts a bitstring and returns its quality / energy (the smaller the better). bit_str ( str ) \u2013 The bitstring representing a solution candidate. float Fixes (assigns) some of the problem variables. variables ( list [ Hashable ] | dict [ Hashable , int ] ) \u2013 Either a list of variables (which get all fixed to the value 1) or a dictionary with keys equal\nto the variables to fix and whose values are equal to the values to fix them to (either 1 or 0). None The initialization method for upper/lower bound of the cost function and its average/best value. The quantities are calculated by brute force (scaling exponentially). By default, using this with problem sizes\nlarger than max_size (default 30) will raise ValueError. This can be bypassed by making max_size larger\nor setting it to None . max_size ( int | None ) \u2013 The maximum size of problems for which the properties may be calculated. ValueError \u2013 If initialize_properties() was called on a ProblemInstance object with dimension\n    larger than max_size . None The highest quality value among all possible bitstrings. Can be calculated together with other bounds using the brute-force initialize_properties() . Shouldn\u2019t be\nmodified by a user. The lowest quality value among all possible bitstrings. Can be calculated together with other bounds using the brute-force initialize_properties() . Shouldn\u2019t be\nmodified by a user. The average quality value over all possible bitstrings. Can be calculated together with bounds using the brute-force initialize_properties() . Shouldn\u2019t be\nmodified by a user. Meant to be used in comparison with QAOA results to see how much (if at all)\nthe optimization improves over uniformly random guessing. The best quality value over all possible bitstrings. For minimization problems, this is equal to lower_bound . Like similar properties, it can be calculated\nusing the brute-force initialize_properties() . Shouldn\u2019t be modified by a user. Meant to be used in\ncomparison with QAOA results to see how close the optimization gets to the ideal best solution. Accepts a bitstring and returns renormalized quality of that bitstring. The quality is renormalized using best_quality and average_quality . A value of 1 corresponds to the best solution. A value of 0 corresponds to average quality. A value above/under 0 corresponds to better/worse than average quality. bit_str ( str ) \u2013 The bitstring representing a solution. The renormalized quality of the solution as a float. float Accepts a dictionary and returns the average quality of the keys weighted by their values. The input dictionary has the format of \u201ccounts\u201d from a qiskit experiment. The keys are bitstrings\n(representing possible solutions) and the values are their respective counts, i.e., the number of times\nthat the particular string was sampled from a QAOA run. The quality is calculated by quality() . counts ( dict [ str , int ] ) \u2013 A dictionary whose keys are solution bitstrings and whose values are the respective counts. Average quality of the bitstrings, weighted by their counts. ValueError \u2013 If the number of measurements in counts is 0 (e.g., if it\u2019s an empty dictionary). float Accepts a dictionary and returns the renormalized quality of the keys weighted by their values. Calculates the average weighted quality using average_quality_counts() and renormalizes it using best_quality and average_quality . A value of 1 corresponds to the best solution. A value of 0 corresponds to average quality. A value above/under 0 corresponds to better/worse than average quality. counts ( dict [ str , int ] ) \u2013 A dictionary whose keys are solution bitstrings and whose values are the respective counts. Average quality of the bitstrings, weighted by their counts and renormalized. float Postprocessing method for restoring fixed variables to the measurement bitstrings. When variables are fixed, the number of variables of the (remaining) problem is reduced. When the problem is\nsolved (e.g., by a quantum computer), the solutions doesn\u2019t include the fixed variables. This method takes\na dictionary of solutions (e.g., the counts from a quantum computer) and modifies the keys (bitstrings) by\ninserting the fixed variables where they belong. counts ( dict [ str , int ] ) \u2013 A dictionary whose keys are bitstrings (solutions) and whose values are integers (their respective\nfrequencies) The input dictionary corrected by inserting the fixed variables into the keys, where they belong. dict [ str , int ] Post-processing which takes a bitstring and replaces it with its lowest-energy unit Hamming distance\nneighbor. Takes the solution bitstring and then iteratively swaps each bit in it. The function returns the lowest-energy\nbitstring from all of these bitstrings (including the original bitstring). bit_str ( str ) \u2013 The bitstring to be replaced by its lowest-energy unit Hamming distance neighbor. The replaced bitstring. str Postprocessing method for checking a unit Hamming distance neighborhood of the dictionary of counts. When implemented naively, the time complexity of this scales cubically \\(\\mathcal{O}(n^3)\\) in the number\nof variables (linear from iterating over them and quadratic from calculating the energy), but some computation\nmight be saved in the calculation of the energy because it\u2019s repeatedly calculated for very similar bitstrings. counts ( dict [ str , int ] ) \u2013 A dictionary whose keys are bitstrings (solutions) and whose values are integers (their respective\nfrequencies) The input dictionary modified by replacing each bitstring by its lowest-energy neigbor. dict [ str , int ] A method that selects only the best / worst quantile of given counts , measured by quality() . The quantile is weighted by the frequencies (counts) of the bitstrings. If multiple bitstrings around\nthe quantile have the same quality, the order is selected arbitrarily (or rather, based on how the built-in sorted function sorts them). If a bitstring has counts that cross the quantile , its counts in the output\nare adjusted to match the quantile exactly (at least rounded to the nearest integer). counts ( dict [ str , int ] ) \u2013 The input dictionary of counts. quantile ( float ) \u2013 The quantile of counts to be selected. best_percentile ( bool ) \u2013 Boolean saying whether the \u201cbest\u201d (lowest quality) or the \u201cworst\u201d (highest) bitstrings\nshould be selected. A dictionary of counts, with only the best / worse bitstrings selected. ValueError \u2013 If the quantile is not between 0 and 1 (included). dict [ str , int ] Calculates the Conditional Value at Risk (CVaR) of the given dictionary of counts at the given quantile. The CVaR is the average of the worst-case quantile of the data. In the case of training QAOA, it\u2019s often\nused to calculate the average of the best quantile of samples. counts ( dict [ str , int ] ) \u2013 The given dictionary of counts. quantile ( float ) \u2013 The given quantile. Since it\u2019s common to calculate the CVaR at 5%, that\u2019s the default value for\nthis variable The CVaR of the counts. float previous iqm.applications.applications next iqm.applications.maxcut By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa.transpiler.quantum_hardware",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.quantum_hardware.html",
    "description": "The module for classes representing various QPU architectures. The module also contains four type aliases, which are imported by other modules for more clear type hinting. Module Attributes LogQubit A...",
    "content": "The module for classes representing various QPU architectures. The module also contains four type aliases, which are imported by other modules for more clear type hinting. Module Attributes LogQubit A custom type alias for int to refer to logical / problem qubits. HardQubit A custom type alias for int to refer to hardware qubits. LogEdge A custom type alias for frozenset of LogQubit to refer to interactions between logical qubits. HardEdge A custom type alias of frozenset of HardQubit to refer to interactions between hardware qubits. Classes CrystalQPUFromBackend (backend) Class for a QPU with square lattice topology, initialited from an IQMBackend object. Grid2DQPU (num_rows,\u00a0num_columns) Class for 2D rectangular QPU. LineQPU (length) A linear QPU (qubits on a line). QPU (hardware_graph[,\u00a0hardware_layout]) A parent class for all QPU architectures. StarQPU (n) A star-shaped QPU (Daneb, Sirius, ...). Inheritance previous hardwired_router next LogQubit By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "SamplerBackend",
    "url": "/iqm-qaoa/api/iqm.qaoa.backends.SamplerBackend.html",
    "description": "Bases: ABC The ABC for sampler backends, i.e., those returning samples from the QAOA. Methods sample (qaoa_object,\u00a0shots) The abstract method for sample() of backends subclassed from SamplerBackend . ...",
    "content": "Bases: ABC The ABC for sampler backends, i.e., those returning samples from the QAOA. Methods sample (qaoa_object,\u00a0shots) The abstract method for sample() of backends subclassed from SamplerBackend . The abstract method for sample() of backends subclassed from SamplerBackend . qaoa_object ( QAOA ) \u2013 A QAOA object to be sampled from. shots ( int ) \u2013 The number of individual samples to take. A dictionary of samples. The keys are bitstrings and the values are their counts (which should add up to shots ) dict [ str , int ] previous EstimatorStateVector next SamplerRandomBitstrings By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "Routing",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.routing.Routing.html",
    "description": "Bases: object This class represents a routing of a QAOA phase separator. A Routing object is intended to be directly used by a router during routing\n(any router). To that end it maintains a list of La...",
    "content": "Bases: object This class represents a routing of a QAOA phase separator. A Routing object is intended to be directly used by a router during routing\n(any router). To that end it maintains a list of Layer objects,\na Graph with the interactions not implemented yet and\na Mapping object that represents the current status of mapping between\nhardware and logical qubits. A router interacts with a Routing object by using the methods apply_swap() and apply_int() . Optionally also attempt_apply_int() . If the problem BQM contains\ninteractions of strength 0 (e.g., because of padding), those won\u2019t be added into the list of layers. When the method apply_int() is called on those interactions, it is skipped. problem_bqm ( BinaryQuadraticModel ) \u2013 The optimization problem represented as BinaryQuadraticModel . qpu ( QPU ) \u2013 The QPU representing the hardware qubit topology. initial_mapping ( Mapping | None ) \u2013 The starting mapping of the logical-to-hardware qubits. Attributes active_subgraph The topology of the QPU that is being used in the routing. Methods apply_int (gate) Apply interaction gate at the earliest possible Layer , add a new layer if necessary. apply_swap (gate[,\u00a0attempt_int]) Apply swap gate at the earliest possible Layer , add a new layer if needed. attempt_apply_int (gate) This is a softer version of apply_int() . build_qiskit (betas,\u00a0gammas) Build the QAOA circuit from the Routing ( self ) in qiskit . count_swap_gates () Counts the number of swap gates in all Layer s so far. draw () Plot all Layer s of the routing in batches of 9. The topology of the QPU that is being used in the routing. Apply swap gate at the earliest possible Layer , add a new layer if\nneeded. Goes through the existing Layer s from the end and tries to apply a swap\ngate between the qubits defined in gate at the earliest possible Layer . That means, as early as possible without crossing any other swap or\ninteraction acting on the same HardQubit s. gate ( HardEdge ) \u2013 An edge between two HardQubit s where the swap should\nbe applied. attempt_int ( bool ) \u2013 Boolean saying whether an interaction gate should be combined with the swap. ValueError \u2013 If there is no edge connecting the two hardware qubits in gate on the hardware graph. None Apply interaction gate at the earliest possible Layer , add a new layer\nif necessary. Goes through the existing Layer s from the end and tries to apply\nan interaction gate between the qubits defined in gate at the earliest possible Layer . That means, as early as possible without crossing any other swap or\ninteraction acting on the same HardQubit s. If an interaction has\nstrength 0, it isn\u2019t added! gate ( HardEdge ) \u2013 An edge between two HardQubit s where the interaction\nshould be applied. ValueError \u2013 If there is no edge connecting the two hardware qubits in gate on the hardware graph. ValueError \u2013 If there is no interaction to be applied between the two corresponding logical qubits. None This is a softer version of apply_int() . It first checks if there is an interaction to be done and doesn\u2019t do anything if there isn\u2019t, as opposed to\nraising an error. This method is made for cases when it\u2019s not clear whether an interaction has been applied\nbetween two logical qubits already. gate ( HardEdge ) \u2013 An edge between two HardQubit s where the interaction\nshould be applied. None Counts the number of swap gates in all Layer s so far. int Build the QAOA circuit from the Routing ( self ) in qiskit . The Routing ( self ) contains all the information needed to create\nthe phase separator part of the QAOA circuit. This method builds the rest of the circuit from it, i.e.: It initializes the qubits in the \\(| + >\\) state by applying the Hadamard gate to all of them. It applies the interactions by going through the Layer s of\nthe Routing . It applies local fields. It applies the driver. It repeats steps 2-4 until it uses up all betas and gammas . It applies the measurements and barrier before them. betas ( list [ float ] ) \u2013 The QAOA parameters to be used in the driver ( RX gate). gammas ( list [ float ] ) \u2013 The QAOA parameters to be used in the phase separator ( RZ and RZZ gates). A complete QAOA QuantumCircuit . QuantumCircuit Plot all Layer s of the routing in batches of 9. This creates a series of plots that are shown on the screen. Each plot contains 9 Layer s arranged in a 3x3 grid. Each Layer is drawn using draw() .\nTherefore, it has the shape of the QPU topology with edges colored based on what is happening on them in\nthe given Layer . Yellow highlight if a combination of swap and int is applied. Blue highlight if a swap gate is applied. Green highlight if an interaction gate is applied. No highlight (black) if nothing is happening along the edge. None previous Mapping next iqm.qaoa.transpiler.rx_to_nx By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.applications.qubo",
    "url": "/iqm-qaoa/api/iqm.applications.qubo.html",
    "description": "Contains problem instance classes for a generic QUBO problem and a genetic constrained QUBO problem. While objects of these classes can be instantiated, it\u2019s generally not recommended. For problems wi...",
    "content": "Contains problem instance classes for a generic QUBO problem and a genetic constrained QUBO problem. While objects of these classes can be instantiated, it\u2019s generally not recommended. For problems with any added\nstructure, it is recommended to use sub-classes (children) of these classes, e.g., MaxCutInstance , MISInstance or SherringtonKirkpatrick . Example Functions relabel_graph_nodes (graph) Map original node labels of the Graph to new ones between 0 and graph.number_of_nodes - 1. Classes ConstrainedQuadraticInstance (cqm[,\u00a0penalty]) A class for constrainted quadratic binary problems. QUBOInstance (qubo_object) A problem instance class for generic QUBO problems. Inheritance previous MaximumWeightISInstance next relabel_graph_nodes By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "LogEdge",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.quantum_hardware.LogEdge.html",
    "description": "A custom type alias for frozenset of LogQubit to refer to interactions between logical qubits. alias of frozenset [ int ] previous HardQubit next HardEdge By IQM QAOA developers \u00a9 Copyright 2021-2025,...",
    "content": "A custom type alias for frozenset of LogQubit to refer to interactions between logical qubits. alias of frozenset [ int ] previous HardQubit next HardEdge By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "StarQPU",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.quantum_hardware.StarQPU.html",
    "description": "Bases: QPU A star-shaped QPU (Daneb, Sirius, \u2026). Importantly, the central resonator always has label 0 in the QPU graph. This is used in circuits built on the star. n ( int ) \u2013 The number of the spoke...",
    "content": "Bases: QPU A star-shaped QPU (Daneb, Sirius, \u2026). Importantly, the central resonator always has label 0 in the QPU graph. This is used in circuits built on the star. n ( int ) \u2013 The number of the spokes of the star graph, so that the graph as a whole has n+1 vertices, including\nthe central vertex. Attributes Methods previous QPU next iqm.qaoa.transpiler.routing By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "greedy_mis",
    "url": "/iqm-qaoa/api/iqm.applications.mis.greedy_mis.html",
    "description": "Standard greedy algorithm for maximum independent set problem class. Steps: Pick the lowest-degree node in the graph. Add it to the independent set. Remove it and all its neighbors from the graph. Rep...",
    "content": "Standard greedy algorithm for maximum independent set problem class. Steps: Pick the lowest-degree node in the graph. Add it to the independent set. Remove it and all its neighbors from the graph. Repeat steps 1-3 until the graph is empty. Return the independent set. mis_problem ( MISInstance | Graph ) \u2013 A problem instance of maximum independent set or a Graph . A bitstring solution. str previous bron_kerbosch next ISInstance By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "EstimatorStateVector",
    "url": "/iqm-qaoa/api/iqm.qaoa.backends.EstimatorStateVector.html",
    "description": "Bases: EstimatorBackend The estimator class for calculating the expectation value using statevector simulation. Methods estimate (qaoa_object) Calculates the expectation value of the Hamiltonian from ...",
    "content": "Bases: EstimatorBackend The estimator class for calculating the expectation value using statevector simulation. Methods estimate (qaoa_object) Calculates the expectation value of the Hamiltonian from running state-vector simulation in qiskit . Calculates the expectation value of the Hamiltonian from running state-vector simulation in qiskit . Builds a QuantumCircuit for the QAOA and runs the statevector simulation of\nthe circuit, calculating the expectation value of the energy from the statevector. The calculation includes\na constant term (coming from the translation of a QUBO problem to a Hamiltonian). qaoa_object ( QAOA ) \u2013 The instance of QAOA whose expectation value is to be\ncalculated. The expectation value of the energy of the QAOA state using angles . float previous EstimatorSingleLayer next SamplerBackend By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa.transpiler.sparse.greedy_router",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.sparse.greedy_router.html",
    "description": "The main module of the greedy routing algorithm. The main function to be called for routing is greedy_router() . The rest are helper functions. Functions greedy_router (problem_bqm,\u00a0qpu) The function ...",
    "content": "The main module of the greedy routing algorithm. The main function to be called for routing is greedy_router() . The rest are helper functions. Functions greedy_router (problem_bqm,\u00a0qpu) The function which takes a problem BQM problem_bqm and a QPU qpu and returns a routing. previous plot_edge_coloring next greedy_router By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "MaxCutInstance",
    "url": "/iqm-qaoa/api/iqm.applications.maxcut.MaxCutInstance.html",
    "description": "Bases: QUBOInstance The maxcut instance class. This class is initialized with a graph whose maxcut we try to find. A maxcut is a division of the graph nodes\ninto two groups, such that the number of ed...",
    "content": "Bases: QUBOInstance The maxcut instance class. This class is initialized with a graph whose maxcut we try to find. A maxcut is a division of the graph nodes\ninto two groups, such that the number of edges connecting nodes from different groups is maximized.\nThe optional break_z2 variable indicates whether the \\(\\mathbb{Z}_2\\) symmetry of the problem is to be\nbroken by pre-assigning one of the nodes to one of the groups. graph ( Graph ) \u2013 The Graph describing the maxcut problem. break_z2 ( bool ) \u2013 Boolean variable indicating whether the \\(\\mathbb{Z}_2\\) symmetry of the problem should be\nartificially broken, reducing the number of problem variables by 1. ValueError \u2013 If the input graph\u2019s nodes aren\u2019t labelled by integers starting from 0. Attributes graph The graph of the problem. Methods cut_size (bit_str) Calculates the cut size of a solution represented by a bitstring. The graph of the problem. Equals the graph that was given on initialization of MaxCutInstance and shouldn\u2019t be modified.\nInstead of modifying the graph, the user should instantiate a new object of MaxCutInstance . Calculates the cut size of a solution represented by a bitstring. The calculation simply iterates over edges of the graph and adds +1 for each edge cut according to\nthe bitstring. Since it uses the original graph, the input bitstring needs to have the same length as\nthe graph has nodes. bit_str ( str ) \u2013 A string of 0\u2019s and 1\u2019s (or any two distinct characters) representing\nthe division of the graph into two sets. The number of edges cut. ValueError \u2013 If the length of the input bitstring isn\u2019t equal to the number of nodes of _graph . ValueError \u2013 If the bitstring contains more than 2 different characters (it doesn\u2019t have to be 0\u2019s and 1\u2019s). int previous maxcut_generator next WeightedMaxCutInstance By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "Mapping",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.routing.Mapping.html",
    "description": "Bases: object This class is responsible for a mapping between logical and hardware qubits. It maintains two dictionaries: log2hard and hard2log which are mappings between logical\nand hardware qubits. ...",
    "content": "Bases: object This class is responsible for a mapping between logical and hardware qubits. It maintains two dictionaries: log2hard and hard2log which are mappings between logical\nand hardware qubits. They are automatically kept in sync. The names for the hardware and logical qubits are\nextracted from qpu and problem_bqm at initialization. qpu ( QPU ) \u2013 a QPU object describing the topology of the QPU, used to\nget hardware qubits. problem_bqm ( BinaryQuadraticModel ) \u2013 The BinaryQuadraticModel of the problem we\u2019re trying to solve, used to get\nlogical qubits. partial_initial_mapping ( dict [ HardQubit , LogQubit ] | None ) \u2013 An optional dictionary that contains a partial mapping to use as a starting point.\nThe keys should be HardQubit and the values LogQubit . ValueError \u2013 If partial_initial_mapping is provided, but it\u2019s not bijective. Attributes hard2log The dictionary containing the mapping from hardware qubits to logical qubits. log2hard The dictionary log2hard is calculated lazily from hard2log . Methods move_hard (source_qubit,\u00a0target_qubit) Moves a logical qubit from a one hardware qubit to a different hardware qubit on the QPU which is not part of the mapping. swap_hard (gate) Swap association between a pair of hardware qubits. swap_log (gate) Swap association between a pair of logical qubits. update (layer) Convenience function that updates the mapping based on the swap gates found in a Layer object. The dictionary containing the mapping from hardware qubits to logical qubits. The dictionary log2hard is calculated lazily from hard2log . Swap association between a pair of logical qubits. Updates the dictionary hard2log ( log2hard gets updated automatically). gate ( LogEdge ) \u2013 The pair of logical qubits to swap. None Swap association between a pair of hardware qubits. Updates the dictionary hard2log ( log2hard gets updated automatically). gate ( HardEdge ) \u2013 The pair of hardware qubits to swap. None Moves a logical qubit from a one hardware qubit to a different hardware qubit on the QPU which is not part of\nthe mapping. Updates the dictionary hard2log ( log2hard gets updated automatically). The dictionary is\nchanged as follows: If the dictionary hard2log has a key source_qubit (but not target_qubit ), this method removes\nthe key source_qubit , creates a new key target_qubit and gives it the value formerly associated to source_qubit The dictionary log2hard is modified correspondingly. The value source_qubit is changed to target_qubit . source_qubit ( HardQubit ) \u2013 The HardQubit whose LogQubit is being moved. target_qubit ( HardQubit ) \u2013 The HardQubit where\nthe LogQubit is being moved. ValueError \u2013 If the target_qubit is already assigned to a different logical qubit. None Convenience function that updates the mapping based on the swap gates found in\na Layer object. Iterates over the gates in a Layer object and swaps the hardware qubits\ncorresponding to swap gates. layer ( Layer ) \u2013 The layer whose swap gates are used. None previous Layer next Routing By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa.transpiler.hardwired.hardwired",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.hardwired.hardwired.html",
    "description": "This module contains \u201chard-wired\u201d routing. For problem sizes from 4 to 15, this creates the optimal Routing so that all\n2-qubit interactions can be executed and the number of swaps is minimized. We be...",
    "content": "This module contains \u201chard-wired\u201d routing. For problem sizes from 4 to 15, this creates the optimal Routing so that all\n2-qubit interactions can be executed and the number of swaps is minimized. We believe this is the optimal routing\nstrategy for fully / densely connected problems. Functions hardwired_router (problem_bqm,\u00a0qpu) The function that creates an optimal routing for all-to-all connected problems, designed by hand. previous iqm.qaoa.transpiler.hardwired next hardwired_router By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "relabel_graph_nodes",
    "url": "/iqm-qaoa/api/iqm.applications.qubo.relabel_graph_nodes.html",
    "description": "Map original node labels of the Graph to new ones between 0 and graph.number_of_nodes - 1. Creates two dictionaries that keep track of the mapping between original labels and new labels numbered betwe...",
    "content": "Map original node labels of the Graph to new ones between 0 and graph.number_of_nodes - 1. Creates two dictionaries that keep track of the mapping between original labels and new labels numbered between 0\nand graph.number_of_nodes - 1. graph ( Graph ) \u2013 The graph whose nodes should be relabeled. A tuple containing the input graph with relabeled nodes and two dictionaries containing the mapping from old\nlabels to new and vice versa. tuple [ Graph , dict [ Any , int ], dict [ int , Any ]] previous iqm.applications.qubo next ConstrainedQuadraticInstance By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa.circuits",
    "url": "/iqm-qaoa/api/iqm.qaoa.circuits.html",
    "description": "This module contains several functions that build various types of circuits (e.g., in qiskit and quimb )\nfrom the QUBOQAOA object. Functions qiskit_circuit (qaoa[,\u00a0measurements]) Constructs a QuantumC...",
    "content": "This module contains several functions that build various types of circuits (e.g., in qiskit and quimb )\nfrom the QUBOQAOA object. Functions qiskit_circuit (qaoa[,\u00a0measurements]) Constructs a QuantumCircuit from the QAOA angles, ignoring details of the QPU. qiskit_circuit_specific_nodes (qaoa,\u00a0...) Constructs a QuantumCircuit for the RCC of given qubits, ignoring details of the QPU. quimb_tn (qaoa) Constructs a quimb tensor network representing the quantum circuit. transpiled_circuit (qaoa[,\u00a0backend,\u00a0...]) The function to return a QuantumCircuit tailored to backend . previous SamplerSimulation next qiskit_circuit By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "LogQubit",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.quantum_hardware.LogQubit.html",
    "description": "A custom type alias for int to refer to logical / problem qubits. previous iqm.qaoa.transpiler.quantum_hardware next HardQubit By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-0...",
    "content": "A custom type alias for int to refer to logical / problem qubits. previous iqm.qaoa.transpiler.quantum_hardware next HardQubit By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "RoutingStar",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.star.star.RoutingStar.html",
    "description": "Bases: Routing This class represents a routing of a QAOA phase separator on the star topology. The main difference from the parent class Routing is that RoutingStar doesn\u2019t use Layer for its layers. T...",
    "content": "Bases: Routing This class represents a routing of a QAOA phase separator on the star topology. The main difference from the parent class Routing is that RoutingStar doesn\u2019t use Layer for its layers. The layers in RoutingStar are much\nsimpler (just one gate in each layer). Here a layer is just a tuple containing a string describing the gate and an\ninteger describing the HardQubit involved. problem_bqm ( BinaryQuadraticModel ) \u2013 The optimization problem represented as BinaryQuadraticModel . qpu ( StarQPU ) \u2013 The QPU representing the hardware qubit topology. initial_mapping ( Mapping | None ) \u2013 The starting mapping of the logical-to-hardware qubits. Attributes Methods apply_directed_int (target) Apply interaction between the resonator and an outer qubit. apply_move_in (qubit) Apply move gate (to move a qubit into the resonator). apply_move_out (qubit) Apply move gate (to move a qubit out of the resonator). build_qiskit (betas,\u00a0gammas) Build the entire QAOA circuit in qiskit . count_move_gates () Counts the number of move gates in the routing. draw () Plot all layers of the routing in batches of 9. Apply move gate (to move a qubit into the resonator). qubit ( int ) \u2013 The HardQubit whose logical qubit is moved to\nthe central resonator. ValueError \u2013 If the central resonator is already occupied by a logical qubit (so a different logical qubit\n    can\u2019t be moved there). ValueError \u2013 If the target qubit doesn\u2019t contain a logical qubit. None Apply move gate (to move a qubit out of the resonator). qubit ( int ) \u2013 The HardQubit where the logical qubit from\nthe resonator is moved to. ValueError \u2013 If the central resonator is empty, so nothing can\u2019t be moved out of it. ValueError \u2013 If the target qubit is already occupied by a different logical qubit. None Apply interaction between the resonator and an outer qubit. The resonator doesn\u2019t support single-qubit gates, so the interaction has to be decomposed in such a way that\nthe single-qubit rotation is applied to the outer target qubit. target ( int ) \u2013 The HardQubit that interacts with the central qubit. ValueError \u2013 If the resonator is empty (so no interaction can be done). ValueError \u2013 If the target qubit doesn\u2019t correspond to any logical qubit. None Counts the number of move gates in the routing. Counts both \u2018move_in\u2019 and \u2018move_out\u2019 gates in the routing. In theory, each \u2018move_in\u2019 gate should be followed by\na corresponding \u2018move_out\u2019 gate, but this counts the gates separately because there might be as of yet\nunforseen situations in which this won\u2019t be true anymore. The number of \u2018move_in\u2019 and \u2018move_out\u2019 gates in the entire routing. int Build the entire QAOA circuit in qiskit . The RoutingStar object contains all the information needed to create\nthe phase separator part of the QAOA circuit. This method builds the rest of the circuit from it, i.e.: It initializes the qubits in the \\(| + >\\) state by applying the Hadamard gate to all of them. It goes through the routing layers and applies the corresponding interactions (or move gates). It applies local fields. It applies the driver. It repeats steps 2-4 until it uses up all betas and gammas . It applies the measurements and a barrier before them. betas ( list [ float ] ) \u2013 The QAOA parameters to be used in the driver ( RX gate). gammas ( list [ float ] ) \u2013 The QAOA parameters to be used in the phase separator ( RZ and RZZ gates). A complete QAOA QuantumCircuit . QuantumCircuit Plot all layers of the routing in batches of 9. This creates a series of plots that are shown on the screen. Each plot contains 9 layers arranged in a 3x3 grid.\nEach layer is drawn using a custom procedure. It has the shape of the QPU topology with edges colored based on\nwhat is happening on them in the given layer. Teal highlight if a \u2018move_in\u2019 gate is applied. Plum highlight if a \u2018move_out\u2019 gate is applied. Green highlight if an \u2018int\u2019 gate is applied. No highlight (black) if nothing is happening along the edge. ValueError \u2013 If the first element of the layers is neither of \u2018int\u2019, \u2018move_in\u2019 or \u2018move_out\u2019. None previous star_router next iqm.qaoa.tree_qaoa By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.applications.mis",
    "url": "/iqm-qaoa/api/iqm.applications.mis.html",
    "description": "Module containing the MIS problem instance class. Two solvers for MIS problems are also provided: A simple and fast greedy solver. Exact solver based on Bron-Kerbosch algorithm to find a graph\u2019s cliqu...",
    "content": "Module containing the MIS problem instance class. Two solvers for MIS problems are also provided: A simple and fast greedy solver. Exact solver based on Bron-Kerbosch algorithm to find a graph\u2019s cliques. Example Functions bron_kerbosch (mis_problem) Bron-Kerbosch algorithm for finding the maximum independent set. greedy_mis (mis_problem) Standard greedy algorithm for maximum independent set problem class. Classes ISInstance (graph,\u00a0penalty,\u00a0objective) The instance class for independent set problems on a graph with a custom cost function. MISInstance (graph[,\u00a0penalty]) The instance class for maximum independent set problems. MaximumWeightISInstance (graph,\u00a0penalty) The instance class for maximum-weight independent set problems. Inheritance previous WeightedMaxCutInstance next bron_kerbosch By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "greedy_router",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.sparse.greedy_router.greedy_router.html",
    "description": "The function which takes a problem BQM problem_bqm and a QPU qpu and returns a routing. This serves as a \u2018wrapper\u2019 for the entire greedy routing algorithm. For details of the algorithm, see [ 6 ] . pr...",
    "content": "The function which takes a problem BQM problem_bqm and a QPU qpu and returns a routing. This serves as a \u2018wrapper\u2019 for the entire greedy routing algorithm. For details of the algorithm, see [ 6 ] . problem_bqm ( BinaryQuadraticModel ) \u2013 The BinaryQuadraticModel of the problem we\u2019re trying to solve. qpu ( QPU ) \u2013 The QPU that we\u2019re going to solve the problem on. A routing object containing all the swap and interaction layers needed to execute one QAOA layer. Routing previous iqm.qaoa.transpiler.sparse.greedy_router next iqm.qaoa.transpiler.sparse.two_color_mapper By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "sn_router",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.sn.sn.sn_router.html",
    "description": "The function that implements the \u2018swap network\u2019 swapping strategies. Implements approach from [ 4 ] adapted for rectangular QPUs, not only square. If the input BQM\nis not all-to-all connected, dummy i...",
    "content": "The function that implements the \u2018swap network\u2019 swapping strategies. Implements approach from [ 4 ] adapted for rectangular QPUs, not only square. If the input BQM\nis not all-to-all connected, dummy interactions (of strength 0) are added to make it all-to-all connected. Tries to\nfind a sufficient rectangle in the provided Crystal QPU (square lattice topology required). problem_bqm ( BinaryQuadraticModel ) \u2013 The BinaryQuadraticModel description of the problem, necessary to create\nan instance of Routing . qpu ( CrystalQPUFromBackend ) \u2013 The QPU, necessary to create an instance of Routing and to get\nthe topology of the qubits. The qpu also needs to contain the layout of the qubits with integer\ncoordinates as an attribute. A Routing object containing the routing created by using swap networks. TypeError \u2013 If the QPU\u2019s layout doesn\u2019t have integer coordinates. It is necessary to correctly identify where\n    the swap and interaction gates need to be applied in the swap network approach. RuntimeError \u2013 If the algorithm doesn\u2019t find a sufficiently large rectangle of qubits in the QPU. Routing previous iqm.qaoa.transpiler.sn.sn next iqm.qaoa.transpiler.sparse By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa.generic_qaoa",
    "url": "/iqm-qaoa/api/iqm.qaoa.generic_qaoa.html",
    "description": "A module containing the generic QAOA abstract base class. Classes QAOA (problem,\u00a0num_layers,\u00a0*[,\u00a0betas,\u00a0...]) The most generic QAOA abstract base class. Inheritance previous transpiled_circuit next QA...",
    "content": "A module containing the generic QAOA abstract base class. Classes QAOA (problem,\u00a0num_layers,\u00a0*[,\u00a0betas,\u00a0...]) The most generic QAOA abstract base class. Inheritance previous transpiled_circuit next QAOA By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa.transpiler",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.html",
    "description": "A folder for modules related to the transpilation (routing) of the QAOA circuit on a QPU. Subpackages and modules hardwired The submodule for hard-wired transpilation of dense QAOA circuits. quantum_h...",
    "content": "A folder for modules related to the transpilation (routing) of the QAOA circuit on a QPU. Subpackages and modules hardwired The submodule for hard-wired transpilation of dense QAOA circuits. quantum_hardware The module for classes representing various QPU architectures. routing This module contains the object classes Mapping , Layer and Routing to be used throughout any transpilation algorithm. rx_to_nx Module to carry a helpful function to transform a rustworkx graph into a networkx.Graph . sn The submodule for swap-network-based transpilation of dense QAOA circuits. sparse The submodule for greedy transpilation for sparse QAOA circuits. star The submodule for transpilation of QAOA circuits to QPUs with star topology. previous ham_graph_to_ham_operator next iqm.qaoa.transpiler.hardwired By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "ham_graph_to_ham_operator",
    "url": "/iqm-qaoa/api/iqm.qaoa.transforming_functions.ham_graph_to_ham_operator.html",
    "description": "A function to transform Hamiltonian represented as a Graph into\na SparsePauliOp object. A Hamiltonian as SparsePauliOp may be used by qiskit functions that e.g.,\ncalculate expectation values. ham_grap...",
    "content": "A function to transform Hamiltonian represented as a Graph into\na SparsePauliOp object. A Hamiltonian as SparsePauliOp may be used by qiskit functions that e.g.,\ncalculate expectation values. ham_graph ( Graph ) \u2013 A Graph whose nodes and edges have a parameter bias whose value corresponds\nto the coefficients before the corresponding Z and ZZ operators in the problem Hamiltonian. The Hamiltonian as SparsePauliOp to be used by qiskit . SparsePauliOp previous iqm.qaoa.transforming_functions next iqm.qaoa.transpiler By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.applications.applications",
    "url": "/iqm-qaoa/api/iqm.applications.applications.html",
    "description": "This module contains the abstract base class providing a template for defining problem instances. Example Classes ProblemInstance () The abstract base class for defining problem instances. Inheritance...",
    "content": "This module contains the abstract base class providing a template for defining problem instances. Example Classes ProblemInstance () The abstract base class for defining problem instances. Inheritance previous iqm.applications next ProblemInstance By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.applications.maxcut",
    "url": "/iqm-qaoa/api/iqm.applications.maxcut.html",
    "description": "This module contains the maxcut problem instance class and related functions. Contains the iterator function maxcut_generator() which yields random instances of MaxCutInstance , useful\nfor application...",
    "content": "This module contains the maxcut problem instance class and related functions. Contains the iterator function maxcut_generator() which yields random instances of MaxCutInstance , useful\nfor applications such as calculating the Q-score. Also contains two classical solvers for maxcut problems: A simple and fast greedy algorithm. A solver based on the standard Goemans-Williamson [ 1 ] , fast and with a performance guarantee. Example Functions goemans_williamson (max_cut_problem) Runs the Goemans-Williamson algorithm for maxcut, returning a solution bitstring. greedy_max_cut (max_cut_problem) Standard greedy algorithm for maxcut problem class. maxcut_generator (n,\u00a0n_instances,\u00a0*[,\u00a0...]) The generator function for generating random maxcut problem instances. Classes MaxCutInstance (graph[,\u00a0break_z2]) The maxcut instance class. WeightedMaxCutInstance (graph[,\u00a0break_z2]) The weighted maxcut instance class. Inheritance previous ProblemInstance next goemans_williamson By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "HardEdge",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.quantum_hardware.HardEdge.html",
    "description": "A custom type alias of frozenset of HardQubit to refer to interactions between hardware qubits. alias of frozenset [ int ] previous LogEdge next CrystalQPUFromBackend By IQM QAOA developers \u00a9 Copyrigh...",
    "content": "A custom type alias of frozenset of HardQubit to refer to interactions between hardware qubits. alias of frozenset [ int ] previous LogEdge next CrystalQPUFromBackend By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "LineQPU",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.quantum_hardware.LineQPU.html",
    "description": "Bases: QPU A linear QPU (qubits on a line). Nothing fancy here, just a special case of a qubit hardware connectivity graph, which is a line. Given a length ,\ncreates a path hardware_graph and the corr...",
    "content": "Bases: QPU A linear QPU (qubits on a line). Nothing fancy here, just a special case of a qubit hardware connectivity graph, which is a line. Given a length ,\ncreates a path hardware_graph and the corresponding hardware_layout which are then passed to QPU class initialization. length ( int ) \u2013 The length of the QPU (as number of qubits). Attributes Methods embedded_chain () Embeds a chain in the line QPU (which is just a line). Embeds a chain in the line QPU (which is just a line). Integer index of the next qubit in the chain. Iterator [ HardQubit ] previous Grid2DQPU next QPU By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa.backends",
    "url": "/iqm-qaoa/api/iqm.qaoa.backends.html",
    "description": "The module for various backends for calculating the expectation value / samples from QAOA. Classes EstimatorBackend () The ABC for estimator backends, i.e., those calculating the expected value of the...",
    "content": "The module for various backends for calculating the expectation value / samples from QAOA. Classes EstimatorBackend () The ABC for estimator backends, i.e., those calculating the expected value of the Hamiltonian. EstimatorFromSampler (sampler,\u00a0shots[,\u00a0cvar]) The estimator class for calculating the expectation value using counts obtained from a sampler. EstimatorQUIMB () The estimator class for calculating the expectation value using the tensor network package quimb . EstimatorSingleLayer () The estimator class for calculating the expectation value analytically (for \\(p=1\\) QAOA). EstimatorStateVector () The estimator class for calculating the expectation value using statevector simulation. SamplerBackend () The ABC for sampler backends, i.e., those returning samples from the QAOA. SamplerRandomBitstrings () A sampler that ignores the QAOA and just produces random bitstrings of the correct length. SamplerResonance (token[,\u00a0server_url,\u00a0transpiler]) A sampler that runs the circuit on IQM Resonance and returns the result. SamplerSimulation ([simulator]) A sampler that simulates the QAOA circuit in qiskit . Inheritance previous iqm.qaoa next EstimatorBackend By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "qiskit_circuit",
    "url": "/iqm-qaoa/api/iqm.qaoa.circuits.qiskit_circuit.html",
    "description": "Constructs a QuantumCircuit from the QAOA angles, ignoring details of the QPU. Constructs a QuantumCircuit corresponding to the QAOA, assuming perfect connectivity of\nthe qubits and complete set of av...",
    "content": "Constructs a QuantumCircuit from the QAOA angles, ignoring details of the QPU. Constructs a QuantumCircuit corresponding to the QAOA, assuming perfect connectivity of\nthe qubits and complete set of available quantum gates. This circuit can be used for simulations or it can be\ntranspiled to be run on a real QPU. qaoa ( QUBOQAOA ) \u2013 A QUBOQAOA object whose angles and interaction strengths are used in\nthe construction of the QuantumCircuit . measurements ( bool ) \u2013 Should measurements be added at the end of the circuit? If the circuit is used for statevector\nsimulation, there shouldn\u2019t be measurements. If the circuit is used for sampling, there should be\nmeasurements. A quantum circuit corresponding to the QAOA, excluding any measurements. QuantumCircuit previous iqm.qaoa.circuits next qiskit_circuit_specific_nodes By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "SamplerRandomBitstrings",
    "url": "/iqm-qaoa/api/iqm.qaoa.backends.SamplerRandomBitstrings.html",
    "description": "Bases: SamplerBackend A sampler that ignores the QAOA and just produces random bitstrings of the correct length. Methods sample (qaoa_object,\u00a0shots) Produce random bitstrings to act as samples from th...",
    "content": "Bases: SamplerBackend A sampler that ignores the QAOA and just produces random bitstrings of the correct length. Methods sample (qaoa_object,\u00a0shots) Produce random bitstrings to act as samples from the QAOA. Produce random bitstrings to act as samples from the QAOA. The qaoa_object is used only to get the number of qubits (which corresponds to the length of\nthe bitstrings). The number of uniformly random bitstrings produced is shots and they are arranged in\na dictionary just like counts from a qiskit measurement. qaoa_object ( QAOA ) \u2013 The QAOA object, only used to get the number of qubits. shots ( int ) \u2013 The number of random strings to generate. A dictionary whose keys are the produced random bitstrings and values their frequencies in the random set. dict [ str , int ] previous SamplerBackend next SamplerResonance By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "CrystalQPUFromBackend",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.quantum_hardware.CrystalQPUFromBackend.html",
    "description": "Bases: QPU Class for a QPU with square lattice topology, initialited from an IQMBackend object. Since the topology is square lattice, the qubits can be identified with 2D integer coordinates (up to a ...",
    "content": "Bases: QPU Class for a QPU with square lattice topology, initialited from an IQMBackend object. Since the topology is square lattice, the qubits can be identified with 2D integer coordinates (up to a global\nshift). However, it appears difficult to calculate these coordinates just from the topology graph, so instead\na helper function is used with hard-coded sets of coordinates for IQM\u2019s public QPU designs. backend ( IQMBackendBase ) \u2013 The backend containing information about the QPU. Attributes Methods previous HardEdge next Grid2DQPU By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa.transpiler.star",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.star.html",
    "description": "The submodule for transpilation of QAOA circuits to QPUs with star topology. Subpackages and modules star The module for the router for the star QPU. previous two_color_mapper next iqm.qaoa.transpiler...",
    "content": "The submodule for transpilation of QAOA circuits to QPUs with star topology. Subpackages and modules star The module for the router for the star QPU. previous two_color_mapper next iqm.qaoa.transpiler.star.star By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "two_color_mapper",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.sparse.two_color_mapper.two_color_mapper.html",
    "description": "Finds an initial mapping between logical and hardware qubits. The mapping is constructed so that almost all interactions of two colors of an edge coloring of the problem graph\ncan be executed in the f...",
    "content": "Finds an initial mapping between logical and hardware qubits. The mapping is constructed so that almost all interactions of two colors of an edge coloring of the problem graph\ncan be executed in the first two layers of the phase separator. It uses an internal function to find\na (near-)optimal coloring of the problem graph, take the subgraph induced by the two largest colors and decompose\nthe subgraph into chains and loops. The loops are then broken down into chains and all these small chains are then\nplaced onto a big chain embedded along the qpu . problem_bqm ( BinaryQuadraticModel ) \u2013 The BinaryQuadraticModel representation of the problem. qpu ( QPU ) \u2013 The QPU, an object of the QPU class (or any of its\nsubclasses). The initial mapping (as Mapping ) and a list of two lists of LogEdge interactions that can be implemented in the first two\nlayers of the routing algorithm. tuple [ Mapping , list [ list [ LogEdge ]]] previous iqm.qaoa.transpiler.sparse.two_color_mapper next iqm.qaoa.transpiler.star By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "SamplerResonance",
    "url": "/iqm-qaoa/api/iqm.qaoa.backends.SamplerResonance.html",
    "description": "Bases: SamplerBackend A sampler that runs the circuit on IQM Resonance and returns the result. token ( str ) \u2013 The API token to be used to connect to IQM Resonance. server_url ( str ) \u2013 The URL to the...",
    "content": "Bases: SamplerBackend A sampler that runs the circuit on IQM Resonance and returns the result. token ( str ) \u2013 The API token to be used to connect to IQM Resonance. server_url ( str ) \u2013 The URL to the quantum computer (defaults to Garnet). transpiler ( str ) \u2013 The transpiling strategy to be used when building the quantum circuit for the QC. Defaults to\n\u201cSparseTranspiler\u201d Methods sample (qaoa_object,\u00a0shots) Samples from the QAOA on a quantum computer via IQM Resonance. Samples from the QAOA on a quantum computer via IQM Resonance. First, it creates a QuantumCircuit (using a custom transpilation approach) and then\nsends it to IQM Resonance. qaoa_object ( QAOA ) \u2013 The QAOA object, to be sampled from. shots ( int ) \u2013 The number of samples (measurements) to take. A dictionary whose keys are the measured bitstrings and values their frequencies in the results. dict [ str , int ] previous SamplerRandomBitstrings next SamplerSimulation By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "HardQubit",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.quantum_hardware.HardQubit.html",
    "description": "A custom type alias for int to refer to hardware qubits. previous LogQubit next LogEdge By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07....",
    "content": "A custom type alias for int to refer to hardware qubits. previous LogQubit next LogEdge By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "transpiled_circuit",
    "url": "/iqm-qaoa/api/iqm.qaoa.circuits.transpiled_circuit.html",
    "description": "The function to return a QuantumCircuit tailored to backend . This function has highly varying outputs based on which transpiler is used. If no transpiler is used,\nthe perfect QuantumCircuit is return...",
    "content": "The function to return a QuantumCircuit tailored to backend . This function has highly varying outputs based on which transpiler is used. If no transpiler is used,\nthe perfect QuantumCircuit is returned using qiskit_circuit() . Otherwise,\nthe QAOA circuit is transpiled using one of the transpilers, respecting the topology of backend . qaoa ( QUBOQAOA ) \u2013 The QUBOQAOA object whose quantum circuit is constructed. backend ( BackendV2 ) \u2013 A backend that the circuit is to be run on. The connectivity of the backend is required\nfor the transpilation. transpiler ( str | None ) \u2013 A string that describes which algorithm should be used for transpilation (if any). Should be one\nof: None , \u201cDefault\u201d, \u201cHardwiredTranspiler\u201d, \u201cSparseTranspiler\u201d, \u201cSwapNetwork\u201d or \u201cMinimumVertexCover\u201d. seed ( int ) \u2013 A seed used for \u201cDefault\u201d transpilation. It fixes the circuit produced by the stochastic qiskit\ntranspiler. It can be used to ensure reproducibility of a transpilation. A quantum circuit transpiled to the topology of backend . TypeError \u2013 If the backend is not an IQM backend and a custom transpiler is selected (i.e., other than None or \u201cDefault\u201d). ValueError \u2013 If the provided transpiler is not one of the allowed transpilers. QuantumCircuit previous quimb_tn next iqm.qaoa.generic_qaoa By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "WeightedMaxCutInstance",
    "url": "/iqm-qaoa/api/iqm.applications.maxcut.WeightedMaxCutInstance.html",
    "description": "Bases: QUBOInstance The weighted maxcut instance class. The weighted maxcut problem is very similar to the standard maxcut, with the only difference being that the edges\nof the graph now have weights....",
    "content": "Bases: QUBOInstance The weighted maxcut instance class. The weighted maxcut problem is very similar to the standard maxcut, with the only difference being that the edges\nof the graph now have weights. Each cut edge contributes its weight to the quality of the cut. graph ( Graph ) \u2013 The Graph describing the weighted maxcut problem. Each edge of the graph needs to have\nan attribute called weight storing a number. break_z2 ( bool ) \u2013 Boolean variable indicating whether the \\(\\mathbb{Z}_2\\) symmetry of the problem should be\nartificially broken, reducing the number of problem variables by 1. ValueError \u2013 If the input graph\u2019s nodes aren\u2019t labelled by integers starting from 0. ValueError \u2013 If the input graph\u2019s edges don\u2019t all have an attribute weight . TypeError \u2013 If the weight of any node is a wrong data type (neither float nor int ). Attributes graph The graph of the problem. Methods cut_size (bit_str) Calculates the cut size of a solution represented by a bitstring. The graph of the problem. Equals the graph that was given on initialization of WeightedMaxCutInstance and shouldn\u2019t be modified.\nInstead of modifying the graph, the user should instantiate a new object of WeightedMaxCutInstance . Calculates the cut size of a solution represented by a bitstring. The calculation simply iterates over edges of the graph and adds the weight of each edge cut according to\nthe bitstring. Since it uses the original graph, the input bitstring needs to have the same length as\nthe graph has nodes. bit_str ( str ) \u2013 A string of 0\u2019s and 1\u2019s (or any two distinct characters) representing\nthe division of the graph into two sets. The weight of edges cut. ValueError \u2013 If the length of the input bitstring isn\u2019t equal to the number of nodes of graph . ValueError \u2013 If the bitstring contains more than 2 different characters (it doesn\u2019t have to be 0\u2019s and 1\u2019s). float previous MaxCutInstance next iqm.applications.mis By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "Layer",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.routing.Layer.html",
    "description": "Bases: object A class describing one layer of the QAOA phase separator, consisting of swap and interaction gates. The class knows about the QPU topology (from qpu ) and uses it to decide which gates a...",
    "content": "Bases: object A class describing one layer of the QAOA phase separator, consisting of swap and interaction gates. The class knows about the QPU topology (from qpu ) and uses it to decide which gates are applicable.\nA Layer object contains an internal copy of the QPU graph iqm.qaoa.transpiler.quantum_hardware.QPU.hardware_graph , but with edges labelled based on whether\nan interaction or a swap occurs along that edge in this layer. Similarly, the nodes are labelled based on whether\nthey\u2019re \u201coccupied\u201d in the present layer. qpu ( QPU ) \u2013 A QPU object, containing the underlying QPU topology. int_gates ( set [ HardEdge ] | None ) \u2013 A set of HardEdge interaction gates to be implemented\nin the layer. Further interaction gates may be added to the layer by using apply_int_gate() . swap_gates ( set [ HardEdge ] | None ) \u2013 A set of HardEdge swap gates to be implemented in\nthe layer. Further swap gates may be added to the layer by using apply_swap_gate() . Methods _qbs_not_involved_in_other_gate (gate) Are the two qubits involved in the proposed gate not already involved in other gates? apply_int_gate (gate) Apply an interaction gate if it is applicable within the given layer. apply_swap_gate (gate) Apply swap gate if it is applicable within the given layer. draw ([mapping,\u00a0ax,\u00a0show]) Plot a sketch of the QPU, coloring the physical couplers based on the gate applied. int_gate_applicable (gate) Can the proposed interaction gate be executed within the given layer? swap_gate_applicable (gate) Can the proposed swap gate be executed within the given layer? Can the proposed interaction gate be executed within the given layer? Goes through a few checks: If the required connection doesn\u2019t exist in the QPU, return False . If there is already a gate applied between these qubits, and it\u2019s the swap gate, return True since\nthe interaction gate can be combined with it. If it\u2019s not a simple swap gate, return False . Otherwise, check if either of the qubits is involved in other gates and return the outcome of that. gate ( HardEdge ) \u2013 The pair of qubits for which we\u2019re checking the applicability of an interaction gate. bool Apply an interaction gate if it is applicable within the given layer. gate ( HardEdge ) \u2013 The pair of qubits between which we apply the interaction gate. ValueError \u2013 If for whatever reason the interaction gate cannot be applied in this layer. None Can the proposed swap gate be executed within the given layer? Goes through a few checks: If the required connection doesn\u2019t exist in the QPU, return False . If there is already a swap gate between these qubits, return True (since the new swap gate can cancel\nit). If there is already an interaction gate between these qubits, return True (since the swap gate can\ncombine with it). Otherwise, check if either of the qubits is involved in other gates. gate ( HardEdge ) \u2013 The pair of qubits for which we\u2019re checking the applicability of a swap gate. bool Apply swap gate if it is applicable within the given layer. gate ( HardEdge ) \u2013 The pair of qubits between which we apply the swap gate. ValueError \u2013 If for whatever reason the swap gate cannot be applied in this layer. None Plot a sketch of the QPU, coloring the physical couplers based on the gate applied. Yellow highlight if a combination of swap and int is applied. Blue highlight if a swap gate is applied. Green highlight if an interaction gate is applied. No highlight (black) if nothing is happening along the edge. The labels for the hardware qubits in the plot are the names of the associated logical qubits. mapping ( Mapping | None ) \u2013 The Mapping object used. ax ( Axes | None ) \u2013 matplotlib.axes.Axes object to specify where to draw the picture. show ( bool ) \u2013 Boolean to specift if the plot is to be shown (or e.g., processed somehow). None previous iqm.qaoa.transpiler.routing next Mapping By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "bron_kerbosch",
    "url": "/iqm-qaoa/api/iqm.applications.mis.bron_kerbosch.html",
    "description": "Bron-Kerbosch algorithm for finding the maximum independent set. The algorithm finds all maximal cliques in a graph recursively. Cliques in complement graph correspond\nto independent sets in the probl...",
    "content": "Bron-Kerbosch algorithm for finding the maximum independent set. The algorithm finds all maximal cliques in a graph recursively. Cliques in complement graph correspond\nto independent sets in the problem graph. We pick the largest of these.\nFor details see find_cliques \u2014 NetworkX documentation (and the references therein): mis_problem ( MISInstance | Graph ) \u2013 A problem instance of maximum independent set or a Graph . A bitstring solution. str previous iqm.applications.mis next greedy_mis By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "ISInstance",
    "url": "/iqm-qaoa/api/iqm.applications.mis.ISInstance.html",
    "description": "Bases: ConstrainedQuadraticInstance The instance class for independent set problems on a graph with a custom cost function. The objective of this class of problems is selecting a subset of nodes in a ...",
    "content": "Bases: ConstrainedQuadraticInstance The instance class for independent set problems on a graph with a custom cost function. The objective of this class of problems is selecting a subset of nodes in a graph, such that no two nodes in\nthe selected subset are connected by an edge, while minimizing some cost function. This class can be instantiated by\ngiving it a graph, a penalty to the cost function to be incurred for each violation of the constraint (when\nthe problem is converted to QUBO) and an objective function as a BinaryQuadraticModel . This class is\nnot intended to be instantiated directly, but rather by its subclasses MISInstance and MaximumWeightISInstance . But if the user does the work of defining their own objective function, there is no harm in instantiating an object of ISInstance . graph ( Graph ) \u2013 The graph from which independent sets are to be picked. penalty ( float | int ) \u2013 The penalty to be incurred per each edge present in the solution. This is needed when the problem\nformulation is transformed into QUBO. objective ( BinaryQuadraticModel ) \u2013 The objective function to be minimized by the independent set. Attributes graph The graph corresponding to the problem. Methods _induced_subgraph_from_bitstring (bit_str) Helper method that takes a bitstring representing a solution and returns the graph induced from it. _recalculate_bqm () The function calculating the BQM is relatively simple for independent set problems. fix_variables (variables) A method to fix some of the problem variables. The graph corresponding to the problem. Equals the graph that was given on initialization of MISInstance and shouldn\u2019t be modified. Instead of\nmodifying the graph, the user should instantiate a new object of MISInstance . A method to fix some of the problem variables. When a variable is fixed to 1, all of its neighboring variables are fixed to 0 (because of the constraints). variables ( list [ Hashable ] | dict [ Hashable , int ] ) \u2013 Either a list of variables (which get all fixed to the value 1) or a dictionary with keys equal\nto the variables to fix and whose values are equal to the values to fix them to (either 1 or 0). ValueError \u2013 If the user is trying to fix two neighbouring nodes to 1, violating the independence\n    constraint. ValueError \u2013 If one of the variables has already been fixed previously to a different value. None previous greedy_mis next MISInstance By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "find_edge_coloring",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.sparse.edge_coloring.find_edge_coloring.html",
    "description": "This function finds an edge coloring for the given graph. It iterates over the graph edges and colors each one using elaborate helper functions. It modifies input_graph by adding an attribute color to...",
    "content": "This function finds an edge coloring for the given graph. It iterates over the graph edges and colors each one using elaborate helper functions. It modifies input_graph by adding an attribute color to every edge, given by an integer number. input_graph ( Graph ) \u2013 The Graph to be edge-colored. A list whose i-th entry contains the set of edges colored by the i-th color. A colored copy of the input input_graph . A list whose i-th entry contains the set of edges colored by the i-th color. A colored copy of the input input_graph . A tuple containing previous ec_is_valid next plot_edge_coloring By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa.transpiler.sparse.two_color_mapper",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.sparse.two_color_mapper.html",
    "description": "This file contains the two_color_mapper() function which creates the initial Mapping . The Mapping is based on the edge coloring of the graph created by\nthe find_edge_coloring() function. Functions tw...",
    "content": "This file contains the two_color_mapper() function which creates the initial Mapping . The Mapping is based on the edge coloring of the graph created by\nthe find_edge_coloring() function. Functions two_color_mapper (problem_bqm,\u00a0qpu) Finds an initial mapping between logical and hardware qubits. previous greedy_router next two_color_mapper By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "Grid2DQPU",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.quantum_hardware.Grid2DQPU.html",
    "description": "Bases: QPU Class for 2D rectangular QPU. Contains variables for number of rows and columns, which determine the hardware graph and layout. Also contains\na simple embedded_chain() method to embed a cha...",
    "content": "Bases: QPU Class for 2D rectangular QPU. Contains variables for number of rows and columns, which determine the hardware graph and layout. Also contains\na simple embedded_chain() method to embed a chain in the hardware graph. num_rows ( int ) \u2013 The number of rows in the grid. num_columns ( int ) \u2013 The number of columns in the grid. Attributes Methods embedded_chain () Embeds a chain in the grid QPU (by going around like a snake). Embeds a chain in the grid QPU (by going around like a snake): Integer index of the next qubit in the chain. Iterator [ HardQubit ] previous CrystalQPUFromBackend next LineQPU By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa.transpiler.hardwired",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.hardwired.html",
    "description": "The submodule for hard-wired transpilation of dense QAOA circuits. Subpackages and modules hardwired This module contains \"hard-wired\" routing. previous iqm.qaoa.transpiler next iqm.qaoa.transpiler.ha...",
    "content": "The submodule for hard-wired transpilation of dense QAOA circuits. Subpackages and modules hardwired This module contains \"hard-wired\" routing. previous iqm.qaoa.transpiler next iqm.qaoa.transpiler.hardwired.hardwired By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "QUBOInstance",
    "url": "/iqm-qaoa/api/iqm.applications.qubo.QUBOInstance.html",
    "description": "Bases: ProblemInstance A problem instance class for generic QUBO problems. This problem instance class should only be used for problems without any structure beyond having a QUBO\ncost function. Proble...",
    "content": "Bases: ProblemInstance A problem instance class for generic QUBO problems. This problem instance class should only be used for problems without any structure beyond having a QUBO\ncost function. Problems with constraints or more structure (such as maxcut, MIS, \u2026) should use sub-classes\n(children) of QUBOInstance . The class is initialized with a qubo_object variable, which stores the QUBO parameters. Valid qubo_object is either a 2D square ndarray , Graph or BinaryQuadraticModel . In the case of a Graph , the interactions need to be\nrepresented as the bias parameter of nodes / edges (treated as 0 if not present). Regardless of the type of qubo_object , the __init__() method internally saves the problem description as bqm , which is a BinaryQuadraticModel . qubo_object ( ndarray | Graph | BinaryQuadraticModel ) \u2013 Either a square ndarray , a Graph or\na BinaryQuadraticModel describing the QUBO problem. Attributes bqm The BinaryQuadraticModel representation of the problem instance. dim The dimension of the problem (i.e., the number of binary variables). qubo_graph The QUBO graph of the problem instance. qubo_matrix The QUBO matrix of the problem instance. Methods fix_variables (variables) Fixes (assigns) some of the problem variables. quality (bit_str) Accepts a bitstring (representing a solution) and returns that solution's quality / energy. The dimension of the problem (i.e., the number of binary variables). The QUBO matrix of the problem instance. The matrix is obtained from the internal variable bqm . If the QUBO cost function of the problem\nvariables \\(x_i \\in \\{0, 1\\}\\) is described as: Then the output of this method is the square matrix \\(Q_{ij}\\) as ndarray . The diagonal entries corresponds to the local fields acting on the variables. The entries above the diagonal correspond to the interactions between variables. The entries below the diagonal are empty. The QUBO graph of the problem instance. The nodes / edges of the graph have a bias parameter containing the local field / interaction strength\nof the corresponding variable(s). Variable pairs without interaction aren\u2019t connected by edges in the graph. The BinaryQuadraticModel representation of the problem instance. This variable is defined in __init__() and is used throughout the class to calculate such quantities as dim or qubo_matrix lazily. Fixes (assigns) some of the problem variables. Warning: For problems that come from a graph (such as maxcut), this doesn\u2019t change the original graph,\nonly the derived QUBO formulation (i.e., the BQM variable)! variables ( list [ Hashable ] | dict [ Hashable , int ] ) \u2013 Either a list of variables (which get all fixed to the value 1) or a dictionary with keys equal\nto the variables to fix and whose values are equal to the values to fix them to (either 1 or 0). ValueError \u2013 If one of the variables has already been fixed previously to a different value. None Accepts a bitstring (representing a solution) and returns that solution\u2019s quality / energy. bit_str ( str ) \u2013 The bitstring whose quality is being calculated. The energy of the input bitstring. float previous ConstrainedQuadraticInstance next iqm.applications.sk By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "SamplerSimulation",
    "url": "/iqm-qaoa/api/iqm.qaoa.backends.SamplerSimulation.html",
    "description": "Bases: SamplerBackend A sampler that simulates the QAOA circuit in qiskit . Currently the only simulator we use is the AerSimulator , but SamplerSimulation is\ndefined to allow the use of other simulat...",
    "content": "Bases: SamplerBackend A sampler that simulates the QAOA circuit in qiskit . Currently the only simulator we use is the AerSimulator , but SamplerSimulation is\ndefined to allow the use of other simulators too. simulator ( AerSimulator ) \u2013 A simulator, (currently) assumed to be an object of class AerSimulator . Methods sample (qaoa_object,\u00a0shots) Samples from the QAOA using a simulation. Samples from the QAOA using a simulation. qaoa_object ( QAOA ) \u2013 The QAOA object, to be sampled from. shots ( int ) \u2013 The number of samples (measurements) to take. A dictionary whose keys are the measured bitstrings and values their frequencies in the results. dict [ str , int ] previous SamplerResonance next iqm.qaoa.circuits By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "qiskit_circuit_specific_nodes",
    "url": "/iqm-qaoa/api/iqm.qaoa.circuits.qiskit_circuit_specific_nodes.html",
    "description": "Constructs a QuantumCircuit for the RCC of given qubits, ignoring details of the QPU. The reverse causal cone (RCC) of a set of qubits contains all the gates and qubits which have any influence\non the...",
    "content": "Constructs a QuantumCircuit for the RCC of given qubits, ignoring details of the QPU. The reverse causal cone (RCC) of a set of qubits contains all the gates and qubits which have any influence\non the measurement results on the initial set of qubits. This method constructs\na QuantumCircuit containing these gates and extra qubits. qaoa ( QUBOQAOA ) \u2013 A QUBOQAOA object whose angles and interaction strengths are used in\nthe construction of the QuantumCircuit . starting_qubits ( set [ int ] ) \u2013 A set of the starting qubits for which we construct the RCC circuit. A QuantumCircuit representing the RCC. QuantumCircuit previous qiskit_circuit next quimb_tn By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "QUBOQAOA",
    "url": "/iqm-qaoa/api/iqm.qaoa.qubo_qaoa.QUBOQAOA.html",
    "description": "Bases: QAOA The class for QAOA with quadratic unconstrained binary (QUBO) cost function. The class inherits a lot of functionality from its parent iqm.qaoa.generic_qaoa.QAOA . One new addition is\nthe ...",
    "content": "Bases: QAOA The class for QAOA with quadratic unconstrained binary (QUBO) cost function. The class inherits a lot of functionality from its parent iqm.qaoa.generic_qaoa.QAOA . One new addition is\nthe attribute bqm which stores the coefficient of the problem Hamiltonian. The same data in the form of Graph is hamiltonian_graph . problem ( QUBOInstance | ConstrainedQuadraticInstance ) \u2013 A QUBOInstance object describing the QUBO problem to be solved. num_layers ( int ) \u2013 The number of QAOA layers, commonly referred to as p in the literature. betas ( Sequence [ float ] | ndarray | None ) \u2013 An optional list of the initial beta angles of QAOA. Has to be provided together with gammas . gammas ( Sequence [ float ] | ndarray | None ) \u2013 An optional list of the initial gamma angles of QAOA. Has to be provided together with betas . initial_angles ( Sequence [ float ] | ndarray | None ) \u2013 An optional list of the initial QAOA angles as one variable. Shouldn\u2019t be provided together\nwith either betas or gammas . Attributes bqm The BQM representation of the problem, taken from the input QUBOInstance . hamiltonian_graph The graph whose edges / nodes have weights bias equal to the coefficients in the problem Hamiltonian. interactions Returns an upper-triangular matrix of the ZZ interactions between the variables. local_fields Returns a ndarray of the local fields of the model ( Z coefficients). Methods train ([estimator,\u00a0min_method]) The function that performs the training of the angles. The BQM representation of the problem, taken from the input QUBOInstance . The graph whose edges / nodes have weights bias equal to the coefficients in the problem Hamiltonian. Returns an upper-triangular matrix of the ZZ interactions between the variables. If the Hamiltonian representing the problem is then this method outputs \\(J_{ij}\\) as upper-triangular square matrix ndarray . Note that\nthese are different from the off-diagonal elements of qubo_matrix of\nthe input problem because the QUBO cost function has different coefficients than the Hamiltonian. Returns a ndarray of the local fields of the model ( Z coefficients). If the Hamiltonian representing the problem is then this method outputs \\(h_{i}\\) as 1-dimensional ndarray . Note that these are different\nfrom the diagonal elements of qubo_matrix of the input problem because the QUBO cost function has different coefficients than the Hamiltonian. The function that performs the training of the angles. The training modifies angles in-place using\nthe minimize() function from scipy . The training uses the provided estimator . estimator ( EstimatorBackend | None ) \u2013 An estimator EstimatorBackend to be used to calculating expectation\nvalues for the minimization. min_method ( str ) \u2013 The minimization method passed to the minimize() function. None previous iqm.qaoa.qubo_qaoa next iqm.qaoa.transforming_functions By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "maxcut_generator",
    "url": "/iqm-qaoa/api/iqm.applications.maxcut.maxcut_generator.html",
    "description": "The generator function for generating random maxcut problem instances. The generator yields maxcut problem instances using random graphs, created according to the input parameters.\nIf enforce_connecte...",
    "content": "The generator function for generating random maxcut problem instances. The generator yields maxcut problem instances using random graphs, created according to the input parameters.\nIf enforce_connected is set to True , then the resulting graphs are checked for connectivity and\nregenerated if the check fails. In that case, the output graphs are not strictly speaking Erd\u0151s\u2013R\u00e9nyi or uniformly\nrandom regular graphs anymore. n ( int ) \u2013 The number of nodes of the graph. n_instances ( int ) \u2013 The number of maxcut instances to generate. graph_family ( str ) \u2013 A string describing the random graph family to generate.\nPossible graph families include \u2018erdos-renyi\u2019 and \u2018regular\u2019. p ( float ) \u2013 For the Erd\u0151s\u2013R\u00e9nyi graph, this is the edge probability. For other graph families, it\u2019s ignored. d ( int ) \u2013 For the random regular graph, this is the degree of each node in the graph. For other graph families, it\u2019s\nignored. break_z2 ( bool ) \u2013 Optional bool indicating whether the \\(\\mathbb{Z}_2\\) symmetry should be explicitly broken\nin the problem instances. seed ( int ) \u2013 Optional random seed for generating the problem instances. enforce_connected ( bool ) \u2013 A bool stating whether it is required that the random graphs are connected. Problem instances of MaxCutInstance randomly constructed in accordance to the input parameters. Iterator [ MaxCutInstance ] previous greedy_max_cut next MaxCutInstance By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "EstimatorSingleLayer",
    "url": "/iqm-qaoa/api/iqm.qaoa.backends.EstimatorSingleLayer.html",
    "description": "Bases: EstimatorBackend The estimator class for calculating the expectation value analytically (for \\(p=1\\) QAOA). Methods estimate (qaoa_object) Calculates the expectation value of the Hamiltonian fo...",
    "content": "Bases: EstimatorBackend The estimator class for calculating the expectation value analytically (for \\(p=1\\) QAOA). Methods estimate (qaoa_object) Calculates the expectation value of the Hamiltonian for \\(p=1\\) QAOA. Calculates the expectation value of the Hamiltonian for \\(p=1\\) QAOA. The function calculates the energy (exp. val. of the Hamiltonian) by adding the expectation values\nof its individual terms expressed through equation (12) in [ 2 ] .\nThe calculation includes a constant term (coming from the translation of a QUBO problem to a Hamiltonian). qaoa_object ( QUBOQAOA ) \u2013 The instance of QUBOQAOA whose expectation value is to be\ncalculated. The expectation value of the energy of the QAOA state using angles . ValueError \u2013 If the provided QUBOQAOA object has more than 1 layer. float previous EstimatorQUIMB next EstimatorStateVector By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "sk_generator",
    "url": "/iqm-qaoa/api/iqm.applications.sk.sk_generator.html",
    "description": "The generator function for generating random SK model problem instances. The generator yields SherringtonKirkpatrick model problem instances using random interaction_matrix ,\ncreated according to the ...",
    "content": "The generator function for generating random SK model problem instances. The generator yields SherringtonKirkpatrick model problem instances using random interaction_matrix ,\ncreated according to the input parameters. \u2018gaussian\u2019 -> Gaussian distribution with mean 0 and standard deviation 1. \u2018rademacher\u2019 -> Value +1 with probability 0.5 and value -1 with probability 0.5. \u2018uniform\u2019 -> Uniform distribution between 0 and 1. n ( int ) \u2013 The number of qubits in the problem instance, also the intraction_matrix dimensions. n_instances ( int ) \u2013 The number of SK model instances to generate. distribution ( str ) \u2013 A string describing the distribution of the elements in the interaction_matrix .\nPossible distributions include \u2018gaussian\u2019 (also known as \u2018normal\u2019), \u2018rademacher\u2019 and \u2018uniform\u2019. seed ( int ) \u2013 Optional random seed for generating the problem instances. An iterator of SherringtonKirkpatrick objects, corresponding to randomly-generated instances of\nthe model. Iterator [ SherringtonKirkpatrick ] previous iqm.applications.sk next SherringtonKirkpatrick By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa",
    "url": "/iqm-qaoa/api/iqm.qaoa.html",
    "description": "IQM QAOA Subpackages and modules backends The module for various backends for calculating the expectation value / samples from QAOA. circuits This module contains several functions that build various ...",
    "content": "IQM QAOA Subpackages and modules backends The module for various backends for calculating the expectation value / samples from QAOA. circuits This module contains several functions that build various types of circuits (e.g., in qiskit and quimb ) from the QUBOQAOA object. generic_qaoa A module containing the generic QAOA abstract base class. qubo_qaoa A module for the QUBOQAOA class. transforming_functions A module for custom functions that transform data from one format to another format transpiler A folder for modules related to the transpilation (routing) of the QAOA circuit on a QPU. tree_qaoa Contains the TreeQAOA class, built for using the tree schedule. previous SherringtonKirkpatrick next iqm.qaoa.backends By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa.transpiler.sparse.edge_coloring",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.sparse.edge_coloring.html",
    "description": "The module for the edge-coloring of the graph. This file contains code to find the edge coloring of an arbitrary simple graph according to the program defined in [ 5 ] . Almost all functions in this f...",
    "content": "The module for the edge-coloring of the graph. This file contains code to find the edge coloring of an arbitrary simple graph according to the program defined in [ 5 ] . Almost all functions in this file are helper functions. Only find_edge_coloring() is intended\nfor external use. The function plot_edge_coloring() may be used for debugging purposes. Functions ec_is_complete (graph) Check that a graph's edge coloring is complete. ec_is_valid (graph) Check that a graph's edge coloring is valid. find_edge_coloring (input_graph) This function finds an edge coloring for the given graph. plot_edge_coloring (graph[,\u00a0pos,\u00a0...]) A method that plots the edge coloring of a graph. previous iqm.qaoa.transpiler.sparse next ec_is_complete By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "ec_is_valid",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.sparse.edge_coloring.ec_is_valid.html",
    "description": "Check that a graph\u2019s edge coloring is valid. Takes a graph whose edges have an attribute color and checks that no two neighboring edges have the same color\n(i.e., the coloring is valid). graph ( Graph...",
    "content": "Check that a graph\u2019s edge coloring is valid. Takes a graph whose edges have an attribute color and checks that no two neighboring edges have the same color\n(i.e., the coloring is valid). graph ( Graph ) \u2013 A Graph whose edges have an attribute color . True if the edge coloring is valid, False otherwise. bool previous ec_is_complete next find_edge_coloring By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "goemans_williamson",
    "url": "/iqm-qaoa/api/iqm.applications.maxcut.goemans_williamson.html",
    "description": "Runs the Goemans-Williamson algorithm for maxcut, returning a solution bitstring. The Goemans-Williamson is a randomized algorithm for maxcut, with a guaranteed approximation ratio of around 0.87856 ....",
    "content": "Runs the Goemans-Williamson algorithm for maxcut, returning a solution bitstring. The Goemans-Williamson is a randomized algorithm for maxcut, with a guaranteed approximation ratio of around 0.87856 . The algorithm was first described in [ 1 ] . Steps: Relax the problem to a semidefinite program (SDP) with each variable represented by a multi-dimensional vector\non a unit sphere. Solve the SDP. Generate a random hyperplane through the origin. Assign the variables to 0 or 1 based on which side of the plane their multi-dimensional vector lies. max_cut_problem ( MaxCutInstance | Graph ) \u2013 A problem instance of maxcut or a Graph . A bitstring solution. str previous iqm.applications.maxcut next greedy_max_cut By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa.transforming_functions",
    "url": "/iqm-qaoa/api/iqm.qaoa.transforming_functions.html",
    "description": "A module for custom functions that transform data from one format to another format Functions ham_graph_to_ham_operator (ham_graph) A function to transform Hamiltonian represented as a Graph into a Sp...",
    "content": "A module for custom functions that transform data from one format to another format Functions ham_graph_to_ham_operator (ham_graph) A function to transform Hamiltonian represented as a Graph into a SparsePauliOp object. previous QUBOQAOA next ham_graph_to_ham_operator By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa.transpiler.sn.sn",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.sn.sn.html",
    "description": "This module contains the swap strategy from [ 4 ] . Functions sn_router (problem_bqm,\u00a0qpu) The function that implements the 'swap network' swapping strategies. previous iqm.qaoa.transpiler.sn next sn_...",
    "content": "This module contains the swap strategy from [ 4 ] . Functions sn_router (problem_bqm,\u00a0qpu) The function that implements the 'swap network' swapping strategies. previous iqm.qaoa.transpiler.sn next sn_router By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "TreeQAOA",
    "url": "/iqm-qaoa/api/iqm.qaoa.tree_qaoa.TreeQAOA.html",
    "description": "Bases: QUBOQAOA The class for tree QAOA with QUBO cost function. The class inherits everything from QUBOQAOA , but adds one more method set_tree_angles() , which sets angles according to the tree sche...",
    "content": "Bases: QUBOQAOA The class for tree QAOA with QUBO cost function. The class inherits everything from QUBOQAOA , but adds one more method set_tree_angles() , which sets angles according to the tree schedule.\nThe tree schedule uses QAOA angles precalculated numerically for a class of high-girth regular graph problems with\nuniform Hamiltonian. For more details see [ 7 ] . problem ( QUBOInstance | ConstrainedQuadraticInstance ) \u2013 A QUBOInstance object describing the QUBO problem to be solved. num_layers ( int ) \u2013 The number of QAOA layers, commonly referred to as p in the literature. betas ( Sequence [ float ] | ndarray | None ) \u2013 An optional list of the initial beta angles of QAOA. Has to be provided together with gammas . gammas ( Sequence [ float ] | ndarray | None ) \u2013 An optional list of the initial gamma angles of QAOA. Has to be provided together with betas . initial_angles ( Sequence [ float ] | ndarray | None ) \u2013 An optional list of the initial QAOA angles as one variable. Shouldn\u2019t be provided together\nwith either betas or gammas . Attributes Methods set_tree_angles () A method for setting iqm.qaoa.generic_qaoa.QAOA.angles according to the tree schedule. A method for setting iqm.qaoa.generic_qaoa.QAOA.angles according to the tree schedule. The tree schedule is designed for problems with uniform 1-body local field, unit 2-body interactions and\nuniform node degree. Therefore, when given a generic problem, the algorithm first calculates the average\ndegree d_av , the average local field h_av and the average interaction strength j_av (which is used\nto renormalize the local field). The angles are then looked up in the saved files for the nearest implemented\ndegree and local field. For \\(p > 6\\) QAOA, the angles are interpolated from the calculated angles for \\(p = 6\\) . The method doesn\u2019t output anything, but it modifies iqm.qaoa.generic_qaoa.QAOA.angles in-place. ValueError \u2013 If the Hamiltonian contains ferromagnetic (i.e., negative) interactions between qubits. The\n    tree schedule shouldn\u2019t be used for such cases. None previous iqm.qaoa.tree_qaoa next License By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "EstimatorQUIMB",
    "url": "/iqm-qaoa/api/iqm.qaoa.backends.EstimatorQUIMB.html",
    "description": "Bases: EstimatorBackend The estimator class for calculating the expectation value using the tensor network package quimb . Methods estimate (qaoa_object) Calculates the expectation value of the Hamilt...",
    "content": "Bases: EstimatorBackend The estimator class for calculating the expectation value using the tensor network package quimb . Methods estimate (qaoa_object) Calculates the expectation value of the Hamiltonian by contracting the RCC tensor networks in quimb . Calculates the expectation value of the Hamiltonian by contracting the RCC tensor networks in quimb . Uses quimb_tn() to build a Circuit . This object\nrepresents the QAOA circuit, so it can be used to calculate expectation values (using the function local_expectation() ). The local expectation values are added to get\nthe expectation value of the full Hamiltonian. The calculation includes a constant term (coming from\nthe translation of a QUBO problem to a Hamiltonian). qaoa_object ( QUBOQAOA ) \u2013 The instance of QUBOQAOA whose expectation value is to be\ncalculated. The expectation value of the energy of the QAOA state using angles . float previous EstimatorFromSampler next EstimatorSingleLayer By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa.transpiler.rx_to_nx",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.rx_to_nx.html",
    "description": "Module to carry a helpful function to transform a rustworkx graph into a networkx.Graph . This function isn\u2019t included in rustworkx or networkx because these two packages don\u2019t want to\nhave the other ...",
    "content": "Module to carry a helpful function to transform a rustworkx graph into a networkx.Graph . This function isn\u2019t included in rustworkx or networkx because these two packages don\u2019t want to\nhave the other as a dependency. Functions rustworkx_to_networkx (graph) Convert a rustworkx graph to a networkx.Graph . previous Routing next rustworkx_to_networkx By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.applications.sk",
    "url": "/iqm-qaoa/api/iqm.applications.sk.html",
    "description": "Module containing the SK model problem instance class. Example Functions sk_generator (n,\u00a0n_instances[,\u00a0distribution,\u00a0...]) The generator function for generating random SK model problem instances. Cla...",
    "content": "Module containing the SK model problem instance class. Example Functions sk_generator (n,\u00a0n_instances[,\u00a0distribution,\u00a0...]) The generator function for generating random SK model problem instances. Classes SherringtonKirkpatrick (interaction_matrix) The problem class for Sherrington Kirkpatrick model. Inheritance previous QUBOInstance next sk_generator By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "star_router",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.star.star.star_router.html",
    "description": "The function that implements the optimal swapping strategy on the star QPU. Looks for the minimum vertex cover set on the problem graph and then swaps the nodes belonging to this cover into\nthe center...",
    "content": "The function that implements the optimal swapping strategy on the star QPU. Looks for the minimum vertex cover set on the problem graph and then swaps the nodes belonging to this cover into\nthe center of the star (adding the interaction gates in between). problem_bqm ( BinaryQuadraticModel ) \u2013 The BinaryQuadraticModel description of the problem, necessary to create\nan instance of RoutingStar . qpu ( StarQPU ) \u2013 The QPU, necessary to create an instance of RoutingStar . A RoutingStar object containing the optimal star swapping strategy. RoutingStar previous iqm.qaoa.transpiler.star.star next RoutingStar By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "SherringtonKirkpatrick",
    "url": "/iqm-qaoa/api/iqm.applications.sk.SherringtonKirkpatrick.html",
    "description": "Bases: QUBOInstance The problem class for Sherrington Kirkpatrick model. In this model, all qubits interact with randomly distributed interactions. The model takes an interaction matrix on\ninput. The ...",
    "content": "Bases: QUBOInstance The problem class for Sherrington Kirkpatrick model. In this model, all qubits interact with randomly distributed interactions. The model takes an interaction matrix on\ninput. The suggested usage is to generate SK problem instances using sk_generator() . interaction_matrix ( ndarray ) \u2013 The matrix of interactions between the spins in the SK model. Attributes Methods previous sk_generator next iqm.qaoa By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa.qubo_qaoa",
    "url": "/iqm-qaoa/api/iqm.qaoa.qubo_qaoa.html",
    "description": "A module for the QUBOQAOA class. The class QUBOQAOA mostly serves to store the parameters (angles) of the QAOA circuit and to facilitate various\noperations on it. The training of the QAOA circuit is d...",
    "content": "A module for the QUBOQAOA class. The class QUBOQAOA mostly serves to store the parameters (angles) of the QAOA circuit and to facilitate various\noperations on it. The training of the QAOA circuit is done here. For constructing circuits representing the QAOA, use\nfunctions from the module circuits . For sampling from the QAOA and calculating expectation values, use\nthe backend classes from the module backends . Classes QUBOQAOA (problem,\u00a0num_layers,\u00a0*[,\u00a0betas,\u00a0...]) The class for QAOA with quadratic unconstrained binary (QUBO) cost function. Inheritance previous QAOA next QUBOQAOA By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "EstimatorBackend",
    "url": "/iqm-qaoa/api/iqm.qaoa.backends.EstimatorBackend.html",
    "description": "Bases: ABC The ABC for estimator backends, i.e., those calculating the expected value of the Hamiltonian. Methods estimate (qaoa_object) The abstract method for estimate() of backends subclassed from ...",
    "content": "Bases: ABC The ABC for estimator backends, i.e., those calculating the expected value of the Hamiltonian. Methods estimate (qaoa_object) The abstract method for estimate() of backends subclassed from EstimatorBackend . The abstract method for estimate() of backends subclassed from EstimatorBackend . The input qaoa_object includes the training parameters ( angles ), which\nare typically used in estimation of the energy. qaoa_object ( QAOA ) \u2013 The QAOA object whose energy is to be estimated. The estimated expected value of the Hamiltonian with the quantum state implied by the QAOA object. float previous iqm.qaoa.backends next EstimatorFromSampler By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa.tree_qaoa",
    "url": "/iqm-qaoa/api/iqm.qaoa.tree_qaoa.html",
    "description": "Contains the TreeQAOA class, built for using the tree schedule. Also contains a little helper function _find_nearest . Classes TreeQAOA (problem,\u00a0num_layers,\u00a0*[,\u00a0betas,\u00a0...]) The class for tree QAOA w...",
    "content": "Contains the TreeQAOA class, built for using the tree schedule. Also contains a little helper function _find_nearest . Classes TreeQAOA (problem,\u00a0num_layers,\u00a0*[,\u00a0betas,\u00a0...]) The class for tree QAOA with QUBO cost function. Inheritance previous RoutingStar next TreeQAOA By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "ec_is_complete",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.sparse.edge_coloring.ec_is_complete.html",
    "description": "Check that a graph\u2019s edge coloring is complete. graph ( Graph ) \u2013 A Graph whose edge coloring we want to check. True if every edge of the graph has an attribute color , False otherwise. bool previous ...",
    "content": "Check that a graph\u2019s edge coloring is complete. graph ( Graph ) \u2013 A Graph whose edge coloring we want to check. True if every edge of the graph has an attribute color , False otherwise. bool previous iqm.qaoa.transpiler.sparse.edge_coloring next ec_is_valid By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "MISInstance",
    "url": "/iqm-qaoa/api/iqm.applications.mis.MISInstance.html",
    "description": "Bases: ISInstance The instance class for maximum independent set problems. The maximum independent set problem refers to finding the largest subset of nodes of a graph, such that no nodes\nin the subse...",
    "content": "Bases: ISInstance The instance class for maximum independent set problems. The maximum independent set problem refers to finding the largest subset of nodes of a graph, such that no nodes\nin the subset are connected by an edge. It is completely equivalent to finding the largest clique on the complement\ngraph. The class is initialized by initializing its parent class ISInstance with\na simple objective function (aiming at maximizing the number of \u201cselected\u201d nodes). graph ( Graph ) \u2013 The Graph describing the MIS problem. penalty ( float | int ) \u2013 The penalty to be incurred per each edge present in the solution, sometimes referred to as \\(\\lambda\\) in the literature. The higher it is, the less likely the algorithm is to include an edge in\nthe solution. It needs to be set above 1 to insure that the solution is a maximum independent set. It\u2019s\ntypically set at 2. At 1, the correct solution will be degenerate with non-independent sets. Attributes best_quality The best quality for the MIS problem, calculated using the Bron-Kerbosch algorithm. Methods fix_constraint_violation_bitstring (bit_str) Postprocessing function that fixes a single bitstring, making it satisfy the constraints. The best quality for the MIS problem, calculated using the Bron-Kerbosch algorithm. Instead of brute-forcing over all possible bitstrings, this uses an exhaustive algorithm that finds\nthe best solution more efficiently (although it also has exponential scaling). Postprocessing function that fixes a single bitstring, making it satisfy the constraints. It works in the following way: Get the subgraph induced by the bitstring bit_str . Find the node with the highest degree. Remove the node from the subgraph (i.e., flip the corresponding bit from \u201c1\u201d to \u201c0\u201d). Repeat 2-3 until the subgraph contains no edges. Return the bitstring corresponding to the remaining subgraph (which is an independent subset of the original\ngraph). For penalty = 1 , this guarantees that the output bitstring has energy at least as low as the input\nbitstring. For penalty > 1 , the energy is expected to be even lower. bit_str ( str ) \u2013 The bitstring to be modified to satisfy the independence constraint. The modified bitstring, corresponding to an independent set of the problem graph. str previous ISInstance next MaximumWeightISInstance By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "ConstrainedQuadraticInstance",
    "url": "/iqm-qaoa/api/iqm.applications.qubo.ConstrainedQuadraticInstance.html",
    "description": "Bases: ProblemInstance A class for constrainted quadratic binary problems. The class saves the problem as a ConstrainedQuadraticModel and uses this object for its\nvarious methods. When the problem nee...",
    "content": "Bases: ProblemInstance A class for constrainted quadratic binary problems. The class saves the problem as a ConstrainedQuadraticModel and uses this object for its\nvarious methods. When the problem needs to be transformed into a QUBO, a private method _recalculate_bqm() is used to return a BinaryQuadraticModel formulation of the problem, making the constraints\nsoft and penalizing their breaking with penalty . cqm ( ConstrainedQuadraticModel ) \u2013 The problem encoded as a ConstrainedQuadraticModel , passed over from a subclass. penalty ( float ) \u2013 The numerical penalty incurred by violating each constraint of the problem, to be used when\nthe problem is transformed into a BQM. Attributes bqm The BQM representation of the problem, penalizing constraint violation. cqm The ConstrainedQuadraticModel representation of the problem instance. dim The dimension of the problem (i.e., the number of binary variables). penalty The penalty for breaking the constraints. qubo_graph The QUBO graph of the problem instance. qubo_matrix The QUBO matrix of the problem instance. Methods _recalculate_bqm ()  constraints_checker (bit_str) Checks whether the constrains of the problem are satisfied. fix_constraint_violation (counts) Post-processing which takes a dictionary of counts and changes the bitstrings in it in some minimal way so that they all satisfy the constraints. fix_constraint_violation_bitstring (bit_str) Post-processing which takes a solution and changes it in some minimal way so that it satisfies the constraints. fix_variables (variables) Fixes (assigns) some of the problem variables. initialize_properties ([max_size]) The initialization method for upper/lower bound, average/best quality. loss (bit_str) The loss function calculated for a given solution. quality (bit_str) The quality function overridden for constrainted problems. satisfy_constraints (counts) Post-processing method that takes a dictionary and removes the bitstrings which don't satisfy the constraints. The ConstrainedQuadraticModel representation of the problem instance. The dimension of the problem (i.e., the number of binary variables). The BQM representation of the problem, penalizing constraint violation. The problem represented as BinaryQuadraticModel . This is calculated using _recalculate_bqm() by inserting the constraints as penalties to the cost function. Fixes (assigns) some of the problem variables. This method is not implemented in ConstrainedQuadraticInstance because in the general case, fixing one\nvariable might have implications for the other variables (implied by the constraints). Therefore, this method\nneeds to be implemented in a subclass of ConstrainedQuadraticInstance , if it\u2019s needed. variables ( list [ Hashable ] | dict [ Hashable , int ] ) \u2013 Either a list of variables (which get all fixed to the value 1) or a dictionary with keys equal\nto the variables to fix and whose values are equal to the values to fix them to (either 1 or 0). None The penalty for breaking the constraints. The QUBO matrix of the problem instance. The matrix is obtained from the internal attribute bqm . The i,i diagonal entry corresponds to the local field acting on the i-th variable. The i,j entry above the diagonal corresponds to the interaction between the i-th and j-th variables. The entries below the diagonal are empty. The QUBO graph of the problem instance. The nodes / edges of the graph have a bias parameter containing the local field / interaction strength\nof the corresponding variable(s). Variables without interaction aren\u2019t connected by edges in the graph. Checks whether the constrains of the problem are satisfied. bit_str ( str ) \u2013 A bitstring representing a solution. Bool indicating whether the solution satisfies the constraints or not. bool The loss function calculated for a given solution. It is equivalent to the quality of the solution, but with extra penalties for breaking the constraints. bit_str ( str ) \u2013 A bitstring representing a solution. The loss of the solution. float The quality function overridden for constrainted problems. For solutions violating the constraints, the \u201cquality\u201d isn\u2019t defined. If a user asks for the quality of\nthe solution, this function first checks if the constraints are satisfied, prints out a warning if they\naren\u2019t, and then returns the loss function. bit_str ( str ) \u2013 A bitstring representing a solution. The loss of the solution and a printed warning if the solution violates the constraints. float The initialization method for upper/lower bound, average/best quality. This is the method from the parent class ProblemInstance , overridden so\nthat the bruteforce search only includes solutions which satisfy the constraints. max_size ( int | None ) \u2013 The maximum size of problems for which the properties may be calculated. ValueError \u2013 If initialize_properties() was called on a ConstrainedQuadraticInstance object with dimension larger than max_size . None Post-processing which takes a dictionary of counts and changes the bitstrings in it in some minimal way so\nthat they all satisfy the constraints. Iterates through the dictionary counts and for each key calls fix_constraint_violation_bitstring() .\nIn case that multiple bitstrings get mapped to the same bitstring, their respective frequencies (values) are\nadded. counts ( dict [ str , int ] ) \u2013 The dictionary of bitstrings with their frequencies as values. The input dictionary modified so that the keys now satisfy the problem constraints. dict [ str , int ] Post-processing which takes a solution and changes it in some minimal way so that it satisfies the\nconstraints. This is not possible to do generally, so this method is not implemented for :class:ConstrainedQuadraticInstance`\nand it needs to be defined for the individual subclasses of ConstrainedQuadraticInstance (if it\u2019s\npossible to do). If the input bitstring bit_str already satisfies the problem constraints, it should be\nreturned unchanged. bit_str ( str ) \u2013 The bitstring to be modified to satisfy the constraints. The bitstring modified in some minimal way to satisfy the constraints. str Post-processing method that takes a dictionary and removes the bitstrings which don\u2019t satisfy the\nconstraints. counts ( dict [ str , int ] ) \u2013 A dictionary of counts, with solution strings as keys and their frequencies as values. The same dictionary as inputted, except with removed entries whose keys don\u2019t satisfy the problem\nconstraints. dict [ str , int ] previous relabel_graph_nodes next QUBOInstance By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa.transpiler.sn",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.sn.html",
    "description": "The submodule for swap-network-based transpilation of dense QAOA circuits. Subpackages and modules sn This module contains the swap strategy from [ 4 ] . previous rustworkx_to_networkx next iqm.qaoa.t...",
    "content": "The submodule for swap-network-based transpilation of dense QAOA circuits. Subpackages and modules sn This module contains the swap strategy from [ 4 ] . previous rustworkx_to_networkx next iqm.qaoa.transpiler.sn.sn By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "QAOA",
    "url": "/iqm-qaoa/api/iqm.qaoa.generic_qaoa.QAOA.html",
    "description": "Bases: ABC The most generic QAOA abstract base class. This abstract base class contains methods such as _internal_angle_logic() or linear_ramp_schedule() that can be used by any type / flavor of QAOA....",
    "content": "Bases: ABC The most generic QAOA abstract base class. This abstract base class contains methods such as _internal_angle_logic() or linear_ramp_schedule() that can be used by any type / flavor of QAOA. problem ( ProblemInstance ) \u2013 The ProblemInstance to be solved by the QAOA. num_layers ( int ) \u2013 The number of QAOA layers. betas ( Sequence [ float ] | ndarray | None ) \u2013 An optional list of the initial beta angles of QAOA. Has to be provided together with gammas . gammas ( Sequence [ float ] | ndarray | None ) \u2013 An optional list of the initial gamma angles of QAOA. Has to be provided together with betas . initial_angles ( Sequence [ float ] | ndarray | None ) \u2013 An optional list of the initial QAOA angles as one variable. Shouldn\u2019t be provided together\nwith either betas or gammas . Attributes angles The angles in the QAOA, including betas and gammas in one ndarray . betas The beta angles in the QAOA, controlling the mixer Hamiltonian terms. gammas The gamma angles in the QAOA, controlling the problem Hamiltonian terms. num_layers The number of QAOA layers. num_qubits The number of qubits, equal to the number of problem variables if no special encoding is used. problem The problem instance associated with the QAOA. trained A boolean flag indicating whether the QAOA has been trained at all or not. Methods _internal_angle_logic ([betas,\u00a0gammas,\u00a0...]) Internal method to guarantee that angles are assigned correctly. estimate (estimator) The method for taking estimates of the expected value of the Hamiltonian from the QAOA circuit. linear_ramp_schedule (delta_beta,\u00a0delta_gamma) The \"linear ramp schedule\" for setting the QAOA angles. sample (sampler[,\u00a0shots]) The method for taking samples (i.e., measurement results) from the QAOA circuit. train () The function that performs the training of the angles. A boolean flag indicating whether the QAOA has been trained at all or not. The number of QAOA layers. At first this is set to the value given at initialization, but it may be modified later (which has an effect on angles ). The problem instance associated with the QAOA. The number of qubits, equal to the number of problem variables if no special encoding is used. The beta angles in the QAOA, controlling the mixer Hamiltonian terms. The gamma angles in the QAOA, controlling the problem Hamiltonian terms. The angles in the QAOA, including betas and gammas in one ndarray . The method for taking samples (i.e., measurement results) from the QAOA circuit. Takes a SamplerBackend and uses it to get shots samples. The backend is\nresponsible for building the quantum circuit and taking the measurements (or obtaining the samples some other\nway), using information from the QAOA object that is passed to its method sample() . sampler ( SamplerBackend ) \u2013 The sampler to use to generate samples. The sampler is an instance of a subclass of SamplerBackend with a sample() method of the appropriate signature. shots ( int ) \u2013 The number of shots to be taken. A dictionary whose keys are bitstrings representing the samples and whose values are their respective\nfrequencies, so that the sum of the values of the dictionary equals to shots . dict [ str , int ] The method for taking estimates of the expected value of the Hamiltonian from the QAOA circuit. Takes a EstimatorBackend and uses it to get estimates of the expected value.\nThe backend takes all the necessary information from the QAOA object that is passed to its method estimate() . estimator ( EstimatorBackend ) \u2013 The estimator used to get the expected value. The estimator is an instance of a subclass of EstimatorBackend with a method estimate() of the appropriate signature. An estimate of the expectation value fo the Hamiltonian. Not normalized in any way. float The \u201clinear ramp schedule\u201d for setting the QAOA angles. Formulas adapted from [ 3 ] . It can be used either instead of training the QAOA or as\na starting set of angles. The above work uses delta_beta and delta_gamma values around 0.5, but the best\nchoice for these values depends on the problem Hamiltonian. delta_beta ( float ) \u2013 The maximum beta angle. delta_gamma ( float ) \u2013 The maximum gamma angle. None The function that performs the training of the angles. None previous iqm.qaoa.generic_qaoa next iqm.qaoa.qubo_qaoa By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa.transpiler.star.star",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.star.star.html",
    "description": "The module for the router for the star QPU. Functions star_router (problem_bqm,\u00a0qpu) The function that implements the optimal swapping strategy on the star QPU. Classes RoutingStar (problem_bqm,\u00a0qpu[,...",
    "content": "The module for the router for the star QPU. Functions star_router (problem_bqm,\u00a0qpu) The function that implements the optimal swapping strategy on the star QPU. Classes RoutingStar (problem_bqm,\u00a0qpu[,\u00a0initial_mapping]) This class represents a routing of a QAOA phase separator on the star topology. Inheritance previous iqm.qaoa.transpiler.star next star_router By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "QPU",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.quantum_hardware.QPU.html",
    "description": "Bases: object A parent class for all QPU architectures. The main purpose of the QPU class is to store the hardware_graph and the shortest_path /s in there.\nThe method draw() can be used independently ...",
    "content": "Bases: object A parent class for all QPU architectures. The main purpose of the QPU class is to store the hardware_graph and the shortest_path /s in there.\nThe method draw() can be used independently to plot the graph (using the hardware_layout ), but it\u2019s\nmeant to be used by the draw() method of the class Layer . hardware_graph ( nx.Graph ) \u2013 A Graph representing the topology of the QPU, i.e., the connections between\nthe HardQubit s. hardware_layout ( dict [ HardQubit , tuple [ Any , Any ] ] | None ) \u2013 A layout of the QPU, i.e., the coordinates of the qubits in the 2D plane. Attributes hardware_graph The connectivity graph of the QPU. hardware_layout The layout of the hardware qubits (in the 2D plane). qubits The set of all HardQubit s of the QPU. shortest_path The dictionary of dictionaries of shortest paths. Methods draw ([mapping,\u00a0ax,\u00a0gate_lists,\u00a0show]) A method for drawing the QPU. has_edge (gate) Is there an edge between the qubits involved in gate ? The set of all HardQubit s of the QPU. Is there an edge between the qubits involved in gate ? gate ( HardEdge ) \u2013 A HardEdge between two HardQubit s. True if there is an edge between the two HardQubit s on the QPU graph and False otherwise. bool The connectivity graph of the QPU. The layout of the hardware qubits (in the 2D plane). The dictionary of dictionaries of shortest paths. It\u2019s defined so that shortest_path[source][target] is the list of nodes lying on the/a shortest path\nbetween the source and target nodes. A method for drawing the QPU. It displays the picture of the QPU in a pop-up window, with edges colored based on gate_lists . mapping ( Mapping | None ) \u2013 The mapping between the logical and hardware qubits, for labels of the graph nodes. ax ( Axes | None ) \u2013 An instance of matplotlib.axes.Axes object, to define the plotting area. gate_lists ( dict [ str , list [ tuple [ HardQubit ] ] ] | None ) \u2013 A dictionary whose keys are colors (as single-letter strings) and values are lists of edges\nwhich should be colored that color. show ( bool ) \u2013 Boolean which decides if the graph will be shown in a pop-up window. **kwargs ( Any ) \u2013 Arbitrary keyword arguments. None previous LineQPU next StarQPU By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "rustworkx_to_networkx",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.rx_to_nx.rustworkx_to_networkx.html",
    "description": "Convert a rustworkx graph to a networkx.Graph . Doesn\u2019t preserve node / edge weights or respect multigraphs. graph ( PyGraph | PyDiGraph ) \u2013 The graph to be converted. The converted graph. Graph previ...",
    "content": "Convert a rustworkx graph to a networkx.Graph . Doesn\u2019t preserve node / edge weights or respect multigraphs. graph ( PyGraph | PyDiGraph ) \u2013 The graph to be converted. The converted graph. Graph previous iqm.qaoa.transpiler.rx_to_nx next iqm.qaoa.transpiler.sn By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "hardwired_router",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.hardwired.hardwired.hardwired_router.html",
    "description": "The function that creates an optimal routing for all-to-all connected problems, designed by hand. The original code was written for hand-picked qubits from the Apollo QPU. When this was expanded to be...",
    "content": "The function that creates an optimal routing for all-to-all connected problems, designed by hand. The original code was written for hand-picked qubits from the Apollo QPU. When this was expanded to be used on\nany QPU, the algorithm had to be adjusted. Here is how it works now: First, the BinaryQuadraticModel representation of the problem is padded with extra\ninteractions (of strength 0), to make it trully all-to-all connected. Then, based on the number of variables of the problem, we construct a dummy graph underlying_graph which\nrepresents the part of the QPU on which the circuit acts. We find a suitable mapping between underlying_graph and the QPU graph hardware_graph . This mapping inverse_iso is used in the apply_int() and apply_swap() method calls. Using the apply_int() and apply_swap() methods, the hardwired routing is constructed. problem_bqm ( BinaryQuadraticModel ) \u2013 The BinaryQuadraticModel representation of the problem, needed only to\ninstantiate the Routing . qpu ( CrystalQPUFromBackend ) \u2013 The CrystalQPUFromBackend object. A Routing object containing the entire routing schedule. ValueError \u2013 If the number of variables of the problem is not between 4 and 15 (inclusive). Routing previous iqm.qaoa.transpiler.hardwired.hardwired next iqm.qaoa.transpiler.quantum_hardware By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.qaoa.transpiler.routing",
    "url": "/iqm-qaoa/api/iqm.qaoa.transpiler.routing.html",
    "description": "This module contains the object classes Mapping , Layer and Routing to be used throughout any\ntranspilation algorithm. Classes Layer (qpu[,\u00a0int_gates,\u00a0swap_gates]) A class describing one layer of the ...",
    "content": "This module contains the object classes Mapping , Layer and Routing to be used throughout any\ntranspilation algorithm. Classes Layer (qpu[,\u00a0int_gates,\u00a0swap_gates]) A class describing one layer of the QAOA phase separator, consisting of swap and interaction gates. Mapping (qpu,\u00a0problem_bqm[,\u00a0...]) This class is responsible for a mapping between logical and hardware qubits. Routing (problem_bqm,\u00a0qpu[,\u00a0initial_mapping]) This class represents a routing of a QAOA phase separator. Inheritance previous StarQPU next Layer By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "quimb_tn",
    "url": "/iqm-qaoa/api/iqm.qaoa.circuits.quimb_tn.html",
    "description": "Constructs a quimb tensor network representing the quantum circuit. The object is constructed just like any other quantum circuit by applying quantum gates. quimb transforms those into tensors. qaoa (...",
    "content": "Constructs a quimb tensor network representing the quantum circuit. The object is constructed just like any other quantum circuit by applying quantum gates. quimb transforms those into tensors. qaoa ( QUBOQAOA ) \u2013 A QUBOQAOA object whose angles and interaction strengths are used in\nthe construction of the tensor network. quimb tensor network representing the QAOA circuit (without measurements). qtn.Circuit previous qiskit_circuit_specific_nodes next transpiled_circuit By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "iqm.applications",
    "url": "/iqm-qaoa/api/iqm.applications.html",
    "description": "Classes and tools for defining problem instances. Subpackages and modules applications This module contains the abstract base class providing a template for defining problem instances. maxcut This mod...",
    "content": "Classes and tools for defining problem instances. Subpackages and modules applications This module contains the abstract base class providing a template for defining problem instances. maxcut This module contains the maxcut problem instance class and related functions. mis Module containing the MIS problem instance class. qubo Contains problem instance classes for a generic QUBO problem and a genetic constrained QUBO problem. sk Module containing the SK model problem instance class. previous API Reference next iqm.applications.applications By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "MaximumWeightISInstance",
    "url": "/iqm-qaoa/api/iqm.applications.mis.MaximumWeightISInstance.html",
    "description": "Bases: ISInstance The instance class for maximum-weight independent set problems. The maximum-weight independent set problem refers to finding a subset of nodes of a graph, such that no nodes in\nthe s...",
    "content": "Bases: ISInstance The instance class for maximum-weight independent set problems. The maximum-weight independent set problem refers to finding a subset of nodes of a graph, such that no nodes in\nthe subset are connected by an edge and sum of the weights of the nodes in the subset is maximized. The class is\ninitialized by initializing its parent class ISInstance with a custom objective\nfunction (carrying the weights of the graph nodes). graph ( Graph ) \u2013 The Graph describing the maximum-weight independent set problem. Each node has to have\nan attribute weight storing a number. penalty ( float | int ) \u2013 The penalty to be incurred per each edge present in the solution, sometimes referred to as \\(\\lambda\\) in the literature. The higher it is, the less likely the algorithm is to include an edge in\nthe solution. This is needed when the problem formulation is transformed into QUBO. ValueError \u2013 If any node of the input graph is missing the weight attribute. TypeError \u2013 If the weight of any node is a wrong data type (neither float nor int ). Attributes Methods previous MISInstance next iqm.applications.qubo By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-qaoa",
    "title": "EstimatorFromSampler",
    "url": "/iqm-qaoa/api/iqm.qaoa.backends.EstimatorFromSampler.html",
    "description": "Bases: EstimatorBackend The estimator class for calculating the expectation value using counts obtained from a sampler. Takes an instance of a subclass of SamplerBackend and uses it to generate sample...",
    "content": "Bases: EstimatorBackend The estimator class for calculating the expectation value using counts obtained from a sampler. Takes an instance of a subclass of SamplerBackend and uses it to generate samples from the QAOA.\nThese energy of these samples is then calculated classically and averaged-out to produce an estimate of\nthe expectation value of the Hamiltonian. If cvar is provided, the estimator returns not the average of\nthe energies, but its CVaR at the cvar threshold. sampler ( SamplerBackend ) \u2013 The sampler to produce the samples. shots ( int ) \u2013 The number of shots that should be produced with the sampler. cvar ( float | None ) \u2013 The threshold used to calculate CVaR (if provided). ValueError \u2013 If cvar is provided, but it\u2019s not between 0 and 1. Methods estimate (qaoa_object) Calculates the expectation value of the Hamiltonian by sampling from the QAOA circuit. Calculates the expectation value of the Hamiltonian by sampling from the QAOA circuit. Uses the sampler provided at initialization to sample from the QAOA circuit and then calculates the expectation\nvalue from the counts. qaoa_object ( QAOA ) \u2013 The instance of QAOA whose expectation value is to be\ncalculated. The average energy of the sampled docstrings (to serve as estimation of the expectation value). float previous EstimatorBackend next EstimatorQUIMB By IQM QAOA developers \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "API Reference",
    "url": "/iqm-data-definitions/API.html",
    "description": "The module iqm.data_definitions contains autogenerated Python code for Protobuf prototypes.\nThe prototypes are used in client\u2013server communication between IQM Station Control and it\u2019s clients.\nUsers a...",
    "content": "The module iqm.data_definitions contains autogenerated Python code for Protobuf prototypes.\nThe prototypes are used in client\u2013server communication between IQM Station Control and it\u2019s clients.\nUsers are not expected to interact with this module directly, except when integrating custom client libraries against\nIQM\u2019s QCCSW. The module iqm.models contains the Python-native representations of the some of the prototypes.\nUsers of iqm-pulse might encounter these. iqm.models Python-native representation of the protos in iqm.data_definitions , recognized by IQM Station Control. iqm.data_definitions  Note The API documentation of iqm.data_definitions is generated automatically based on the raw .proto files\nthat define the cross-platform communication protocols.\nAs such, the minimal HTML documentation is missing the typical docstrings.\nHowever, the Python module iqm.data_definitions includes Python stub files ( .pyi ), which include\nproper type hints and docstrings, so they are displayed in IDEs.\nFurthermore, the HTML documentation of the _pb2 modules include the .proto source files,\nincluding docstrings, so that low-level integrators can use them generate compatible code for their chosen language. previous IQM Data Definitions next models By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "IQM Data Definitions",
    "url": "/iqm-data-definitions/index.html",
    "description": "2.13 2025-07-07 Low-level data prototypes shared across the control software of IQM quantum computers. Index Module Index Search Page next API Reference By IQM \u00a9 Copyright 2021-2025, IQM. Last updated...",
    "content": "2.13 2025-07-07 Low-level data prototypes shared across the control software of IQM quantum computers. Index Module Index Search Page next API Reference By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "common",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.html",
    "description": "Full path: iqm.data_definitions.common Subpackages and modules v1  previous data_definitions next v1 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07....",
    "content": "Full path: iqm.data_definitions.common Subpackages and modules v1  previous data_definitions next v1 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Parameter",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.parameter_pb2.Parameter.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.parameter_pb2 Attributes DESCRIPTOR  Methods previous parameter_pb2 next playlist_pb2 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.parameter_pb2 Attributes DESCRIPTOR  Methods previous parameter_pb2 next playlist_pb2 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "RealPulse",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.instructions.RealPulse.html",
    "description": "Bases: object Class for Real pulses. Contains a waveform object describing the waveform shape. Module: iqm.models.playlist.instructions Attributes wave  scale  Methods wave ( Waveform ) \u2013 scale ( floa...",
    "content": "Bases: object Class for Real pulses. Contains a waveform object describing the waveform shape. Module: iqm.models.playlist.instructions Attributes wave  scale  Methods wave ( Waveform ) \u2013 scale ( float ) \u2013 previous ReadoutTrigger next ThresholdStateDiscrimination By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "GaussianDerivative",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.waveforms.GaussianDerivative.html",
    "description": "Bases: Waveform Derivative of a gaussian pulse. Normalized so that values are in \\([-1, 1]\\) .\nThe normalization factor is \\(\\sigma \\: \\sqrt{e}\\) . where \\(c\\) is center_offset , and \\(\\sigma\\) is sig...",
    "content": "Bases: Waveform Derivative of a gaussian pulse. Normalized so that values are in \\([-1, 1]\\) .\nThe normalization factor is \\(\\sigma \\: \\sqrt{e}\\) . where \\(c\\) is center_offset , and \\(\\sigma\\) is sigma . sigma ( float ) \u2013 gaussian standard deviation center_offset ( float ) \u2013 center offset n_samples ( int ) \u2013 Module: iqm.models.playlist.waveforms Attributes center_offset  sigma  n_samples Requested number of samples for the waveform. Methods previous Gaussian next GaussianSmoothedSquare By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "channel_properties_pb2",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.channel_properties_pb2.html",
    "description": "Generated protocol buffer code. Full path: iqm.data_definitions.common.v1.channel_properties_pb2 Classes AWGProperties  ChannelProperties  ChannelPropertyDictionary  ChannelPropertyEntry  ReadoutPrope...",
    "content": "Generated protocol buffer code. Full path: iqm.data_definitions.common.v1.channel_properties_pb2 Classes AWGProperties  ChannelProperties  ChannelPropertyDictionary  ChannelPropertyEntry  ReadoutProperties  previous v1 next AWGProperties By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "AWGProperties",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.channel_properties_pb2.AWGProperties.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.channel_properties_pb2 Attributes DESCRIPTOR  Methods previous channel_properties_pb2 next ChannelProperties By IQM \u00a9 Copyright 2021-202...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.channel_properties_pb2 Attributes DESCRIPTOR  Methods previous channel_properties_pb2 next ChannelProperties By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "iqm.models.playlist.waveforms.register_canonical_waveform",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.waveforms.register_canonical_waveform.html",
    "description": "Decorator for making a Waveform into a canonical waveform. cls ( type [ Waveform ] ) \u2013 type previous iqm.models.playlist.waveforms.is_canonical next iqm.models.playlist.waveforms.to_canonical By IQM \u00a9...",
    "content": "Decorator for making a Waveform into a canonical waveform. cls ( type [ Waveform ] ) \u2013 type previous iqm.models.playlist.waveforms.is_canonical next iqm.models.playlist.waveforms.to_canonical By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "NumcodecsConfig",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.spot_result_pb2.NumcodecsConfig.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.spot_result_pb2 Attributes DESCRIPTOR  Methods previous NpyArray next SpotResultValue By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.spot_result_pb2 Attributes DESCRIPTOR  Methods previous NpyArray next SpotResultValue By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "MultiplexedRealPulse",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.MultiplexedRealPulse.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message previous MultiplexedIQPulse next Playlist By IQM \u00a9 Copyright 2021-2...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message previous MultiplexedIQPulse next Playlist By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "TruncatedGaussianDerivative",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.TruncatedGaussianDerivative.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous TruncatedGaussian next TruncatedGaussianSmoothedSquare By IQM \u00a9 Copyright 2021-2025...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous TruncatedGaussian next TruncatedGaussianSmoothedSquare By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "ThresholdStateDiscrimination",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.instructions.ThresholdStateDiscrimination.html",
    "description": "Bases: ComplexIntegration Perform a weighted integration of the IQ raw signal and compares the real part of the result against a\nthreshold value, resulting in a single bit. Module: iqm.models.playlist...",
    "content": "Bases: ComplexIntegration Perform a weighted integration of the IQ raw signal and compares the real part of the result against a\nthreshold value, resulting in a single bit. Module: iqm.models.playlist.instructions Attributes feedback_signal_label In fast feedback routing, the transmitted signals are associated with this label. threshold The real part of the integration result is compared against this. weights Integration weights. label Identifier for the returned data, like QB1__readout.time_trace . delay_samples Delay from beginning of probe pulse to beginning of acquisition window, in samples. Methods label ( str ) \u2013 delay_samples ( int ) \u2013 weights ( IQPulse ) \u2013 threshold ( float ) \u2013 feedback_signal_label ( str ) \u2013 The real part of the integration result is compared against this. In fast feedback routing, the transmitted signals are associated with this label.\nConditionalInstructions whose \u201ccondition\u201d field has the string value of feedback_signal_label will receive the signal from this ThresholdStateDiscrimination.\nEmpty string (default) means the signal is not routed anywhere.\nThe same feedback_signal_label may not be used multiple times within the same ReadoutTrigger.\nThe same feedback_signal_label can be used in different ReadoutTriggers and different segments. previous RealPulse next TimeTrace By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "segment",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.segment.html",
    "description": "Segment class definitions Full path: iqm.models.playlist.segment Classes Segment Contains the instructions to be executed in one segment for each channel. previous Playlist next Segment By IQM \u00a9 Copyr...",
    "content": "Segment class definitions Full path: iqm.models.playlist.segment Classes Segment Contains the instructions to be executed in one segment for each channel. previous Playlist next Segment By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "ChannelConfiguration",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.ChannelConfiguration.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous AcquisitionMethod next ChannelDescription By IQM \u00a9 Copyright 2021-2025, IQM. Last u...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous AcquisitionMethod next ChannelDescription By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "ReadoutTrigger",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.ReadoutTrigger.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous ReadoutChannelConfig next RealChannelConfig By IQM \u00a9 Copyright 2021-2025, IQM. Last...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous ReadoutChannelConfig next RealChannelConfig By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "station_control",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.station_control.html",
    "description": "Full path: iqm.data_definitions.station_control Subpackages and modules v1  v2  previous SingleParameterSweep next v1 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07....",
    "content": "Full path: iqm.data_definitions.station_control Subpackages and modules v1  v2  previous SingleParameterSweep next v1 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "TruncatedGaussianSmoothedSquare",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.TruncatedGaussianSmoothedSquare.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous TruncatedGaussianDerivative next VirtualRZ By IQM \u00a9 Copyright 2021-2025, IQM. Last ...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous TruncatedGaussianDerivative next VirtualRZ By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "ObservationValue",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.observation_pb2.ObservationValue.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.observation_pb2 Attributes DESCRIPTOR  Methods previous ObservationUncertainty next parameter_pb2 By IQM \u00a9 Copyright 2021-2025, IQM. Las...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.observation_pb2 Attributes DESCRIPTOR  Methods previous ObservationUncertainty next parameter_pb2 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Complex128",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.data_types_pb2.Complex128.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.data_types_pb2 Attributes DESCRIPTOR  Methods previous BoolSequence next Complex128Sequence By IQM \u00a9 Copyright 2021-2025, IQM. Last upda...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.data_types_pb2 Attributes DESCRIPTOR  Methods previous BoolSequence next Complex128Sequence By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "ObservationUncertainty",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.observation_pb2.ObservationUncertainty.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.observation_pb2 Attributes DESCRIPTOR  Methods previous Int64Array next ObservationValue By IQM \u00a9 Copyright 2021-2025, IQM. Last updated...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.observation_pb2 Attributes DESCRIPTOR  Methods previous Int64Array next ObservationValue By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "IQPulse",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.IQPulse.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous IQChannelConfig next Instruction By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous IQChannelConfig next Instruction By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "ParallelSweep",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.sweep_pb2.ParallelSweep.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.sweep_pb2 Attributes DESCRIPTOR  Methods previous CartesianSweep next SingleParameterSweep By IQM \u00a9 Copyright 2021-2025, IQM. Last updat...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.sweep_pb2 Attributes DESCRIPTOR  Methods previous CartesianSweep next SingleParameterSweep By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "ReadoutTrigger",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.instructions.ReadoutTrigger.html",
    "description": "Bases: object Instruction for playing a probe pulse and acquiring the associated readout results. Module: iqm.models.playlist.instructions Attributes probe_pulse Index pointing to a probe pulse, usual...",
    "content": "Bases: object Instruction for playing a probe pulse and acquiring the associated readout results. Module: iqm.models.playlist.instructions Attributes probe_pulse Index pointing to a probe pulse, usually a MultiplexedIQPulse. acquisitions Active readout acquisition methods associated with this trigger instance. Methods probe_pulse ( Instruction ) \u2013 acquisitions ( tuple [ AcquisitionMethod , ... ] ) \u2013 Index pointing to a probe pulse, usually a MultiplexedIQPulse. Active readout acquisition methods associated with this trigger instance. previous MultiplexedRealPulse next RealPulse By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Wait",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.Wait.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous VirtualRZ next Waveform By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous VirtualRZ next Waveform By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "iqm.models.playlist.waveforms.is_canonical",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.waveforms.is_canonical.html",
    "description": "Returns True if waveform is a canonical waveform else False waveform ( type [ Waveform ] ) \u2013 bool previous CanonicalWaveform next iqm.models.playlist.waveforms.register_canonical_waveform By IQM \u00a9 Cop...",
    "content": "Returns True if waveform is a canonical waveform else False waveform ( type [ Waveform ] ) \u2013 bool previous CanonicalWaveform next iqm.models.playlist.waveforms.register_canonical_waveform By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "run_definition_pb2",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.station_control.v2.run_definition_pb2.html",
    "description": "Generated protocol buffer code. Full path: iqm.data_definitions.station_control.v2.run_definition_pb2 Classes RunDefinition  previous v2 next RunDefinition By IQM \u00a9 Copyright 2021-2025, IQM. Last upda...",
    "content": "Generated protocol buffer code. Full path: iqm.data_definitions.station_control.v2.run_definition_pb2 Classes RunDefinition  previous v2 next RunDefinition By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Gaussian",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.waveforms.Gaussian.html",
    "description": "Bases: Waveform Gaussian pulse. where \\(c\\) is center_offset , and \\(\\sigma\\) is sigma . sigma ( float ) \u2013 gaussian standard deviation center_offset ( float ) \u2013 center offset n_samples ( int ) \u2013 Modul...",
    "content": "Bases: Waveform Gaussian pulse. where \\(c\\) is center_offset , and \\(\\sigma\\) is sigma . sigma ( float ) \u2013 gaussian standard deviation center_offset ( float ) \u2013 center offset n_samples ( int ) \u2013 Module: iqm.models.playlist.waveforms Attributes center_offset  sigma  n_samples Requested number of samples for the waveform. Methods previous CosineRiseFall next GaussianDerivative By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "ReadoutProperties",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.channel_properties_pb2.ReadoutProperties.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.channel_properties_pb2 Attributes DESCRIPTOR  Methods previous ChannelPropertyEntry next data_types_pb2 By IQM \u00a9 Copyright 2021-2025, IQ...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.channel_properties_pb2 Attributes DESCRIPTOR  Methods previous ChannelPropertyEntry next data_types_pb2 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Wait",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.instructions.Wait.html",
    "description": "Bases: object Class for WaitInstruction. Module: iqm.models.playlist.instructions Methods previous VirtualRZ next playlist By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07....",
    "content": "Bases: object Class for WaitInstruction. Module: iqm.models.playlist.instructions Methods previous VirtualRZ next playlist By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Complex128Sequence",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.data_types_pb2.Complex128Sequence.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.data_types_pb2 Attributes DESCRIPTOR  Methods previous Complex128 next Datum By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.data_types_pb2 Attributes DESCRIPTOR  Methods previous Complex128 next Datum By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "IQPulse",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.instructions.IQPulse.html",
    "description": "Bases: object Class for IQ Pulses. Contains waveforms for both in-phase and quadrature waveforms. Module: iqm.models.playlist.instructions Attributes modulation_frequency  phase  phase_increment  wave...",
    "content": "Bases: object Class for IQ Pulses. Contains waveforms for both in-phase and quadrature waveforms. Module: iqm.models.playlist.instructions Attributes modulation_frequency  phase  phase_increment  wave_i  wave_q  scale_i  scale_q  Methods wave_i ( Waveform ) \u2013 wave_q ( Waveform ) \u2013 scale_i ( float ) \u2013 scale_q ( float ) \u2013 phase ( float ) \u2013 modulation_frequency ( float ) \u2013 phase_increment ( float ) \u2013 previous ConditionalInstruction next Instruction By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "v1",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.station_control.v1.html",
    "description": "Full path: iqm.data_definitions.station_control.v1 Subpackages and modules run_definition_pb2 Generated protocol buffer code. sweep_request_pb2 Generated protocol buffer code. task_service_pb2 Generat...",
    "content": "Full path: iqm.data_definitions.station_control.v1 Subpackages and modules run_definition_pb2 Generated protocol buffer code. sweep_request_pb2 Generated protocol buffer code. task_service_pb2 Generated protocol buffer code. previous station_control next run_definition_pb2 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "ReadoutProperties",
    "url": "/iqm-data-definitions/api/iqm.models.channel_properties.channel_properties.ReadoutProperties.html",
    "description": "Bases: ChannelProperties Channel properties of a QA channel. Module: iqm.models.channel_properties.channel_properties Attributes integration_start_dead_time Minimum delay for probe pulse entries insid...",
    "content": "Bases: ChannelProperties Channel properties of a QA channel. Module: iqm.models.channel_properties.channel_properties Attributes integration_start_dead_time Minimum delay for probe pulse entries inside a ReadoutTrigger in samples. integration_stop_dead_time Minimum delay in samples after the last integrator has stopped, before a new ReadoutTrigger can be executed. sampling_rate Sample rate of the instrument responsible for the channel (in Hz). instruction_duration_granularity All instruction durations on this channel must be multiples of this granularity (in samples). instruction_duration_min All instruction durations on this channel must at least this long (in samples). compatible_instructions Instruction types that are allowed on this channel. Methods sampling_rate ( float ) \u2013 instruction_duration_granularity ( int ) \u2013 instruction_duration_min ( int ) \u2013 compatible_instructions ( tuple [ type [ Instruction ] , ... ] ) \u2013 is_virtual ( bool ) \u2013 blocks_component ( bool ) \u2013 integration_start_dead_time ( int ) \u2013 integration_stop_dead_time ( int ) \u2013 Minimum delay for probe pulse entries inside a ReadoutTrigger in samples. Minimum delay in samples after the last integrator has stopped, before a new\nReadoutTrigger can be executed. This delay must be taken into account when calculating the duration\nof a ReadoutTrigger. The duration is the sum of: This value, The duration of the longest integration among the acquisitions in the ReadoutTrigger instruction, The acquisition delay of the above integration. previous ChannelProperties next playlist By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "TruncatedGaussian",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.TruncatedGaussian.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous Schedule next TruncatedGaussianDerivative By IQM \u00a9 Copyright 2021-2025, IQM. Last u...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous Schedule next TruncatedGaussianDerivative By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "ChannelDescription",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.channel_descriptions.ChannelDescription.html",
    "description": "Bases: object for a channel. channel_config ( ChannelConfiguration ) \u2013 ChannelConfiguration object which contains data related to the channel controller_name ( str ) \u2013 name of the controller instructi...",
    "content": "Bases: object for a channel. channel_config ( ChannelConfiguration ) \u2013 ChannelConfiguration object which contains data related to the channel controller_name ( str ) \u2013 name of the controller instruction_table \u2013 Contains mapping of the instructions to be executed on this channel. Each\ninstruction should be unique. waveform_table \u2013 Contains mapping of the waveforms to be executed on this channel. Each\nwaveform should be unique. acquisition_table \u2013 Table of acquisition configs.\nEach ReadoutTrigger instruction may ask to perform an arbitrary combination of these.\nIn practice, possible combinations are limited by device capabilities. Module: iqm.models.playlist.channel_descriptions Attributes channel_config  controller_name  instruction_table  waveform_table  acquisition_table  Methods add_acquisition Add an acquisition method to the table map if the configuration is unique. add_instruction Add an instruction to the instruction table if the instruction is unique. Add an instruction to the instruction table if the instruction is unique. If the instruction contains other instructions, those are also added if they are unique.\nIf any of the instructions contain unique waveforms, those are also added to the waveform table. instruction ( Instruction ) \u2013 Instruction to be added corresponding index to the instruction table int Add an acquisition method to the table map if the configuration is unique. If it contains unique waveforms, those are added to the waveform table. acquisition ( AcquisitionMethod ) \u2013 Configuration to be added. Corresponding index to the acquisition table. int previous ChannelConfiguration next IQChannelConfig By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "RunDefinition",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.station_control.v1.run_definition_pb2.RunDefinition.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.station_control.v1.run_definition_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message previous run_definition_pb2 next sweep_request_pb2 B...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.station_control.v1.run_definition_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message previous run_definition_pb2 next sweep_request_pb2 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "ComplexIntegration",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.instructions.ComplexIntegration.html",
    "description": "Bases: AcquisitionMethod Perform a weighted integration of the IQ raw signal, resulting in a complex number. Module: iqm.models.playlist.instructions Attributes weights Integration weights. label Iden...",
    "content": "Bases: AcquisitionMethod Perform a weighted integration of the IQ raw signal, resulting in a complex number. Module: iqm.models.playlist.instructions Attributes weights Integration weights. label Identifier for the returned data, like QB1__readout.time_trace . delay_samples Delay from beginning of probe pulse to beginning of acquisition window, in samples. Methods label ( str ) \u2013 delay_samples ( int ) \u2013 weights ( IQPulse ) \u2013 Integration weights. previous AcquisitionMethod next ConditionalInstruction By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Instruction",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.instructions.Instruction.html",
    "description": "Bases: Generic [ Operation ] Wrapper class for Instructions. Module: iqm.models.playlist.instructions Attributes duration_samples  operation  Methods duration_samples ( int ) \u2013 operation ( Operation )...",
    "content": "Bases: Generic [ Operation ] Wrapper class for Instructions. Module: iqm.models.playlist.instructions Attributes duration_samples  operation  Methods duration_samples ( int ) \u2013 operation ( Operation ) \u2013 previous IQPulse next MultiplexedIQPulse By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Instruction",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.Instruction.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous IQPulse next MultiplexedIQPulse By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on ...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous IQPulse next MultiplexedIQPulse By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "ChannelConfiguration",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.channel_descriptions.ChannelConfiguration.html",
    "description": "Bases: object Base type for all channel configurations. Module: iqm.models.playlist.channel_descriptions Methods previous channel_descriptions next ChannelDescription By IQM \u00a9 Copyright 2021-2025, IQM...",
    "content": "Bases: object Base type for all channel configurations. Module: iqm.models.playlist.channel_descriptions Methods previous channel_descriptions next ChannelDescription By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "TruncatedGaussian",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.waveforms.TruncatedGaussian.html",
    "description": "Bases: Waveform Gaussian pulse, where the decaying tails are removed by offsetting, truncating, and then rescaling the pulse\nslightly, so that the resulting waveform is zero where the original wavefor...",
    "content": "Bases: Waveform Gaussian pulse, where the decaying tails are removed by offsetting, truncating, and then rescaling the pulse\nslightly, so that the resulting waveform is zero where the original waveform reaches the threshold level, and\nbeyond, while still reaching the same maximal pulse amplitude.  Currently, the threshold is fixed at \\(g_0 = 0.003\\) . where \\(c\\) is center_offset , and \\(\\sigma\\) is calculated via \\(\\sigma :=\\) full_width \\(/ \\sqrt{8 \\text{ln}(1/g_0)}\\) . The waveform after offsetting, truncating and rescaling is given by where \\(g_0\\) is the threshold level for the truncation. full_width ( float ) \u2013 Duration of the support of the pulse, >= 0. center_offset ( float ) \u2013 The waveform is centered at this offset from the midpoint of the sampling window. n_samples ( int ) \u2013 Module: iqm.models.playlist.waveforms Attributes center_offset  full_width  n_samples Requested number of samples for the waveform. Methods previous Samples next TruncatedGaussianDerivative By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "v2",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.station_control.v2.html",
    "description": "Full path: iqm.data_definitions.station_control.v2 Subpackages and modules run_definition_pb2 Generated protocol buffer code. task_service_pb2 Generated protocol buffer code. previous SweepTaskRequest...",
    "content": "Full path: iqm.data_definitions.station_control.v2 Subpackages and modules run_definition_pb2 Generated protocol buffer code. task_service_pb2 Generated protocol buffer code. previous SweepTaskRequest next run_definition_pb2 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "SpotResultValue",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.spot_result_pb2.SpotResultValue.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.spot_result_pb2 Attributes DESCRIPTOR  Methods previous NumcodecsConfig next struct_pb2 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated ...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.spot_result_pb2 Attributes DESCRIPTOR  Methods previous NumcodecsConfig next struct_pb2 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "ConditionalInstruction",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.ConditionalInstruction.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous ChannelDescription next Constant By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous ChannelDescription next Constant By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "RunDefinition",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.station_control.v2.run_definition_pb2.RunDefinition.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.station_control.v2.run_definition_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message previous run_definition_pb2 next task_service_pb2 By...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.station_control.v2.run_definition_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message previous run_definition_pb2 next task_service_pb2 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "VirtualRZ",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.VirtualRZ.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous TruncatedGaussianSmoothedSquare next Wait By IQM \u00a9 Copyright 2021-2025, IQM. Last u...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous TruncatedGaussianSmoothedSquare next Wait By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "models",
    "url": "/iqm-data-definitions/api/iqm.models.html",
    "description": "Python-native representation of the protos in iqm.data_definitions , recognized by IQM Station Control. Full path: iqm.models Subpackages and modules channel_properties Hardware properties of station ...",
    "content": "Python-native representation of the protos in iqm.data_definitions , recognized by IQM Station Control. Full path: iqm.models Subpackages and modules channel_properties Hardware properties of station devices. playlist Control pulses and pulse sequences for quantum processors. previous API Reference next channel_properties By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Constant",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.Constant.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous ConditionalInstruction next CosineRiseFall By IQM \u00a9 Copyright 2021-2025, IQM. Last ...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous ConditionalInstruction next CosineRiseFall By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Waveform",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.waveforms.Waveform.html",
    "description": "Bases: object Describes the normalized shape of a real-valued control pulse. The shape is described by a function \\(f: \\mathbb{R} \\to [-1, 1]\\) that comes with an implicit\nsampling window. \\(f\\) maps ...",
    "content": "Bases: object Describes the normalized shape of a real-valued control pulse. The shape is described by a function \\(f: \\mathbb{R} \\to [-1, 1]\\) that comes with an implicit\nsampling window. \\(f\\) maps time (measured in units of the sampling window duration and relative\nto its center point) to the value of the pulse at that time. Each Waveform subclass may have attributes that affect its shape. All time-like attributes are\nmeasured in units of the sampling window duration. The station method non_timelike_attributes may be used to define non-timelike attributes and their units (in addition to \u201cs\u201d , \u201cHz\u201d has a special\nbehaviour in that such attributes will be converted to the units of the inverse of duration). Providing type\nhints to the waveform attributes is mandatory, as they are used in parsing the information for the GateImplementations . Supported scalar attribute types are: int , float , complex , str , bool .\nIn addition, list[<scalar type>] is supported for all the aforementioned scalar types, and also numpy.ndarray , in which case it is interpreted to contain complex numbers. When the Waveform is used by an instrument it is typically sampled using the sample() method, which\nconverts it into an array of n_samples equidistant samples, generated using the midpoint method,\nby evaluating the function \\(f(t)\\) inside the sampling window \\(t \\in [-1/2, 1/2]\\) .\nThe instruments will discretize the values of the samples to a finite, instrument-dependent resolution,\ntypically 14\u201316 bits. Usually, it is sufficient for Waveforms to describe normalized waveforms (i.e. using the full\nvalue range \\([-1, 1]\\) ), not including a scaling prefactor in the defining expression.\nInstead, the scaling should be specified as a parameter of the Instruction using the Waveform\n(e.g. IQPulse , RealPulse ), thus allowing compilers to more efficiently\nre-use waveforms and utilize the available hardware support to perform such re-scaling in real time. Module: iqm.models.playlist.waveforms Attributes n_samples Requested number of samples for the waveform. Methods non_timelike_attributes Mapping from waveform attributes to the units of their calibration data, unless that unit is second. sample Sample the waveform. n_samples ( int ) \u2013 Requested number of samples for the waveform. May be different from the duration (in samples) of the\nparent Instruction. Mapping from waveform attributes to the units of their calibration data, unless that unit is second. Used to construct the parameters for the calibration data required by the waveform.\nBy default all the waveform attributes are \u201ctimelike\u201d (the unit for their calibration data is s).\nHowever, some waveform attributes can be dimensionless, e.g. the relative amplitudes in a sum of\nconsisting of multiple terms, or frequency-like (calibration data has the unit \u2018Hz\u2019).\nIf a Waveform subclass has non-timelike attributes, it needs to redefine this method. When the Waveform is constructed, all timelike calibration data is converted to units of the\nsampling window duration, and all frequency-like calibration data into units of inverse sampling\nwindow duration. dict [ str , str ] Sample the waveform. Contains the boilerplate code for determining the sample coordinates,\nthe actual sampling happens in _sample() . self sampled in the window [-1/2, 1/2] ndarray previous TruncatedGaussianSmoothedSquare next data_definitions By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Array",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.data_types_pb2.Array.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.data_types_pb2 Attributes DESCRIPTOR  Methods previous data_types_pb2 next Arrays By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 202...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.data_types_pb2 Attributes DESCRIPTOR  Methods previous data_types_pb2 next Arrays By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Segment",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.segment.Segment.html",
    "description": "Bases: object Contains the instructions to be executed in one segment for each channel. instructions ( dict [ str , list [ int ] ] ) \u2013 dict containing controller name as the key and the list of Instru...",
    "content": "Bases: object Contains the instructions to be executed in one segment for each channel. instructions ( dict [ str , list [ int ] ] ) \u2013 dict containing controller name as the key and the list of Instruction indices to be executed value. ( as the ) \u2013 Module: iqm.models.playlist.segment Attributes instructions  Methods add_to_segment Adds an instruction to the segment for a specific channel. Adds an instruction to the segment for a specific channel. Also calls the add_instruction of the channel\nfor adding the instruction to the channels waveform map. channel_description ( ChannelDescription ) \u2013 The target ChannelDescription object instruction ( Instruction ) \u2013 The instruction to be added previous segment next waveforms By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "GaussianSmoothedSquare",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.GaussianSmoothedSquare.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous GaussianDerivative next IQChannelConfig By IQM \u00a9 Copyright 2021-2025, IQM. Last upd...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous GaussianDerivative next IQChannelConfig By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Datum",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.data_types_pb2.Datum.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.data_types_pb2 Attributes DESCRIPTOR  Methods previous Complex128Sequence next Float64Sequence By IQM \u00a9 Copyright 2021-2025, IQM. Last u...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.data_types_pb2 Attributes DESCRIPTOR  Methods previous Complex128Sequence next Float64Sequence By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "CosineRiseFall",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.CosineRiseFall.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous Constant next Gaussian By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-0...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous Constant next Gaussian By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Float64Sequence",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.data_types_pb2.Float64Sequence.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.data_types_pb2 Attributes DESCRIPTOR  Methods previous Datum next Int64Sequence By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.data_types_pb2 Attributes DESCRIPTOR  Methods previous Datum next Int64Sequence By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Gaussian",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.Gaussian.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous CosineRiseFall next GaussianDerivative By IQM \u00a9 Copyright 2021-2025, IQM. Last upda...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous CosineRiseFall next GaussianDerivative By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "playlist",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.html",
    "description": "Control pulses and pulse sequences for quantum processors. Full path: iqm.models.playlist Subpackages and modules channel_descriptions Channel Description and Channel Configuration definitions. instru...",
    "content": "Control pulses and pulse sequences for quantum processors. Full path: iqm.models.playlist Subpackages and modules channel_descriptions Channel Description and Channel Configuration definitions. instructions Instruction definitions. playlist Implements the new data structure of a playlist. segment Segment class definitions waveforms Waveform definitions. previous ReadoutProperties next channel_descriptions By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "ChannelPropertyEntry",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.channel_properties_pb2.ChannelPropertyEntry.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.channel_properties_pb2 Attributes DESCRIPTOR  Methods previous ChannelPropertyDictionary next ReadoutProperties By IQM \u00a9 Copyright 2021-...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.channel_properties_pb2 Attributes DESCRIPTOR  Methods previous ChannelPropertyDictionary next ReadoutProperties By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "instructions",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.instructions.html",
    "description": "Instruction definitions. Full path: iqm.models.playlist.instructions Classes AcquisitionMethod Describes a way to acquire readout data. ComplexIntegration Perform a weighted integration of the IQ raw ...",
    "content": "Instruction definitions. Full path: iqm.models.playlist.instructions Classes AcquisitionMethod Describes a way to acquire readout data. ComplexIntegration Perform a weighted integration of the IQ raw signal, resulting in a complex number. ConditionalInstruction Class for Conditional Pulses. IQPulse Class for IQ Pulses. Instruction Wrapper class for Instructions. MultiplexedIQPulse Instruction to simultaneously play multiple IQ pulses. MultiplexedRealPulse Instruction to simultaneously play multiple real pulses. ReadoutTrigger Instruction for playing a probe pulse and acquiring the associated readout results. RealPulse Class for Real pulses. ThresholdStateDiscrimination Perform a weighted integration of the IQ raw signal and compares the real part of the result against a threshold value, resulting in a single bit. TimeTrace Capture the raw IQ signal without integration. VirtualRZ Class for Virtual Rz. Wait Class for WaitInstruction. previous RealChannelConfig next AcquisitionMethod By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "SingleParameterSweep",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.sweep_pb2.SingleParameterSweep.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.sweep_pb2 Attributes DESCRIPTOR  Methods previous ParallelSweep next station_control By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on ...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.sweep_pb2 Attributes DESCRIPTOR  Methods previous ParallelSweep next station_control By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "task_service_pb2",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.station_control.v1.task_service_pb2.html",
    "description": "Generated protocol buffer code. Full path: iqm.data_definitions.station_control.v1.task_service_pb2 Classes SweepResultsResponse  SweepTaskRequest  previous SweepRequest next SweepResultsResponse By I...",
    "content": "Generated protocol buffer code. Full path: iqm.data_definitions.station_control.v1.task_service_pb2 Classes SweepResultsResponse  SweepTaskRequest  previous SweepRequest next SweepResultsResponse By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Waveform",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.Waveform.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous Wait next setting_pb2 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous Wait next setting_pb2 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Arrays",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.data_types_pb2.Arrays.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.data_types_pb2 Attributes DESCRIPTOR  Methods previous Array next BoolSequence By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-0...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.data_types_pb2 Attributes DESCRIPTOR  Methods previous Array next BoolSequence By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "data_types_pb2",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.data_types_pb2.html",
    "description": "Generated protocol buffer code. Full path: iqm.data_definitions.common.v1.data_types_pb2 Classes Array  Arrays  BoolSequence  Complex128  Complex128Sequence  Datum  Float64Sequence  Int64Sequence  Seq...",
    "content": "Generated protocol buffer code. Full path: iqm.data_definitions.common.v1.data_types_pb2 Classes Array  Arrays  BoolSequence  Complex128  Complex128Sequence  Datum  Float64Sequence  Int64Sequence  Sequence  StringSequence  previous ReadoutProperties next Array By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "AcquisitionMethod",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.AcquisitionMethod.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message Bases: Message , Message Bases: Message , Message previous playlist...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message Bases: Message , Message Bases: Message , Message previous playlist_pb2 next ChannelConfiguration By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "VirtualRZ",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.instructions.VirtualRZ.html",
    "description": "Bases: object Class for Virtual Rz. Module: iqm.models.playlist.instructions Attributes phase_increment  Methods phase_increment ( float ) \u2013 previous TimeTrace next Wait By IQM \u00a9 Copyright 2021-2025, ...",
    "content": "Bases: object Class for Virtual Rz. Module: iqm.models.playlist.instructions Attributes phase_increment  Methods phase_increment ( float ) \u2013 previous TimeTrace next Wait By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "MultiplexedIQPulse",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.MultiplexedIQPulse.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message previous Instruction next MultiplexedRealPulse By IQM \u00a9 Copyright 2...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message previous Instruction next MultiplexedRealPulse By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "ChannelDescription",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.ChannelDescription.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous ChannelConfiguration next ConditionalInstruction By IQM \u00a9 Copyright 2021-2025, IQM....",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous ChannelConfiguration next ConditionalInstruction By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "run_definition_pb2",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.station_control.v1.run_definition_pb2.html",
    "description": "Generated protocol buffer code. Full path: iqm.data_definitions.station_control.v1.run_definition_pb2 Classes RunDefinition  previous v1 next RunDefinition By IQM \u00a9 Copyright 2021-2025, IQM. Last upda...",
    "content": "Generated protocol buffer code. Full path: iqm.data_definitions.station_control.v1.run_definition_pb2 Classes RunDefinition  previous v1 next RunDefinition By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Int64Array",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.observation_pb2.Int64Array.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.observation_pb2 Attributes DESCRIPTOR  Methods previous Float64Array next ObservationUncertainty By IQM \u00a9 Copyright 2021-2025, IQM. Last...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.observation_pb2 Attributes DESCRIPTOR  Methods previous Float64Array next ObservationUncertainty By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "sweep_pb2",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.sweep_pb2.html",
    "description": "Generated protocol buffer code. Full path: iqm.data_definitions.common.v1.sweep_pb2 Classes CartesianSweep  ParallelSweep  SingleParameterSweep  previous Value next CartesianSweep By IQM \u00a9 Copyright 2...",
    "content": "Generated protocol buffer code. Full path: iqm.data_definitions.common.v1.sweep_pb2 Classes CartesianSweep  ParallelSweep  SingleParameterSweep  previous Value next CartesianSweep By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "channel_descriptions",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.channel_descriptions.html",
    "description": "Channel Description and Channel Configuration definitions. Full path: iqm.models.playlist.channel_descriptions Classes ChannelConfiguration Base type for all channel configurations. ChannelDescription...",
    "content": "Channel Description and Channel Configuration definitions. Full path: iqm.models.playlist.channel_descriptions Classes ChannelConfiguration Base type for all channel configurations. ChannelDescription ChannelDescription class contains all channel specific data and the suitable instructions and waveforms IQChannelConfig Placeholder configuration for Complex Channels ReadoutChannelConfig Requested configuration of a readout channel. RealChannelConfig Placeholder configuration for Real Channels previous playlist next ChannelConfiguration By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "data_definitions",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.html",
    "description": "Full path: iqm.data_definitions Subpackages and modules common  station_control  previous Waveform next common By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07....",
    "content": "Full path: iqm.data_definitions Subpackages and modules common  station_control  previous Waveform next common By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "RealChannelConfig",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.RealChannelConfig.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous ReadoutTrigger next RealPulse By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 20...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous ReadoutTrigger next RealPulse By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "parameter_pb2",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.parameter_pb2.html",
    "description": "Generated protocol buffer code. Full path: iqm.data_definitions.common.v1.parameter_pb2 Classes Parameter  previous ObservationValue next Parameter By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2...",
    "content": "Generated protocol buffer code. Full path: iqm.data_definitions.common.v1.parameter_pb2 Classes Parameter  previous ObservationValue next Parameter By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "RealChannelConfig",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.channel_descriptions.RealChannelConfig.html",
    "description": "Bases: ChannelConfiguration Placeholder configuration for Real Channels Module: iqm.models.playlist.channel_descriptions Attributes sampling_rate  Methods sampling_rate ( float ) \u2013 previous ReadoutCha...",
    "content": "Bases: ChannelConfiguration Placeholder configuration for Real Channels Module: iqm.models.playlist.channel_descriptions Attributes sampling_rate  Methods sampling_rate ( float ) \u2013 previous ReadoutChannelConfig next instructions By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Playlist",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.playlist.Playlist.html",
    "description": "Bases: object Information required to build a batch of programs for AWGs and readout instruments. Consists of a number of Segment s, executed in a sequence, and\ninformation about the properties of the...",
    "content": "Bases: object Information required to build a batch of programs for AWGs and readout instruments. Consists of a number of Segment s, executed in a sequence, and\ninformation about the properties of the control and readout channels used\nin the Segments, as well as Instruction and Waveform tables. This class implements the new data structure that contains all the data necessary\nfor an experiment to execute. Schedule contains information of all the channels used as\nwell as the instruction execution schedule. channel_descriptions ( dict [ str , ChannelDescription ] ) \u2013 Controller name mapped to channel and channel specific instruction\nand waveform data. segments ( list [ Segment ] ) \u2013 Contains all the segments in the order of execution. Module: iqm.models.playlist.playlist Attributes channel_descriptions  segments  Methods add_channel Adds a new channel to the Schedule. Adds a new channel to the Schedule. new_channel ( ChannelDescription ) \u2013 channel to add ValueError \u2013 channel with that name already exists, and has different properties None previous playlist next segment By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "SweepRequest",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.station_control.v1.sweep_request_pb2.SweepRequest.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.station_control.v1.sweep_request_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message previous RunMetadata next task_service_pb2 By IQM \u00a9 C...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.station_control.v1.sweep_request_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message previous RunMetadata next task_service_pb2 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "IQChannelConfig",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.IQChannelConfig.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous GaussianSmoothedSquare next IQPulse By IQM \u00a9 Copyright 2021-2025, IQM. Last updated...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous GaussianSmoothedSquare next IQPulse By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Constant",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.waveforms.Constant.html",
    "description": "Bases: Waveform Constant waveform. Module: iqm.models.playlist.waveforms Attributes n_samples Requested number of samples for the waveform. Methods n_samples ( int ) \u2013 previous iqm.models.playlist.wav...",
    "content": "Bases: Waveform Constant waveform. Module: iqm.models.playlist.waveforms Attributes n_samples Requested number of samples for the waveform. Methods n_samples ( int ) \u2013 previous iqm.models.playlist.waveforms.to_canonical next CosineRiseFall By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "SweepResultsResponse",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.station_control.v2.task_service_pb2.SweepResultsResponse.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.station_control.v2.task_service_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message previous task_service_pb2 next Changelog By IQM \u00a9 Copy...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.station_control.v2.task_service_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message previous task_service_pb2 next Changelog By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "iqm.models.playlist.waveforms.to_canonical",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.waveforms.to_canonical.html",
    "description": "Convert the waveform into a canonical version of itself, e.g. for serialization. Canonical waveforms are returned as is, non-canonical waveforms are sampled. canonical version of the waveform waveform...",
    "content": "Convert the waveform into a canonical version of itself, e.g. for serialization. Canonical waveforms are returned as is, non-canonical waveforms are sampled. canonical version of the waveform waveform ( Waveform ) \u2013 Waveform previous iqm.models.playlist.waveforms.register_canonical_waveform next Constant By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "ListValue",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.struct_pb2.ListValue.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.struct_pb2 Attributes DESCRIPTOR  Methods previous struct_pb2 next Struct By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07....",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.struct_pb2 Attributes DESCRIPTOR  Methods previous struct_pb2 next Struct By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "TruncatedGaussianSmoothedSquare",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.waveforms.TruncatedGaussianSmoothedSquare.html",
    "description": "Bases: Waveform Convolution of a square pulse and a gaussian pulse, offset and truncated so that it has finite support. One can think of it as a square pulse smoothed with a gaussian one, or vice vers...",
    "content": "Bases: Waveform Convolution of a square pulse and a gaussian pulse, offset and truncated so that it has finite support. One can think of it as a square pulse smoothed with a gaussian one, or vice versa.\nThe decaying tails are removed by offsetting, truncating, and then rescaling the pulse slightly,\nso that the resulting waveform is zero where the original waveform reaches the threshold level, and beyond, while\nstill reaching the same maximal pulse amplitude.\nCurrently, the threshold is fixed at \\(g_0 = 0.003\\) . where \\(\\text{erf}\\) is the error function, \\(c\\) is center_offset , \\(w\\) is the\nsquare width, and \\(\\sigma\\) is the gaussian standard deviation. We set \\(w :=\\) full_width - rise_time \\(\\sigma :=\\) rise_time \\(/ (\\sqrt{8} \\: \\text{erf}^{-1}(1 - 2 g_0))\\) The cutoff time \\(t_c = c - w / 2 -\\) rise_time \\(/ 2\\) marks the start of the rising segment.\nThe waveform after offsetting, truncating and rescaling is given by where \\(g_0\\) is the threshold level for the truncation.\nWe have \\(f(t_c) \\approx 0\\) , and the approximation is good if \\(g_0 < 0.1\\) . The values of the waveform are in \\([0, 1]\\) . full_width ( float ) \u2013 Duration of the support of the pulse, from start of the rising to the end of the falling segment. rise_time ( float ) \u2013 Duration of the rising and falling segments. center_offset ( float ) \u2013 The waveform is centered at this offset from the midpoint of the sampling window. n_samples ( int ) \u2013 Module: iqm.models.playlist.waveforms Attributes center_offset  full_width  rise_time  n_samples Requested number of samples for the waveform. Methods previous TruncatedGaussianDerivative next Waveform By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Sequence",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.data_types_pb2.Sequence.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.data_types_pb2 Attributes DESCRIPTOR  Methods previous Int64Sequence next StringSequence By IQM \u00a9 Copyright 2021-2025, IQM. Last updated...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.data_types_pb2 Attributes DESCRIPTOR  Methods previous Int64Sequence next StringSequence By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Complex128Array",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.observation_pb2.Complex128Array.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.observation_pb2 Attributes DESCRIPTOR  Methods previous observation_pb2 next Float64Array By IQM \u00a9 Copyright 2021-2025, IQM. Last update...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.observation_pb2 Attributes DESCRIPTOR  Methods previous observation_pb2 next Float64Array By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Int64Sequence",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.data_types_pb2.Int64Sequence.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.data_types_pb2 Attributes DESCRIPTOR  Methods previous Float64Sequence next Sequence By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on ...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.data_types_pb2 Attributes DESCRIPTOR  Methods previous Float64Sequence next Sequence By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Value",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.struct_pb2.Value.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.struct_pb2 Attributes DESCRIPTOR  Methods previous Struct next sweep_pb2 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07....",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.struct_pb2 Attributes DESCRIPTOR  Methods previous Struct next sweep_pb2 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "GaussianDerivative",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.GaussianDerivative.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous Gaussian next GaussianSmoothedSquare By IQM \u00a9 Copyright 2021-2025, IQM. Last update...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous Gaussian next GaussianSmoothedSquare By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "TruncatedGaussianDerivative",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.waveforms.TruncatedGaussianDerivative.html",
    "description": "Bases: Waveform Derivative of a gaussian pulse, where the decaying tails are removed by offsetting, truncating, and then\nrescaling the pulse slightly, so that the resulting waveform is zero where the ...",
    "content": "Bases: Waveform Derivative of a gaussian pulse, where the decaying tails are removed by offsetting, truncating, and then\nrescaling the pulse slightly, so that the resulting waveform is zero where the original waveform reaches the\nthreshold level, and beyond, while still reaching the same maximal pulse amplitude. Currently, the threshold is\nfixed at \\(g_0 = 0.003\\) . Normalized so that values are in \\([-1, 1]\\) .\nThe normalization factor is \\(\\sigma \\: \\sqrt{e}\\) . where \\(c\\) is center_offset , and \\(\\sigma\\) is calculated via \\(\\sigma :=\\) full_width \\(/ \\sqrt{8 \\text{ln}(1/g_0)}\\) . The waveform after offsetting, truncating and rescaling is given by where \\(g_0\\) is the threshold level for the truncation. full_width ( float ) \u2013 Duration of the support of the pulse, >= 0. center_offset ( float ) \u2013 The waveform is centered at this offset from the midpoint of the sampling window. n_samples ( int ) \u2013 Module: iqm.models.playlist.waveforms Attributes center_offset  full_width  n_samples Requested number of samples for the waveform. Methods previous TruncatedGaussian next TruncatedGaussianSmoothedSquare By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "spot_result_pb2",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.spot_result_pb2.html",
    "description": "Generated protocol buffer code. Full path: iqm.data_definitions.common.v1.spot_result_pb2 Classes NpyArray  NumcodecsConfig  SpotResultValue  previous SettingNode next NpyArray By IQM \u00a9 Copyright 2021...",
    "content": "Generated protocol buffer code. Full path: iqm.data_definitions.common.v1.spot_result_pb2 Classes NpyArray  NumcodecsConfig  SpotResultValue  previous SettingNode next NpyArray By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "AWGProperties",
    "url": "/iqm-data-definitions/api/iqm.models.channel_properties.channel_properties.AWGProperties.html",
    "description": "Bases: ChannelProperties Channel properties of an AWG channel. Module: iqm.models.channel_properties.channel_properties Attributes local_oscillator Whether this AWG contains a local oscillator or not....",
    "content": "Bases: ChannelProperties Channel properties of an AWG channel. Module: iqm.models.channel_properties.channel_properties Attributes local_oscillator Whether this AWG contains a local oscillator or not. mixer_correction Whether this AWG has mixer correction or not. fast_feedback_sources Defines compatible fast feedback sources sampling_rate Sample rate of the instrument responsible for the channel (in Hz). instruction_duration_granularity All instruction durations on this channel must be multiples of this granularity (in samples). instruction_duration_min All instruction durations on this channel must at least this long (in samples). compatible_instructions Instruction types that are allowed on this channel. Methods sampling_rate ( float ) \u2013 instruction_duration_granularity ( int ) \u2013 instruction_duration_min ( int ) \u2013 compatible_instructions ( tuple [ type [ Instruction ] , ... ] ) \u2013 is_virtual ( bool ) \u2013 blocks_component ( bool ) \u2013 fast_feedback_sources ( list [ str ] ) \u2013 local_oscillator ( bool ) \u2013 mixer_correction ( bool ) \u2013 Defines compatible fast feedback sources Whether this AWG contains a local oscillator or not. Whether this AWG has mixer correction or not. previous channel_properties next ChannelProperties By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "SweepTaskRequest",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.station_control.v1.task_service_pb2.SweepTaskRequest.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.station_control.v1.task_service_pb2 Attributes DESCRIPTOR  Methods previous SweepResultsResponse next v2 By IQM \u00a9 Copyright 2021-2025, IQM. Last u...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.station_control.v1.task_service_pb2 Attributes DESCRIPTOR  Methods previous SweepResultsResponse next v2 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "RunMetadata",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.station_control.v1.sweep_request_pb2.RunMetadata.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.station_control.v1.sweep_request_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message previous sweep_request_pb2 next SweepRequest By IQM \u00a9...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.station_control.v1.sweep_request_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message previous sweep_request_pb2 next SweepRequest By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Float64Array",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.observation_pb2.Float64Array.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.observation_pb2 Attributes DESCRIPTOR  Methods previous Complex128Array next Int64Array By IQM \u00a9 Copyright 2021-2025, IQM. Last updated ...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.observation_pb2 Attributes DESCRIPTOR  Methods previous Complex128Array next Int64Array By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "CartesianSweep",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.sweep_pb2.CartesianSweep.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.sweep_pb2 Attributes DESCRIPTOR  Methods previous sweep_pb2 next ParallelSweep By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-0...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.sweep_pb2 Attributes DESCRIPTOR  Methods previous sweep_pb2 next ParallelSweep By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "StringSequence",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.data_types_pb2.StringSequence.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.data_types_pb2 Attributes DESCRIPTOR  Methods previous Sequence next observation_pb2 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on ...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.data_types_pb2 Attributes DESCRIPTOR  Methods previous Sequence next observation_pb2 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "channel_properties",
    "url": "/iqm-data-definitions/api/iqm.models.channel_properties.channel_properties.html",
    "description": "Hardware properties of station devices. Full path: iqm.models.channel_properties.channel_properties Classes AWGProperties Channel properties of an AWG channel. ChannelProperties Parent class of AWG an...",
    "content": "Hardware properties of station devices. Full path: iqm.models.channel_properties.channel_properties Classes AWGProperties Channel properties of an AWG channel. ChannelProperties Parent class of AWG and QA Channel properties that contains common attributes and methods. ReadoutProperties Channel properties of a QA channel. previous channel_properties next AWGProperties By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Samples",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.Samples.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous RealPulse next Schedule By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous RealPulse next Schedule By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Schedule",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.Schedule.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message Bases: Message , Message previous Samples next TruncatedGaussian By...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message Bases: Message , Message previous Samples next TruncatedGaussian By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Struct",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.struct_pb2.Struct.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.struct_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message previous ListValue next Value By IQM \u00a9 Copyright 2021-2025, IQM. Last...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.struct_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message previous ListValue next Value By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "ConditionalInstruction",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.instructions.ConditionalInstruction.html",
    "description": "Bases: object Class for Conditional Pulses. Module: iqm.models.playlist.instructions Attributes condition  if_true  if_false  Methods condition ( str ) \u2013 if_true ( Instruction ) \u2013 if_false ( Instructi...",
    "content": "Bases: object Class for Conditional Pulses. Module: iqm.models.playlist.instructions Attributes condition  if_true  if_false  Methods condition ( str ) \u2013 if_true ( Instruction ) \u2013 if_false ( Instruction ) \u2013 previous ComplexIntegration next IQPulse By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "BoolSequence",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.data_types_pb2.BoolSequence.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.data_types_pb2 Attributes DESCRIPTOR  Methods previous Arrays next Complex128 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.data_types_pb2 Attributes DESCRIPTOR  Methods previous Arrays next Complex128 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "playlist",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.playlist.html",
    "description": "Implements the new data structure of a playlist. Full path: iqm.models.playlist.playlist Classes Playlist Information required to build a batch of programs for AWGs and readout instruments. previous W...",
    "content": "Implements the new data structure of a playlist. Full path: iqm.models.playlist.playlist Classes Playlist Information required to build a batch of programs for AWGs and readout instruments. previous Wait next Playlist By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "v1",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.html",
    "description": "Full path: iqm.data_definitions.common.v1 Subpackages and modules channel_properties_pb2 Generated protocol buffer code. data_types_pb2 Generated protocol buffer code. observation_pb2 Generated protoc...",
    "content": "Full path: iqm.data_definitions.common.v1 Subpackages and modules channel_properties_pb2 Generated protocol buffer code. data_types_pb2 Generated protocol buffer code. observation_pb2 Generated protocol buffer code. parameter_pb2 Generated protocol buffer code. playlist_pb2 Generated protocol buffer code. setting_pb2 Generated protocol buffer code. spot_result_pb2 Generated protocol buffer code. struct_pb2 Generated protocol buffer code. sweep_pb2 Generated protocol buffer code. previous common next channel_properties_pb2 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "TimeTrace",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.instructions.TimeTrace.html",
    "description": "Bases: AcquisitionMethod Capture the raw IQ signal without integration. Module: iqm.models.playlist.instructions Attributes duration_samples Length of the capture window, in samples. label Identifier ...",
    "content": "Bases: AcquisitionMethod Capture the raw IQ signal without integration. Module: iqm.models.playlist.instructions Attributes duration_samples Length of the capture window, in samples. label Identifier for the returned data, like QB1__readout.time_trace . delay_samples Delay from beginning of probe pulse to beginning of acquisition window, in samples. Methods label ( str ) \u2013 delay_samples ( int ) \u2013 duration_samples ( int ) \u2013 Length of the capture window, in samples. previous ThresholdStateDiscrimination next VirtualRZ By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "CosineRiseFall",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.waveforms.CosineRiseFall.html",
    "description": "Bases: Waveform Waveform that has a sinusoidal rise and fall, and a constant part in between. where \\(c\\) is center_offset , \\(r\\) is rise_time , and \\(p\\) is the plateau width,\ncalculated via \\(p :=\\...",
    "content": "Bases: Waveform Waveform that has a sinusoidal rise and fall, and a constant part in between. where \\(c\\) is center_offset , \\(r\\) is rise_time , and \\(p\\) is the plateau width,\ncalculated via \\(p :=\\) full_width - 2 * rise_time . Its values are in \\([0, 1]\\) . full_width ( float ) \u2013 Duration of the support of the pulse, >= 2 * rise_time . rise_time ( float ) \u2013 Duration of the sinusoidal rise (and fall) part of the waveform, >= 0. center_offset ( float ) \u2013 The waveform is centered at this offset from the midpoint of the sampling window. n_samples ( int ) \u2013 Module: iqm.models.playlist.waveforms Attributes center_offset  full_width  rise_time  n_samples Requested number of samples for the waveform. Methods previous Constant next Gaussian By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "channel_properties",
    "url": "/iqm-data-definitions/api/iqm.models.channel_properties.html",
    "description": "Hardware properties of station devices. Full path: iqm.models.channel_properties Subpackages and modules channel_properties Hardware properties of station devices. previous models next channel_propert...",
    "content": "Hardware properties of station devices. Full path: iqm.models.channel_properties Subpackages and modules channel_properties Hardware properties of station devices. previous models next channel_properties By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "MultiplexedIQPulse",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.instructions.MultiplexedIQPulse.html",
    "description": "Bases: object Instruction to simultaneously play multiple IQ pulses. Each component pulse entry can be added with arbitrary delay from the beginning of this instruction.\nWhere outside the duration of ...",
    "content": "Bases: object Instruction to simultaneously play multiple IQ pulses. Each component pulse entry can be added with arbitrary delay from the beginning of this instruction.\nWhere outside the duration of the MultiplexedIQPulse, the pulse entries are truncated.\nWhere overlapping, samples of multiple pulse entries are summed.\nWhere the interval of a MultiplexedIQPulse does not overlap with any of its entry pulse, its samples will be 0. Module: iqm.models.playlist.instructions Attributes entries Pairs of instruction and offset . Methods entries ( tuple [ tuple [ Instruction , int ] , ... ] ) \u2013 Pairs of instruction and offset .\nInstruction should be an IQPulse. offset is the number of samples the pulse is delayed from the beginning of the instruction.\nIt has no granularity constraints. Negative values are allowed, but beginning will be truncated. previous Instruction next MultiplexedRealPulse By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "GaussianSmoothedSquare",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.waveforms.GaussianSmoothedSquare.html",
    "description": "Bases: Waveform Convolution of a square pulse and a gaussian pulse. One can think of it as a square pulse smoothed with a gaussian one, or vice versa. where \\(\\text{erf}\\) is the error function, \\(c\\)...",
    "content": "Bases: Waveform Convolution of a square pulse and a gaussian pulse. One can think of it as a square pulse smoothed with a gaussian one, or vice versa. where \\(\\text{erf}\\) is the error function, \\(c\\) is center_offset , \\(s\\) is square_width , and \\(\\sigma\\) is gaussian_sigma . Its values are in \\((0, 1)\\) . square_width ( float ) \u2013 square pulse width gaussian_sigma ( float ) \u2013 gaussian pulse standard deviation center_offset ( float ) \u2013 The waveform is centered at this offset from the midpoint of the sampling window. n_samples ( int ) \u2013 Module: iqm.models.playlist.waveforms Attributes center_offset  square_width  gaussian_sigma  n_samples Requested number of samples for the waveform. Methods previous GaussianDerivative next Samples By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "ChannelProperties",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.channel_properties_pb2.ChannelProperties.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.channel_properties_pb2 Attributes DESCRIPTOR  Methods previous AWGProperties next ChannelPropertyDictionary By IQM \u00a9 Copyright 2021-2025...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.channel_properties_pb2 Attributes DESCRIPTOR  Methods previous AWGProperties next ChannelPropertyDictionary By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "ReadoutChannelConfig",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.ReadoutChannelConfig.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous Playlist next ReadoutTrigger By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 202...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous Playlist next ReadoutTrigger By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "SweepResultsResponse",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.station_control.v1.task_service_pb2.SweepResultsResponse.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.station_control.v1.task_service_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message previous task_service_pb2 next SweepTaskRequest By IQM...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.station_control.v1.task_service_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message previous task_service_pb2 next SweepTaskRequest By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "task_service_pb2",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.station_control.v2.task_service_pb2.html",
    "description": "Generated protocol buffer code. Full path: iqm.data_definitions.station_control.v2.task_service_pb2 Classes SweepResultsResponse  previous RunDefinition next SweepResultsResponse By IQM \u00a9 Copyright 20...",
    "content": "Generated protocol buffer code. Full path: iqm.data_definitions.station_control.v2.task_service_pb2 Classes SweepResultsResponse  previous RunDefinition next SweepResultsResponse By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "ReadoutChannelConfig",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.channel_descriptions.ReadoutChannelConfig.html",
    "description": "Bases: ChannelConfiguration Requested configuration of a readout channel. Module: iqm.models.playlist.channel_descriptions Attributes sampling_rate  Methods sampling_rate ( float ) \u2013 previous IQChanne...",
    "content": "Bases: ChannelConfiguration Requested configuration of a readout channel. Module: iqm.models.playlist.channel_descriptions Attributes sampling_rate  Methods sampling_rate ( float ) \u2013 previous IQChannelConfig next RealChannelConfig By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "SettingNode",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.setting_pb2.SettingNode.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.setting_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message Bases: Message , Message Bases: Message , Message previous setting_p...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.setting_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message Bases: Message , Message Bases: Message , Message previous setting_pb2 next spot_result_pb2 By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "sweep_request_pb2",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.station_control.v1.sweep_request_pb2.html",
    "description": "Generated protocol buffer code. Full path: iqm.data_definitions.station_control.v1.sweep_request_pb2 Classes RunMetadata  SweepRequest  previous RunDefinition next RunMetadata By IQM \u00a9 Copyright 2021-...",
    "content": "Generated protocol buffer code. Full path: iqm.data_definitions.station_control.v1.sweep_request_pb2 Classes RunMetadata  SweepRequest  previous RunDefinition next RunMetadata By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "AcquisitionMethod",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.instructions.AcquisitionMethod.html",
    "description": "Bases: object Describes a way to acquire readout data. Module: iqm.models.playlist.instructions Attributes label Identifier for the returned data, like QB1__readout.time_trace . delay_samples Delay fr...",
    "content": "Bases: object Describes a way to acquire readout data. Module: iqm.models.playlist.instructions Attributes label Identifier for the returned data, like QB1__readout.time_trace . delay_samples Delay from beginning of probe pulse to beginning of acquisition window, in samples. Methods label ( str ) \u2013 delay_samples ( int ) \u2013 Identifier for the returned data, like QB1__readout.time_trace . Delay from beginning of probe pulse to beginning of acquisition window, in samples. previous instructions next ComplexIntegration By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "ChannelProperties",
    "url": "/iqm-data-definitions/api/iqm.models.channel_properties.channel_properties.ChannelProperties.html",
    "description": "Bases: object Parent class of AWG and QA Channel properties that contains common attributes and methods. Module: iqm.models.channel_properties.channel_properties Attributes blocks_component Whether co...",
    "content": "Bases: object Parent class of AWG and QA Channel properties that contains common attributes and methods. Module: iqm.models.channel_properties.channel_properties Attributes blocks_component Whether content in this channel should block the entire component that it is associated with in the scheduling. is_virtual Virtual channels are only used on the frontend side during compilation and scheduling. sampling_rate Sample rate of the instrument responsible for the channel (in Hz). instruction_duration_granularity All instruction durations on this channel must be multiples of this granularity (in samples). instruction_duration_min All instruction durations on this channel must at least this long (in samples). compatible_instructions Instruction types that are allowed on this channel. Methods duration_to_int_samples Convert a time duration to an integer number of samples at the channel sample rate. duration_to_samples Convert a time duration to number of samples at the channel sample rate. duration_to_seconds Convert a time duration in samples at the channel sample rate to seconds. round_duration_to_granularity Round a time duration to the channel granularity. sampling_rate ( float ) \u2013 instruction_duration_granularity ( int ) \u2013 instruction_duration_min ( int ) \u2013 compatible_instructions ( tuple [ type [ Instruction ] , ... ] ) \u2013 is_virtual ( bool ) \u2013 blocks_component ( bool ) \u2013 Sample rate of the instrument responsible for the channel (in Hz). All instruction durations on this channel must be multiples of this granularity (in samples). All instruction durations on this channel must at least this long (in samples). Instruction types that are allowed on this channel. Virtual channels are only used on the frontend side during compilation and scheduling.\nThey are removed from the Schedule before it is sent to Station\nControl. For example, virtual drive channels of computational resonators. Whether content in this channel should block the entire component that it is associated with in the scheduling.\nTypically all physical channels should block their components, but certain virtual channels might not\nrequire this. Convert a time duration to number of samples at the channel sample rate. duration ( float ) \u2013 time duration in s duration in samples float Convert a time duration in samples at the channel sample rate to seconds. duration ( float ) \u2013 time duration in samples duration in seconds float Convert a time duration to an integer number of samples at the channel sample rate. duration must be sufficiently close to an integer number of samples, and\nthat number must be something the channel can handle. duration ( float ) \u2013 time duration in s message ( str ) \u2013 message identifying the duration we are testing check_min_samples ( bool ) \u2013 If True, check that the output is at least instruction_duration_min . duration as an integer number of samples ValueError \u2013 duration is not close to an integer number of samples, or is\n    otherwise unacceptable to the channel int Round a time duration to the channel granularity. duration ( float ) \u2013 time duration in s round_up ( bool ) \u2013 whether to round the durations up to the closest granularity force_min_duration ( bool ) \u2013 whether to force the duration to be at least self.instruction_duration_min in\nseconds duration rounded to channel granularity, in seconds float previous AWGProperties next ReadoutProperties By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "MultiplexedRealPulse",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.instructions.MultiplexedRealPulse.html",
    "description": "Bases: object Instruction to simultaneously play multiple real pulses. Each component pulse entry can be added with arbitrary delay from the beginning of this instruction.\nWhere outside the duration o...",
    "content": "Bases: object Instruction to simultaneously play multiple real pulses. Each component pulse entry can be added with arbitrary delay from the beginning of this instruction.\nWhere outside the duration of the MultiplexedRealPulse, the pulse entries are truncated.\nWhere overlapping, samples of multiple pulse entries are summed.\nWhere the interval of a MultiplexedRealPulse does not overlap with any of its entry pulse, its samples will be 0. Module: iqm.models.playlist.instructions Attributes entries Pairs of instruction and offset . Methods entries ( tuple [ tuple [ Instruction , int ] , ... ] ) \u2013 Pairs of instruction and offset .\nInstruction should be valid a RealPulse. offset is the number of samples the pulse is delayed from the beginning of the instruction.\nIt has no granularity constraints. Negative values are allowed, but beginning will be truncated. previous MultiplexedIQPulse next ReadoutTrigger By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "waveforms",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.waveforms.html",
    "description": "Waveform definitions. Full path: iqm.models.playlist.waveforms Module Attributes CanonicalWaveform Alias for Waveform to emphasize the fact the waveforms defined in this module have their own serialis...",
    "content": "Waveform definitions. Full path: iqm.models.playlist.waveforms Module Attributes CanonicalWaveform Alias for Waveform to emphasize the fact the waveforms defined in this module have their own serialisation. Functions is_canonical (waveform) Returns True if waveform is a canonical waveform else False register_canonical_waveform (cls) Decorator for making a Waveform into a canonical waveform. to_canonical (waveform) Convert the waveform into a canonical version of itself, e.g. for serialization. Classes CanonicalWaveform Alias for Waveform to emphasize the fact the waveforms defined in this module have their own serialisation. Constant Constant waveform. CosineRiseFall Waveform that has a sinusoidal rise and fall, and a constant part in between. Gaussian Gaussian pulse. GaussianDerivative Derivative of a gaussian pulse. GaussianSmoothedSquare Convolution of a square pulse and a gaussian pulse. Samples Custom pre-sampled waveform. TruncatedGaussian Gaussian pulse, where the decaying tails are removed by offsetting, truncating, and then rescaling the pulse slightly, so that the resulting waveform is zero where the original waveform reaches the threshold level, and beyond, while still reaching the same maximal pulse amplitude. TruncatedGaussianDerivative Derivative of a gaussian pulse, where the decaying tails are removed by offsetting, truncating, and then rescaling the pulse slightly, so that the resulting waveform is zero where the original waveform reaches the threshold level, and beyond, while still reaching the same maximal pulse amplitude. TruncatedGaussianSmoothedSquare Convolution of a square pulse and a gaussian pulse, offset and truncated so that it has finite support. Waveform Describes the normalized shape of a real-valued control pulse. previous Segment next CanonicalWaveform By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "playlist_pb2",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.html",
    "description": "Generated protocol buffer code. Full path: iqm.data_definitions.common.v1.playlist_pb2 Classes AcquisitionMethod  ChannelConfiguration  ChannelDescription  ConditionalInstruction  Constant  CosineRise...",
    "content": "Generated protocol buffer code. Full path: iqm.data_definitions.common.v1.playlist_pb2 Classes AcquisitionMethod  ChannelConfiguration  ChannelDescription  ConditionalInstruction  Constant  CosineRiseFall  Gaussian  GaussianDerivative  GaussianSmoothedSquare  IQChannelConfig  IQPulse  Instruction  MultiplexedIQPulse  MultiplexedRealPulse  Playlist  ReadoutChannelConfig  ReadoutTrigger  RealChannelConfig  RealPulse  Samples  Schedule  TruncatedGaussian  TruncatedGaussianDerivative  TruncatedGaussianSmoothedSquare  VirtualRZ  Wait  Waveform  previous Parameter next AcquisitionMethod By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "ChannelPropertyDictionary",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.channel_properties_pb2.ChannelPropertyDictionary.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.channel_properties_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message previous ChannelProperties next ChannelPropertyEntry By I...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.channel_properties_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message previous ChannelProperties next ChannelPropertyEntry By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "RealPulse",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.RealPulse.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous RealChannelConfig next Samples By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods previous RealChannelConfig next Samples By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "CanonicalWaveform",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.waveforms.CanonicalWaveform.html",
    "description": "Alias for Waveform to emphasize the fact the waveforms defined in this module have their own serialisation. Module: iqm.models.playlist.waveforms Attributes n_samples Requested number of samples for t...",
    "content": "Alias for Waveform to emphasize the fact the waveforms defined in this module have their own serialisation. Module: iqm.models.playlist.waveforms Attributes n_samples Requested number of samples for the waveform. Methods non_timelike_attributes Mapping from waveform attributes to the units of their calibration data, unless that unit is second. sample Sample the waveform. previous waveforms next iqm.models.playlist.waveforms.is_canonical By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Playlist",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.playlist_pb2.Playlist.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message previous MultiplexedRealPulse next ReadoutChannelConfig By IQM \u00a9 Co...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.playlist_pb2 Attributes DESCRIPTOR  Methods Bases: Message , Message previous MultiplexedRealPulse next ReadoutChannelConfig By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "IQChannelConfig",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.channel_descriptions.IQChannelConfig.html",
    "description": "Bases: ChannelConfiguration Placeholder configuration for Complex Channels Module: iqm.models.playlist.channel_descriptions Attributes sampling_rate  Methods sampling_rate ( float ) \u2013 previous Channel...",
    "content": "Bases: ChannelConfiguration Placeholder configuration for Complex Channels Module: iqm.models.playlist.channel_descriptions Attributes sampling_rate  Methods sampling_rate ( float ) \u2013 previous ChannelDescription next ReadoutChannelConfig By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "Samples",
    "url": "/iqm-data-definitions/api/iqm.models.playlist.waveforms.Samples.html",
    "description": "Bases: Waveform Custom pre-sampled waveform. This class can be used to represent an arbitrary waveform\nthat is not supported with the predefined shapes of waveforms. Module: iqm.models.playlist.wavefo...",
    "content": "Bases: Waveform Custom pre-sampled waveform. This class can be used to represent an arbitrary waveform\nthat is not supported with the predefined shapes of waveforms. Module: iqm.models.playlist.waveforms Attributes samples  n_samples Requested number of samples for the waveform. Methods sample Sample the waveform. samples ( ndarray ) \u2013 Sample the waveform. Contains the boilerplate code for determining the sample coordinates,\nthe actual sampling happens in _sample() . self sampled in the window [-1/2, 1/2] ndarray previous GaussianSmoothedSquare next TruncatedGaussian By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "setting_pb2",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.setting_pb2.html",
    "description": "Generated protocol buffer code. Full path: iqm.data_definitions.common.v1.setting_pb2 Classes SettingNode  previous Waveform next SettingNode By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07...",
    "content": "Generated protocol buffer code. Full path: iqm.data_definitions.common.v1.setting_pb2 Classes SettingNode  previous Waveform next SettingNode By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "observation_pb2",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.observation_pb2.html",
    "description": "Generated protocol buffer code. Full path: iqm.data_definitions.common.v1.observation_pb2 Classes Complex128Array  Float64Array  Int64Array  ObservationUncertainty  ObservationValue  previous StringSe...",
    "content": "Generated protocol buffer code. Full path: iqm.data_definitions.common.v1.observation_pb2 Classes Complex128Array  Float64Array  Int64Array  ObservationUncertainty  ObservationValue  previous StringSequence next Complex128Array By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "NpyArray",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.spot_result_pb2.NpyArray.html",
    "description": "Bases: Message , Message Module: iqm.data_definitions.common.v1.spot_result_pb2 Attributes DESCRIPTOR  Methods previous spot_result_pb2 next NumcodecsConfig By IQM \u00a9 Copyright 2021-2025, IQM. Last upd...",
    "content": "Bases: Message , Message Module: iqm.data_definitions.common.v1.spot_result_pb2 Attributes DESCRIPTOR  Methods previous spot_result_pb2 next NumcodecsConfig By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-data-definitions",
    "title": "struct_pb2",
    "url": "/iqm-data-definitions/api/iqm.data_definitions.common.v1.struct_pb2.html",
    "description": "Generated protocol buffer code. Full path: iqm.data_definitions.common.v1.struct_pb2 Classes ListValue  Struct  Value  previous SpotResultValue next ListValue By IQM \u00a9 Copyright 2021-2025, IQM. Last u...",
    "content": "Generated protocol buffer code. Full path: iqm.data_definitions.common.v1.struct_pb2 Classes ListValue  Struct  Value  previous SpotResultValue next ListValue By IQM \u00a9 Copyright 2021-2025, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "API Reference",
    "url": "/iqm-benchmarks/API.html",
    "description": "iqm.benchmarks IQM's Python Library Benchmarking Suite QCVV. previous 2-Qubit Clifford Group Decomposition next iqm.benchmarks By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-...",
    "content": "iqm.benchmarks IQM's Python Library Benchmarking Suite QCVV. previous 2-Qubit Clifford Group Decomposition next iqm.benchmarks By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "IQM Benchmarks",
    "url": "/iqm-benchmarks/index.html",
    "description": "2.40 2025-07-07 iqm-finland/iqm-benchmarks Quantum Characterization, Verification, and Validation (QCVV) tools for quantum computing.\nDeveloped by IQM . Index Module Index Search Page next IQM Benchma...",
    "content": "2.40 2025-07-07 iqm-finland/iqm-benchmarks Quantum Characterization, Verification, and Validation (QCVV) tools for quantum computing.\nDeveloped by IQM . Index Module Index Search Page next IQM Benchmarks By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "IQM Benchmarks",
    "url": "/iqm-benchmarks/readme.html",
    "description": "IQM Benchmarks is a suite of Quantum Characterization, Verification, and Validation (QCVV) tools for quantum computing. It is designed to be a comprehensive tool for benchmarking quantum hardware. The...",
    "content": "IQM Benchmarks is a suite of Quantum Characterization, Verification, and Validation (QCVV) tools for quantum computing. It is designed to be a comprehensive tool for benchmarking quantum hardware. The suite is designed to be modular, allowing users to easily add new benchmarks and customize existing ones. The suite is designed to be easy to use, with a simple API that allows users to run benchmarks with a single command. Below is a list of the benchmarks currently available in the suite: Gates / Layers: Standard Clifford Randomized Benchmarking [ Phys. Rev. A 85, 042311 (2012)] Interleaved Randomized Benchmarking [ Phys. Rev. Lett. 109, 080505 (2012)] Compressive Gate Set Tomography [ PRX Quantum 4, 010325 (2023)] Mirror Randomized Benchmarking [ Phys. Rev. Lett. 129, 150502 (2022)] Error Per Layered Gate [ arXiv:2311.05933 [quant-ph] (2023)] Holistic: Quantum Volume [ Phys. Rev. A 100, 032328 (2019)] CLOPS [ arXiv:2110.14108 [quant-ph] (2021)] Entanglement: GHZ State Fidelity [ arXiv:0712.0921 [quant-ph] (2007)] Graph State Bipartite Entanglement [ Adv. Quantum Technol., 2100061 (2021)] Optimization: Q-Score [ IEEE Trans. Quantum Eng., 2 (2021)] The project is split into different benchmarks, all sharing the Benchmark class or the legacy BenchmarkBase class. Each individual benchmark takes as an argument their own BenchmarkConfigurationBase class. All the (legacy) benchmarks executed at once are wrapped by the BenchmarkExperiment class, which handles dependencies among the benchmarks, storing the results, producing the plots\u2026 uv is highly recommended for practical Python environment and package management.\nWith uv installed in your system, start a terminal in your machine and create a new Python environment Note: refer to uv\u2019s documentation if there are problems setting up a Python environment. After the command has run, read the output and make sure to use the prompt to activate the environment.\nThen, you can install the latest release of the IQM Benchmarks by running: Supplied within the Python package there is an additional requirements.txt file containing locked, security scanned\ndependencies. The file can be used to constrain installed dependencies either directly from the repo or by\nextracting it from the PyPI package. Optional dependencies like compressive gate set tomography and jupyter notebooks can be installed as follows: Current optional dependencies are: examples : Jupyter notebooks mgst : Compressive gate set tomography test : Code testing and Linting docs : Documentation building cicd : CICD tools To install in development mode with all required dependencies, you can instead clone the repository and from the project directory run To run the tests, you can use the following command: To build the API documentation as HTML: Update the requirements. This is necessary when you add a new dependency or update an existing one in pyproject.toml .\nAfter this, any changes in the lockfile requirements.txt have to be committed.\nThe script upgrades locked dependencies defined in pyproject.toml within the given version ranges. However, transitive\ndependencies are deliberately not upgraded automatically. The IQM Benchmarks suite is designed to be used with real quantum hardware. To use the suite, you will need to have access to a quantum computer. The suite is designed to work with both IQM Resonance (IQM\u2019s quantum cloud service) and on-prem devices, but can be easily adapted to work with other quantum computing platforms. To use the suite with IQM Resonance, you will need to set up an account and obtain an API token. You can then set the IQM_TOKEN environment variable to your API token. The suite will automatically use this token to authenticate with IQM Resonance. You can easily set up one or more benchmarks by defining a configuration for them. For example, for Randomized, Interleaved and Mirror Benchmarking, or Quantum Volume: In order to execute them, you must specify a backend. for IQM Resonance this can be given as a simple string, such as \u201cgarnet\u201d (together with your IQM Token environment variable) and for an on-prem device and IQM Resonance this can be defined using the URL of the quantum computer. Also, you need to reference the benchmark configuration you want to run: Full examples on how to run benchmarks and analyze the results can be found in the examples folder. This repository can be setup to perform a scheduled (weekly, daily\u2026) benchmark from a Gitlab/Github pipeline, executed on a real device. An example configuration is given in the scheduled_experiments folder. previous IQM Benchmarks next Examples By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.benchmark_definition.BenchmarkObservation",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.benchmark_definition.BenchmarkObservation.html",
    "description": "Bases: object Dataclass to store the main results of a single run of a Benchmark name ( str ) \u2013 value ( Any ) \u2013 identifier ( BenchmarkObservationIdentifier ) \u2013 uncertainty ( Any | None ) \u2013 name of the...",
    "content": "Bases: object Dataclass to store the main results of a single run of a Benchmark name ( str ) \u2013 value ( Any ) \u2013 identifier ( BenchmarkObservationIdentifier ) \u2013 uncertainty ( Any | None ) \u2013 name of the observation str value of the observation Any identifier, which should be a string of the qubit layout iqm.benchmarks.benchmark_definition.BenchmarkObservationIdentifier uncertainty of the observation Any | None Attributes uncertainty  name  value  identifier  Methods __eq__ (other) Return self==value. __repr__ () Return repr(self). previous iqm.benchmarks.benchmark_definition.BenchmarkAnalysisResult next iqm.benchmarks.benchmark_definition.BenchmarkObservationIdentifier By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.readout_mitigation.readout_error_m3",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.readout_mitigation.readout_error_m3.html",
    "description": "Counts processor using M3IQM for readout error mitigation. The qubits argument can be either a dictionary coming from mthree.utils.final_measurement_mapping or an array like the initial layout coming ...",
    "content": "Counts processor using M3IQM for readout error mitigation. The qubits argument can be either a dictionary coming from mthree.utils.final_measurement_mapping or an array like the initial layout coming from [backend.qubit_name_to_index(name)] returns a dictionary of quasiprobabilties. NOTE: we could also pass a list of input counts and then this would return a list of quasiprobabilities.\nThis would not work out of the box for us since we need the annotations of either Dict or List (not Union). counts ( Dict [ str , float ] ) \u2013 mit ( M3IQM ) \u2013 qubits ( Iterable ) \u2013 Dict [ str , float ] previous iqm.benchmarks.readout_mitigation.apply_readout_error_mitigation next iqm.benchmarks.readout_mitigation.M3IQM By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.graph_states.plot_max_negativities",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.graph_states.plot_max_negativities.html",
    "description": "Plots the maximum negativity for each corresponding pair of qubits. negativities ( Dict [ str , Dict [ str , str | float ] ] ) \u2013 A dictionary (str qubit keys) of dictionaries (keys \u201cvalue\u201d/\u201duncertaint...",
    "content": "Plots the maximum negativity for each corresponding pair of qubits. negativities ( Dict [ str , Dict [ str , str | float ] ] ) \u2013 A dictionary (str qubit keys) of dictionaries (keys \u201cvalue\u201d/\u201duncertainty\u201d) of negativities (float) to plot. backend_name ( str ) \u2013 The name of the backend for the corresponding experiment. qubit_names ( Dict [ int , str ] ) \u2013 A dictionary of qubit names corresponding to qubit indices. timestamp ( str ) \u2013 The timestamp of the corresponding experiment. tomography ( Literal [ \"shadow_tomography\" , \"state_tomography\" ] ) \u2013 The type of tomography that was used. num_shots ( int ) \u2013 The number of shots used in the corresponding experiment. num_bootstraps ( Optional [ int ] ) \u2013 The number of bootstraps used if tomography corresponds to state tomography.\n* Defaults to None if the tomography type is \u201cshadow_tomography\u201d. num_RM_samples ( Optional [ int ] ) \u2013 The number of randomized measurement samples used if tomography corresponds to shadow tomography.\n* Defaults to None if the tomography type is \u201cstate_tomography\u201d. num_MoMs_samples ( Optional [ int ] ) \u2013 The number of Median of Means samples per randomized measurement used if tomography corresponds to shadow tomography.\n* Defaults to None if the tomography type is \u201cshadow_tomography\u201d. The figure label and the max negativities plot figure. Tuple[ str , Figure] previous iqm.benchmarks.entanglement.graph_states.plot_density_matrix next iqm.benchmarks.entanglement.graph_states.plot_max_negativities_graph By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.eplg.eplg.plot_layered_fidelities_graph",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.eplg.eplg.plot_layered_fidelities_graph.html",
    "description": "Plots the layered fidelity for each corresponding pair of qubits in a graph layout of the given backend. fidelities ( Dict [ str , Dict [ str , float ] ] ) \u2013 A dictionary (str qubit keys) of dictionar...",
    "content": "Plots the layered fidelity for each corresponding pair of qubits in a graph layout of the given backend. fidelities ( Dict [ str , Dict [ str , float ] ] ) \u2013 A dictionary (str qubit keys) of dictionaries (keys \u201cvalue\u201d/\u201duncertainty\u201d) of fidelities (float) to plot. backend_coupling_map ( CouplingMap ) \u2013 The CouplingMap instance. qubit_names ( Dict [ int , str ] ) \u2013 A dictionary of qubit names corresponding to qubit indices. timestamp ( str ) \u2013 The timestamp of the corresponding experiment. station ( str ) \u2013 The name of the station to use for the graph layout. eplg_estimate ( Optional [ Dict [ str , float ] ] ) \u2013 A dictionary with the EPLG estimate value and its uncertainty. The figure label and the layered fidelities plot figure. Tuple[ str , Figure] previous iqm.benchmarks.randomized_benchmarking.eplg.eplg.eplg_analysis next iqm.benchmarks.randomized_benchmarking.eplg.eplg.EPLGBenchmark By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.mirror_rb",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.mirror_rb.html",
    "description": "Mirror RB estimates the average layer fidelity of ensembles of gates Subpackages and modules mirror_rb Mirror Randomized Benchmarking. previous iqm.benchmarks.randomized_benchmarking.interleaved_rb.in...",
    "content": "Mirror RB estimates the average layer fidelity of ensembles of gates Subpackages and modules mirror_rb Mirror Randomized Benchmarking. previous iqm.benchmarks.randomized_benchmarking.interleaved_rb.interleaved_rb.InterleavedRandomizedBenchmarking next iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.compressive_gst.gst_analysis.run_mGST_wrapper",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.compressive_gst.gst_analysis.run_mGST_wrapper.html",
    "description": "Wrapper function for mGST algorithm execution which prepares an initialization and sets the alg. parameters dataset ( Dataset ) \u2013 xarray.Dataset\nA dataset containing counts from the experiment and con...",
    "content": "Wrapper function for mGST algorithm execution which prepares an initialization and sets the alg. parameters dataset ( Dataset ) \u2013 xarray.Dataset\nA dataset containing counts from the experiment and configurations y ( ndarray ) \u2013 ndarray\nThe circuit outcome probabilities as a num_povm x num_circuits array ndarray Kraus estimate array where each subarray along the first axis contains a set of Kraus operators.\nThe second axis enumerates Kraus operators for a gate specified by the first axis. X ndarray Superoperator estimate array where reconstructed CPT superoperators in\nstandard basis are stacked along the first axis. E ndarray Current POVM estimate rho ndarray Current initial state estimate K_target ndarray Target gate Kraus array where each subarray along the first axis contains a set of Kraus operators.\nThe second axis enumerates Kraus operators for a gate specified by the first axis. X_target ndarray Target gate superoperator estimate array where reconstructed CPT superoperators in\nstandard basis are stacked along the first axis. E_target ndarray Target POVM rho_target ndarray Target initial state Kraus estimate array where each subarray along the first axis contains a set of Kraus operators.\nThe second axis enumerates Kraus operators for a gate specified by the first axis. Superoperator estimate array where reconstructed CPT superoperators in\nstandard basis are stacked along the first axis. Current POVM estimate Current initial state estimate Target gate Kraus array where each subarray along the first axis contains a set of Kraus operators.\nThe second axis enumerates Kraus operators for a gate specified by the first axis. Target gate superoperator estimate array where reconstructed CPT superoperators in\nstandard basis are stacked along the first axis. Target POVM Target initial state K previous iqm.benchmarks.compressive_gst.gst_analysis.result_str_to_floats next iqm.benchmarks.entanglement By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.benchmark_definition.Benchmark",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.benchmark_definition.Benchmark.html",
    "description": "Bases: ABC A base class for running cortex-based Benchmark experiments. In order to write a new benchmark, it is recommended to derive a class\nfrom this baseclass. A new benchmark is defined by derivi...",
    "content": "Bases: ABC A base class for running cortex-based Benchmark experiments. In order to write a new benchmark, it is recommended to derive a class\nfrom this baseclass. A new benchmark is defined by deriving from this base\nclass and implementing the execute method. Additionally, a custom analysis\nfor the benchmark can be implemented by giving the pointer to the analysis\nmethod in analysis_function field. The given analysis_function should\naccept AnalysisResult as its input and return the final result. Attributes default_options  options  Methods analysis_function (result) The default analysis that only pass the result through. analyze ([run_index]) The default analysis for the benchmark. execute (backend) Executes the benchmark. name () Return the name of the benchmark. run ([calibration_set_id]) Runs the benchmark using the given backend and calibration_set_id. backend ( str | IQMBackendBase ) \u2013 configuration ( BenchmarkConfigurationBase ) \u2013 The default analysis that only pass the result through. result ( BenchmarkRunResult ) \u2013 BenchmarkAnalysisResult Return the name of the benchmark. Executes the benchmark. This method should be overridden by deriving classes. backend ( IQMBackend | IQMFacadeBackend | str ) \u2013 Qiskit backend used to execute benchmarks. An xarray dataset which contains to results of the benchmark execution.\nThe dataset should contain all the information necessary for analysing\nthe benchmark results. Dataset Runs the benchmark using the given backend and calibration_set_id. calibration_set_id ( str | UUID | None ) \u2013 CalibrationSetId used to initialize the backend or None for the latest calibration set. The result of the benchmark run. RunResult The default analysis for the benchmark. Internally uses the function defined by the attribute analysis_function to perform the analysis. This function makes a shallow copy of the dataset produced by\nrun. Therefore, it is recommended to not make changes to the data of the dataset but\njust the structure of the array. run_index \u2013 Index for the run to analyze. An analysis result constructed from the run and updated by the analysis method defined by\nthe analysis_function field. BenchmarkAnalysisResult previous iqm.benchmarks.benchmark_definition.show_figure next iqm.benchmarks.benchmark_definition.BenchmarkAnalysisResult By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.split_into_disjoint_pairs",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.split_into_disjoint_pairs.html",
    "description": "Split a Sequence of pairs of integers into a List of a minimal number of Lists of disjoint pairs.\nExample: input [(0,3), (2,3), (3,8), (8,13), (13,17), (17,18)] gives\noutput [[(0, 3), (8, 13), (17, 18...",
    "content": "Split a Sequence of pairs of integers into a List of a minimal number of Lists of disjoint pairs.\nExample: input [(0,3), (2,3), (3,8), (8,13), (13,17), (17,18)] gives\noutput [[(0, 3), (8, 13), (17, 18)], [(2, 3), (13, 17)], [(3, 8)]]. # TODO: enable specifying a max split size of Lists of disjoint pairs. # pylint: disable=fixme pairs ( Sequence [ Tuple [ int , int ] ] ) \u2013 The input list of pairs of integers. A List of Lists of disjoint pairs. List[List[Tuple[ int , int ]]] previous iqm.benchmarks.utils.sort_batches_by_final_layout next iqm.benchmarks.utils.split_sequence_in_chunks By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.html",
    "description": "Common functions for Randomized Benchmarking-based techniques Functions compute_inverse_clifford (qc_inv,\u00a0...) Function to compute the inverse Clifford of a circuit :param qc_inv: The Clifford circuit...",
    "content": "Common functions for Randomized Benchmarking-based techniques Functions compute_inverse_clifford (qc_inv,\u00a0...) Function to compute the inverse Clifford of a circuit :param qc_inv: The Clifford circuit to be inverted :type qc_inv: QuantumCircuit :param clifford_dictionary: A dictionary of Clifford gates labeled by (de)stabilizers :type clifford_dictionary: Dict edge_grab (qubit_set,\u00a0n_layers,\u00a0backend_arg) Generate a list of random layers containing single-qubit Cliffords and two-qubit gates, sampled according to the edge-grab algorithm (see arXiv:2204.07568 [quant-ph]). estimate_survival_probabilities (num_qubits,\u00a0...) Compute a result's probability of being on the ground state. exponential_rb (depths,\u00a0...) Fit function for interleaved/non-interleaved RB fit_decay_lmfit (func,\u00a0qubit_set,\u00a0data,\u00a0...) Perform a fitting routine for 0th-order (Ap^m+B) RB using lmfit generate_all_rb_circuits (qubits,\u00a0...) param qubits : List of qubits List of qubits generate_fixed_depth_parallel_rb_circuits (...) Generates parallel RB circuits, before and after transpilation, at fixed depth generate_random_clifford_seq_circuits (...[,\u00a0...]) Generate random Clifford circuits in native gates for a given sequence length. get_survival_probabilities (num_qubits,\u00a0counts) Compute a result's probability of being on the ground state. import_native_gate_cliffords ([system_size]) Import native gate Clifford dictionaries lmfit_minimizer (fit_parameters,\u00a0fit_data,\u00a0...) param fit_parameters : the parameters to fit the parameters to fit plot_rb_decay (identifier,\u00a0qubits_array,\u00a0...) Plot the fidelity decay and the fit to the model. relabel_qubits_array_from_zero (arr[,\u00a0...]) Helper function to relabel a qubits array to an increasingly ordered one starting from zero e.g., [[2,3], [5], [7,8]]  ->  [[0,1], [2], [3,4]] Note: this assumes the input array is sorted in increasing order! submit_parallel_rb_job (backend_arg,\u00a0...) Submit fixed-depth parallel MRB jobs for execution in the specified IQMBackend :param backend_arg: the IQM backend to submit the job :type backend_arg: IQMBackendBase :param qubits_array: the qubits to identify the submitted job :type qubits_array: Sequence[Sequence[int]] :param depth: the depth (number of canonical layers) of the circuits to identify the submitted job :type depth: int :param sorted_transpiled_circuit_dicts: A dictionary containing all MRB circuits :type sorted_transpiled_circuit_dicts: Dict[Tuple[int,...], List[QuantumCircuit]] :param shots: the number of shots to submit the job :type shots: int :param calset_id: the calibration identifier :type calset_id: Optional[str] :param max_gates_per_batch: the maximum number of gates per batch to submit the job :type max_gates_per_batch: Optional[str] :param max_circuits_per_batch: the maximum number of circuits per batch to submit the job. submit_sequential_rb_jobs (qubits,\u00a0...[,\u00a0...]) Submit sequential RB jobs for execution in the specified IQMBackend :param qubits: the qubits to identify the submitted job :type qubits: List[int] :param transpiled_circuits: A dictionary containing all MRB circuits :type transpiled_circuits: Dict[str, List[QuantumCircuit]] :param shots: the number of shots to submit per job :type shots: int :param backend_arg: the IQM backend to submit the job :type backend_arg: IQMBackendBase :param calset_id: the calibration identifier :type calset_id: Optional[str] :param max_gates_per_batch: the maximum number of gates per batch :type max_gates_per_batch: Optional[int] :param max_circuits_per_batch: the maximum number of circuits per batch :type max_circuits_per_batch: Optional[int] :param circuit_compilation_options: Compilation options passed to submit_execute :type circuit_compilation_options: Optional[CircuitCompilationOptions] survival_probabilities_parallel (...[,\u00a0...]) Estimates marginalized survival probabilities from a parallel RB execution (at fixed depth). validate_irb_gate (gate_id,\u00a0backend_arg[,\u00a0...]) Validate that an input gate is Clifford and transpiled to IQM's native basis validate_rb_qubits (qubits_array,\u00a0backend_arg) Validate qubit inputs for a Clifford RB experiment :param qubits_array: the array of qubits :type qubits_array: List[List[int]] :param backend_arg: the IQM backend :type backend_arg: IQMBackendBase previous iqm.benchmarks.randomized_benchmarking.multi_lmfit.multi_dataset_residual next iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.compute_inverse_clifford By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.list_to_numcircuit_times_numpauli_matrix",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.list_to_numcircuit_times_numpauli_matrix.html",
    "description": "Convert a flat list to a matrix of shape (num_circ_samples, num_pauli_samples).\n:param input_list: the input flat list\n:type input_list: List[Any]\n:param num_circ_samples: the number of sets of Pauli-...",
    "content": "Convert a flat list to a matrix of shape (num_circ_samples, num_pauli_samples).\n:param input_list: the input flat list\n:type input_list: List[Any]\n:param num_circ_samples: the number of sets of Pauli-dressed circuit samples\n:type num_circ_samples: int\n:param num_pauli_samples: the number of Pauli samples per circuit\n:type num_pauli_samples: int ValueError \u2013 Length of passed list is not (num_circ_samples * num_pauli_samples). the matrix List[List[Any]] input_list ( List [ Any ] ) \u2013 num_circ_samples ( int ) \u2013 num_pauli_samples ( int ) \u2013 previous iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.generate_pauli_dressed_mrb_circuits next iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.mrb_analysis By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.direct_rb",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.direct_rb.html",
    "description": "Direct RB estimates the layer fidelity of canonical gates Subpackages and modules direct_rb Direct Randomized Benchmarking. previous iqm.benchmarks.randomized_benchmarking.clifford_rb.clifford_rb.Clif...",
    "content": "Direct RB estimates the layer fidelity of canonical gates Subpackages and modules direct_rb Direct Randomized Benchmarking. previous iqm.benchmarks.randomized_benchmarking.clifford_rb.clifford_rb.CliffordRandomizedBenchmarking next iqm.benchmarks.randomized_benchmarking.direct_rb.direct_rb By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.compute_polarizations",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.compute_polarizations.html",
    "description": "Estimates the polarization for a list of noisy counts with respect to corresponding ideal counts\nThe polarization here is a rescaling of the average fidelity, that corrects for few-qubit effects num_q...",
    "content": "Estimates the polarization for a list of noisy counts with respect to corresponding ideal counts\nThe polarization here is a rescaling of the average fidelity, that corrects for few-qubit effects num_qubits ( int ) \u2013 the number of qubits being benchmarked noisy_counts ( List [ Dict [ str , int ] ] ) \u2013 the list of counts coming from real execution ideal_counts ( List [ Dict [ str , int ] ] ) \u2013 the list of counts coming from simulated, ideal execution num_circ_samples ( int ) \u2013 the number circuit of samples used to estimate the polarization num_pauli_samples ( int ) \u2013 the number of pauli samples per circuit sample used to estimate the polarization the polarizations for each circuit sample of the given sequence length List[ float ] previous iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb next iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.generate_fixed_depth_mrb_circuits By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.get_measurement_mapping",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.get_measurement_mapping.html",
    "description": "Extracts the final measurement mapping (qubits to bits) of a quantum circuit. circuit ( QuantumCircuit ) \u2013 The quantum circuit to extract the measurement mapping from. A dictionary where keys are qubi...",
    "content": "Extracts the final measurement mapping (qubits to bits) of a quantum circuit. circuit ( QuantumCircuit ) \u2013 The quantum circuit to extract the measurement mapping from. A dictionary where keys are qubits and values are classical bits. dict previous iqm.benchmarks.utils.get_iqm_backend next iqm.benchmarks.utils.get_neighbors_of_edges By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.compressive_gst.gst_analysis.result_str_to_floats",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.compressive_gst.gst_analysis.result_str_to_floats.html",
    "description": "Converts formated string results from mgst to float (value, uncertainty) pairs result_str ( str ) \u2013 str\nThe value of a result parameter formated as str err ( str ) \u2013 str\nThe error interval of the para...",
    "content": "Converts formated string results from mgst to float (value, uncertainty) pairs result_str ( str ) \u2013 str\nThe value of a result parameter formated as str err ( str ) \u2013 str\nThe error interval of the parameters float The parameter value as floar uncertainty: float A single uncertainty value The parameter value as floar A single uncertainty value value previous iqm.benchmarks.compressive_gst.gst_analysis.pandas_results_to_observations next iqm.benchmarks.compressive_gst.gst_analysis.run_mGST_wrapper By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.benchmark.BenchmarkBase",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.benchmark.BenchmarkBase.html",
    "description": "Bases: ABC The base implementation of all benchmarks, from which they inherit. Methods check_requirements (all_benchmarks) Check whether the requirements for the benchmark are met, returning a valid b...",
    "content": "Bases: ABC The base implementation of all benchmarks, from which they inherit. Methods check_requirements (all_benchmarks) Check whether the requirements for the benchmark are met, returning a valid benchmark dictionary. execute_full_benchmark () Execute the full benchmark on the given backend. generate_requirements (all_benchmarks) Generate the required attributes for execution. name () Return the name of the benchmark. backend ( IQMBackendBase ) \u2013 configuration ( BenchmarkConfigurationBase ) \u2013 Return the name of the benchmark. Execute the full benchmark on the given backend. Check whether the requirements for the benchmark are met, returning a valid benchmark dictionary. all_benchmarks ( OrderedDict [ str , BenchmarkBase ] ) \u2013 OrderedDict [ str , BenchmarkBase ] Generate the required attributes for execution. all_benchmarks ( OrderedDict [ str , BenchmarkBase ] ) \u2013 None previous iqm.benchmarks.benchmark next iqm.benchmarks.benchmark.BenchmarkConfigurationBase By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.marginal_distribution",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.marginal_distribution.html",
    "description": "Compute the marginal distribution over specified bits (indices). Params:\n- prob_dist (Dict[str, float | int]): A dictionary with keys being bitstrings and values are either probabilities or counts\n- i...",
    "content": "Compute the marginal distribution over specified bits (indices). Params:\n- prob_dist (Dict[str, float | int]): A dictionary with keys being bitstrings and values are either probabilities or counts\n- indices (Iterable[int]): List of bit indices to marginalize over Returns:\n- dict: A dictionary representing the marginal distribution over the specified bits. prob_dist_or_counts ( Dict [ str , float | int ] ) \u2013 indices ( Iterable [ int ] ) \u2013 Dict [ str , float ] previous iqm.benchmarks.utils.get_tomography_matrix next iqm.benchmarks.utils.median_with_uncertainty By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.multi_lmfit.create_multi_dataset_params",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.multi_lmfit.create_multi_dataset_params.html",
    "description": "Generates lmfit Parameter object with parameters for each line to fit previous iqm.benchmarks.randomized_benchmarking.multi_lmfit next iqm.benchmarks.randomized_benchmarking.multi_lmfit.eval_func_sing...",
    "content": "Generates lmfit Parameter object with parameters for each line to fit previous iqm.benchmarks.randomized_benchmarking.multi_lmfit next iqm.benchmarks.randomized_benchmarking.multi_lmfit.eval_func_single_dataset By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.get_survival_probabilities",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.get_survival_probabilities.html",
    "description": "Compute a result\u2019s probability of being on the ground state. num_qubits ( int ) \u2013 the number of qubits counts ( List [ Dict [ str , int ] ] ) \u2013 the result of the execution of a list of quantum circuit...",
    "content": "Compute a result\u2019s probability of being on the ground state. num_qubits ( int ) \u2013 the number of qubits counts ( List [ Dict [ str , int ] ] ) \u2013 the result of the execution of a list of quantum circuits (counts) the ground state probabilities of the RB sequence List[ float ] previous iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.generate_random_clifford_seq_circuits next iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.import_native_gate_cliffords By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.eplg.eplg.EPLGBenchmark",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.eplg.eplg.EPLGBenchmark.html",
    "description": "Bases: Benchmark EPLG estimates the layer fidelity of native 2Q gate layers Attributes name  Methods add_all_meta_to_dataset (dataset) Adds all configuration metadata and circuits to the dataset varia...",
    "content": "Bases: Benchmark EPLG estimates the layer fidelity of native 2Q gate layers Attributes name  Methods add_all_meta_to_dataset (dataset) Adds all configuration metadata and circuits to the dataset variable analysis_function (run) EPLG analysis function execute (backend) Execute the EPLG Benchmark validate_custom_qubits_array () Validates the custom qubits array input . validate_random_chain_inputs () Validates inputs for chain sampling. backend_arg ( IQMBackendBase | str ) \u2013 configuration ( EPLGConfiguration ) \u2013 EPLG analysis function run ( BenchmarkRunResult ) \u2013 The result of the benchmark run. AnalysisResult corresponding to DRB. BenchmarkAnalysisResult Adds all configuration metadata and circuits to the dataset variable dataset ( xr.Dataset ) \u2013 The xarray dataset Validates the custom qubits array input . Validates inputs for chain sampling. ValueError \u2013 If the chain inputs are beyond general or EPLG criteria. Execute the EPLG Benchmark backend ( IQMBackendBase ) \u2013 Dataset previous iqm.benchmarks.randomized_benchmarking.eplg.eplg.plot_layered_fidelities_graph next iqm.benchmarks.randomized_benchmarking.eplg.eplg.EPLGConfiguration By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.compressive_gst.compressive_gst.parse_gate_set",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.compressive_gst.compressive_gst.parse_gate_set.html",
    "description": "Handles different gate set inputs and produces a valid gate set configuration ( GSTConfiguration ) \u2013 BenchmarkConfigurationBase\nConfiguration class containing variables num_qubits ( int ) \u2013 int\nThe nu...",
    "content": "Handles different gate set inputs and produces a valid gate set configuration ( GSTConfiguration ) \u2013 BenchmarkConfigurationBase\nConfiguration class containing variables num_qubits ( int ) \u2013 int\nThe number of qubits on which the gate set is defined qubit_layouts ( List [ List [ int ] ] ) \u2013 List[List[int]]\nA List of physical qubit layouts, as specified by integer labels, where the benchmark is meant to be run. List[QuantumCircuit] A list of gates defined as quantum circuit objects gate_labels_dict: Dict[str, Dict[int, str]] The names of gates, i.e. \u201cRx_pi_2\u201d for a pi/2 rotation around the x-axis. num_gates: int The number of gates in the gate set A list of gates defined as quantum circuit objects The names of gates, i.e. \u201cRx_pi_2\u201d for a pi/2 rotation around the x-axis. The number of gates in the gate set gate_set previous iqm.benchmarks.compressive_gst.compressive_gst.create_predefined_gate_set next iqm.benchmarks.compressive_gst.compressive_gst.parse_layouts By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.direct_rb.direct_rb.generate_fixed_depth_parallel_drb_circuits",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.direct_rb.direct_rb.generate_fixed_depth_parallel_drb_circuits.html",
    "description": "The circuits follow a layered pattern with barriers, taylored to measure EPLG (arXiv:2311.05933),\nwith layers of random Cliffords interleaved among sampled layers of 2Q gates and sequence inversion. q...",
    "content": "The circuits follow a layered pattern with barriers, taylored to measure EPLG (arXiv:2311.05933),\nwith layers of random Cliffords interleaved among sampled layers of 2Q gates and sequence inversion. qubits_array ( Sequence [ Sequence [ int ] ] ) \u2013 The array of physical qubit layouts on which to generate parallel DRB circuits. depth ( int ) \u2013 The depth (number of canonical DRB layers) of the circuits. num_circuit_samples ( int ) \u2013 The number of DRB circuits to generate. backend_arg ( str | IQMBackendBase ) \u2013 The backend on which to generate the circuits. assigned_density_2q_gates ( Dict [ str , float ] ) \u2013 The expected densities of 2-qubit gates in the final circuits per qubit layout. assigned_two_qubit_gate_ensembles ( Dict [ str , Dict [ str , float ] ] ) \u2013 The two-qubit gate ensembles to use in the random DRB circuits per qubit layout. assigned_clifford_sqg_probabilities ( Dict [ str , float ] ) \u2013 Probability with which to uniformly sample Clifford 1Q gates per qubit layout. assigned_sqg_gate_ensembles ( Dict [ str , Dict [ str , float ] ] ) \u2013 A dictionary with keys being str specifying 1Q gates, and values being corresponding probabilities per qubit layout. cliffords_1q ( Dict [ str , QuantumCircuit ] ) \u2013 dictionary of 1-qubit Cliffords in terms of IQM-native r gates. cliffords_2q ( Dict [ str , QuantumCircuit ] ) \u2013 dictionary of 2-qubit Cliffords in terms of IQM-native r and CZ gates. qiskit_optim_level ( int ) \u2013 Qiskit transpiler optimization level.\n* Defaults to 1. routing_method ( Literal [ \"basic\" , \"lookahead\" , \"stochastic\" , \"sabre\" , \"none\" ] ) \u2013 Qiskit transpiler routing method.\n* Default is \u201cbasic\u201d. is_eplg ( bool ) \u2013 Whether the circuits belong to an EPLG experiment.\n* If True a single layer is generated.\n* Default is False. A dictionary of untranspiled and transpiled lists of parallel (simultaneous) DRB circuits. Dict[ str , List[QuantumCircuit]] previous iqm.benchmarks.randomized_benchmarking.direct_rb.direct_rb.generate_drb_circuits next iqm.benchmarks.randomized_benchmarking.direct_rb.direct_rb.DirectRBConfiguration By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils_shadows",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils_shadows.html",
    "description": "Shadow Tomography utility functions Functions CUE (random_gen,\u00a0n) Prepares single qubit Haar-random unitary (drawn from Circuilar Unitary Ensemble - CUE). get_local_shadow (counts,\u00a0unitary_arg,\u00a0...[,\u00a0...",
    "content": "Shadow Tomography utility functions Functions CUE (random_gen,\u00a0n) Prepares single qubit Haar-random unitary (drawn from Circuilar Unitary Ensemble - CUE). get_local_shadow (counts,\u00a0unitary_arg,\u00a0...[,\u00a0...]) Constructs shadows for each individual initialisation. get_negativity (rho,\u00a0NA,\u00a0NB) Computes the negativity of a given density matrix. local_shadow_tomography (qc,\u00a0Nu,\u00a0active_qubits) Prepares the circuits to perform local Haar or Clifford shadow tomography. previous iqm.benchmarks.utils_plots.GraphPositions next iqm.benchmarks.utils_shadows.CUE By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.exponential_rb",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.exponential_rb.html",
    "description": "Fit function for interleaved/non-interleaved RB depths ( np.ndarray ) \u2013 the depths of the RB experiment depolarization_probability ( float ) \u2013 the depolarization value (1-p) of the RB decay offset ( f...",
    "content": "Fit function for interleaved/non-interleaved RB depths ( np.ndarray ) \u2013 the depths of the RB experiment depolarization_probability ( float ) \u2013 the depolarization value (1-p) of the RB decay offset ( float ) \u2013 the offset of the RB decay amplitude ( float ) \u2013 the amplitude of the RB decay the exponential fit function np.ndarray previous iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.estimate_survival_probabilities next iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.fit_decay_lmfit By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.graph_states.find_edges_with_disjoint_neighbors",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.graph_states.find_edges_with_disjoint_neighbors.html",
    "description": "Finds sets of edges with non-overlapping neighboring nodes. graph ( Sequence [ Sequence [ int ] ] ) \u2013 The input graph specified as a sequence of edges (Sequence[int]). A list of lists of edges (Tuple[...",
    "content": "Finds sets of edges with non-overlapping neighboring nodes. graph ( Sequence [ Sequence [ int ] ] ) \u2013 The input graph specified as a sequence of edges (Sequence[int]). A list of lists of edges (Tuple[int]) from the original graph with non-overlapping neighboring nodes. List[List[Tuple[ int ]]] previous iqm.benchmarks.entanglement.graph_states next iqm.benchmarks.entanglement.graph_states.generate_graph_state By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils_plots.plot_layout_fidelity_graph",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils_plots.plot_layout_fidelity_graph.html",
    "description": "Plot a graph showing the quantum chip layout with fidelity information. Creates a visualization of the quantum chip topology where nodes represent qubits\nand edges represent connections between qubits...",
    "content": "Plot a graph showing the quantum chip layout with fidelity information. Creates a visualization of the quantum chip topology where nodes represent qubits\nand edges represent connections between qubits. Edge thickness indicates gate errors\n(thinner edges mean better fidelity) and selected qubits are highlighted in orange. cal_url ( str ) \u2013 URL to retrieve calibration data from qubit_layouts ( list [ list [ int ] ] | None ) \u2013 List of qubit layouts where each layout is a list of qubit indices station ( str | None ) \u2013 Name of the quantum computing station to use predefined positions for.\nIf None, positions will be generated algorithmically. The generated figure object containing the graph visualization matplotlib.figure.Figure previous iqm.benchmarks.utils_plots.evaluate_hamiltonian_paths next iqm.benchmarks.utils_plots.rx_to_nx_graph By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.submit_execute",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.submit_execute.html",
    "description": "organized as a dictionary with keys being identifiers of a batch (normally qubits) and values corresponding lists of quantum circuits.\nThe result is returned as a single list of IQMJob objects. sorted...",
    "content": "organized as a dictionary with keys being identifiers of a batch (normally qubits) and values corresponding lists of quantum circuits.\nThe result is returned as a single list of IQMJob objects. sorted_transpiled_qc_list ( Dict [ Tuple [ int ] | str , List [ QuantumCircuit ] ] ) \u2013 A dictionary of lists of quantum circuits to be executed.\n* The keys (Tuple[int] | str) should correspond to final measured qubits.\n* The values (List[QuantumCircuit]) should be the corresponding list (batch) of quantum circuits. backend ( IQMBackendBase ) \u2013 the backend to execute the circuits on. shots ( int ) \u2013 the number of shots per circuit. calset_id ( Optional [ str ] ) \u2013 the calibration set ID.\n* Default is None: uses the latest calibration ID. max_gates_per_batch ( Optional [ int ] ) \u2013 the maximum number of gates per batch sent to the backend, used to make manageable batches.\n* Default is None. max_circuits_per_batch ( Optional [ int ] ) \u2013 the maximum number of circuits per batch sent to the backend, used to make manageable batches.\n* Default is None. circuit_compilation_options ( CircuitCompilationOptions ) \u2013 Ability to pass a compilation options object,\nenabling execution with dynamical decoupling, among other options - see qiskit-iqm documentation.\n* Default is None. a list of IQMJob objects corresponding to the submitted circuits. List[IQMJob] previous iqm.benchmarks.utils.split_sequence_in_chunks next iqm.benchmarks.utils.timeit By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.graph_states",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.graph_states.html",
    "description": "Graph states benchmark Functions find_edges_with_disjoint_neighbors (graph) Finds sets of edges with non-overlapping neighboring nodes. generate_graph_state (qubits,\u00a0backend) Generates a circuit with ...",
    "content": "Graph states benchmark Functions find_edges_with_disjoint_neighbors (graph) Finds sets of edges with non-overlapping neighboring nodes. generate_graph_state (qubits,\u00a0backend) Generates a circuit with minimal depth preparing a native graph state for a given backend using given qubits. generate_minimal_edge_layers (cp_map) Sorts the edges of a coupling map, arranging them in a dictionary with values being subsets of the coupling map with no overlapping nodes. negativity_analysis (run) Analysis function for a Graph State benchmark experiment. plot_density_matrix (matrix,\u00a0qubit_pair,\u00a0...) Plots a density matrix for corresponding qubit pairs, neighbor qubit projections, and negativities. plot_max_negativities (negativities,\u00a0...[,\u00a0...]) Plots the maximum negativity for each corresponding pair of qubits. plot_max_negativities_graph (negativities,\u00a0...) Plots the maximum negativity for each corresponding pair of qubits in a graph layout of the given backend. shadow_tomography_analysis (dataset,\u00a0...) Performs shadow tomography analysis on the given dataset. state_tomography_analysis (dataset,\u00a0...) Performs state tomography analysis on the given dataset. update_pauli_expectations (...) Helper function that updates the input Pauli expectations dictionary of dictionaries (projections -> {pauli string: expectation}). Classes GraphStateBenchmark (backend_arg,\u00a0configuration) The Graph States benchmark estimates the bipartite entangelement negativity of native graph states. GraphStateConfiguration (*,\u00a0benchmark,\u00a0shots,\u00a0...) Graph States Benchmark configuration. Inheritance previous iqm.benchmarks.entanglement.ghz.GHZConfiguration next iqm.benchmarks.entanglement.graph_states.find_edges_with_disjoint_neighbors By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.median_with_uncertainty",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.median_with_uncertainty.html",
    "description": "Computes the median of a Sequence of float observations and returns value and propagated uncertainty.\nReference: https://mathworld.wolfram.com/StatisticalMedian.html observations ( Sequence [ float ] ...",
    "content": "Computes the median of a Sequence of float observations and returns value and propagated uncertainty.\nReference: https://mathworld.wolfram.com/StatisticalMedian.html observations ( Sequence [ float ] ) \u2013 a Sequence of floating-point numbers. a dictionary with keys \u201cvalue\u201d and \u201cuncertainty\u201d for the median of the input Sequence. Dict[ str , float ] previous iqm.benchmarks.utils.marginal_distribution next iqm.benchmarks.utils.perform_backend_transpilation By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.quantum_volume.quantum_volume.qv_analysis",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.quantum_volume.quantum_volume.qv_analysis.html",
    "description": "Analysis function for a Quantum Volume experiment run ( RunResult ) \u2013 A Quantum Volume experiment run for which analysis result is created AnalysisResult corresponding to Quantum Volume BenchmarkAnaly...",
    "content": "Analysis function for a Quantum Volume experiment run ( RunResult ) \u2013 A Quantum Volume experiment run for which analysis result is created AnalysisResult corresponding to Quantum Volume BenchmarkAnalysisResult previous iqm.benchmarks.quantum_volume.quantum_volume.plot_hop_threshold next iqm.benchmarks.quantum_volume.quantum_volume.QuantumVolumeBenchmark By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.optimization.qscore",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.optimization.qscore.html",
    "description": "Qscore benchmark Functions calculate_optimal_angles_for_QAOA_p1 (graph) Calculates the optimal angles for single layer QAOA MaxCut ansatz. compute_expectation_value (counts,\u00a0graph,\u00a0...) Computes expec...",
    "content": "Qscore benchmark Functions calculate_optimal_angles_for_QAOA_p1 (graph) Calculates the optimal angles for single layer QAOA MaxCut ansatz. compute_expectation_value (counts,\u00a0graph,\u00a0...) Computes expectation value based on measurement results. create_objective_function (counts,\u00a0graph,\u00a0...) Creates a function that maps the parameters to the parametrized circuit, runs it and computes the expectation value. cut_cost_function (x,\u00a0graph) Returns the number of cut edges in a graph (with minus sign). get_optimal_angles (num_layers) provides the optimal angles for QAOA MaxCut ansatz given the number of layers is_successful (approximation_ratio) Check whether a Q-score benchmark returned approximation ratio above beta*, therefore being successful. plot_approximation_ratios (nodes,\u00a0beta_ratio,\u00a0...) Generate the figure of approximation ratios vs number of nodes, qscore_analysis (run) Analysis function for a QScore experiment run_QAOA (counts,\u00a0graph_physical,\u00a0qubit_node,\u00a0...) Solves the cut size of MaxCut for a graph using QAOA. Classes QScoreBenchmark (backend_arg,\u00a0configuration) Q-score estimates the size of combinatorial optimization problems a given number of qubits can execute with meaningful results. QScoreConfiguration (*,\u00a0benchmark,\u00a0shots,\u00a0...) Q-score configuration. Inheritance previous iqm.benchmarks.optimization next iqm.benchmarks.optimization.qscore.calculate_optimal_angles_for_QAOA_p1 By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.compressive_gst.gst_analysis",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.compressive_gst.gst_analysis.html",
    "description": "Data analysis code for compressive gate set tomography Functions bootstrap_errors (dataset,\u00a0y,\u00a0K,\u00a0X,\u00a0E,\u00a0rho,\u00a0...) Resamples circuit outcomes a number of times and computes GST estimates for each repet...",
    "content": "Data analysis code for compressive gate set tomography Functions bootstrap_errors (dataset,\u00a0y,\u00a0K,\u00a0X,\u00a0E,\u00a0rho,\u00a0...) Resamples circuit outcomes a number of times and computes GST estimates for each repetition All results are then returned in order to compute bootstrap-error bars for GST estimates. dataframe_to_figure (df[,\u00a0row_labels,\u00a0...]) Turns a pandas DataFrame into a figure This is needed to conform with the standard file saving routine of QCVV. dataset_counts_to_mgst_format (dataset,\u00a0...) Turns the dictionary of outcomes obtained from qiskit backend generate_basis_labels (pdim[,\u00a0basis]) Generate a list of labels for the Pauli basis or the standard basis generate_gate_results (dataset,\u00a0qubit_layout,\u00a0...) Produces all result tables for arbitrary Kraus rank estimates and turns them into figures. generate_non_gate_results (dataset,\u00a0...) Creates error bars (if bootstrapping was used) and formats results for non-gate errors. generate_unit_rank_gate_results (dataset,\u00a0...) Produces all result tables for Kraus rank 1 estimates and turns them into figures. mgst_analysis (run) Analysis function for compressive GST pandas_results_to_observations (dataset,\u00a0...) Converts high level GST results from a pandas Dataframe to a simple observation dictionary result_str_to_floats (result_str,\u00a0err) Converts formated string results from mgst to float (value, uncertainty) pairs run_mGST_wrapper (dataset,\u00a0y) Wrapper function for mGST algorithm execution which prepares an initialization and sets the alg. previous iqm.benchmarks.compressive_gst.compressive_gst.GSTConfiguration next iqm.benchmarks.compressive_gst.gst_analysis.bootstrap_errors By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.readout_mitigation.M3IQM",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.readout_mitigation.M3IQM.html",
    "description": "Bases: M3Mitigation M3 readout mitigation class modified to work with IQM devices. Methods _grab_additional_cals (qubits[,\u00a0shots,\u00a0...]) Grab missing calibration data from backend. cals_from_system ([q...",
    "content": "Bases: M3Mitigation M3 readout mitigation class modified to work with IQM devices. Methods _grab_additional_cals (qubits[,\u00a0shots,\u00a0...]) Grab missing calibration data from backend. cals_from_system ([qubits,\u00a0shots,\u00a0method,\u00a0...]) Grab calibration data from system. Grab calibration data from system. qubits ( array_like ) \u2013 Qubits over which to correct calibration data. Default is all. shots ( int ) \u2013 Number of shots per circuit. min(1e4, max_shots). method ( str ) \u2013 Type of calibration, \u2018balanced\u2019 (default for hardware),\n\u2018independent\u2019 (default for simulators), or \u2018marginal\u2019. initial_reset ( bool ) \u2013 Use resets at beginning of calibration circuits, default=False. rep_delay ( float ) \u2013 Delay between circuits on IBM Quantum backends. cals_file ( str ) \u2013 Output path to write JSON calibration data to. async_cal ( bool ) \u2013 Do calibration async in a separate thread, default is False. M3Error \u2013 Called while a calibration currently in progress. previous iqm.benchmarks.readout_mitigation.readout_error_m3 next iqm.benchmarks.utils By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils_plots",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils_plots.html",
    "description": "Plotting and visualization utility functions Functions draw_graph_edges (backend_coupling_map,\u00a0...) Draw given edges on a graph within the given backend. evaluate_hamiltonian_paths (N,\u00a0path_samples,\u00a0....",
    "content": "Plotting and visualization utility functions Functions draw_graph_edges (backend_coupling_map,\u00a0...) Draw given edges on a graph within the given backend. evaluate_hamiltonian_paths (N,\u00a0path_samples,\u00a0...) Evaluates Hamiltonian paths according to the product of 2Q gate fidelities on the corresponding edges of the backend graph. plot_layout_fidelity_graph (cal_url[,\u00a0...]) Plot a graph showing the quantum chip layout with fidelity information. rx_to_nx_graph (backend_coupling_map) Convert the Rustworkx graph returned by a backend to a Networkx graph. Classes GraphPositions () A class to store and generate graph positions for different chip layouts. Inheritance previous iqm.benchmarks.utils.xrvariable_to_counts next iqm.benchmarks.utils_plots.draw_graph_edges By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.get_iqm_backend",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.get_iqm_backend.html",
    "description": "Get the IQM backend object from a backend name (str). backend_label ( str ) \u2013 The name of the IQM backend. IQMBackendBase. IQMBackendBase previous iqm.benchmarks.utils.get_active_qubits next iqm.bench...",
    "content": "Get the IQM backend object from a backend name (str). backend_label ( str ) \u2013 The name of the IQM backend. IQMBackendBase. IQMBackendBase previous iqm.benchmarks.utils.get_active_qubits next iqm.benchmarks.utils.get_measurement_mapping By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.get_neighbors_of_edges",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.get_neighbors_of_edges.html",
    "description": "Given a Sequence of edges and a graph, return all neighboring nodes of the edges. edges ( Sequence [ Sequence [ int ] ] ) \u2013 A sequence of pairs of integers, representing edges of a graph. graph ( Sequ...",
    "content": "Given a Sequence of edges and a graph, return all neighboring nodes of the edges. edges ( Sequence [ Sequence [ int ] ] ) \u2013 A sequence of pairs of integers, representing edges of a graph. graph ( Sequence [ Sequence [ int ] ] ) \u2013 The input graph specified as a sequence of edges (Sequence[int]). list of all neighboring nodes of the input edges. Sequence[ int ] previous iqm.benchmarks.utils.get_measurement_mapping next iqm.benchmarks.utils.get_tomography_matrix By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.ghz.fidelity_analysis",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.ghz.fidelity_analysis.html",
    "description": "Analyze counts and compute the state fidelity run ( BenchmarkRunResult ) \u2013 RunResult\nThe RunResult object containing a dataset with counts and benchmark parameters AnalysisResult An object containing ...",
    "content": "Analyze counts and compute the state fidelity run ( BenchmarkRunResult ) \u2013 RunResult\nThe RunResult object containing a dataset with counts and benchmark parameters AnalysisResult An object containing the dataset, plots, and observations An object containing the dataset, plots, and observations BenchmarkAnalysisResult previous iqm.benchmarks.entanglement.ghz next iqm.benchmarks.entanglement.ghz.fidelity_ghz_coherences By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils_shadows.get_local_shadow",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils_shadows.get_local_shadow.html",
    "description": "Constructs shadows for each individual initialisation. counts ( Dict [ str , int ] ) \u2013 a dictionary of bit-string counts. unitary_arg ( np.ndarray | Sequence [ str ] ) \u2013 local random unitaries used fo...",
    "content": "Constructs shadows for each individual initialisation. counts ( Dict [ str , int ] ) \u2013 a dictionary of bit-string counts. unitary_arg ( np.ndarray | Sequence [ str ] ) \u2013 local random unitaries used for a given initialisation, either specified as\n- a numpy array, or\n- a Sequence of Clifford labels. subsystem_bit_indices ( Sequence [ int ] ) \u2013 Bit indices in the counts of the subsystem to construct the shadow of. clifford_or_haar ( Literal [ \"clifford\" , \"haar\" ] ) \u2013 Whether to use Clifford or Haar random 1Q gates.\n* Default is \u201cclifford\u201d. cliffords_1q ( Optional [ Dict [ str , QuantumCircuit ] ] ) \u2013 dictionary of 1-qubit Cliffords in terms of IQM-native r and CZ gates\n* Default is None. shadow of considered subsystem. np.ndarray previous iqm.benchmarks.utils_shadows.CUE next iqm.benchmarks.utils_shadows.get_negativity By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.ghz.GHZConfiguration",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.ghz.GHZConfiguration.html",
    "description": "Bases: BenchmarkConfigurationBase GHZ state configuration benchmark ( Type [ Benchmark ] ) \u2013 shots ( int ) \u2013 max_gates_per_batch ( int | None ) \u2013 max_circuits_per_batch ( int | None ) \u2013 calset_id ( st...",
    "content": "Bases: BenchmarkConfigurationBase GHZ state configuration benchmark ( Type [ Benchmark ] ) \u2013 shots ( int ) \u2013 max_gates_per_batch ( int | None ) \u2013 max_circuits_per_batch ( int | None ) \u2013 calset_id ( str | None ) \u2013 routing_method ( Literal [ 'basic' , 'lookahead' , 'stochastic' , 'sabre' , 'none' ] ) \u2013 physical_layout ( Literal [ 'fixed' , 'batching' ] ) \u2013 use_dd ( bool | None ) \u2013 dd_strategy ( DDStrategy | None ) \u2013 state_generation_routine ( str ) \u2013 custom_qubits_array ( Sequence [ Sequence [ int ] ] | None ) \u2013 qubit_counts ( Sequence [ int ] | None ) \u2013 qiskit_optim_level ( int ) \u2013 optimize_sqg ( bool ) \u2013 fidelity_routine ( str ) \u2013 num_RMs ( int | None ) \u2013 rem ( bool ) \u2013 mit_shots ( int ) \u2013 cal_url ( str | None ) \u2013 GHZBenchmark Type[ Benchmark ] The routine to construct circuits generating a GHZ state. Possible values:\n- \u201ctree\u201d (default): Optimized GHZ state generation circuit in log depth that\ntakes the qubit coupling and CZ fidelities into account. The algorithm creates\na minimal spanning tree for the qubit layout and chooses an initial qubit\nthat minimizes largest weighted distance to all other qubits.\n- \u201clog\u201d: Optimized circuit with parallel application of CX gates such that the\nnumber of CX gates scales logarithmically in the system size. This\nimplementation currently does not take connectivity on the backend into account.\n- \u201cnaive\u201d: Applies the naive textbook circuit with #CX gates scaling linearly in\nthe system size.\n* If other is specified, assumes \u201clog\u201d. str A sequence (e.g., Tuple or List) of sequences of Optional[Sequence[Sequence[ int ]]] If None, takes all qubits specified in the backend coupling map. CURRENTLY NOT SUPPORTED, A sequence (e.g., Tuple or List) of integers Optional[Sequence[ int ]] The optimization level used for transpilation to backend architecture.\n* Default: 3 int Whether consecutive single qubit gates are optimized for reduced gate count via bool Default: True The method with which the fidelity is estimated. Possible values:\n- \u201ccoherences\u201d: The multiple quantum coherences method as in [Mooney, 2021]\n- \u201crandomized_measurements\u201d: Fidelity estimation via randomized measurements outlined in https://arxiv.org/abs/1812.02624 * Default is \u201ccoherences\u201d str The number of randomized measurements used if the respective fidelity routine is chosen\n* Default: 100 Optional[ int ] Boolean flag determining if readout error mitigation is used\n* Default: True bool Total number of shots for readout error mitigation\n* Default: 1000 int Optional URL where the calibration data for the selected backend can be retrieved from\nThe calibration data is used for the \u201ctree\u201d state generation routine to prioritize couplings with high\nCZ fidelity.\n* Default: None Optional[ str ] Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. benchmark  state_generation_routine  custom_qubits_array  qubit_counts  shots  qiskit_optim_level  optimize_sqg  fidelity_routine  num_RMs  rem  mit_shots  cal_url  max_gates_per_batch  max_circuits_per_batch  calset_id  routing_method  physical_layout  use_dd  dd_strategy  Methods Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.benchmarks.entanglement.ghz.GHZBenchmark next iqm.benchmarks.entanglement.graph_states By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.compressive_gst.gst_analysis.generate_gate_results",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.compressive_gst.gst_analysis.generate_gate_results.html",
    "description": "Produces all result tables for arbitrary Kraus rank estimates and turns them into figures. df_g ( DataFrame ) \u2013 Pandas DataFrame\nThe dataframe with properly formated results X_opt ( ndarray ) \u2013 3D num...",
    "content": "Produces all result tables for arbitrary Kraus rank estimates and turns them into figures. df_g ( DataFrame ) \u2013 Pandas DataFrame\nThe dataframe with properly formated results X_opt ( ndarray ) \u2013 3D numpy array\nThe gate set after gauge optimization E_opt ( ndarray ) \u2013 3D numpy array\nAn array containg all the POVM elements as matrices after gauge optimization rho_opt ( ndarray ) \u2013 2D numpy array\nThe density matrix after gauge optmization max_evals ( int ) \u2013 int\nThe maximum number of eigenvalues of the Choi matrices which are returned. dataset ( Dataset ) \u2013 qubit_layout ( List [ int ] ) \u2013 Pandas DataFrame The dataframe with properly formated results of standard gate errors df_g_evals_final Pandas DataFrame A dataframe containing eigenvalues of the Choi matrices for all gates fig_g: Figure A table in Figure format of gate results (fidelities etc.) fig_choi: Figure A table in Figure format of eigenvalues of the Choi matrices of all gates The dataframe with properly formated results of standard gate errors A dataframe containing eigenvalues of the Choi matrices for all gates A table in Figure format of gate results (fidelities etc.) A table in Figure format of eigenvalues of the Choi matrices of all gates df_g_final previous iqm.benchmarks.compressive_gst.gst_analysis.generate_basis_labels next iqm.benchmarks.compressive_gst.gst_analysis.generate_non_gate_results By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.compressive_gst.compressive_gst",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.compressive_gst.compressive_gst.html",
    "description": "Compressive gate set tomography Generation of circuits to measure Running of said circuits on the backend Conversion of the ideal gate set into numpy arrays to be processed by mGST Optional generation...",
    "content": "Compressive gate set tomography Generation of circuits to measure Running of said circuits on the backend Conversion of the ideal gate set into numpy arrays to be processed by mGST Optional generation of an initialization for mGST Running mGST to get first gate set estimates Gauge optimization to the target gates using pyGSTi\u2019s gauge optimizer Optional rerun of mGST on bootstrap data to produce error bars Generation of error measures and result tables Generation of matrix plots for the reconstructed gate set Functions create_predefined_gate_set (gate_set,\u00a0...) Create a list of quantum circuits corresponding to a predefined gate set. parse_gate_set (configuration,\u00a0num_qubits,\u00a0...) Handles different gate set inputs and produces a valid gate set parse_layouts (qubit_layouts) Checks for correct setting of qubit_layouts in the configuration and return a correct type Classes CompressiveGST (backend,\u00a0configuration) SPAM-robust characterization of a set of quantum gates GSTConfiguration (*,\u00a0benchmark,\u00a0shots,\u00a0...) Compressive GST configuration base. Inheritance previous iqm.benchmarks.compressive_gst next iqm.benchmarks.compressive_gst.compressive_gst.create_predefined_gate_set By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.quantum_volume.clops",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.quantum_volume.clops.html",
    "description": "CLOPS benchmark Functions clops_analysis (run) Analysis function for a CLOPS (v or h) experiment plot_times (clops_data,\u00a0observations) Generate a figure representing the different elapsed times in the...",
    "content": "CLOPS benchmark Functions clops_analysis (run) Analysis function for a CLOPS (v or h) experiment plot_times (clops_data,\u00a0observations) Generate a figure representing the different elapsed times in the CLOPS experiment. retrieve_clops_elapsed_times (job_meta) Retrieve the elapsed times from the CLOPS job metadata Classes CLOPSBenchmark (backend_arg,\u00a0configuration) CLOPS reflect the speed of execution of parametrized QV circuits. CLOPSConfiguration (*,\u00a0benchmark,\u00a0shots,\u00a0...) CLOPS configuration. Inheritance previous iqm.benchmarks.quantum_volume next iqm.benchmarks.quantum_volume.clops.clops_analysis By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.compressive_gst.gst_analysis.generate_basis_labels",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.compressive_gst.gst_analysis.generate_basis_labels.html",
    "description": "Generate a list of labels for the Pauli basis or the standard basis pdim ( int ) \u2013 int\nPhysical dimension basis ( str | None ) \u2013 str\nWhich basis the labels correspond to, currently default is standard...",
    "content": "Generate a list of labels for the Pauli basis or the standard basis pdim ( int ) \u2013 int\nPhysical dimension basis ( str | None ) \u2013 str\nWhich basis the labels correspond to, currently default is standard basis and \u201cPauli\u201d can be choose\nfor Pauli basis labels like \u201cII\u201d, \u201cIX\u201d, \u201cXX\u201d, \u2026 List[str] A list of all string combinations for the given dimension and basis A list of all string combinations for the given dimension and basis labels previous iqm.benchmarks.compressive_gst.gst_analysis.dataset_counts_to_mgst_format next iqm.benchmarks.compressive_gst.gst_analysis.generate_gate_results By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.quantum_volume.clops.CLOPSConfiguration",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.quantum_volume.clops.CLOPSConfiguration.html",
    "description": "Bases: BenchmarkConfigurationBase CLOPS configuration. benchmark ( Type [ Benchmark ] ) \u2013 shots ( int ) \u2013 max_gates_per_batch ( int | None ) \u2013 max_circuits_per_batch ( int | None ) \u2013 calset_id ( str |...",
    "content": "Bases: BenchmarkConfigurationBase CLOPS configuration. benchmark ( Type [ Benchmark ] ) \u2013 shots ( int ) \u2013 max_gates_per_batch ( int | None ) \u2013 max_circuits_per_batch ( int | None ) \u2013 calset_id ( str | None ) \u2013 routing_method ( Literal [ 'basic' , 'lookahead' , 'stochastic' , 'sabre' , 'none' ] ) \u2013 physical_layout ( Literal [ 'fixed' , 'batching' ] ) \u2013 use_dd ( bool | None ) \u2013 dd_strategy ( DDStrategy | None ) \u2013 qubits ( Sequence [ int ] ) \u2013 num_circuits ( int ) \u2013 num_updates ( int ) \u2013 num_shots ( int ) \u2013 clops_h_bool ( bool ) \u2013 qiskit_optim_level ( int ) \u2013 optimize_sqg ( bool ) \u2013 CLOPS Benchmark. Type[ Benchmark ] The Sequence (List or Tuple) of physical qubit labels in which to run the benchmark.\n* The physical qubit layout should correspond to the one used to establish QV. Sequence[ int ] The number of parametrized circuit layouts.\n* By definition of arXiv:2110.14108 [quant-ph] set to 100. int The number of parameter assignment updates per circuit layout to perform.\n* By definition of arXiv:2110.14108 [quant-ph] set to 10. int The number of measurement shots per circuit to perform.\n* By definition of arXiv:2110.14108 [quant-ph] set to 100. int Whether a CLOPS value with layer definition of CLOPS_H is estimated.\n* Default is False\n* This will not estimate a rigorous CLOPS_H value (as loosely defined in www.ibm.com/quantum/blog/quantum-metric-layer-fidelity) bool The Qiskit transpilation optimization level.\n* The optimization level should correspond to the one used to establish QV.\n* Default is 3. int Whether Single Qubit Gate Optimization is performed upon transpilation.\n* The optimize_sqg value should correspond to the one used to establish QV.\n* Default is True bool The Qiskit transpilation routing method to use.\n* The routing_method value should correspond to the one used to establish QV.\n* Default is \u201csabre\u201d. Literal[\u201cbasic\u201d, \u201clookahead\u201d, \u201cstochastic\u201d, \u201csabre\u201d, \u201cnone\u201d] Whether the coupling map is restricted to qubits in the input layout or not.\n- \u201cfixed\u201d: Restricts the coupling map to only the specified qubits.\n- \u201cbatching\u201d: Considers the full coupling map of the backend and circuit execution is batched per final layout.\n* Default is \u201cfixed\u201d. Literal[\u201cfixed\u201d, \u201cbatching\u201d] Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. benchmark  qubits  num_circuits  num_updates  num_shots  clops_h_bool  qiskit_optim_level  optimize_sqg  shots  max_gates_per_batch  max_circuits_per_batch  calset_id  routing_method  physical_layout  use_dd  dd_strategy  Methods Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.benchmarks.quantum_volume.clops.CLOPSBenchmark next iqm.benchmarks.quantum_volume.quantum_volume By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.optimization.qscore.QScoreBenchmark",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.optimization.qscore.QScoreBenchmark.html",
    "description": "Bases: Benchmark Q-score estimates the size of combinatorial optimization problems a given number of qubits can execute with meaningful results. Attributes name  Methods add_all_meta_to_dataset (datas...",
    "content": "Bases: Benchmark Q-score estimates the size of combinatorial optimization problems a given number of qubits can execute with meaningful results. Attributes name  Methods add_all_meta_to_dataset (dataset) Adds all configuration metadata and circuits to the dataset variable analysis_function (run) Analysis function for a QScore experiment choose_qubits_custom (num_qubits) Choose the qubits to execute the circuits on, according to elements in custom_qubits_array matching num_qubits number of qubits choose_qubits_naive (num_qubits) Choose the qubits to execute the circuits on, sequentially starting at qubit 0. execute (backend) Executes the benchmark. generate_maxcut_ansatz (graph,\u00a0theta) Generate an ansatz circuit for QAOA MaxCut, with measurements at the end. backend_arg ( IQMBackendBase ) \u2013 configuration ( QScoreConfiguration ) \u2013 Analysis function for a QScore experiment run ( RunResult ) \u2013 A QScore experiment run for which analysis result is created AnalysisResult corresponding to QScore BenchmarkAnalysisResult Generate an ansatz circuit for QAOA MaxCut, with measurements at the end. graph ( networkx graph ) \u2013 the MaxCut problem graph theta ( list [ float ] ) \u2013 the variational parameters for QAOA, first gammas then betas the QAOA ansatz quantum circuit. QuantumCircuit Adds all configuration metadata and circuits to the dataset variable dataset ( xr.Dataset ) \u2013 The xarray dataset Choose the qubits to execute the circuits on, sequentially starting at qubit 0. num_qubits ( int ) \u2013 the number of qubits to choose. the list of qubits to execute the circuits on. list [ int ] Choose the qubits to execute the circuits on, according to elements in custom_qubits_array matching num_qubits number of qubits num_qubits ( int ) \u2013 the number of qubits to choose the list of qubits to execute the circuits on list [ int ] Executes the benchmark. backend ( IQMBackendBase ) \u2013 Dataset previous iqm.benchmarks.optimization.qscore.run_QAOA next iqm.benchmarks.optimization.qscore.QScoreConfiguration By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.perform_backend_transpilation",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.perform_backend_transpilation.html",
    "description": "Transpile a list of circuits to backend specifications. qc_list ( List [ QuantumCircuit ] ) \u2013 The original (untranspiled) list of quantum circuits. backend ( IQMBackendBase ) \u2013 The backend to execute ...",
    "content": "Transpile a list of circuits to backend specifications. qc_list ( List [ QuantumCircuit ] ) \u2013 The original (untranspiled) list of quantum circuits. backend ( IQMBackendBase ) \u2013 The backend to execute the benchmark on. qubits ( Sequence [ int ] ) \u2013 The qubits to target in the transpilation. coupling_map ( List [ List [ int ] ] ) \u2013 The target coupling map to transpile to. basis_gates ( Tuple [ str , ... ] ) \u2013 The basis gates. qiskit_optim_level ( int ) \u2013 Qiskit \u201coptimization_level\u201d value. optimize_sqg ( bool ) \u2013 Whether SQG optimization is performed taking into account virtual Z. drop_final_rz ( bool ) \u2013 Whether the SQG optimizer drops a final RZ gate. routing_method ( Optional [ str ] ) \u2013 The routing method employed by Qiskit\u2019s transpilation pass. A list of transpiled quantum circuits. List[QuantumCircuit] ValueError \u2013 if Star topology and label 0 is in qubit layout. previous iqm.benchmarks.utils.median_with_uncertainty next iqm.benchmarks.utils.random_hamiltonian_path By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.circuit_containers",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.circuit_containers.html",
    "description": "This module contains classes to easily interact with quantum circuits Classes BenchmarkCircuit (name,\u00a0circuit_groups) A class grouping a list of CircuitGroup into a single purpose. CircuitGroup (circu...",
    "content": "This module contains classes to easily interact with quantum circuits Classes BenchmarkCircuit (name,\u00a0circuit_groups) A class grouping a list of CircuitGroup into a single purpose. CircuitGroup (circuits,\u00a0name) Group of IQMCircuits . Circuits (benchmark_circuits) Container for all the BenchmarkCircuit that are generated in a single benchmark execution. Inheritance previous iqm.benchmarks.benchmark_definition.BenchmarkRunResult next iqm.benchmarks.circuit_containers.BenchmarkCircuit By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.quantum_volume.quantum_volume",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.quantum_volume.quantum_volume.html",
    "description": "Quantum Volume benchmark Functions compute_heavy_output_probabilities (...) Compute the HOP of all quantum circuits. cumulative_hop (hops) Computes the cumulative average heavy output probabilities of...",
    "content": "Quantum Volume benchmark Functions compute_heavy_output_probabilities (...) Compute the HOP of all quantum circuits. cumulative_hop (hops) Computes the cumulative average heavy output probabilities of a QV experiment. cumulative_std (hops) Computes the cumulative standard deviation heavy output probabilities of a QV experiment. get_ideal_heavy_outputs (qc_list,\u00a0...) Calculate the heavy output bitrstrings of a list of quantum circuits. get_rem_hops (all_rem_quasidistro,\u00a0...) Computes readout-error-mitigated heavy output probabilities. heavy_projector (probabilities) Project (select) the samples from a given probability distribution onto heavy outputs. is_successful (heavy_output_probabilities[,\u00a0...]) Check whether a QV benchmark returned heavy output results over the threshold, therefore being successful. plot_hop_threshold (qubits,\u00a0depth,\u00a0qv_result,\u00a0...) Generate the figure representing each HOP, the average and the threshold. qv_analysis (run) Analysis function for a Quantum Volume experiment Classes QuantumVolumeBenchmark (backend_arg,\u00a0...) Quantum Volume reflects the deepest circuit a given number of qubits can execute with meaningful results. QuantumVolumeConfiguration (*,\u00a0benchmark,\u00a0...) Quantum Volume configuration. Inheritance previous iqm.benchmarks.quantum_volume.clops.CLOPSConfiguration next iqm.benchmarks.quantum_volume.quantum_volume.compute_heavy_output_probabilities By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.bootstrap_counts",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.bootstrap_counts.html",
    "description": "Returns num_bootstrap_samples resampled copies of the original_counts. original_counts ( Dict [ str , int ] ) \u2013 The original dictionary of counts to bootstrap from. num_bootstrap_samples ( int ) \u2013 The...",
    "content": "Returns num_bootstrap_samples resampled copies of the original_counts. original_counts ( Dict [ str , int ] ) \u2013 The original dictionary of counts to bootstrap from. num_bootstrap_samples ( int ) \u2013 The number of bootstrapping samples to generate.\n* Default is 100. rgen ( Optional [ Generator ] ) \u2013 The random number generator.\n* Default is None: assigns numpy\u2019s default_rng(). include_original_counts ( bool ) \u2013 Whether to include the original counts in the returned bootstrapped count samples.\n* Default is False. A list of bootstrapped counts. List[Dict[ str , int ]] previous iqm.benchmarks.utils next iqm.benchmarks.utils.count_2q_layers By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.multi_lmfit",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.multi_lmfit.html",
    "description": "Lmfit for multiple datasets, generalized and extended version of the shown example in the lmfit documentation: https://lmfit.github.io/lmfit-py/examples/example_fit_multi_datasets.html#sphx-glr-exampl...",
    "content": "Lmfit for multiple datasets, generalized and extended version of the shown example in the lmfit documentation: https://lmfit.github.io/lmfit-py/examples/example_fit_multi_datasets.html#sphx-glr-examples-example-fit-multi-datasets-py Functions create_multi_dataset_params (func,\u00a0data[,\u00a0...]) Generates lmfit Parameter object with parameters for each line to fit eval_func_single_dataset (func,\u00a0params,\u00a0i,\u00a0x) Returns the evaluation of the fit function for a single dataset get_param_names_from_func_signature (func) Gets the function parameter names from its signature multi_dataset_residual (params,\u00a0x,\u00a0data,\u00a0func) Calculate total residual for fits of func to several data sets. previous iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.MirrorRandomizedBenchmarking next iqm.benchmarks.randomized_benchmarking.multi_lmfit.create_multi_dataset_params By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.quantum_volume.quantum_volume.cumulative_hop",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.quantum_volume.quantum_volume.cumulative_hop.html",
    "description": "Computes the cumulative average heavy output probabilities of a QV experiment.\n:param hops: The individual heavy output probabilities for each trial.\n:type hops: List[float] cumulative average heavy o...",
    "content": "Computes the cumulative average heavy output probabilities of a QV experiment.\n:param hops: The individual heavy output probabilities for each trial.\n:type hops: List[float] cumulative average heavy output probabilities for all trials. List[ float ] hops ( List [ float ] ) \u2013 previous iqm.benchmarks.quantum_volume.quantum_volume.compute_heavy_output_probabilities next iqm.benchmarks.quantum_volume.quantum_volume.cumulative_std By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.direct_rb.direct_rb.direct_rb_analysis",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.direct_rb.direct_rb.direct_rb_analysis.html",
    "description": "Direct RB analysis function run ( BenchmarkRunResult ) \u2013 The result of the benchmark run. AnalysisResult corresponding to DRB. BenchmarkAnalysisResult previous iqm.benchmarks.randomized_benchmarking.d...",
    "content": "Direct RB analysis function run ( BenchmarkRunResult ) \u2013 The result of the benchmark run. AnalysisResult corresponding to DRB. BenchmarkAnalysisResult previous iqm.benchmarks.randomized_benchmarking.direct_rb.direct_rb next iqm.benchmarks.randomized_benchmarking.direct_rb.direct_rb.generate_drb_circuits By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.retrieve_all_counts",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.retrieve_all_counts.html",
    "description": "Retrieve the counts from a list of IQMJob objects.\n:param iqm_jobs: The list of IQMJob objects.\n:type iqm_jobs: List[IQMJob]\n:param identifier: a string identifying the job.\n:type identifier: Optional...",
    "content": "Retrieve the counts from a list of IQMJob objects.\n:param iqm_jobs: The list of IQMJob objects.\n:type iqm_jobs: List[IQMJob]\n:param identifier: a string identifying the job.\n:type identifier: Optional[str] The counts of all the IQMJob objects. List[Dict[ str , int ]] iqm_jobs ( List [ IQMJob ] ) \u2013 identifier ( str | None ) \u2013 previous iqm.benchmarks.utils.remove_directed_duplicates_to_list next iqm.benchmarks.utils.retrieve_all_job_metadata By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.compute_inverse_clifford",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.compute_inverse_clifford.html",
    "description": "Function to compute the inverse Clifford of a circuit\n:param qc_inv: The Clifford circuit to be inverted\n:type qc_inv: QuantumCircuit\n:param clifford_dictionary: A dictionary of Clifford gates labeled...",
    "content": "Function to compute the inverse Clifford of a circuit\n:param qc_inv: The Clifford circuit to be inverted\n:type qc_inv: QuantumCircuit\n:param clifford_dictionary: A dictionary of Clifford gates labeled by (de)stabilizers\n:type clifford_dictionary: Dict A Clifford circuit Optional[QuantumCircuit] qc_inv ( IQMCircuit ) \u2013 clifford_dictionary ( Dict ) \u2013 previous iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common next iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.edge_grab By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.generate_all_rb_circuits",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.generate_all_rb_circuits.html",
    "description": "qubits ( List [ int ] ) \u2013 List of qubits sequence_lengths ( List [ int ] ) \u2013 List of sequence lengths clifford_dict ( Dict [ str , QuantumCircuit ] ) \u2013 the dictionary of Clifford circuits num_circuit_...",
    "content": "qubits ( List [ int ] ) \u2013 List of qubits sequence_lengths ( List [ int ] ) \u2013 List of sequence lengths clifford_dict ( Dict [ str , QuantumCircuit ] ) \u2013 the dictionary of Clifford circuits num_circuit_samples ( int ) \u2013 the number of circuits samples backend_arg ( str | IQMBackendBase ) \u2013 the backend fir which to generate the circuits. interleaved_gate ( str ) \u2013 the name of the interleaved gate Tuple of untranspiled and transpiled circuits for all class-defined sequence lengths Tuple [ Dict [ int , List [ IQMCircuit ]], Dict [ int , List [ IQMCircuit ]]] previous iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.fit_decay_lmfit next iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.generate_fixed_depth_parallel_rb_circuits By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.compressive_gst.compressive_gst.CompressiveGST",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.compressive_gst.compressive_gst.CompressiveGST.html",
    "description": "Bases: Benchmark SPAM-robust characterization of a set of quantum gates Attributes name  Methods add_configuration_to_dataset (dataset) Creates an xarray.Dataset and adds the circuits and configuratio...",
    "content": "Bases: Benchmark SPAM-robust characterization of a set of quantum gates Attributes name  Methods add_configuration_to_dataset (dataset) Creates an xarray.Dataset and adds the circuits and configuration metadata to it analysis_function (run) Analysis function for compressive GST execute (backend) The main GST execution routine generate_meas_circuits () Generate random circuits from the gate set backend ( IQMBackendBase ) \u2013 configuration ( GSTConfiguration ) \u2013 Analysis function for compressive GST run ( BenchmarkRunResult ) \u2013 BenchmarkRunResult\nA BenchmarkRunResult instance storing the dataset BenchmarkAnalysisResult An BenchmarkAnalysisResult instance with the updated dataset, as well as plots and observations An BenchmarkAnalysisResult instance with the updated dataset, as well as plots and observations result Generate random circuits from the gate set The random circuits are distributed among different depths ranging from L_MIN\nto L_MAX, both are configurable and stored in self.configuration.seq_len_list.\nNo transpilation other than mapping to the desired qubits is performed,\nas the gates need to be executed axactly as described for GST to give\nmeaningful results BenchmarkCircuit The transpiled circuits untranspiled_circuits: BenchmarkCircuit The untranspiled circuits circuit_gen_transp_time: float The time it took to generate and transpile the circuits The transpiled circuits The untranspiled circuits The time it took to generate and transpile the circuits transpiled_circuits Creates an xarray.Dataset and adds the circuits and configuration metadata to it self \u2013 Source class xarray.Dataset to be used for further data storage dataset The main GST execution routine Dataset previous iqm.benchmarks.compressive_gst.compressive_gst.parse_layouts next iqm.benchmarks.compressive_gst.compressive_gst.GSTConfiguration By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.graph_states.plot_density_matrix",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.graph_states.plot_density_matrix.html",
    "description": "Plots a density matrix for corresponding qubit pairs, neighbor qubit projections, and negativities. matrix ( np.ndarray ) \u2013 The matrix to plot. qubit_pair ( Sequence [ int ] ) \u2013 The corresponding qubi...",
    "content": "Plots a density matrix for corresponding qubit pairs, neighbor qubit projections, and negativities. matrix ( np.ndarray ) \u2013 The matrix to plot. qubit_pair ( Sequence [ int ] ) \u2013 The corresponding qubit pair. projection ( str ) \u2013 The projection corresponding to the matrix to plot. negativity ( Dict [ str , float ] ) \u2013 A dictionary with keys \u201cvalue\u201d and \u201cuncertainty\u201d and values being respective negativities. backend_name ( str ) \u2013 The name of the backend for the corresponding experiment. timestamp ( str ) \u2013 The timestamp for the corresponding experiment. tomography ( Literal [ \"state_tomography\" , \"shadow_tomography\" ] ) \u2013 The type of tomography used to gather the data of the matrix to plot. num_RM_samples ( Optional [ int ] = None ) \u2013 The number of randomized measurement samples if tomography is shadow_tomography.\n* Default is None if tomography is state_tomography. num_MoMs_samples ( Optional [ int ] = None ) \u2013 The number of Median of Means used per randomized measurement if tomography is shadow_tomography.\n* Default is None if tomography is state_tomography. The figure label and the density matrix plot figure. Tuple[ str , Figure] previous iqm.benchmarks.entanglement.graph_states.negativity_analysis next iqm.benchmarks.entanglement.graph_states.plot_max_negativities By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.direct_rb.direct_rb",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.direct_rb.direct_rb.html",
    "description": "Direct Randomized Benchmarking. Functions direct_rb_analysis (run) Direct RB analysis function generate_drb_circuits (qubits,\u00a0depth,\u00a0...[,\u00a0...]) Generates lists of samples of Direct RB circuits, of st...",
    "content": "Direct Randomized Benchmarking. Functions direct_rb_analysis (run) Direct RB analysis function generate_drb_circuits (qubits,\u00a0depth,\u00a0...[,\u00a0...]) Generates lists of samples of Direct RB circuits, of structure: generate_fixed_depth_parallel_drb_circuits (...) Generates DRB circuits in parallel on multiple qubit layouts. Classes DirectRBConfiguration (*,\u00a0benchmark,\u00a0shots,\u00a0...) Direct RB configuration DirectRandomizedBenchmarking (backend_arg,\u00a0...) Direct RB estimates the fidelity of layers of canonical gates Inheritance previous iqm.benchmarks.randomized_benchmarking.direct_rb next iqm.benchmarks.randomized_benchmarking.direct_rb.direct_rb.direct_rb_analysis By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.ghz.plot_fidelities",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.ghz.plot_fidelities.html",
    "description": "Plots all the fidelities stored in the observations into a single plot of fidelity vs. number of qubits observations ( List [ BenchmarkObservation ] ) \u2013 A list of Observations, each assumed to be a fi...",
    "content": "Plots all the fidelities stored in the observations into a single plot of fidelity vs. number of qubits observations ( List [ BenchmarkObservation ] ) \u2013 A list of Observations, each assumed to be a fidelity dataset ( xr.Dataset ) \u2013 The experiment dataset containing results and metadata qubit_layouts ( List [ List [ int ] ] ) \u2013 The list of qubit layouts as given by the user. This is used to name the layouts in order for identification\nin the plot. fig \u2013 The figure object with the fidelity plot. Figure previous iqm.benchmarks.entanglement.ghz.get_edges next iqm.benchmarks.entanglement.ghz.GHZBenchmark By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.html",
    "description": "IQM\u2019s Python Library Benchmarking Suite QCVV. Subpackages and modules benchmark Generic Benchmark class benchmark_definition This module implements the base class for defining a benchmark. circuit_con...",
    "content": "IQM\u2019s Python Library Benchmarking Suite QCVV. Subpackages and modules benchmark Generic Benchmark class benchmark_definition This module implements the base class for defining a benchmark. circuit_containers This module contains classes to easily interact with quantum circuits compressive_gst Compressive GST is a self-consistent characterization method which constructs the process matrices for a set of gates, as well as full parametrizations of an initial state and a POVM. entanglement GHZ verifies the generation of Greenberger-Horne-Zeilinger states Graph State estimates the amount of bipartite entanglement of native graph states logging_config Module to initialize logger. optimization Q-score estimates the size of combinatorial optimization problems a given number of qubits can execute with meaningful results. quantum_volume Quantum Volume reflects the deepest circuit a given number of qubits can execute with meaningful results. randomized_benchmarking Randomized Benchmarking reflects the fidelity of a gate or operation on a number of qubits readout_mitigation M3 modification for readout mitigation at IQM QPU's. utils General utility functions utils_plots Plotting and visualization utility functions utils_shadows Shadow Tomography utility functions previous API Reference next iqm.benchmarks.benchmark By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.benchmark_definition.BenchmarkObservationIdentifier",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.benchmark_definition.BenchmarkObservationIdentifier.html",
    "description": "Bases: object Identifier for observations for ease of use qubit_indices ( list [ int ] ) \u2013 list containing the indices of the qubits the observation was executed on. list [ int ] Attributes string_ide...",
    "content": "Bases: object Identifier for observations for ease of use qubit_indices ( list [ int ] ) \u2013 list containing the indices of the qubits the observation was executed on. list [ int ] Attributes string_identifier String version of the qubit indices for ease of use qubit_indices  Methods __eq__ (other) Return self==value. __repr__ () Return repr(self). String version of the qubit indices for ease of use A string of the qubit indices previous iqm.benchmarks.benchmark_definition.BenchmarkObservation next iqm.benchmarks.benchmark_definition.BenchmarkRunResult By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.clifford_rb.clifford_rb.CliffordRBConfiguration",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.clifford_rb.clifford_rb.CliffordRBConfiguration.html",
    "description": "Bases: BenchmarkConfigurationBase Clifford RB configuration. benchmark ( Type [ Benchmark ] ) \u2013 shots ( int ) \u2013 max_gates_per_batch ( int | None ) \u2013 max_circuits_per_batch ( int | None ) \u2013 calset_id (...",
    "content": "Bases: BenchmarkConfigurationBase Clifford RB configuration. benchmark ( Type [ Benchmark ] ) \u2013 shots ( int ) \u2013 max_gates_per_batch ( int | None ) \u2013 max_circuits_per_batch ( int | None ) \u2013 calset_id ( str | None ) \u2013 routing_method ( Literal [ 'basic' , 'lookahead' , 'stochastic' , 'sabre' , 'none' ] ) \u2013 physical_layout ( Literal [ 'fixed' , 'batching' ] ) \u2013 use_dd ( bool | None ) \u2013 dd_strategy ( DDStrategy | None ) \u2013 qubits_array ( Sequence [ Sequence [ int ] ] ) \u2013 sequence_lengths ( Sequence [ int ] ) \u2013 num_circuit_samples ( int ) \u2013 parallel_execution ( bool ) \u2013 CliffordRandomizedBenchmarking Type[ Benchmark ] The array of qubits on which to execute the benchmark. Sequence[Sequence[ int ]] The length of Cliffords sequences with which to execute benchmark. Sequence[ int ] The number of Cliffords circuits per sequence length. int The number of measurement shots per circuit. int Whether the benchmark is executed on all qubits in parallel or not.\n* Default is False. bool Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. benchmark  qubits_array  sequence_lengths  num_circuit_samples  parallel_execution  shots  max_gates_per_batch  max_circuits_per_batch  calset_id  routing_method  physical_layout  use_dd  dd_strategy  Methods Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.benchmarks.randomized_benchmarking.clifford_rb.clifford_rb.clifford_rb_analysis next iqm.benchmarks.randomized_benchmarking.clifford_rb.clifford_rb.CliffordRandomizedBenchmarking By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.clifford_rb.clifford_rb.clifford_rb_analysis",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.clifford_rb.clifford_rb.clifford_rb_analysis.html",
    "description": "Analysis function for a Clifford RB experiment run ( RunResult ) \u2013 A Clifford RB experiment run for which analysis result is created AnalysisResult corresponding to Clifford RB BenchmarkAnalysisResult...",
    "content": "Analysis function for a Clifford RB experiment run ( RunResult ) \u2013 A Clifford RB experiment run for which analysis result is created AnalysisResult corresponding to Clifford RB BenchmarkAnalysisResult previous iqm.benchmarks.randomized_benchmarking.clifford_rb.clifford_rb next iqm.benchmarks.randomized_benchmarking.clifford_rb.clifford_rb.CliffordRBConfiguration By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.split_sequence_in_chunks",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.split_sequence_in_chunks.html",
    "description": "Split a given Sequence into chunks of a given split size, return as a List of Sequences. sequence_in ( Sequence [ Any ] ) \u2013 The input list. split_size ( int ) \u2013 The split size. A List of Sequences. Li...",
    "content": "Split a given Sequence into chunks of a given split size, return as a List of Sequences. sequence_in ( Sequence [ Any ] ) \u2013 The input list. split_size ( int ) \u2013 The split size. A List of Sequences. List[Sequence[Any]] previous iqm.benchmarks.utils.split_into_disjoint_pairs next iqm.benchmarks.utils.submit_execute By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.edge_grab",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.edge_grab.html",
    "description": "Generate a list of random layers containing single-qubit Cliffords and two-qubit gates,\nsampled according to the edge-grab algorithm (see arXiv:2204.07568 [quant-ph]). qubit_set ( List [ int ] ) \u2013 The...",
    "content": "Generate a list of random layers containing single-qubit Cliffords and two-qubit gates,\nsampled according to the edge-grab algorithm (see arXiv:2204.07568 [quant-ph]). qubit_set ( List [ int ] ) \u2013 The set of qubits of the backend. n_layers ( int ) \u2013 The number of layers. backend_arg ( IQMBackendBase | str ) \u2013 IQM backend. density_2q_gates ( float ) \u2013 The expected density of 2Q gates in a circuit formed by subsequent application of layers.\n* Default is 0.25 two_qubit_gate_ensemble ( Optional [ Dict [ str , float ] ] ) \u2013 A dictionary with keys being str specifying 2Q gates, and values being corresponding probabilities.\n* Default is None. clifford_sqg_probability ( float ) \u2013 Probability with which to uniformly sample Clifford 1Q gates.\n* Default is 1.0. sqg_gate_ensemble ( Optional [ Dict [ str , float ] ] ) \u2013 A dictionary with keys being str specifying 1Q gates, and values being corresponding probabilities.\n* Default is None. ValueError \u2013 if the probabilities in the gate ensembles do not add up to unity. the list of gate layers, in the form of quantum circuits. List[QuantumCircuit] previous iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.compute_inverse_clifford next iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.estimate_survival_probabilities By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.sort_batches_by_final_layout",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.sort_batches_by_final_layout.html",
    "description": "Sort batches of circuits according to the final measurement mapping in their corresponding backend. transpiled_circuit_list ( List [ QuantumCircuit ] ) \u2013 the list of circuits transpiled to a given bac...",
    "content": "Sort batches of circuits according to the final measurement mapping in their corresponding backend. transpiled_circuit_list ( List [ QuantumCircuit ] ) \u2013 the list of circuits transpiled to a given backend. dictionary, keys: final measured qubits, values: corresponding circuits.\nsorted_indices (Dict[Tuple, List[int]]): dictionary, keys: final measured qubits, values: corresponding circuit indices. sorted_circuits (Dict[Tuple, List[QuantumCircuit]]) previous iqm.benchmarks.utils.set_coupling_map next iqm.benchmarks.utils.split_into_disjoint_pairs By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.quantum_volume.quantum_volume.cumulative_std",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.quantum_volume.quantum_volume.cumulative_std.html",
    "description": "Computes the cumulative standard deviation heavy output probabilities of a QV experiment. hops ( List [ float ] ) \u2013 The individual heavy output probabilities for each trial. cumulative standard deviat...",
    "content": "Computes the cumulative standard deviation heavy output probabilities of a QV experiment. hops ( List [ float ] ) \u2013 The individual heavy output probabilities for each trial. cumulative standard deviation heavy output probabilities for all trials. List[ float ] previous iqm.benchmarks.quantum_volume.quantum_volume.cumulative_hop next iqm.benchmarks.quantum_volume.quantum_volume.get_ideal_heavy_outputs By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.optimization.qscore.create_objective_function",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.optimization.qscore.create_objective_function.html",
    "description": "Creates a function that maps the parameters to the parametrized circuit,\nruns it and computes the expectation value. counts ( Dict [ str , int ] ) \u2013 The dictionary of bitstring counts. graph ( network...",
    "content": "Creates a function that maps the parameters to the parametrized circuit,\nruns it and computes the expectation value. counts ( Dict [ str , int ] ) \u2013 The dictionary of bitstring counts. graph ( networkx graph ) \u2013 the MaxCut problem graph. qubit_to_node ( Dict [ int , int ] ) \u2013 mapping of qubit to nodes of the graph virtual_nodes ( List [ Tuple [ int , int ] ] ) \u2013 list of virtual nodes in the graph function that gives expectation value of the cut edges from counts sampled from the ansatz callable previous iqm.benchmarks.optimization.qscore.compute_expectation_value next iqm.benchmarks.optimization.qscore.cut_cost_function By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.ghz.GHZBenchmark",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.ghz.GHZBenchmark.html",
    "description": "Bases: Benchmark The GHZ Benchmark estimates the quality of generated Greenberger\u2013Horne\u2013Zeilinger states Attributes name  Methods add_configuration_to_dataset (dataset) Creates a xarray.Dataset and ad...",
    "content": "Bases: Benchmark The GHZ Benchmark estimates the quality of generated Greenberger\u2013Horne\u2013Zeilinger states Attributes name  Methods add_configuration_to_dataset (dataset) Creates a xarray.Dataset and adds the circuits and configuration metadata to it. analysis_function (run) Analyze counts and compute the state fidelity append_rms (num_rms,\u00a0qubit_layout) Appends 1Q Clifford gates sampled uniformly at random to all qubits in the given circuit. execute (backend) Executes the benchmark. generate_coherence_meas_circuits (...) Takes a given GHZ circuit and outputs circuits needed to measure fidelity via mult. generate_native_ghz (qubit_layout,\u00a0...) Generate a circuit preparing a GHZ state, according to a given routine and transpiled to the native gate set and topology. generate_readout_circuit (qubit_layout,\u00a0...) A wrapper for the creation of different circuits to estimate the fidelity backend ( IQMBackendBase ) \u2013 configuration ( GHZConfiguration ) \u2013 Analyze counts and compute the state fidelity run ( BenchmarkRunResult ) \u2013 RunResult\nThe RunResult object containing a dataset with counts and benchmark parameters AnalysisResult An object containing the dataset, plots, and observations An object containing the dataset, plots, and observations BenchmarkAnalysisResult Generate a circuit preparing a GHZ state,\naccording to a given routine and transpiled to the native gate set and topology. qubit_layout ( List [ int ] ) \u2013 List[int]\nThe subset of system-qubits used in the protocol, indexed from 0 qubit_count ( int ) \u2013 int\nThe number of qubits for which a GHZ state should be created. This values should be smaller or equal to\nthe number of qubits in qubit_layout routine ( str ) \u2013 str\nThe routine to generate the GHZ circuit QuantumCircuit implementing GHZ native state CircuitGroup Takes a given GHZ circuit and outputs circuits needed to measure fidelity via mult. q. coherences method qubit_layout ( List [ int ] ) \u2013 List[int]\nThe subset of system-qubits used in the protocol, indexed from 0 qubit_count ( int ) \u2013 int\nThe number of qubits for which a GHZ state should be created. This values should be smaller or equal to\nthe number of qubits in qubit_layout List[QuantumCircuit] A list of transpiled quantum circuits to be measured A list of transpiled quantum circuits to be measured qc_list_transpiled Appends 1Q Clifford gates sampled uniformly at random to all qubits in the given circuit.\n:param num_rms: How many randomized measurement circuits are generated\n:type num_rms: int\n:param qubit_layout List[int]: The subset of system-qubits used in the protocol, indexed from 0 List[QuantumCircuit] of the original circuit with 1Q Clifford gates appended to it num_rms ( int ) \u2013 qubit_layout ( List [ int ] ) \u2013 List [ IQMCircuit ] A wrapper for the creation of different circuits to estimate the fidelity qubit_layout ( List [ int ] ) \u2013 List[int]\nThe subset of system-qubits used in the protocol, indexed from 0 qubit_count ( int ) \u2013 int\nThe number of qubits for which a GHZ state should be created. This values should be smaller or equal to\nthe number of qubits in qubit_layout List[QuantumCircuit] A list of transpiled quantum circuits to be measured A list of transpiled quantum circuits to be measured all_circuits_list Creates a xarray.Dataset and adds the circuits and configuration metadata to it. dataset ( xr.Dataset ) \u2013 dataset to be used for further data storage xr.Dataset Executes the benchmark. Dataset previous iqm.benchmarks.entanglement.ghz.plot_fidelities next iqm.benchmarks.entanglement.ghz.GHZConfiguration By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.generate_fixed_depth_parallel_rb_circuits",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.generate_fixed_depth_parallel_rb_circuits.html",
    "description": "Generates parallel RB circuits, before and after transpilation, at fixed depth qubits_array ( List [ List [ int ] ] ) \u2013 the qubits entering the quantum circuits. cliffords_1q ( Dict [ str , QuantumCir...",
    "content": "Generates parallel RB circuits, before and after transpilation, at fixed depth qubits_array ( List [ List [ int ] ] ) \u2013 the qubits entering the quantum circuits. cliffords_1q ( Dict [ str , QuantumCircuit ] ) \u2013 dictionary of 1-qubit Cliffords in terms of IQM-native r gates. cliffords_2q ( Dict [ str , QuantumCircuit ] ) \u2013 dictionary of 2-qubit Cliffords in terms of IQM-native r and CZ gates. sequence_length ( int ) \u2013 the number of random Cliffords in the circuits. num_samples ( int ) \u2013 the number of circuit samples. backend_arg ( IQMBackendBase | str ) \u2013 the backend to transpile the circuits to. interleaved_gate ( Optional [ QuantumCircuit ] ) \u2013 whether the circuits should have interleaved gates. A list of QuantumCircuits of given RB sequence length for parallel RB Tuple [ List [ IQMCircuit ], List [ IQMCircuit ]] previous iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.generate_all_rb_circuits next iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.generate_random_clifford_seq_circuits By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.ghz.fidelity_ghz_coherences",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.ghz.fidelity_ghz_coherences.html",
    "description": "Estimates the GHZ state fidelity based on the multiple quantum coherences method based on [Mooney, 2021] dataset ( Dataset ) \u2013 xr.Dataset\nAn xarray dataset containing the measurement data qubit_layout...",
    "content": "Estimates the GHZ state fidelity based on the multiple quantum coherences method based on [Mooney, 2021] dataset ( Dataset ) \u2013 xr.Dataset\nAn xarray dataset containing the measurement data qubit_layout ( List [ int ] ) \u2013 List[int]\nThe subset of system-qubits used in the protocol circuits ( Circuits ) \u2013 Circuits\nInstance of Circuits containing transpiled circuits The ghz fidelity or, if rem=True, fidelity and readout error mitigated fidelity dict [ str , dict [ str , Any]] previous iqm.benchmarks.entanglement.ghz.fidelity_analysis next iqm.benchmarks.entanglement.ghz.fidelity_ghz_randomized_measurements By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.graph_states.generate_graph_state",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.graph_states.generate_graph_state.html",
    "description": "Generates a circuit with minimal depth preparing a native graph state for a given backend using given qubits. qubits ( Sequence [ int ] ) \u2013 A list of integers representing the qubits. backend ( IQMBac...",
    "content": "Generates a circuit with minimal depth preparing a native graph state for a given backend using given qubits. qubits ( Sequence [ int ] ) \u2013 A list of integers representing the qubits. backend ( IQMBackendBase ) \u2013 The backend to target the graph state generating circuit. The circuit generating a graph state in the target backend. QuantumCircuit previous iqm.benchmarks.entanglement.graph_states.find_edges_with_disjoint_neighbors next iqm.benchmarks.entanglement.graph_states.generate_minimal_edge_layers By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.get_active_qubits",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.get_active_qubits.html",
    "description": "Extract active qubits from a quantum circuit. qc ( QuantumCircuit ) \u2013 The quantum circuit to extract active qubits from. A list of active qubits. List[ int ] previous iqm.benchmarks.utils.get_Pauli_ex...",
    "content": "Extract active qubits from a quantum circuit. qc ( QuantumCircuit ) \u2013 The quantum circuit to extract active qubits from. A list of active qubits. List[ int ] previous iqm.benchmarks.utils.get_Pauli_expectation next iqm.benchmarks.utils.get_iqm_backend By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.validate_rb_qubits",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.validate_rb_qubits.html",
    "description": "Validate qubit inputs for a Clifford RB experiment\n:param qubits_array: the array of qubits\n:type qubits_array: List[List[int]]\n:param backend_arg: the IQM backend\n:type backend_arg: IQMBackendBase Va...",
    "content": "Validate qubit inputs for a Clifford RB experiment\n:param qubits_array: the array of qubits\n:type qubits_array: List[List[int]]\n:param backend_arg: the IQM backend\n:type backend_arg: IQMBackendBase ValueError if specified pairs of qubits are not connected \u2013 qubits_array ( List [ List [ int ] ] ) \u2013 backend_arg ( str | IQMBackendBase ) \u2013 previous iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.validate_irb_gate next iqm.benchmarks.readout_mitigation By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.quantum_volume.quantum_volume.QuantumVolumeConfiguration",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.quantum_volume.quantum_volume.QuantumVolumeConfiguration.html",
    "description": "Bases: BenchmarkConfigurationBase Quantum Volume configuration. benchmark ( Type [ Benchmark ] ) \u2013 shots ( int ) \u2013 max_gates_per_batch ( int | None ) \u2013 max_circuits_per_batch ( int | None ) \u2013 calset_i...",
    "content": "Bases: BenchmarkConfigurationBase Quantum Volume configuration. benchmark ( Type [ Benchmark ] ) \u2013 shots ( int ) \u2013 max_gates_per_batch ( int | None ) \u2013 max_circuits_per_batch ( int | None ) \u2013 calset_id ( str | None ) \u2013 routing_method ( Literal [ 'basic' , 'lookahead' , 'stochastic' , 'sabre' , 'none' ] ) \u2013 physical_layout ( Literal [ 'fixed' , 'batching' ] ) \u2013 use_dd ( bool | None ) \u2013 dd_strategy ( DDStrategy | None ) \u2013 num_circuits ( int ) \u2013 num_sigmas ( int ) \u2013 choose_qubits_routine ( Literal [ 'custom' ] ) \u2013 custom_qubits_array ( Sequence [ Sequence [ int ] ] ) \u2013 qiskit_optim_level ( int ) \u2013 optimize_sqg ( bool ) \u2013 rem ( bool ) \u2013 mit_shots ( int ) \u2013 QuantumVolumeBenchmark Type[ Benchmark ] The number of circuits to use.\n* Should be at least 100 for a meaningful QV experiment. int The number of sample standard deviations to consider with for the threshold criteria.\n* Default by consensus is 2 int The routine to select qubit layouts.\n* Default is \u201ccustom\u201d. Literal[\u201ccustom\u201d] The physical qubit layouts to perform the benchmark on.\n* Default is [[0, 2]]. Optional[Sequence[Sequence[ int ]]] The Qiskit transpilation optimization level.\n* Default is 3. int Whether Single Qubit Gate Optimization is performed upon transpilation.\n* Default is True. bool The Qiskit transpilation routing method to use.\n* Default is \u201csabre\u201d. Literal[\u201cbasic\u201d, \u201clookahead\u201d, \u201cstochastic\u201d, \u201csabre\u201d, \u201cnone\u201d] Whether the coupling map is restricted to qubits in the input layout or not.\n- \u201cfixed\u201d: Restricts the coupling map to only the specified qubits.\n- \u201cbatching\u201d: Considers the full coupling map of the backend and circuit execution is batched per final layout.\n* Default is \u201cfixed\u201d Literal[\u201cfixed\u201d, \u201cbatching\u201d] Whether Readout Error Mitigation is applied in post-processing. When set to True, both results (readout-unmitigated and -mitigated) are produced.\n- Default is True. bool The measurement shots to use for readout calibration.\n* Default is 1_000. int Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. benchmark  num_circuits  num_sigmas  choose_qubits_routine  custom_qubits_array  qiskit_optim_level  optimize_sqg  rem  mit_shots  shots  max_gates_per_batch  max_circuits_per_batch  calset_id  routing_method  physical_layout  use_dd  dd_strategy  Methods Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.benchmarks.quantum_volume.quantum_volume.QuantumVolumeBenchmark next iqm.benchmarks.randomized_benchmarking By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.plot_rb_decay",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.plot_rb_decay.html",
    "description": "Plot the fidelity decay and the fit to the model. identifier ( str ) \u2013 the type of RB experiment qubits_array ( List [ List [ int ] ] ) \u2013 Array of sets of qubits for which to plot decays dataset ( xr....",
    "content": "Plot the fidelity decay and the fit to the model. identifier ( str ) \u2013 the type of RB experiment qubits_array ( List [ List [ int ] ] ) \u2013 Array of sets of qubits for which to plot decays dataset ( xr.dataset ) \u2013 the dataset from the experiment observations ( Dict [ str , Dict [ str , Any ] ] ) \u2013 the corresponding observations from the experiment bars ( bool , optional ) \u2013 Whether error bars are plotted or not. Defaults to False violin ( bool , optional ) \u2013 Whether violins are plotted or not. Defaults to True scatter ( bool , optional ) \u2013 Whether all individual points are plotted or not. Defaults to True shade_stdev ( bool , optional ) \u2013 Whether standard deviations are shaded or not. Defaults to False shade_meanerror ( bool , optional ) \u2013 Whether to shade standard deviations. Defaults to False logscale ( bool , optional ) \u2013 Whether x-axis uses logscale. Defaults to True interleaved_gate ( Optional [ str ] ) \u2013 The label or the interleaved gate. Defaults to None mrb_2q_density ( Optional [ float ] , optional ) \u2013 Density of MRB 2Q gates. Defaults to None. mrb_2q_ensemble ( Optional [ Dict [ str , float ] ] , optional ) \u2013 MRB ensemble of 2Q gates. Defaults to None. is_eplg ( bool , optional ) \u2013 Whether the experiment is EPLG or not. Defaults to False. the plot title and the figure Tuple[ str , Figure] previous iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.lmfit_minimizer next iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.relabel_qubits_array_from_zero By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.compressive_gst.gst_analysis.dataframe_to_figure",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.compressive_gst.gst_analysis.dataframe_to_figure.html",
    "description": "Turns a pandas DataFrame into a figure\nThis is needed to conform with the standard file saving routine of QCVV. df ( DataFrame ) \u2013 Pandas DataFrame\nA dataframe table containing GST results row_labels ...",
    "content": "Turns a pandas DataFrame into a figure\nThis is needed to conform with the standard file saving routine of QCVV. df ( DataFrame ) \u2013 Pandas DataFrame\nA dataframe table containing GST results row_labels ( List [ str ] | None ) \u2013 List[str]\nThe row labels for the dataframe col_width ( float ) \u2013 int\nUsed to control cell width in the table fontsize ( int ) \u2013 int\nFont size of text/numbers in table cells Matplotlib figure object A figure representing the dataframe. A figure representing the dataframe. figure previous iqm.benchmarks.compressive_gst.gst_analysis.bootstrap_errors next iqm.benchmarks.compressive_gst.gst_analysis.dataset_counts_to_mgst_format By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.graph_states.plot_max_negativities_graph",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.graph_states.plot_max_negativities_graph.html",
    "description": "Plots the maximum negativity for each corresponding pair of qubits in a graph layout of the given backend. negativities ( Dict [ str , Dict [ str , str | float ] ] ) \u2013 A dictionary (str qubit keys) of...",
    "content": "Plots the maximum negativity for each corresponding pair of qubits in a graph layout of the given backend. negativities ( Dict [ str , Dict [ str , str | float ] ] ) \u2013 A dictionary (str qubit keys) of dictionaries (keys \u201cvalue\u201d/\u201duncertainty\u201d) of negativities (float) to plot. backend_coupling_map ( CouplingMap ) \u2013 The CouplingMap instance. qubit_names ( Dict [ int , str ] ) \u2013 A dictionary of qubit names corresponding to qubit indices. timestamp ( str ) \u2013 The timestamp of the corresponding experiment. tomography ( Literal [ \"shadow_tomography\" , \"state_tomography\" ] ) \u2013 The type of tomography that was used. station ( str ) \u2013 The name of the station to use for the graph layout. num_shots ( Optional [ int ] ) \u2013 The number of shots used in the corresponding experiment.\n* Defaults to None: won\u2019t be displayed in title. num_bootstraps ( Optional [ int ] ) \u2013 The number of bootstraps used if tomography corresponds to state tomography.\n* Defaults to None if the tomography type is \u201cshadow_tomography\u201d. num_RM_samples ( Optional [ int ] ) \u2013 The number of randomized measurement samples used if tomography corresponds to shadow tomography.\n* Defaults to None if the tomography type is \u201cstate_tomography\u201d. num_MoMs_samples ( Optional [ int ] ) \u2013 The number of Median of Means samples per randomized measurement used if tomography corresponds to shadow tomography.\n* Defaults to None if the tomography type is \u201cshadow_tomography\u201d. The figure label and the max negativities plot figure. Tuple[ str , Figure] previous iqm.benchmarks.entanglement.graph_states.plot_max_negativities next iqm.benchmarks.entanglement.graph_states.shadow_tomography_analysis By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.compressive_gst.compressive_gst.parse_layouts",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.compressive_gst.compressive_gst.parse_layouts.html",
    "description": "Checks for correct setting of qubit_layouts in the configuration and return a correct type qubit_layouts ( List [ int ] | List [ List [ int ] ] ) \u2013 List[List[[int]] or List[int]\nThe qubit_layouts on t...",
    "content": "Checks for correct setting of qubit_layouts in the configuration and return a correct type qubit_layouts ( List [ int ] | List [ List [ int ] ] ) \u2013 List[List[[int]] or List[int]\nThe qubit_layouts on the backend where the gates are defined on List[List[int]] A properly typed qubit_layout if no Error was raised A properly typed qubit_layout if no Error was raised qubit_layouts previous iqm.benchmarks.compressive_gst.compressive_gst.parse_gate_set next iqm.benchmarks.compressive_gst.compressive_gst.CompressiveGST By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.graph_states.negativity_analysis",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.graph_states.negativity_analysis.html",
    "description": "Analysis function for a Graph State benchmark experiment. run ( BenchmarkRunResult ) \u2013 BenchmarkAnalysisResult previous iqm.benchmarks.entanglement.graph_states.generate_minimal_edge_layers next iqm.b...",
    "content": "Analysis function for a Graph State benchmark experiment. run ( BenchmarkRunResult ) \u2013 BenchmarkAnalysisResult previous iqm.benchmarks.entanglement.graph_states.generate_minimal_edge_layers next iqm.benchmarks.entanglement.graph_states.plot_density_matrix By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.ghz.generate_ghz_star",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.ghz.generate_ghz_star.html",
    "description": "Generates the circuit for creating a GHZ state by maximizing the number of CZ gates between a pair of MOVE gates.\n:param num_qubits: the number of qubits of the GHZ state A quantum circuit generating ...",
    "content": "Generates the circuit for creating a GHZ state by maximizing the number of CZ gates between a pair of MOVE gates.\n:param num_qubits: the number of qubits of the GHZ state A quantum circuit generating a GHZ state on a given number of qubits. QuantumCircuit num_qubits ( int ) \u2013 previous iqm.benchmarks.entanglement.ghz.generate_ghz_spanning_tree next iqm.benchmarks.entanglement.ghz.get_cx_map By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.benchmark_definition.default_analysis_function",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.benchmark_definition.default_analysis_function.html",
    "description": "The default analysis that only pass the result through. result ( BenchmarkRunResult ) \u2013 BenchmarkAnalysisResult previous iqm.benchmarks.benchmark_definition.add_counts_to_dataset next iqm.benchmarks.b...",
    "content": "The default analysis that only pass the result through. result ( BenchmarkRunResult ) \u2013 BenchmarkAnalysisResult previous iqm.benchmarks.benchmark_definition.add_counts_to_dataset next iqm.benchmarks.benchmark_definition.merge_datasets_dac By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.compressive_gst.gst_analysis.mgst_analysis",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.compressive_gst.gst_analysis.mgst_analysis.html",
    "description": "Analysis function for compressive GST run ( BenchmarkRunResult ) \u2013 BenchmarkRunResult\nA BenchmarkRunResult instance storing the dataset BenchmarkAnalysisResult An BenchmarkAnalysisResult instance with...",
    "content": "Analysis function for compressive GST run ( BenchmarkRunResult ) \u2013 BenchmarkRunResult\nA BenchmarkRunResult instance storing the dataset BenchmarkAnalysisResult An BenchmarkAnalysisResult instance with the updated dataset, as well as plots and observations An BenchmarkAnalysisResult instance with the updated dataset, as well as plots and observations result previous iqm.benchmarks.compressive_gst.gst_analysis.generate_unit_rank_gate_results next iqm.benchmarks.compressive_gst.gst_analysis.pandas_results_to_observations By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.quantum_volume.quantum_volume.compute_heavy_output_probabilities",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.quantum_volume.quantum_volume.compute_heavy_output_probabilities.html",
    "description": "Compute the HOP of all quantum circuits. execution_results ( List [ Dict [ str , int ] ] ) \u2013 counts from execution of all quantum circuits. ideal_heavy_outputs ( List [ Dict [ str , float ] ] ) \u2013 list...",
    "content": "Compute the HOP of all quantum circuits. execution_results ( List [ Dict [ str , int ] ] ) \u2013 counts from execution of all quantum circuits. ideal_heavy_outputs ( List [ Dict [ str , float ] ] ) \u2013 list of ideal heavy output dictionaries. the HOP of all quantum circuits. List[ float ] previous iqm.benchmarks.quantum_volume.quantum_volume next iqm.benchmarks.quantum_volume.quantum_volume.cumulative_hop By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.circuit_containers.BenchmarkCircuit",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.circuit_containers.BenchmarkCircuit.html",
    "description": "Bases: object A class grouping a list of CircuitGroup into a single purpose. This can typically represent, for example,\nall of the transpiled circuits that are executed. name ( str ) \u2013 circuit_groups ...",
    "content": "Bases: object A class grouping a list of CircuitGroup into a single purpose. This can typically represent, for example,\nall of the transpiled circuits that are executed. name ( str ) \u2013 circuit_groups ( List [ CircuitGroup ] ) \u2013 Name of the BenchmarkCircuit . str List of CircuitGroup contained inside List[ iqm.benchmarks.circuit_containers.CircuitGroup ] Attributes group_names Names of all the contained CircuitGroup . groups The circuit groups inside. qubit_indices Set of all the qubits used in all the CircuitGroup , represented as an integer. qubit_layouts Set of all the qubit layouts used, where the qubits are represented as an instance of Qubit . qubit_layouts_by_index Set of all the qubit layouts used, where the qubits are represented as an integer. qubits Set of all the qubits used in all the CircuitGroup , represented as an instance of Qubit . name  circuit_groups  Methods __eq__ (other) Return self==value. __getitem__ (key)  __repr__ () Return repr(self). __setitem__ (key,\u00a0value)  get_circuit_group_by_name (name) Gets a CircuitGroup by name. Gets a CircuitGroup by name. name ( str ) \u2013 name of the group. The desired CircuitGroup , or None if it does not exist. CircuitGroup | None The circuit groups inside. Names of all the contained CircuitGroup . Set of all the qubits used in all the CircuitGroup , represented as an integer. Set of all the qubits used in all the CircuitGroup , represented as an instance of Qubit . Set of all the qubit layouts used, where the qubits are represented as an integer. Set of all the qubit layouts used, where the qubits are represented as an instance of Qubit . previous iqm.benchmarks.circuit_containers next iqm.benchmarks.circuit_containers.CircuitGroup By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.graph_states.generate_minimal_edge_layers",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.graph_states.generate_minimal_edge_layers.html",
    "description": "Sorts the edges of a coupling map, arranging them in a dictionary with values being subsets of the coupling map with no overlapping nodes.\nEach item will correspond to a layer of pairs of qubits in wh...",
    "content": "Sorts the edges of a coupling map, arranging them in a dictionary with values being subsets of the coupling map with no overlapping nodes.\nEach item will correspond to a layer of pairs of qubits in which parallel 2Q gates can be applied. cp_map ( CouplingMap ) \u2013 A list of lists of pairs of integers, representing a coupling map. A dictionary with values being subsets of the coupling map with no overlapping nodes. Dict[ int , List[List[ int ]]] previous iqm.benchmarks.entanglement.graph_states.generate_graph_state next iqm.benchmarks.entanglement.graph_states.negativity_analysis By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.eplg.eplg.EPLGConfiguration",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.eplg.eplg.EPLGConfiguration.html",
    "description": "Bases: BenchmarkConfigurationBase EPLG Configuration benchmark ( Type [ Benchmark ] ) \u2013 shots ( int ) \u2013 max_gates_per_batch ( int | None ) \u2013 max_circuits_per_batch ( int | None ) \u2013 calset_id ( str | N...",
    "content": "Bases: BenchmarkConfigurationBase EPLG Configuration benchmark ( Type [ Benchmark ] ) \u2013 shots ( int ) \u2013 max_gates_per_batch ( int | None ) \u2013 max_circuits_per_batch ( int | None ) \u2013 calset_id ( str | None ) \u2013 routing_method ( Literal [ 'basic' , 'lookahead' , 'stochastic' , 'sabre' , 'none' ] ) \u2013 physical_layout ( Literal [ 'fixed' , 'batching' ] ) \u2013 use_dd ( bool | None ) \u2013 dd_strategy ( DDStrategy | None ) \u2013 drb_depths ( Sequence [ int ] ) \u2013 drb_circuit_samples ( int ) \u2013 custom_qubits_array ( Sequence [ Tuple [ int , int ] ] | None ) \u2013 chain_length ( int | None ) \u2013 chain_path_samples ( int | None ) \u2013 num_disjoint_layers ( int | None ) \u2013 max_hamiltonian_path_tries ( int | None ) \u2013 calibration_url ( str | None ) \u2013 The layer depths to consider for the parallel DRB. Sequence[ int ] The number of circuit samples to consider for the parallel DRB. int The custom qubits array to consider; this corresponds to a Sequence of Tuple pairs of qubits.\n* If not specified, will proceed to generate linear chains at random, selecting the one with the highest total 2Q gate fidelity.\n* Default is None. Optional[Sequence[Tuple[ int , int ]]] The length of a linear chain of 2Q gates to consider, corresponding to the number of qubits, if custom_qubits_array not specified.\n* Default is None: assigns the number of qubits in the backend minus one. Optional[ int ] The number of chain path samples to consider, if custom_qubits_array not specified.\n* Default is None: assigns 20 path samples (arbitrary). int The number of disjoint layers to consider.\n* Default is None: assigns 2 disjoint layers (arbitrary). Optional[ int ] The maximum number of tries to find a Hamiltonian path.\n* Default is None: assigns 10 tries (arbitrary). Optional[ int ] The URL of the IQM station to retrieve calibration data from.\n* It must be specified if custom_qubits_array is not specified.\n* Default is None - raises an error if custom_qubits_array is not specified. Optional[ str ] Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. benchmark  drb_depths  drb_circuit_samples  custom_qubits_array  chain_length  chain_path_samples  num_disjoint_layers  max_hamiltonian_path_tries  calibration_url  shots  max_gates_per_batch  max_circuits_per_batch  calset_id  routing_method  physical_layout  use_dd  dd_strategy  Methods Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.benchmarks.randomized_benchmarking.eplg.eplg.EPLGBenchmark next iqm.benchmarks.randomized_benchmarking.interleaved_rb By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.clifford_rb.clifford_rb",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.clifford_rb.clifford_rb.html",
    "description": "\u2018Standard\u2019 Clifford Randomized Benchmarking. Functions clifford_rb_analysis (run) Analysis function for a Clifford RB experiment Classes CliffordRBConfiguration (*,\u00a0benchmark,\u00a0shots,\u00a0...) Clifford RB ...",
    "content": "\u2018Standard\u2019 Clifford Randomized Benchmarking. Functions clifford_rb_analysis (run) Analysis function for a Clifford RB experiment Classes CliffordRBConfiguration (*,\u00a0benchmark,\u00a0shots,\u00a0...) Clifford RB configuration. CliffordRandomizedBenchmarking (backend_arg,\u00a0...) Clifford RB estimates the average gate fidelity of the n-qubit Clifford group Inheritance previous iqm.benchmarks.randomized_benchmarking.clifford_rb next iqm.benchmarks.randomized_benchmarking.clifford_rb.clifford_rb.clifford_rb_analysis By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.clifford_rb.clifford_rb.CliffordRandomizedBenchmarking",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.clifford_rb.clifford_rb.CliffordRandomizedBenchmarking.html",
    "description": "Bases: Benchmark Clifford RB estimates the average gate fidelity of the n-qubit Clifford group Attributes name  Methods add_all_circuits_to_dataset (dataset) Adds all generated circuits during executi...",
    "content": "Bases: Benchmark Clifford RB estimates the average gate fidelity of the n-qubit Clifford group Attributes name  Methods add_all_circuits_to_dataset (dataset) Adds all generated circuits during execution to the dataset variable add_all_metadata_to_dataset (dataset) Adds all configuration metadata and circuits to the dataset variable :param dataset: The xarray dataset :type dataset: xr.Dataset analysis_function (run) Analysis function for a Clifford RB experiment execute (backend) Executes the benchmark backend_arg ( IQMBackendBase | str ) \u2013 configuration ( CliffordRBConfiguration ) \u2013 Analysis function for a Clifford RB experiment run ( RunResult ) \u2013 A Clifford RB experiment run for which analysis result is created AnalysisResult corresponding to Clifford RB BenchmarkAnalysisResult Adds all configuration metadata and circuits to the dataset variable\n:param dataset: The xarray dataset\n:type dataset: xr.Dataset dataset ( Dataset ) \u2013 Adds all generated circuits during execution to the dataset variable dataset ( xr.Dataset ) \u2013 The xarray dataset Returns: Executes the benchmark backend ( IQMBackendBase ) \u2013 Dataset previous iqm.benchmarks.randomized_benchmarking.clifford_rb.clifford_rb.CliffordRBConfiguration next iqm.benchmarks.randomized_benchmarking.direct_rb By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.generate_random_clifford_seq_circuits",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.generate_random_clifford_seq_circuits.html",
    "description": "Generate random Clifford circuits in native gates for a given sequence length. qubits ( List [ int ] ) \u2013 the list of qubits clifford_dict ( Dict [ str , QuantumCircuit ] ) \u2013 A dictionary of Clifford g...",
    "content": "Generate random Clifford circuits in native gates for a given sequence length. qubits ( List [ int ] ) \u2013 the list of qubits clifford_dict ( Dict [ str , QuantumCircuit ] ) \u2013 A dictionary of Clifford gates labeled by (de)stabilizers seq_length ( int ) \u2013 the sequence length num_circ_samples ( int ) \u2013 the number of samples backend_arg ( str | IQMBackendBase ) \u2013 interleaved_gate ( Optional [ QuantumCircuit ] ) \u2013 Clifford native gate to be interleaved - None by default the list of self.num_samples random Clifford quantum circuits List[QuantumCircuit] previous iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.generate_fixed_depth_parallel_rb_circuits next iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.get_survival_probabilities By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.readout_mitigation.apply_readout_error_mitigation",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.readout_mitigation.apply_readout_error_mitigation.html",
    "description": "backend_arg ( str | IQMBackendBase ) \u2013 the backend to calibrate an M3 mitigator against. transpiled_circuits ( List [ QuantumCircuit ] ) \u2013 the list of transpiled quantum circuits. counts ( List [ Dict...",
    "content": "backend_arg ( str | IQMBackendBase ) \u2013 the backend to calibrate an M3 mitigator against. transpiled_circuits ( List [ QuantumCircuit ] ) \u2013 the list of transpiled quantum circuits. counts ( List [ Dict [ str , int ] ] ) \u2013 the measurement counts corresponding to the circuits. mit_shots ( int ) \u2013 number of shots per circuit. a list of dictionaries with REM-corrected quasiprobabilities for each outcome. tuple [Any, Any] | tuple [QuasiCollection, list ] | QuasiCollection previous iqm.benchmarks.readout_mitigation next iqm.benchmarks.readout_mitigation.readout_error_m3 By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.fit_decay_lmfit",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.fit_decay_lmfit.html",
    "description": "Perform a fitting routine for 0th-order (Ap^m+B) RB using lmfit func ( Callable ) \u2013 the model function for fitting qubit_set ( List [ int ] ) \u2013 the qubits entering the model data ( List [ List [ float...",
    "content": "Perform a fitting routine for 0th-order (Ap^m+B) RB using lmfit func ( Callable ) \u2013 the model function for fitting qubit_set ( List [ int ] ) \u2013 the qubits entering the model data ( List [ List [ float ] ] | List [ List [ List [ float ] ] ] ) \u2013 the data to be fitted rb_identifier ( str ) \u2013 the RB identifier, either \u201cstdrb\u201d, \u201cirb\u201d or \u201cmrb\u201d simultaneous_fit_vars ( List [ str ] , optional ) \u2013 the list of variables used to fit simultaneously interleaved_gate_str ( Optional [ str ] ) \u2013 the name of the interleaved gate in IRB A tuple of fitting data (list of lists of average fidelities or polarizations) and MRB fit parameters Tuple [ ndarray , Parameters ] previous iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.exponential_rb next iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.generate_all_rb_circuits By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.optimization.qscore.compute_expectation_value",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.optimization.qscore.compute_expectation_value.html",
    "description": "Computes expectation value based on measurement results. counts ( Dict [ str , int ] ) \u2013 key as bitstring, val as count graph ( networkx ) \u2013 the MaxCut problem graph qubit_to_node ( Dict [ int , int ]...",
    "content": "Computes expectation value based on measurement results. counts ( Dict [ str , int ] ) \u2013 key as bitstring, val as count graph ( networkx ) \u2013 the MaxCut problem graph qubit_to_node ( Dict [ int , int ] ) \u2013 mapping of qubit to nodes of the graph virtual_nodes ( List [ Tuple [ int , int ] ] ) \u2013 list of virtual nodes in the graph expectation value of the cut edges for number of counts avg ( float ) previous iqm.benchmarks.optimization.qscore.calculate_optimal_angles_for_QAOA_p1 next iqm.benchmarks.optimization.qscore.create_objective_function By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.eplg.eplg",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.eplg.eplg.html",
    "description": "Error Per Layered Gate (EPLG). Functions eplg_analysis (run) EPLG analysis function plot_layered_fidelities_graph (fidelities,\u00a0...) Plots the layered fidelity for each corresponding pair of qubits in ...",
    "content": "Error Per Layered Gate (EPLG). Functions eplg_analysis (run) EPLG analysis function plot_layered_fidelities_graph (fidelities,\u00a0...) Plots the layered fidelity for each corresponding pair of qubits in a graph layout of the given backend. Classes EPLGBenchmark (backend_arg,\u00a0configuration) EPLG estimates the layer fidelity of native 2Q gate layers EPLGConfiguration (*,\u00a0benchmark,\u00a0shots,\u00a0...) EPLG Configuration Inheritance previous iqm.benchmarks.randomized_benchmarking.eplg next iqm.benchmarks.randomized_benchmarking.eplg.eplg.eplg_analysis By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.retrieve_all_job_metadata",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.retrieve_all_job_metadata.html",
    "description": "Retrieve the counts from a list of IQMJob objects.\n:param iqm_jobs List[IQMJob]: The list of IQMJob objects. Relevant metadata of all the IQMJob objects. Dict[ str , Dict[ str , Any]] iqm_jobs ( List ...",
    "content": "Retrieve the counts from a list of IQMJob objects.\n:param iqm_jobs List[IQMJob]: The list of IQMJob objects. Relevant metadata of all the IQMJob objects. Dict[ str , Dict[ str , Any]] iqm_jobs ( List [ IQMJob ] ) \u2013 previous iqm.benchmarks.utils.retrieve_all_counts next iqm.benchmarks.utils.set_coupling_map By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils_plots.rx_to_nx_graph",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils_plots.rx_to_nx_graph.html",
    "description": "Convert the Rustworkx graph returned by a backend to a Networkx graph. backend_coupling_map ( CouplingMap ) \u2013 The coupling map of the backend. The Networkx Graph corresponding to the backend graph. ne...",
    "content": "Convert the Rustworkx graph returned by a backend to a Networkx graph. backend_coupling_map ( CouplingMap ) \u2013 The coupling map of the backend. The Networkx Graph corresponding to the backend graph. networkx.Graph previous iqm.benchmarks.utils_plots.plot_layout_fidelity_graph next iqm.benchmarks.utils_plots.GraphPositions By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.quantum_volume.clops.CLOPSBenchmark",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.quantum_volume.clops.CLOPSBenchmark.html",
    "description": "Bases: Benchmark CLOPS reflect the speed of execution of parametrized QV circuits. Attributes name  Methods add_all_meta_to_dataset (dataset) Adds all configuration metadata and circuits to the datase...",
    "content": "Bases: Benchmark CLOPS reflect the speed of execution of parametrized QV circuits. Attributes name  Methods add_all_meta_to_dataset (dataset) Adds all configuration metadata and circuits to the dataset variable analysis_function (run) Analysis function for a CLOPS (v or h) experiment append_parameterized_unitary (qc,\u00a0q0,\u00a0q1,\u00a0...) Append a decomposed, parametrized SU(4) gate using CX gates to the given quantum circuit. assign_random_parameters_to_all (...) param dict_parametrized_circs : Dictionary with list of int (qubits) as keys and lists of parametrized quantum circuits as values Dictionary with list of int (qubits) as keys and lists of parametrized quantum circuits as values clops_cycle (backend,\u00a0...) Executes a single CLOPS cycle (parameter assignment and execution) for the given update :param backend: the backend to execute the jobs with :type backend: IQMBackendBase :param sorted_transpiled_qc_list: A dictionary of lists of transpiled quantum circuits :type sorted_transpiled_qc_list: Dict[str, List[QuantumCircuit]] :param update: The current cycle update :type update: int execute (backend) Executes the benchmark generate_circuit_list () Generate a list of parametrized QV quantum circuits, with measurements at the end. generate_random_parameters () Generate an array of as many random parameters as needed by the QV template circuits. generate_single_circuit () Generate a single parametrized QV quantum circuit, with measurements at the end. generate_transpiled_clops_templates () Generates CLOPS circuit templates transpiled to the backend's physical layout backend_arg ( IQMBackendBase | str ) \u2013 configuration ( CLOPSConfiguration ) \u2013 Analysis function for a CLOPS (v or h) experiment run ( RunResult ) \u2013 A CLOPS experiment run for which analysis result is created AnalysisResult corresponding to CLOPS BenchmarkAnalysisResult Adds all configuration metadata and circuits to the dataset variable dataset ( xr.Dataset ) \u2013 The xarray dataset Append a decomposed, parametrized SU(4) gate using CX gates to the given quantum circuit. qc ( QuantumCircuit ) \u2013 the quantum circuit to append the SU(4) gate to q0 ( int ) \u2013 the first qubit involved in the gate q1 ( int ) \u2013 the second qubit involved in the gate layer ( int ) \u2013 the QV layer the gate belongs to pair ( int ) \u2013 the pair index corresponding to the gate None Generate a single parametrized QV quantum circuit, with measurements at the end. the QV quantum circuit. QuantumCircuit Generate a list of parametrized QV quantum circuits, with measurements at the end. the list of parametrized QV quantum circuits. List[QuantumCircuit] Generate an array of as many random parameters as needed by the QV template circuits. the array of random parameters np.ndarray[np.float64] dict_parametrized_circs ( Dict [ Tuple , List [ QuantumCircuit ] ] ) \u2013 Dictionary with list of int (qubits) as keys and lists of parametrized quantum circuits as values optimize_sqg ( bool ) \u2013 Whether single qubit gate optimization is applied lists of list of float parameter values corresponding to param updates dictionary with lists of int (qubits) as keys and lists of quantum circuits as values lists of list of float parameter values corresponding to param updates dictionary with lists of int (qubits) as keys and lists of quantum circuits as values A tuple of dictionaries Executes a single CLOPS cycle (parameter assignment and execution) for the given update\n:param backend: the backend to execute the jobs with\n:type backend: IQMBackendBase\n:param sorted_transpiled_qc_list: A dictionary of lists of transpiled quantum circuits\n:type sorted_transpiled_qc_list: Dict[str, List[QuantumCircuit]]\n:param update: The current cycle update\n:type update: int The elapsed times for parameter assignment, submission and retrieval of jobs Tuple[ float , float , float ] backend ( IQMBackendBase ) \u2013 sorted_transpiled_qc_list ( Dict [ Tuple , List [ IQMCircuit ] ] ) \u2013 update ( int ) \u2013 Generates CLOPS circuit templates transpiled to the backend\u2019s physical layout a dictionary of quantum circuits with keys being str(qubit layout) Dict[ str , QuantumCircuit] Executes the benchmark backend ( IQMBackendBase ) \u2013 Dataset previous iqm.benchmarks.quantum_volume.clops.retrieve_clops_elapsed_times next iqm.benchmarks.quantum_volume.clops.CLOPSConfiguration By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.set_coupling_map",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.set_coupling_map.html",
    "description": "Set a coupling map according to the specified physical layout. qubits ( Sequence [ int ] ) \u2013 the list of physical qubits to consider. backend ( IQMBackendBase ) \u2013 the backend from IQM. physical_layout...",
    "content": "Set a coupling map according to the specified physical layout. qubits ( Sequence [ int ] ) \u2013 the list of physical qubits to consider. backend ( IQMBackendBase ) \u2013 the backend from IQM. physical_layout ( Literal [ \"fixed\" , \"batching\" ] ) \u2013 the physical layout type to consider.\n- \u201cfixed\u201d sets a coupling map restricted to the input qubits -> results will be constrained to measure those qubits.\n- \u201cbatching\u201d sets the coupling map of the backend -> results in a benchmark will be \u201cbatched\u201d according to final layouts.\n* Default is \u201cfixed\u201d. ValueError \u2013 if the physical layout is not \u201cfixed\u201d or \u201cbatching\u201d. ValueError \u2013 if Star topology and label 0 is in qubit layout. ValueError \u2013 if the physical layout is not \u201cfixed\u201d or \u201cbatching\u201d. A coupling map according to the specified physical layout. CouplingMap previous iqm.benchmarks.utils.retrieve_all_job_metadata next iqm.benchmarks.utils.sort_batches_by_final_layout By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.ghz.get_cx_map",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.ghz.get_cx_map.html",
    "description": "Calculate the cx_map based on participating qubits and the 2QB gate fidelities between them. Uses networkx graph algorithms to calculate the minimal spanning tree of the subgraph defined by qubit_layo...",
    "content": "Calculate the cx_map based on participating qubits and the 2QB gate fidelities between them. Uses networkx graph algorithms to calculate the minimal spanning tree of the subgraph defined by qubit_layout.\nThe weights are -log(CZ fidelity) for each edge. Then, finds the qubit in the most central position\nby calculating the distances between all qubits. Next, adds CX applications to the list, starting\nfrom the central qubit, such that the smallest number of layers is executed (most parallel). qubit_layout ( List [ int ] ) \u2013 List[int]\nThe subset of system-qubits used in the protocol, indexed from 0 graph ( Graph ) \u2013 networkx.Graph\nThe connectivity graph with edge weight given by CZ fidelities List[List[int]] A list of CX gates for the GHZ generation circuit, starting from the first gate to be applied A list of CX gates for the GHZ generation circuit, starting from the first gate to be applied cx_map previous iqm.benchmarks.entanglement.ghz.generate_ghz_star next iqm.benchmarks.entanglement.ghz.get_edges By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.quantum_volume.clops.clops_analysis",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.quantum_volume.clops.clops_analysis.html",
    "description": "Analysis function for a CLOPS (v or h) experiment run ( RunResult ) \u2013 A CLOPS experiment run for which analysis result is created AnalysisResult corresponding to CLOPS BenchmarkAnalysisResult previous...",
    "content": "Analysis function for a CLOPS (v or h) experiment run ( RunResult ) \u2013 A CLOPS experiment run for which analysis result is created AnalysisResult corresponding to CLOPS BenchmarkAnalysisResult previous iqm.benchmarks.quantum_volume.clops next iqm.benchmarks.quantum_volume.clops.plot_times By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils_shadows.get_negativity",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils_shadows.get_negativity.html",
    "description": "Computes the negativity of a given density matrix.\nNote that a negativity >0 is only a necessary and sufficient condition for entanglement if NA = NB = 1. For more    qubits per subsystems it is merel...",
    "content": "Computes the negativity of a given density matrix.\nNote that a negativity >0 is only a necessary and sufficient condition for entanglement if NA = NB = 1. For more    qubits per subsystems it is merely a necessary condition.\n:param rho: Density matrix.\n:type rho: np.ndarray\n:param NA: Number of qubits for subsystem A.\n:type NA: int\n:param NB: Number of qubits for subsystem B.\n:type NB: int the negativity of the input density matrix. float rho ( ndarray ) \u2013 NA ( int ) \u2013 NB ( int ) \u2013 previous iqm.benchmarks.utils_shadows.get_local_shadow next iqm.benchmarks.utils_shadows.local_shadow_tomography By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.benchmark_definition",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.benchmark_definition.html",
    "description": "This module implements the base class for defining a benchmark. Functions add_counts_to_dataset (counts,\u00a0identifier,\u00a0...) Adds the counts from a cortex job result to the given dataset. default_analysi...",
    "content": "This module implements the base class for defining a benchmark. Functions add_counts_to_dataset (counts,\u00a0identifier,\u00a0...) Adds the counts from a cortex job result to the given dataset. default_analysis_function (result) The default analysis that only pass the result through. merge_datasets_dac (datasets) Merges a list of datasets recursively to minimize dataset sizes during merge show_figure (fig) Shows a closed figure. Classes Benchmark (backend,\u00a0configuration,\u00a0**kwargs) A base class for running cortex-based Benchmark experiments. BenchmarkAnalysisResult (dataset,\u00a0circuits,\u00a0...) A dataclass storing the results of the analysis. BenchmarkObservation (name,\u00a0value,\u00a0identifier) Dataclass to store the main results of a single run of a Benchmark BenchmarkObservationIdentifier (qubit_indices) Identifier for observations for ease of use BenchmarkRunResult (dataset,\u00a0circuits) A dataclass that stores the results of a single run of a Benchmark. Inheritance previous iqm.benchmarks.benchmark.BenchmarkConfigurationBase next iqm.benchmarks.benchmark_definition.add_counts_to_dataset By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.import_native_gate_cliffords",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.import_native_gate_cliffords.html",
    "description": "Import native gate Clifford dictionaries system_size ( str , optional ) \u2013 System size to load, either \u201c1q\u201d or \u201c2q\u201d. If None, load both dictionaries. If system_size is specified, returns the dictionary...",
    "content": "Import native gate Clifford dictionaries system_size ( str , optional ) \u2013 System size to load, either \u201c1q\u201d or \u201c2q\u201d. If None, load both dictionaries. If system_size is specified, returns the dictionary for that system size.\nIf system_size is None, returns a tuple of (1q_dict, 2q_dict). ValueError \u2013 If system_size is not None, \u201c1q\u201d, or \u201c2q\u201d. Dict [ str , IQMCircuit ] | Tuple [ Dict [ str , IQMCircuit ], Dict [ str , IQMCircuit ]] previous iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.get_survival_probabilities next iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.lmfit_minimizer By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.survival_probabilities_parallel",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.survival_probabilities_parallel.html",
    "description": "Estimates marginalized survival probabilities from a parallel RB execution (at fixed depth). qubits_array ( List [ int ] ) \u2013 List of qubits in which the experiment was performed counts ( Dict [ str , ...",
    "content": "Estimates marginalized survival probabilities from a parallel RB execution (at fixed depth). qubits_array ( List [ int ] ) \u2013 List of qubits in which the experiment was performed counts ( Dict [ str , int ] ) \u2013 The measurement counts for corresponding bitstrings separate_registers ( bool ) \u2013 Whether the clbits were generated in separate registers\n* If True, the bit strings will be separated by a space, e.g., \u201800 10\u2019 means \u201800\u2019 belongs to one register and \u201810\u2019 to another.\n* Default is False. The survival probabilities for each qubit. Dict[ str , List[ float ]] previous iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.submit_sequential_rb_jobs next iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.validate_irb_gate By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.eplg",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.eplg.html",
    "description": "Error Per Layered Gate (EPLG) estimates the layer fidelity of 2Q gate layers. Subpackages and modules eplg Error Per Layered Gate (EPLG). previous iqm.benchmarks.randomized_benchmarking.direct_rb.dire...",
    "content": "Error Per Layered Gate (EPLG) estimates the layer fidelity of 2Q gate layers. Subpackages and modules eplg Error Per Layered Gate (EPLG). previous iqm.benchmarks.randomized_benchmarking.direct_rb.direct_rb.DirectRandomizedBenchmarking next iqm.benchmarks.randomized_benchmarking.eplg.eplg By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.get_Pauli_expectation",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.get_Pauli_expectation.html",
    "description": "Gets an estimate of a Pauli expectation value for a given set of counts and a Pauli measurement label. counts ( Dict [ str , int ] ) \u2013 A dictionary of counts.\n* NB: keys are assumed to have a single b...",
    "content": "Gets an estimate of a Pauli expectation value for a given set of counts and a Pauli measurement label. counts ( Dict [ str , int ] ) \u2013 A dictionary of counts.\n* NB: keys are assumed to have a single bitstring, i.e., coming from a single classical register. pauli_label ( str ) \u2013 A Pauli measurement label, specified as a string of I, X, Y, Z characters. ValueError \u2013 If Pauli labels are not specified in terms of I, X, Y, Z characters. The estimate of the Pauli expectation value. float previous iqm.benchmarks.utils.generate_state_tomography_circuits next iqm.benchmarks.utils.get_active_qubits By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.estimate_survival_probabilities",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.estimate_survival_probabilities.html",
    "description": "Compute a result\u2019s probability of being on the ground state.\n:param num_qubits: the number of qubits\n:type num_qubits: int\n:param counts: the result of the execution of a list of quantum circuits (cou...",
    "content": "Compute a result\u2019s probability of being on the ground state.\n:param num_qubits: the number of qubits\n:type num_qubits: int\n:param counts: the result of the execution of a list of quantum circuits (counts)\n:type counts: List[Dict[str, int]] the ground state probabilities of the RB sequence List[ float ] num_qubits ( int ) \u2013 counts ( List [ Dict [ str , int ] ] ) \u2013 previous iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.edge_grab next iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.exponential_rb By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.compressive_gst.gst_analysis.bootstrap_errors",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.compressive_gst.gst_analysis.bootstrap_errors.html",
    "description": "Resamples circuit outcomes a number of times and computes GST estimates for each repetition\nAll results are then returned in order to compute bootstrap-error bars for GST estimates.\nParametric bootstr...",
    "content": "Resamples circuit outcomes a number of times and computes GST estimates for each repetition\nAll results are then returned in order to compute bootstrap-error bars for GST estimates.\nParametric bootstrapping uses the estimated gate set to create a newly sampled data set.\nNon-parametric bootstrapping uses the initial dataset and resamples according to the\ncorresp. outcome probabilities.\nEach bootstrap run is initialized with the estimated gate set in order to save processing time. dataset ( xarray.Dataset ) \u2013 A dataset containing counts from the experiment and configurations qubit_layout ( List [ int ] ) \u2013 The list of qubits for the current GST experiment y ( ndarray ) \u2013 The circuit outcome probabilities as a num_povm x num_circuits array K ( ndarray ) \u2013 Each subarray along the first axis contains a set of Kraus operators.\nThe second axis enumerates Kraus operators for a gate specified by the first axis. X ( 3D ndarray ) \u2013 Array where reconstructed CPT superoperators in standard basis are stacked along the first axis. E ( ndarray ) \u2013 Current POVM estimate rho ( ndarray ) \u2013 Current initial state estimate target_mdl ( pygsti model object ) \u2013 The target gate set identifier ( str ) \u2013 The string identifier of the current benchmark parametric ( bool ) \u2013 If set to True, parametric bootstrapping is used, else non-parametric bootstrapping. Default: False X_array ( ndarray ) \u2013 Array containing all estimated gate tensors of different bootstrapping repetitions along first axis E_array ( ndarray ) \u2013 Array containing all estimated POVM tensors of different bootstrapping repetitions along first axis rho_array ( ndarray ) \u2013 Array containing all estimated initial states of different bootstrapping repetitions along first axis df_g_array ( ndarray ) \u2013 Contains gate quality measures of bootstrapping repetitions df_o_array ( ndarray ) \u2013 Contains SPAM and other quality measures of bootstrapping repetitions X_array ( ndarray ) \u2013 Array containing all estimated gate tensors of different bootstrapping repetitions along first axis E_array ( ndarray ) \u2013 Array containing all estimated POVM tensors of different bootstrapping repetitions along first axis rho_array ( ndarray ) \u2013 Array containing all estimated initial states of different bootstrapping repetitions along first axis df_g_array ( ndarray ) \u2013 Contains gate quality measures of bootstrapping repetitions df_o_array ( ndarray ) \u2013 Contains SPAM and other quality measures of bootstrapping repetitions tuple [ Any , Any , Any , Any , Any ] previous iqm.benchmarks.compressive_gst.gst_analysis next iqm.benchmarks.compressive_gst.gst_analysis.dataframe_to_figure By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.ghz",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.ghz.html",
    "description": "GHZ state benchmark Functions fidelity_analysis (run) Analyze counts and compute the state fidelity fidelity_ghz_coherences (dataset,\u00a0...) Estimates the GHZ state fidelity based on the multiple quantu...",
    "content": "GHZ state benchmark Functions fidelity_analysis (run) Analyze counts and compute the state fidelity fidelity_ghz_coherences (dataset,\u00a0...) Estimates the GHZ state fidelity based on the multiple quantum coherences method based on [Mooney, 2021] fidelity_ghz_randomized_measurements (...) Estimates GHZ state fidelity through cross-correlations of RMs. generate_ghz_linear (num_qubits) Generates a GHZ state by applying a Hadamard and a series of CX gates in a linear fashion. generate_ghz_log_cruz (num_qubits) Generates a GHZ state in log-depth according to https://arxiv.org/abs/1807.05572 :param num_qubits: the number of qubits of the GHZ state generate_ghz_log_mooney (num_qubits) Generates a GHZ state in log-depth according to https://arxiv.org/abs/2101.08946 :param num_qubits: the number of qubits of the GHZ state generate_ghz_spanning_tree (graph,\u00a0qubit_layout) Generates a GHZ state in log-depth by computing a minimal spanning tree for a given coupling map. generate_ghz_star (num_qubits) Generates the circuit for creating a GHZ state by maximizing the number of CZ gates between a pair of MOVE gates. get_cx_map (qubit_layout,\u00a0graph) Calculate the cx_map based on participating qubits and the 2QB gate fidelities between them. get_edges (coupling_map,\u00a0qubit_layout[,\u00a0...]) Produces a networkx.Graph from coupling map fidelity information, with edges given by couplings plot_fidelities (observations,\u00a0dataset,\u00a0...) Plots all the fidelities stored in the observations into a single plot of fidelity vs. Classes GHZBenchmark (backend,\u00a0configuration) The GHZ Benchmark estimates the quality of generated Greenberger\u2013Horne\u2013Zeilinger states GHZConfiguration (*,\u00a0benchmark,\u00a0shots,\u00a0...) GHZ state configuration Inheritance previous iqm.benchmarks.entanglement next iqm.benchmarks.entanglement.ghz.fidelity_analysis By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.generate_pauli_dressed_mrb_circuits",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.generate_pauli_dressed_mrb_circuits.html",
    "description": "where for each circuit, random Pauli layers are interleaved between each layer of the circuit qubits ( List [ int ] ) \u2013 the qubits of the backend pauli_samples_per_circ ( int ) \u2013 the number of pauli s...",
    "content": "where for each circuit, random Pauli layers are interleaved between each layer of the circuit qubits ( List [ int ] ) \u2013 the qubits of the backend pauli_samples_per_circ ( int ) \u2013 the number of pauli samples per circuit depth ( int ) \u2013 the depth (number of canonical layers) of the circuit backend_arg ( IQMBackendBase | str ) \u2013 the backend density_2q_gates ( float ) \u2013 the expected density of 2Q gates two_qubit_gate_ensemble ( Optional [ Dict [ str , float ] ] ) \u2013 A dictionary with keys being str specifying 2Q gates, and values being corresponding probabilities.\n* Default is None. clifford_sqg_probability ( float ) \u2013 Probability with which to uniformly sample Clifford 1Q gates.\n* Default is 1.0. sqg_gate_ensemble ( Optional [ Dict [ str , float ] ] ) \u2013 A dictionary with keys being str specifying 1Q gates, and values being corresponding probabilities.\n* Default is None. qiskit_optim_level ( int ) \u2013 Qiskit transpiler optimization level.\n* Default is 1. routing_method ( str ) \u2013 Qiskit transpiler routing method.\n* Default is \u201cbasic\u201d. simulation_method ( Literal [ \"automatic\" , \"statevector\" , \"stabilizer\" , \"extended_stabilizer\" , \"matrix_product_state\" ] ) \u2013 Qiskit\u2019s Aer simulation method\n* Default is \u201cautomatic\u201d. Dict[str, List[QuantumCircuit]] Dict [ str , List [ IQMCircuit ]] previous iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.generate_fixed_depth_mrb_circuits next iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.list_to_numcircuit_times_numpauli_matrix By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.interleaved_rb.interleaved_rb.interleaved_rb_analysis",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.interleaved_rb.interleaved_rb.interleaved_rb_analysis.html",
    "description": "Analysis function for an Interleaved RB experiment run ( RunResult ) \u2013 An interleaved RB experiment run for which analysis result is created AnalysisResult corresponding to Interleaved RB BenchmarkAna...",
    "content": "Analysis function for an Interleaved RB experiment run ( RunResult ) \u2013 An interleaved RB experiment run for which analysis result is created AnalysisResult corresponding to Interleaved RB BenchmarkAnalysisResult previous iqm.benchmarks.randomized_benchmarking.interleaved_rb.interleaved_rb next iqm.benchmarks.randomized_benchmarking.interleaved_rb.interleaved_rb.InterleavedRBConfiguration By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.graph_states.shadow_tomography_analysis",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.graph_states.shadow_tomography_analysis.html",
    "description": "Performs shadow tomography analysis on the given dataset. dataset ( xr.Dataset ) \u2013 The dataset containing the experimental data. all_qubit_pairs_per_group ( Dict [ int , List [ Tuple [ int , int ] ] ]...",
    "content": "Performs shadow tomography analysis on the given dataset. dataset ( xr.Dataset ) \u2013 The dataset containing the experimental data. all_qubit_pairs_per_group ( Dict [ int , List [ Tuple [ int , int ] ] ] ) \u2013 Dictionary mapping group indices to lists of qubit pairs. all_qubit_neighbors_per_group ( Dict [ int , List [ List [ int ] ] ] ) \u2013 Dictionary mapping group indices to lists of neighbor qubit groups. all_unprojected_qubits ( Dict [ int , List [ int ] ] ) \u2013 Dictionary mapping group indices to lists of unprojected qubits. backend_name ( str ) \u2013 The name of the backend used for the experiment. execution_timestamp ( str ) \u2013 The timestamp of the experiment execution. A tuple containing: A dictionary of plots. A list of benchmark observations. A dictionary of maximum negativities. The updated dataset. A dictionary of plots. A list of benchmark observations. A dictionary of maximum negativities. The updated dataset. Tuple[Dict[ str , Any], List[ BenchmarkObservation ], Dict[ str , Dict[ str , str | float ]], xr.Dataset] previous iqm.benchmarks.entanglement.graph_states.plot_max_negativities_graph next iqm.benchmarks.entanglement.graph_states.state_tomography_analysis By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils_shadows.CUE",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils_shadows.CUE.html",
    "description": "Prepares single qubit Haar-random unitary (drawn from Circuilar Unitary Ensemble - CUE). random_gen ( RandomState ) \u2013 a random generator. n ( int ) \u2013 the size of the matrix. an n x n CUE matrix np.nda...",
    "content": "Prepares single qubit Haar-random unitary (drawn from Circuilar Unitary Ensemble - CUE). random_gen ( RandomState ) \u2013 a random generator. n ( int ) \u2013 the size of the matrix. an n x n CUE matrix np.ndarray previous iqm.benchmarks.utils_shadows next iqm.benchmarks.utils_shadows.get_local_shadow By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.benchmark_definition.merge_datasets_dac",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.benchmark_definition.merge_datasets_dac.html",
    "description": "Merges a list of datasets recursively to minimize dataset sizes during merge datasets ( List [ Dataset ] ) \u2013 List[xr.Dateset]\nA list of xarray datasets A list containing a single merged dataset Datase...",
    "content": "Merges a list of datasets recursively to minimize dataset sizes during merge datasets ( List [ Dataset ] ) \u2013 List[xr.Dateset]\nA list of xarray datasets A list containing a single merged dataset Dataset previous iqm.benchmarks.benchmark_definition.default_analysis_function next iqm.benchmarks.benchmark_definition.show_figure By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.direct_rb.direct_rb.DirectRandomizedBenchmarking",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.direct_rb.direct_rb.DirectRandomizedBenchmarking.html",
    "description": "Bases: Benchmark Direct RB estimates the fidelity of layers of canonical gates Attributes name  Methods add_all_meta_to_dataset (dataset) Adds all configuration metadata and circuits to the dataset va...",
    "content": "Bases: Benchmark Direct RB estimates the fidelity of layers of canonical gates Attributes name  Methods add_all_meta_to_dataset (dataset) Adds all configuration metadata and circuits to the dataset variable analysis_function (run) Direct RB analysis function assign_inputs_to_qubits () Assigns all DRB inputs (Optional[Sequence[Any]]) to input qubit layouts. execute (backend) Executes the Direct Randomized Benchmarking benchmark. submit_single_drb_job (backend_arg,\u00a0qubits,\u00a0...) Submit fixed-depth DRB jobs for execution in the specified IQMBackend backend_arg ( IQMBackendBase | str ) \u2013 configuration ( DirectRBConfiguration ) \u2013 Direct RB analysis function run ( BenchmarkRunResult ) \u2013 The result of the benchmark run. AnalysisResult corresponding to DRB. BenchmarkAnalysisResult Adds all configuration metadata and circuits to the dataset variable dataset ( xr.Dataset ) \u2013 The xarray dataset Assigns all DRB inputs (Optional[Sequence[Any]]) to input qubit layouts. Submit fixed-depth DRB jobs for execution in the specified IQMBackend backend_arg ( IQMBackendBase ) \u2013 the IQM backend to submit the job to qubits ( Sequence [ int ] ) \u2013 the qubits to identify the submitted job depth ( int ) \u2013 the depth (number of canonical layers) of the circuits to identify the submitted job sorted_transpiled_circuit_dicts ( Dict [ Tuple [ int , ... ] , List [ QuantumCircuit ] ] ) \u2013 A dictionary containing all MRB circuits Dict with qubit layout, depth, submitted job objects, and submission time Dict [ str , Any ] Executes the Direct Randomized Benchmarking benchmark. backend ( IQMBackendBase ) \u2013 The IQM backend to execute the benchmark on Dataset containing benchmark results and metadata xr.Dataset previous iqm.benchmarks.randomized_benchmarking.direct_rb.direct_rb.DirectRBConfiguration next iqm.benchmarks.randomized_benchmarking.eplg By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.benchmark_definition.show_figure",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.benchmark_definition.show_figure.html",
    "description": "Shows a closed figure. fig \u2013 Figure to show. previous iqm.benchmarks.benchmark_definition.merge_datasets_dac next iqm.benchmarks.benchmark_definition.Benchmark By IQM Benchmarks developers \u00a9 Copyright...",
    "content": "Shows a closed figure. fig \u2013 Figure to show. previous iqm.benchmarks.benchmark_definition.merge_datasets_dac next iqm.benchmarks.benchmark_definition.Benchmark By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.benchmark_definition.BenchmarkAnalysisResult",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.benchmark_definition.BenchmarkAnalysisResult.html",
    "description": "Bases: object A dataclass storing the results of the analysis. The result consists of a dataset, plots, and observations. Plots are defined as a dictionary\nthat maps a plot name to a figure. Observati...",
    "content": "Bases: object A dataclass storing the results of the analysis. The result consists of a dataset, plots, and observations. Plots are defined as a dictionary\nthat maps a plot name to a figure. Observations are key-value pairs of data that contain the\nmain results of the benchmark. Attributes circuits  dataset  plots  observations  Methods __eq__ (other) Return self==value. __repr__ () Return repr(self). from_run_result (run) Creates a new AnalysisResult from a RunResult . plot (plot_name) Plots the given figure. plot_all () Plots all the figures defined for the analysis. dataset ( Dataset ) \u2013 circuits ( Circuits | None ) \u2013 plots ( dict [ str , Figure ] ) \u2013 observations ( list [ BenchmarkObservation ] ) \u2013 Plots the given figure. plot_name ( str ) \u2013 Name of the figure to be plotted. Plots all the figures defined for the analysis. Creates a new AnalysisResult from a RunResult . run ( BenchmarkRunResult ) \u2013 A run for which analysis result is created. previous iqm.benchmarks.benchmark_definition.Benchmark next iqm.benchmarks.benchmark_definition.BenchmarkObservation By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.optimization.qscore.cut_cost_function",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.optimization.qscore.cut_cost_function.html",
    "description": "Returns the number of cut edges in a graph (with minus sign). x ( str ) \u2013 solution bitstring. graph ( networkx graph ) \u2013 the MaxCut problem graph. number of cut edges multiplied by -1. obj ( float ) p...",
    "content": "Returns the number of cut edges in a graph (with minus sign). x ( str ) \u2013 solution bitstring. graph ( networkx graph ) \u2013 the MaxCut problem graph. number of cut edges multiplied by -1. obj ( float ) previous iqm.benchmarks.optimization.qscore.create_objective_function next iqm.benchmarks.optimization.qscore.get_optimal_angles By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.relabel_qubits_array_from_zero",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.relabel_qubits_array_from_zero.html",
    "description": "Helper function to relabel a qubits array to an increasingly ordered one starting from zero\ne.g., [[2,3], [5], [7,8]]  ->  [[0,1], [2], [3,4]]\nNote: this assumes the input array is sorted in increasin...",
    "content": "Helper function to relabel a qubits array to an increasingly ordered one starting from zero\ne.g., [[2,3], [5], [7,8]]  ->  [[0,1], [2], [3,4]]\nNote: this assumes the input array is sorted in increasing order! arr ( List [ List [ int ] ] ) \u2013 the qubits array to relabel. separate_registers ( bool ) \u2013 whether the clbits were generated in separate registers.\n* This has the effect of skipping one value in between each sublist, e.g., [[2,3], [5], [7,8]]  ->  [[0,1], [3], [5,6]]\n* Default is False. reversed_arr ( bool ) \u2013 whether the input array is reversed.\n* This has the effect of reversing the output array, e.g., [[2,3], [5,7], [8]] -> [[0], [1,2], [3,4]]\n* Default is False. the relabeled qubits array. List[List[ int ]] previous iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.plot_rb_decay next iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.submit_parallel_rb_job By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.reduce_to_active_qubits",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.reduce_to_active_qubits.html",
    "description": "Reduces a quantum circuit to only its active qubits. backend_topology ( Optional [ str ] ) \u2013 The backend topology to execute the benchmark on. circuit ( QuantumCircuit ) \u2013 The original quantum circuit...",
    "content": "Reduces a quantum circuit to only its active qubits. backend_topology ( Optional [ str ] ) \u2013 The backend topology to execute the benchmark on. circuit ( QuantumCircuit ) \u2013 The original quantum circuit. backend_num_qubits ( int ) \u2013 The number of qubits in the backend. A new quantum circuit containing only active qubits. QuantumCircuit previous iqm.benchmarks.utils.random_hamiltonian_path next iqm.benchmarks.utils.remove_directed_duplicates_to_list By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.submit_sequential_rb_jobs",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.submit_sequential_rb_jobs.html",
    "description": "Submit sequential RB jobs for execution in the specified IQMBackend\n:param qubits: the qubits to identify the submitted job\n:type qubits: List[int]\n:param transpiled_circuits: A dictionary containing ...",
    "content": "Submit sequential RB jobs for execution in the specified IQMBackend\n:param qubits: the qubits to identify the submitted job\n:type qubits: List[int]\n:param transpiled_circuits: A dictionary containing all MRB circuits\n:type transpiled_circuits: Dict[str, List[QuantumCircuit]]\n:param shots: the number of shots to submit per job\n:type shots: int\n:param backend_arg: the IQM backend to submit the job\n:type backend_arg: IQMBackendBase\n:param calset_id: the calibration identifier\n:type calset_id: Optional[str]\n:param max_gates_per_batch: the maximum number of gates per batch\n:type max_gates_per_batch: Optional[int]\n:param max_circuits_per_batch: the maximum number of circuits per batch\n:type max_circuits_per_batch: Optional[int]\n:param circuit_compilation_options: Compilation options passed to submit_execute\n:type circuit_compilation_options: Optional[CircuitCompilationOptions] Dict with qubit layout, submitted job objects, type (vanilla/DD) and submission time qubits ( List [ int ] ) \u2013 transpiled_circuits ( Dict [ int , List [ IQMCircuit ] ] ) \u2013 shots ( int ) \u2013 backend_arg ( str | IQMBackendBase ) \u2013 calset_id ( str | None ) \u2013 max_gates_per_batch ( int | None ) \u2013 max_circuits_per_batch ( int | None ) \u2013 circuit_compilation_options ( CircuitCompilationOptions | None ) \u2013 List [ Dict [ str , Any ]] previous iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.submit_parallel_rb_job next iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.survival_probabilities_parallel By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.graph_states.state_tomography_analysis",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.graph_states.state_tomography_analysis.html",
    "description": "Performs state tomography analysis on the given dataset. dataset ( xr.Dataset ) \u2013 The dataset containing the experimental data. all_qubit_pairs_per_group ( Dict [ int , List [ Tuple [ int , int ] ] ] ...",
    "content": "Performs state tomography analysis on the given dataset. dataset ( xr.Dataset ) \u2013 The dataset containing the experimental data. all_qubit_pairs_per_group ( Dict [ int , List [ Tuple [ int , int ] ] ] ) \u2013 Dictionary mapping group indices to lists of qubit pairs. all_qubit_neighbors_per_group ( Dict [ int , List [ List [ int ] ] ] ) \u2013 Dictionary mapping group indices to lists of neighbor qubit groups. all_unprojected_qubits ( Dict [ int , List [ int ] ] ) \u2013 Dictionary mapping group indices to lists of unprojected qubits. backend_name ( str ) \u2013 The name of the backend used for the experiment. execution_timestamp ( str ) \u2013 The timestamp of the experiment execution. A tuple containing: A dictionary of plots. A list of benchmark observations. A dictionary of maximum negativities. The updated dataset. A dictionary of plots. A list of benchmark observations. A dictionary of maximum negativities. The updated dataset. Tuple[Dict[ str , Any], List[ BenchmarkObservation ], Dict[ str , Dict[ str , float ]], xr.Dataset] previous iqm.benchmarks.entanglement.graph_states.shadow_tomography_analysis next iqm.benchmarks.entanglement.graph_states.update_pauli_expectations By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.ghz.generate_ghz_log_mooney",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.ghz.generate_ghz_log_mooney.html",
    "description": "Generates a GHZ state in log-depth according to https://arxiv.org/abs/2101.08946 :param num_qubits: the number of qubits of the GHZ state A quantum circuit generating a GHZ state on a given number of ...",
    "content": "Generates a GHZ state in log-depth according to https://arxiv.org/abs/2101.08946 :param num_qubits: the number of qubits of the GHZ state A quantum circuit generating a GHZ state on a given number of qubits. QuantumCircuit num_qubits ( int ) \u2013 previous iqm.benchmarks.entanglement.ghz.generate_ghz_log_cruz next iqm.benchmarks.entanglement.ghz.generate_ghz_spanning_tree By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.quantum_volume.quantum_volume.heavy_projector",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.quantum_volume.quantum_volume.heavy_projector.html",
    "description": "Project (select) the samples from a given probability distribution onto heavy outputs. probabilities ( Dict [ str , float ] ) \u2013 A dictionary of bitstrings and associated probabilities. The dictionary ...",
    "content": "Project (select) the samples from a given probability distribution onto heavy outputs. probabilities ( Dict [ str , float ] ) \u2013 A dictionary of bitstrings and associated probabilities. The dictionary of heavy output bitstrings, all with weight 1. Dict[ str , float ] previous iqm.benchmarks.quantum_volume.quantum_volume.get_rem_hops next iqm.benchmarks.quantum_volume.quantum_volume.is_successful By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.interleaved_rb.interleaved_rb.InterleavedRBConfiguration",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.interleaved_rb.interleaved_rb.InterleavedRBConfiguration.html",
    "description": "Bases: BenchmarkConfigurationBase Interleaved RB configuration.\n.. attribute:: benchmark InterleavedRandomizedBenchmarking. Type[Benchmark] benchmark ( Type [ Benchmark ] ) \u2013 shots ( int ) \u2013 max_gates...",
    "content": "Bases: BenchmarkConfigurationBase Interleaved RB configuration.\n.. attribute:: benchmark InterleavedRandomizedBenchmarking. Type[Benchmark] benchmark ( Type [ Benchmark ] ) \u2013 shots ( int ) \u2013 max_gates_per_batch ( int | None ) \u2013 max_circuits_per_batch ( int | None ) \u2013 calset_id ( str | None ) \u2013 routing_method ( Literal [ 'basic' , 'lookahead' , 'stochastic' , 'sabre' , 'none' ] ) \u2013 physical_layout ( Literal [ 'fixed' , 'batching' ] ) \u2013 use_dd ( bool | None ) \u2013 dd_strategy ( DDStrategy | None ) \u2013 qubits_array ( Sequence [ Sequence [ int ] ] ) \u2013 sequence_lengths ( Sequence [ int ] ) \u2013 num_circuit_samples ( int ) \u2013 parallel_execution ( bool ) \u2013 interleaved_gate ( str ) \u2013 interleaved_gate_params ( Sequence [ float ] | None ) \u2013 simultaneous_fit ( Sequence [ Literal [ 'amplitude' , 'offset' ] ] ) \u2013 The array of physical qubit labels with which to execute IRB. Sequence[Sequence[ int ]] The length of each random Clifford sequence. Sequence[ int ] The number of circuit samples to generate. int The number of measurement shots with which to execute each circuit sample. int Whether the benchmark is executed on all qubits in parallel or not.\n* Default is False. bool The name of the gate to interleave.\n* Should be specified as a qiskit circuit library gate name, e.g., \u201cYGate\u201d or \u201cCZGate\u201d. str Any optional parameters entering the gate.\n* Default is None. Optional[Sequence[ float ]] Optional parameters to fit simultaneously.\n* Default is [\u201camplitude\u201d, \u201coffset\u201d]. Sequence[Literal[\u201camplitude\u201d, \u201coffset\u201d]] Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. benchmark  qubits_array  sequence_lengths  num_circuit_samples  parallel_execution  interleaved_gate  interleaved_gate_params  simultaneous_fit  shots  max_gates_per_batch  max_circuits_per_batch  calset_id  routing_method  physical_layout  use_dd  dd_strategy  Methods Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.benchmarks.randomized_benchmarking.interleaved_rb.interleaved_rb.interleaved_rb_analysis next iqm.benchmarks.randomized_benchmarking.interleaved_rb.interleaved_rb.InterleavedRandomizedBenchmarking By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.html",
    "description": "Mirror Randomized Benchmarking. Functions compute_polarizations (num_qubits,\u00a0...) Estimates the polarization for a list of noisy counts with respect to corresponding ideal counts The polarization here...",
    "content": "Mirror Randomized Benchmarking. Functions compute_polarizations (num_qubits,\u00a0...) Estimates the polarization for a list of noisy counts with respect to corresponding ideal counts The polarization here is a rescaling of the average fidelity, that corrects for few-qubit effects generate_fixed_depth_mrb_circuits (qubits,\u00a0...) Generates a dictionary MRB circuits at fixed depth, indexed by sample number generate_pauli_dressed_mrb_circuits (qubits,\u00a0...) Samples a mirror circuit and generates samples of \"Pauli-dressed\" circuits, list_to_numcircuit_times_numpauli_matrix (...) Convert a flat list to a matrix of shape (num_circ_samples, num_pauli_samples). mrb_analysis (run) Analysis function for a MRB experiment Classes MirrorRBConfiguration (*,\u00a0benchmark,\u00a0shots,\u00a0...) Mirror RB configuration. MirrorRandomizedBenchmarking (backend_arg,\u00a0...) Mirror RB estimates the fidelity of ensembles of n-qubit layers Inheritance previous iqm.benchmarks.randomized_benchmarking.mirror_rb next iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.compute_polarizations By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.MirrorRBConfiguration",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.MirrorRBConfiguration.html",
    "description": "Bases: BenchmarkConfigurationBase Mirror RB configuration. benchmark ( Type [ Benchmark ] ) \u2013 shots ( int ) \u2013 max_gates_per_batch ( int | None ) \u2013 max_circuits_per_batch ( int | None ) \u2013 calset_id ( s...",
    "content": "Bases: BenchmarkConfigurationBase Mirror RB configuration. benchmark ( Type [ Benchmark ] ) \u2013 shots ( int ) \u2013 max_gates_per_batch ( int | None ) \u2013 max_circuits_per_batch ( int | None ) \u2013 calset_id ( str | None ) \u2013 routing_method ( Literal [ 'basic' , 'lookahead' , 'stochastic' , 'sabre' , 'none' ] ) \u2013 physical_layout ( Literal [ 'fixed' , 'batching' ] ) \u2013 use_dd ( bool | None ) \u2013 dd_strategy ( DDStrategy | None ) \u2013 qubits_array ( Sequence [ Sequence [ int ] ] ) \u2013 depths_array ( Sequence [ Sequence [ int ] ] ) \u2013 num_circuit_samples ( int ) \u2013 num_pauli_samples ( int ) \u2013 qiskit_optim_level ( int ) \u2013 two_qubit_gate_ensemble ( Dict [ str , float ] ) \u2013 density_2q_gates ( float ) \u2013 clifford_sqg_probability ( float ) \u2013 sqg_gate_ensemble ( Dict [ str , float ] | None ) \u2013 simulation_method ( Literal [ 'automatic' , 'statevector' , 'stabilizer' , 'extended_stabilizer' , 'matrix_product_state' ] ) \u2013 MirrorRandomizedBenchmarking. Type[ Benchmark ] The array of physical qubits in which to execute MRB. Sequence[Sequence[ int ]] The array of physical depths in which to execute MRB for a corresponding qubit list.\n* If len is the same as that of qubits_array, each Sequence[int] corresponds to the depths for the corresponding layout of qubits.\n* If len is different from that of qubits_array, assigns the first Sequence[int]. Sequence[Sequence[ int ]] The number of random-layer mirror circuits to generate. int The number of random Pauli layers to interleave per mirror circuit. int The number of measurement shots to execute per circuit. int The Qiskit-level of optimization to use in transpilation.\n* Default is 1. int The routing method to use in transpilation.\n* Default is \u201csabre\u201d. Literal[\u201cbasic\u201d, \u201clookahead\u201d, \u201cstochastic\u201d, \u201csabre\u201d, \u201cnone\u201d] The two-qubit gate ensemble to use in the random mirror circuits.\n* Keys correspond to str names of qiskit circuit library gates, e.g., \u201cCZGate\u201d or \u201cCXGate\u201d.\n* Values correspond to the probability for the respective gate to be sampled.\n* Default is {\u201cCZGate\u201d: 1.0}. Dict[ str , float ] The expected density of 2-qubit gates in the final circuits.\n* Default is 0.25. float Probability with which to uniformly sample Clifford 1Q gates.\n* Default is 1.0. float A dictionary with keys being str specifying 1Q gates, and values being corresponding probabilities.\n* Default is None. Optional[Dict[ str , float ]] Qiskit\u2019s Aer simulation method\n* Default is \u201cautomatic\u201d. Literal[\u201cautomatic\u201d, \u201cstatevector\u201d, \u201cstabilizer\u201d, \u201cextended_stabilizer\u201d, \u201cmatrix_product_state\u201d] Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. benchmark  qubits_array  depths_array  num_circuit_samples  num_pauli_samples  qiskit_optim_level  two_qubit_gate_ensemble  density_2q_gates  clifford_sqg_probability  sqg_gate_ensemble  simulation_method  shots  max_gates_per_batch  max_circuits_per_batch  calset_id  routing_method  physical_layout  use_dd  dd_strategy  Methods Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.mrb_analysis next iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.MirrorRandomizedBenchmarking By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.interleaved_rb",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.interleaved_rb.html",
    "description": "Interleaved RB reflects the fidelity of a given gate Subpackages and modules interleaved_rb Interleaved Clifford Randomized Benchmarking. previous iqm.benchmarks.randomized_benchmarking.eplg.eplg.EPLG...",
    "content": "Interleaved RB reflects the fidelity of a given gate Subpackages and modules interleaved_rb Interleaved Clifford Randomized Benchmarking. previous iqm.benchmarks.randomized_benchmarking.eplg.eplg.EPLGConfiguration next iqm.benchmarks.randomized_benchmarking.interleaved_rb.interleaved_rb By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.html",
    "description": "General utility functions Functions bootstrap_counts (original_counts[,\u00a0...]) Returns num_bootstrap_samples resampled copies of the original_counts. count_2q_layers (circuit_list) Calculate the number...",
    "content": "General utility functions Functions bootstrap_counts (original_counts[,\u00a0...]) Returns num_bootstrap_samples resampled copies of the original_counts. count_2q_layers (circuit_list) Calculate the number of layers of parallel 2-qubit gates in a list of circuits. count_native_gates (backend_arg,\u00a0...) Count the number of IQM native gates of each quantum circuit in a list. extract_fidelities (cal_url) Returns couplings and CZ-fidelities from calibration data URL generate_state_tomography_circuits (qc,\u00a0...) Generate all quantum circuits required for a quantum state tomography experiment. get_Pauli_expectation (counts,\u00a0pauli_label) Gets an estimate of a Pauli expectation value for a given set of counts and a Pauli measurement label. get_active_qubits (qc) Extract active qubits from a quantum circuit. get_iqm_backend (backend_label) Get the IQM backend object from a backend name (str). get_measurement_mapping (circuit) Extracts the final measurement mapping (qubits to bits) of a quantum circuit. get_neighbors_of_edges (edges,\u00a0graph) Given a Sequence of edges and a graph, return all neighboring nodes of the edges. get_tomography_matrix (pauli_expectations) Reconstructs a density matrix from given Pauli expectations. marginal_distribution (prob_dist_or_counts,\u00a0...) Compute the marginal distribution over specified bits (indices). median_with_uncertainty (observations) Computes the median of a Sequence of float observations and returns value and propagated uncertainty. perform_backend_transpilation (qc_list,\u00a0...) Transpile a list of circuits to backend specifications. random_hamiltonian_path (G,\u00a0N) Generates a random Hamiltonian path with N vertices from a given NetworkX graph. reduce_to_active_qubits (circuit[,\u00a0...]) Reduces a quantum circuit to only its active qubits. remove_directed_duplicates_to_list (cp_map) Remove duplicate edges from a coupling map and returns as a list of edges (as a list of pairs of vertices). retrieve_all_counts (iqm_jobs[,\u00a0identifier]) Retrieve the counts from a list of IQMJob objects. retrieve_all_job_metadata (iqm_jobs) Retrieve the counts from a list of IQMJob objects. set_coupling_map (qubits,\u00a0backend[,\u00a0...]) Set a coupling map according to the specified physical layout. sort_batches_by_final_layout (...) Sort batches of circuits according to the final measurement mapping in their corresponding backend. split_into_disjoint_pairs (pairs) Split a Sequence of pairs of integers into a List of a minimal number of Lists of disjoint pairs. split_sequence_in_chunks (sequence_in,\u00a0split_size) Split a given Sequence into chunks of a given split size, return as a List of Sequences. submit_execute (sorted_transpiled_qc_list,\u00a0...) Submit function to execute lists of quantum circuits on the specified backend, timeit (f) Calculates the amount of time a function takes to execute. xrvariable_to_counts (dataset,\u00a0identifier,\u00a0...) Retrieve counts from xarray dataset. previous iqm.benchmarks.readout_mitigation.M3IQM next iqm.benchmarks.utils.bootstrap_counts By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.xrvariable_to_counts",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.xrvariable_to_counts.html",
    "description": "Retrieve counts from xarray dataset. dataset ( xr.Dataset ) \u2013 the dataset to extract counts from. identifier ( str ) \u2013 the identifier for the dataset counts. counts_range ( int ) \u2013 the range of counts...",
    "content": "Retrieve counts from xarray dataset. dataset ( xr.Dataset ) \u2013 the dataset to extract counts from. identifier ( str ) \u2013 the identifier for the dataset counts. counts_range ( int ) \u2013 the range of counts to extract (e.g., the amount of circuits that were executed). A list of counts dictionaries from the dataset. List[Dict[ str , int ]] previous iqm.benchmarks.utils.timeit next iqm.benchmarks.utils_plots By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.random_hamiltonian_path",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.random_hamiltonian_path.html",
    "description": "Generates a random Hamiltonian path with N vertices from a given NetworkX graph. G ( networkx.Graph ) \u2013 The input graph. N ( int ) \u2013 The desired number of vertices in the Hamiltonian path. A list of e...",
    "content": "Generates a random Hamiltonian path with N vertices from a given NetworkX graph. G ( networkx.Graph ) \u2013 The input graph. N ( int ) \u2013 The desired number of vertices in the Hamiltonian path. A list of edges (tuples of nodes) representing the Hamiltonian path, or an empty list if not possible. list previous iqm.benchmarks.utils.perform_backend_transpilation next iqm.benchmarks.utils.reduce_to_active_qubits By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.lmfit_minimizer",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.lmfit_minimizer.html",
    "description": "fit_parameters ( Parameters ) \u2013 the parameters to fit fit_data ( np.ndarray ) \u2013 the data to fit depths ( List [ int ] ) \u2013 the depths of the RB experiment func ( Callable ) \u2013 the model function for fit...",
    "content": "fit_parameters ( Parameters ) \u2013 the parameters to fit fit_data ( np.ndarray ) \u2013 the data to fit depths ( List [ int ] ) \u2013 the depths of the RB experiment func ( Callable ) \u2013 the model function for fitting the result of the minimization MinimizerResult previous iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.import_native_gate_cliffords next iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.plot_rb_decay By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.multi_lmfit.eval_func_single_dataset",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.multi_lmfit.eval_func_single_dataset.html",
    "description": "Returns the evaluation of the fit function for a single dataset previous iqm.benchmarks.randomized_benchmarking.multi_lmfit.create_multi_dataset_params next iqm.benchmarks.randomized_benchmarking.mult...",
    "content": "Returns the evaluation of the fit function for a single dataset previous iqm.benchmarks.randomized_benchmarking.multi_lmfit.create_multi_dataset_params next iqm.benchmarks.randomized_benchmarking.multi_lmfit.get_param_names_from_func_signature By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.optimization.qscore.qscore_analysis",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.optimization.qscore.qscore_analysis.html",
    "description": "Analysis function for a QScore experiment run ( RunResult ) \u2013 A QScore experiment run for which analysis result is created AnalysisResult corresponding to QScore BenchmarkAnalysisResult previous iqm.b...",
    "content": "Analysis function for a QScore experiment run ( RunResult ) \u2013 A QScore experiment run for which analysis result is created AnalysisResult corresponding to QScore BenchmarkAnalysisResult previous iqm.benchmarks.optimization.qscore.plot_approximation_ratios next iqm.benchmarks.optimization.qscore.run_QAOA By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.ghz.get_edges",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.ghz.get_edges.html",
    "description": "and edge weights given by fidelities coupling_map ( CouplingMap ) \u2013 The list pairs on which 2-qubit gates are natively supported qubit_layout ( List [ int ] ) \u2013 The subset of system-qubits used in the...",
    "content": "and edge weights given by fidelities coupling_map ( CouplingMap ) \u2013 The list pairs on which 2-qubit gates are natively supported qubit_layout ( List [ int ] ) \u2013 The subset of system-qubits used in the protocol, indexed from 0 edges_cal ( Optional [ List [ List [ int ] ] ] ) \u2013 A coupling map of qubit pairs that have CZ fidelities in the calibration data fidelities_cal ( Optional [ List [ float ] ] ) \u2013 A list of CZ fidelities ordered in the same way as edges_cal networkx.Graph The final weighted graph for the given calibration or coupling map The final weighted graph for the given calibration or coupling map graph previous iqm.benchmarks.entanglement.ghz.get_cx_map next iqm.benchmarks.entanglement.ghz.plot_fidelities By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.ghz.generate_ghz_spanning_tree",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.ghz.generate_ghz_spanning_tree.html",
    "description": "Generates a GHZ state in log-depth by computing a minimal spanning tree for a given coupling map. graph ( Graph ) \u2013 networkx.Graph\nA graph of the backend coupling map qubit_layout ( List [ int ] ) \u2013 L...",
    "content": "Generates a GHZ state in log-depth by computing a minimal spanning tree for a given coupling map. graph ( Graph ) \u2013 networkx.Graph\nA graph of the backend coupling map qubit_layout ( List [ int ] ) \u2013 List[int]\nThe subset of system-qubits used in the protocol, indexed from 0 n_state ( int | None ) \u2013 int\nThe number of qubits for which a GHZ state should be created. This values should be smaller or equal to\nthe number of qubits in qubit_layout QuantumCircuit A quantum circuit generating a GHZ state of n qubits participating_qubits: List[int] The list of qubits on which the GHZ state is defined. This is a subset of qubit_layout with size n_state A quantum circuit generating a GHZ state of n qubits The list of qubits on which the GHZ state is defined. This is a subset of qubit_layout with size n_state qc previous iqm.benchmarks.entanglement.ghz.generate_ghz_log_mooney next iqm.benchmarks.entanglement.ghz.generate_ghz_star By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.direct_rb.direct_rb.DirectRBConfiguration",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.direct_rb.direct_rb.DirectRBConfiguration.html",
    "description": "Bases: BenchmarkConfigurationBase Direct RB configuration benchmark ( Type [ Benchmark ] ) \u2013 shots ( int ) \u2013 max_gates_per_batch ( int | None ) \u2013 max_circuits_per_batch ( int | None ) \u2013 calset_id ( st...",
    "content": "Bases: BenchmarkConfigurationBase Direct RB configuration benchmark ( Type [ Benchmark ] ) \u2013 shots ( int ) \u2013 max_gates_per_batch ( int | None ) \u2013 max_circuits_per_batch ( int | None ) \u2013 calset_id ( str | None ) \u2013 routing_method ( Literal [ 'basic' , 'lookahead' , 'stochastic' , 'sabre' , 'none' ] ) \u2013 physical_layout ( Literal [ 'fixed' , 'batching' ] ) \u2013 use_dd ( bool | None ) \u2013 dd_strategy ( DDStrategy | None ) \u2013 qubits_array ( Sequence [ Sequence [ int ] ] | Sequence [ Sequence [ Sequence [ int ] ] ] ) \u2013 is_eplg ( bool ) \u2013 parallel_execution ( bool ) \u2013 depths ( Sequence [ int ] ) \u2013 num_circuit_samples ( int ) \u2013 qiskit_optim_level ( int ) \u2013 two_qubit_gate_ensembles ( Sequence [ Dict [ str , float ] ] | None ) \u2013 densities_2q_gates ( Sequence [ float ] | None ) \u2013 clifford_sqg_probabilities ( Sequence [ float ] | None ) \u2013 sqg_gate_ensembles ( Sequence [ Dict [ str , float ] ] | None ) \u2013 DirectRandomizedBenchmarking. Type[ Benchmark ] The array of physical qubits in which to execute DRB.\n* It can be specified as a Sequence (e.g. list or tuple) of qubit-index registers, e.g., [[0, 1], [2, 3]],\nor as Sequences of such Sequences, e.g., [[[0, 1], [2, 3]], [[0, 2], [1, 3]]].\nIn the second case, each Sequence[Sequence[int]] will execute sequentially, i.e.,\nexecution will be done for [[0, 1], [2, 3]] first, then for [[0, 2], [1, 3]],\neach either in parallel or sequence, according to the (bool) value of parallel_execution. Sequence[Sequence[ int ]] | Sequence[Sequence[Sequence[ int ]]] Whether the DRB experiment is executed as a EPLG subroutine.\n* If True:\n- default parallel_execution below is override to True.\n- default two_qubit_gate_ensembles is {\u201cCZGate\u201d: 1.0}.\n- default densities_2q_gates is 0.5 (probability of sampling 2Q gates is 1).\n- default clifford_sqg_probabilities is 0.0.\n- default sqg_gate_ensembles is {\u201cIGate\u201d: 1.0}.\n* Default is False. bool Whether DRB is executed in parallel for all qubit layouts in qubits_array.\n* If is_eplg is False, it executes parallel DRB with MRB gate ensemble and density defaults.\n* Default is False. bool The list of layer depths in which to execute DRB for all qubit layouts in qubits_array. Sequence[ int ] The number of random-layer DRB circuits to generate. int The number of measurement shots to execute per circuit. int The Qiskit-level of optimization to use in transpilation.\n* Default is 1. int The routing method to use in transpilation.\n* Default is \u201csabre\u201d. Literal[\u201cbasic\u201d, \u201clookahead\u201d, \u201cstochastic\u201d, \u201csabre\u201d, \u201cnone\u201d] The two-qubit gate ensembles to use in the random DRB circuits.\n* Keys correspond to str names of qiskit circuit library gates, e.g., \u201cCZGate\u201d or \u201cCXGate\u201d.\n* Values correspond to the probability for the respective gate to be sampled.\n* Each Dict[str,float] corresponds to each qubit layout in qubits_array.\n* If len(two_qubit_gate_ensembles) != len(qubits_array), the first Dict is assigned by default.\n* Default is None, which assigns {str(q): {\u201cCZGate\u201d: 1.0} for q in qubits_array}. Optional[Sequence[Dict[ str , float ]]] The expected densities of 2-qubit gates in the final circuits per qubit layout.\n* If len(densities_2q_gates) != len(qubits_array), the first density value is assigned by default.\n* Default is None, which assigns 0.25 to all qubit layouts. Optional[Sequence[ float ]] Probability with which to uniformly sample Clifford 1Q gates per qubit layout.\n* Default is None, which assigns 1.0 to all qubit layouts. Optional[Sequence[ float ]] A dictionary with keys being str specifying 1Q gates, and values being corresponding probabilities.\n* If len(sqg_gate_ensembles) != len(qubits_array), the first ensemble is assigned by default.\n* Default is None, which leaves only uniform sampling of 1Q Clifford gates. Optional[Sequence[Dict[ str , float ]]] Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. benchmark  qubits_array  is_eplg  parallel_execution  depths  num_circuit_samples  qiskit_optim_level  two_qubit_gate_ensembles  densities_2q_gates  clifford_sqg_probabilities  sqg_gate_ensembles  routing_method  shots  max_gates_per_batch  max_circuits_per_batch  calset_id  physical_layout  use_dd  dd_strategy  Methods Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.benchmarks.randomized_benchmarking.direct_rb.direct_rb.generate_fixed_depth_parallel_drb_circuits next iqm.benchmarks.randomized_benchmarking.direct_rb.direct_rb.DirectRandomizedBenchmarking By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.mrb_analysis",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.mrb_analysis.html",
    "description": "Analysis function for a MRB experiment run ( RunResult ) \u2013 A MRB experiment run for which analysis result is created AnalysisResult corresponding to MRB BenchmarkAnalysisResult previous iqm.benchmarks...",
    "content": "Analysis function for a MRB experiment run ( RunResult ) \u2013 A MRB experiment run for which analysis result is created AnalysisResult corresponding to MRB BenchmarkAnalysisResult previous iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.list_to_numcircuit_times_numpauli_matrix next iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.MirrorRBConfiguration By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils_plots.draw_graph_edges",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils_plots.draw_graph_edges.html",
    "description": "Draw given edges on a graph within the given backend. backend_coupling_map ( CouplingMap ) \u2013 The coupling map to draw the graph from. backend_num_qubits ( int ) \u2013 The number of qubits of the respectve...",
    "content": "Draw given edges on a graph within the given backend. backend_coupling_map ( CouplingMap ) \u2013 The coupling map to draw the graph from. backend_num_qubits ( int ) \u2013 The number of qubits of the respectve backend. edge_list ( Sequence [ Tuple [ int , int ] ] ) \u2013 The edge list of the linear chain. timestamp ( str ) \u2013 The timestamp to include in the figure name. disjoint_layers ( Optional [ Sequence [ Sequence [ Tuple [ int , int ] ] ] ) \u2013 Sequences of edges defining disjoint layers to draw.\n* Default is None. station ( Optional [ str ] ) \u2013 The name of the station.\n* Default is None. qubit_names ( Optional [ Dict [ int , str ] ] ) \u2013 A dictionary mapping qubit indices to their names.\n* Default is None. is_eplg ( Optional [ bool ] ) \u2013 A flag indicating if the graph refers to an EPLG experiment.\n* Default is False. The figure name and the figure object. Tuple[ str , Figure] previous iqm.benchmarks.utils_plots next iqm.benchmarks.utils_plots.evaluate_hamiltonian_paths By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.generate_fixed_depth_mrb_circuits",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.generate_fixed_depth_mrb_circuits.html",
    "description": "Generates a dictionary MRB circuits at fixed depth, indexed by sample number qubits ( List [ int ] ) \u2013 A list of integers specifying physical qubit labels circ_samples ( int ) \u2013 The number of sets of ...",
    "content": "Generates a dictionary MRB circuits at fixed depth, indexed by sample number qubits ( List [ int ] ) \u2013 A list of integers specifying physical qubit labels circ_samples ( int ) \u2013 The number of sets of Pauli-dressed circuit samples pauli_samples_per_circ ( int ) \u2013 the number of pauli samples per circuit depth ( int ) \u2013 the depth (number of canonical layers) of the circuits backend_arg ( IQMBackendBase | str ) \u2013 the backend density_2q_gates ( float ) \u2013 the expected density of 2Q gates two_qubit_gate_ensemble ( Optional [ Dict [ str , float ] ] ) \u2013 A dictionary with keys being str specifying 2Q gates, and values being corresponding probabilities.\n* Default is None. two_qubit_gate_ensemble \u2013 clifford_sqg_probability ( float ) \u2013 Probability with which to uniformly sample Clifford 1Q gates.\n* Default is 1.0. sqg_gate_ensemble ( Optional [ Dict [ str , float ] ] ) \u2013 A dictionary with keys being str specifying 1Q gates, and values being corresponding probabilities.\n* Default is None. qiskit_optim_level ( int ) \u2013 Qiskit transpiler optimization level.\n* Default is 1. routing_method ( str ) \u2013 Qiskit transpiler routing method.\n* Default is \u201cbasic\u201d. simulation_method ( Literal [ \"automatic\" , \"statevector\" , \"stabilizer\" , \"extended_stabilizer\" , \"matrix_product_state\" ] ) \u2013 Qiskit\u2019s Aer simulation method\n* Default is \u201cautomatic\u201d. A dictionary of lists of Pauli-dressed quantum circuits corresponding to the circuit sample index Dict [ int , Dict [ str , List [ IQMCircuit ]]] previous iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.compute_polarizations next iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.generate_pauli_dressed_mrb_circuits By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.circuit_containers.CircuitGroup",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.circuit_containers.CircuitGroup.html",
    "description": "Bases: object Group of IQMCircuits . It represents a list of circuits with a common purpose, typically executed in a batch. circuits ( List [ IQMCircuit ] ) \u2013 name ( str | None ) \u2013 List of IQMCircuit ...",
    "content": "Bases: object Group of IQMCircuits . It represents a list of circuits with a common purpose, typically executed in a batch. circuits ( List [ IQMCircuit ] ) \u2013 name ( str | None ) \u2013 List of IQMCircuit . List[ iqm.qiskit_iqm.iqm_circuit.IQMCircuit ] Name of the group. str | None Attributes circuit_names Name of all the circuits contained in the group as a string name  qubit_layouts The qubit layouts contained in all the circuits, where the qubits are represented by an instance of Qubit . qubit_layouts_by_index The qubit layouts contained in all the circuits, where the qubits are represented by an integer. qubits The set of active qubits in all of the circuits circuits  Methods __eq__ (other) Return self==value. __getitem__ (key)  __repr__ () Return repr(self). __setitem__ (key,\u00a0value)  add_circuit (circuit) Adds a circuit to the internal list get_circuits_by_name (name) Returns a list of the internal circuits that share the same name The qubit layouts contained in all the circuits, where the qubits are represented by an integer. All qubit layouts. The qubit layouts contained in all the circuits, where the qubits are represented by an instance of Qubit . All qubit layouts. The set of active qubits in all of the circuits A set of Qubit Adds a circuit to the internal list circuit ( IQMCircuit ) \u2013 Circuit to add. Name of all the circuits contained in the group as a string List of strings Returns a list of the internal circuits that share the same name name ( str ) \u2013 Name of the circuit to return as a string The circuit with the desired name as a string, or None if they are not found. IQMCircuit | None previous iqm.benchmarks.circuit_containers.BenchmarkCircuit next iqm.benchmarks.circuit_containers.Circuits By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.quantum_volume.clops.retrieve_clops_elapsed_times",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.quantum_volume.clops.retrieve_clops_elapsed_times.html",
    "description": "Retrieve the elapsed times from the CLOPS job metadata job_meta ( Dict [ Dict [ str , Any ] ] ) \u2013 A dictionary of CLOPS jobs metadata A dictionary of elapsed times of all CLOPS jobs Dict[ str , float ...",
    "content": "Retrieve the elapsed times from the CLOPS job metadata job_meta ( Dict [ Dict [ str , Any ] ] ) \u2013 A dictionary of CLOPS jobs metadata A dictionary of elapsed times of all CLOPS jobs Dict[ str , float ] previous iqm.benchmarks.quantum_volume.clops.plot_times next iqm.benchmarks.quantum_volume.clops.CLOPSBenchmark By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.readout_mitigation",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.readout_mitigation.html",
    "description": "M3 modification for readout mitigation at IQM QPU\u2019s. Functions apply_readout_error_mitigation (backend_arg,\u00a0...) param backend_arg : the backend to calibrate an M3 mitigator against. the backend to ca...",
    "content": "M3 modification for readout mitigation at IQM QPU\u2019s. Functions apply_readout_error_mitigation (backend_arg,\u00a0...) param backend_arg : the backend to calibrate an M3 mitigator against. the backend to calibrate an M3 mitigator against. readout_error_m3 (counts,\u00a0mit,\u00a0qubits) Counts processor using M3IQM for readout error mitigation. Classes M3IQM ([system,\u00a0iter_threshold]) M3 readout mitigation class modified to work with IQM devices. Inheritance previous iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.validate_rb_qubits next iqm.benchmarks.readout_mitigation.apply_readout_error_mitigation By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.count_2q_layers",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.count_2q_layers.html",
    "description": "Calculate the number of layers of parallel 2-qubit gates in a list of circuits. circuit_list ( List [ QuantumCircuit ] ) \u2013 the list of quantum circuits to analyze. the number of layers of parallel 2-q...",
    "content": "Calculate the number of layers of parallel 2-qubit gates in a list of circuits. circuit_list ( List [ QuantumCircuit ] ) \u2013 the list of quantum circuits to analyze. the number of layers of parallel 2-qubit gates in the list of circuits. List[ int ] previous iqm.benchmarks.utils.bootstrap_counts next iqm.benchmarks.utils.count_native_gates By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.compressive_gst.compressive_gst.create_predefined_gate_set",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.compressive_gst.compressive_gst.create_predefined_gate_set.html",
    "description": "Create a list of quantum circuits corresponding to a predefined gate set. The circuits are assigned to the specified qubit_layouts on the backend only during transipilation, so the qubit labels\nat thi...",
    "content": "Create a list of quantum circuits corresponding to a predefined gate set. The circuits are assigned to the specified qubit_layouts on the backend only during transipilation, so the qubit labels\nat this stage may not represent the actual qubit labels on the backend. gate_set ( str | List [ Any ] ) \u2013 str\nThe name of the gate set num_qubits ( int ) \u2013 qubit_layouts ( List [ List [ int ] ] ) \u2013 List[QuantumCircuit] The gate set as a list of circuits gate_labels_dict: Dict[str, Dict[int, str]] The names of gates, i.e. \u201cRx_pi_2\u201d for a pi/2 rotation around the x-axis. num_gates: int The number of gates in the gate set The gate set as a list of circuits The names of gates, i.e. \u201cRx_pi_2\u201d for a pi/2 rotation around the x-axis. The number of gates in the gate set gates previous iqm.benchmarks.compressive_gst.compressive_gst next iqm.benchmarks.compressive_gst.compressive_gst.parse_gate_set By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils_plots.evaluate_hamiltonian_paths",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils_plots.evaluate_hamiltonian_paths.html",
    "description": "Evaluates Hamiltonian paths according to the product of 2Q gate fidelities on the corresponding edges of the backend graph. N ( int ) \u2013 the number of vertices in the Hamiltonian paths to evaluate. pat...",
    "content": "Evaluates Hamiltonian paths according to the product of 2Q gate fidelities on the corresponding edges of the backend graph. N ( int ) \u2013 the number of vertices in the Hamiltonian paths to evaluate. path_samples ( int ) \u2013 the number of Hamiltonian paths to evaluate. backend_arg ( str | IQMBackendBase ) \u2013 the backend to evaluate the Hamiltonian paths on with respect to fidelity. url ( str ) \u2013 the URL address for the backend to retrieve calibration data from. max_tries ( int ) \u2013 the maximum number of tries to generate a Hamiltonian path. A dictionary with keys being fidelity products and values being the respective Hamiltonian paths. Dict[ int , List[Tuple[ int , int ]]] previous iqm.benchmarks.utils_plots.draw_graph_edges next iqm.benchmarks.utils_plots.plot_layout_fidelity_graph By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.compressive_gst.compressive_gst.GSTConfiguration",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.compressive_gst.compressive_gst.GSTConfiguration.html",
    "description": "Bases: BenchmarkConfigurationBase Compressive GST configuration base. benchmark ( Type [ Benchmark ] ) \u2013 shots ( int ) \u2013 max_gates_per_batch ( int | None ) \u2013 max_circuits_per_batch ( int | None ) \u2013 ca...",
    "content": "Bases: BenchmarkConfigurationBase Compressive GST configuration base. benchmark ( Type [ Benchmark ] ) \u2013 shots ( int ) \u2013 max_gates_per_batch ( int | None ) \u2013 max_circuits_per_batch ( int | None ) \u2013 calset_id ( str | None ) \u2013 routing_method ( Literal [ 'basic' , 'lookahead' , 'stochastic' , 'sabre' , 'none' ] ) \u2013 physical_layout ( Literal [ 'fixed' , 'batching' ] ) \u2013 use_dd ( bool | None ) \u2013 dd_strategy ( DDStrategy | None ) \u2013 qubit_layouts ( List [ int ] | List [ List [ int ] ] ) \u2013 gate_set ( str | List [ Any ] ) \u2013 num_circuits ( int ) \u2013 rank ( int ) \u2013 gate_labels ( List | None ) \u2013 seq_len_list ( list [ int ] ) \u2013 from_init ( bool ) \u2013 max_inits ( int ) \u2013 opt_method ( str ) \u2013 max_iterations ( str | List [ int ] ) \u2013 convergence_criteria ( str | List [ float ] ) \u2013 batch_size ( str | int ) \u2013 bootstrap_samples ( int ) \u2013 testing ( bool ) \u2013 parallel_execution ( bool ) \u2013 GHZBenchmark Type[ Benchmark ] A sequence (e.g., Tuple or List) of sequences of\nphysical qubit layouts, as specified by integer labels, where the benchmark is meant to be run. Sequence[Sequence[ int ]] The gate set in given either as a list of qiskit quantum\ncirucuits, or as one of the predefined gate sets \u201c1QXYI\u201d, \u201c2QXYCZ\u201d, \u201c2QXYCZ_extended\u201d, \u201c3QXYCZ\u201d.\nA gate set should be tomographically complete, meaning from the specified gates and the vacuum state, one\nshould be able to prepare states that form a frame for the state space. A practical sufficient condition\nis that the gate set is able the generate all combinations of local Pauli eigenstates. Union[ str , List[Type[QuantumCircuit]]] How many random circuits are generated from the gate set. Guidelines on choosing this value:\n- At least 50 circuits for a single qubit gate set with 3 gates.\n- At least 400 circuits for a two qubit gate set with 6 gates.\n- At least 2000 circuits for a three qubit gate set with 9 gates.\nThe number of random circuits needed is expected to grow linearly in the number of gates and exponentially\nin the number of qubits. int The Kraus rank of the reconstruction. Choose rank=1 for coherent error analysis and rank<=dim**2\ngenerally. int The number of measurement shots per circuit.\n* Default: 1024 int Names of the gates in the gate set. Used for plots and result tables.\n* Default: None Union[Dict, None] Three numbers controling the depth of the random sequences. The first is the minimal\ndepth, the last is the maximal depth and the middle number specifies a cutoff depth below which all possible\nsequences are selected.\n* Default: [1, 8, 14] list [ int ] Whether the target gate set is used as an initialization to the mGST algorithm.\n* Default: True bool If from_init = False, random initial points are tried and this parameter limits the amount of\nretries.\n* Default: 20 int Which optimization method is used, can be either of \u201cGD\u201d or \u201cSFN\u201d, for gradient descent or\nsaddle free Newton, respectively.\n* Default: \u201cauto\u201d (Method is automatically selected based on qubit count and rank) str How many iterations to run the optimization algorithm for. Accepted\nvalues are either \u201cauto\u201d or a list of two integers. The first specifies the number of iterations for the\noptimization on batches or circuit data, while the second specifies the number of iterations on the full\ndata for all circuits.\n* Default: \u201cauto\u201d (Numbers are automatically selected based on qubit count and rank) Union[ str , List[ int ]] Two parameters which determine when the optimization algorithm\nterminates. The first is a multiplier which specifies how close the cost function should get to a threshold\nfor the given shot noise in order for the optimization to be considered \u201csuccessful\u201d. Values in [2,10] are\nusually sensible. The second parameter sets the relative change in cost function between\ntwo consecutive iterations, below which the algorithm terminates.\n* Default: [4, 1e-4] Union[ str , List[ float ]] The number of circuits per batch in the optimization. This hyperparamters is\nautomatically set and determines the convergence behaviour. A smaller batch size reduces runtime but can\nlead to erratic jumps in parameter space and lack of convergence.\n* Default: \u201cauto\u201d Union[ str , int ] The number of times the optimization algorithm is repeated on fake data to estimate\nthe uncertainty via bootstrapping. int Whether to run the circuits for all layouts in parallel on the backend. bool Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. benchmark  qubit_layouts  gate_set  num_circuits  rank  shots  gate_labels  seq_len_list  from_init  max_inits  opt_method  max_iterations  convergence_criteria  batch_size  bootstrap_samples  testing  parallel_execution  max_gates_per_batch  max_circuits_per_batch  calset_id  routing_method  physical_layout  use_dd  dd_strategy  Methods Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.benchmarks.compressive_gst.compressive_gst.CompressiveGST next iqm.benchmarks.compressive_gst.gst_analysis By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.submit_parallel_rb_job",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.submit_parallel_rb_job.html",
    "description": "Submit fixed-depth parallel MRB jobs for execution in the specified IQMBackend\n:param backend_arg: the IQM backend to submit the job\n:type backend_arg: IQMBackendBase\n:param qubits_array: the qubits t...",
    "content": "Submit fixed-depth parallel MRB jobs for execution in the specified IQMBackend\n:param backend_arg: the IQM backend to submit the job\n:type backend_arg: IQMBackendBase\n:param qubits_array: the qubits to identify the submitted job\n:type qubits_array: Sequence[Sequence[int]]\n:param depth: the depth (number of canonical layers) of the circuits to identify the submitted job\n:type depth: int\n:param sorted_transpiled_circuit_dicts: A dictionary containing all MRB circuits\n:type sorted_transpiled_circuit_dicts: Dict[Tuple[int,\u2026], List[QuantumCircuit]]\n:param shots: the number of shots to submit the job\n:type shots: int\n:param calset_id: the calibration identifier\n:type calset_id: Optional[str]\n:param max_gates_per_batch: the maximum number of gates per batch to submit the job\n:type max_gates_per_batch: Optional[str]\n:param max_circuits_per_batch: the maximum number of circuits per batch to submit the job.\n:type max_circuits_per_batch: Optional[int] Dict with qubit layout, submitted job objects, type (vanilla/DD) and submission time backend_arg ( IQMBackendBase ) \u2013 qubits_array ( Sequence [ Sequence [ int ] ] ) \u2013 depth ( int ) \u2013 sorted_transpiled_circuit_dicts ( Dict [ Tuple [ int , ... ] , List [ IQMCircuit ] ] ) \u2013 shots ( int ) \u2013 calset_id ( str | None ) \u2013 max_gates_per_batch ( str | None ) \u2013 max_circuits_per_batch ( int | None ) \u2013 Dict [ str , Any ] previous iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.relabel_qubits_array_from_zero next iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.submit_sequential_rb_jobs By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.benchmark_definition.BenchmarkRunResult",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.benchmark_definition.BenchmarkRunResult.html",
    "description": "Bases: object A dataclass that stores the results of a single run of a Benchmark. RunResult should contain enough information that the Benchmark can be analyzed based on those\nresults. Attributes data...",
    "content": "Bases: object A dataclass that stores the results of a single run of a Benchmark. RunResult should contain enough information that the Benchmark can be analyzed based on those\nresults. Attributes dataset  circuits  Methods __eq__ (other) Return self==value. __repr__ () Return repr(self). dataset ( Dataset ) \u2013 circuits ( Circuits ) \u2013 previous iqm.benchmarks.benchmark_definition.BenchmarkObservationIdentifier next iqm.benchmarks.circuit_containers By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.optimization.qscore.QScoreConfiguration",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.optimization.qscore.QScoreConfiguration.html",
    "description": "Bases: BenchmarkConfigurationBase Q-score configuration. benchmark ( Type [ Benchmark ] ) \u2013 shots ( int ) \u2013 max_gates_per_batch ( int | None ) \u2013 max_circuits_per_batch ( int | None ) \u2013 calset_id ( str...",
    "content": "Bases: BenchmarkConfigurationBase Q-score configuration. benchmark ( Type [ Benchmark ] ) \u2013 shots ( int ) \u2013 max_gates_per_batch ( int | None ) \u2013 max_circuits_per_batch ( int | None ) \u2013 calset_id ( str | None ) \u2013 routing_method ( Literal [ 'basic' , 'lookahead' , 'stochastic' , 'sabre' , 'none' ] ) \u2013 physical_layout ( Literal [ 'fixed' , 'batching' ] ) \u2013 use_dd ( bool | None ) \u2013 dd_strategy ( DDStrategy | None ) \u2013 num_instances ( int ) \u2013 num_qaoa_layers ( int ) \u2013 min_num_nodes ( int ) \u2013 max_num_nodes ( int | None ) \u2013 use_virtual_node ( bool ) \u2013 use_classically_optimized_angles ( bool ) \u2013 choose_qubits_routine ( Literal [ 'naive' , 'custom' ] ) \u2013 min_num_qubits ( int ) \u2013 custom_qubits_array ( Sequence [ Sequence [ int ] ] | None ) \u2013 qiskit_optim_level ( int ) \u2013 optimize_sqg ( bool ) \u2013 seed ( int ) \u2013 REM ( bool ) \u2013 mit_shots ( int ) \u2013 QScoreBenchmark Type[ Benchmark ] Number of random graphs to be chosen. int Depth of the QAOA circuit.\n* Default is 1. int The min number of nodes to be taken into account, which should be >= 2.\n* Default is 2. int The max number of nodes to be taken into account, which has to be <= num_qubits + 1.\n* Default is None int Parameter to increase the potential Qscore by +1.\n* Default is True. bool Use pre-optimised tuned parameters in the QAOA circuit.\n* Default is True. bool The routine to select qubit layouts.\n* Default is \u201ccustom\u201d. Literal[\u201ccustom\u201d] Minumum number of qubits.\n* Default is 2 int The physical qubit layouts to perform the benchmark on.\nIf virtual_node is set to True, then a given graph with n nodes requires n-1 selected qubits.\nIf virtual_node is set to False, then a given graph with n nodes requires n selected qubits.\n* Default is None. Optional[Sequence[Sequence[ int ]]] The Qiskit transpilation optimization level.\n* Default is 3. int Whether Single Qubit Gate Optimization is performed upon transpilation.\n* Default is True. bool The random seed.\n* Default is 1. int Use readout error mitigation.\n* Default is False. bool (int): Number of shots used in readout error mitigation.\n* Default is 1000. int Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. benchmark  num_instances  num_qaoa_layers  min_num_nodes  max_num_nodes  use_virtual_node  use_classically_optimized_angles  choose_qubits_routine  min_num_qubits  custom_qubits_array  qiskit_optim_level  optimize_sqg  seed  REM  mit_shots  shots  max_gates_per_batch  max_circuits_per_batch  calset_id  routing_method  physical_layout  use_dd  dd_strategy  Methods Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.benchmarks.optimization.qscore.QScoreBenchmark next iqm.benchmarks.quantum_volume By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.graph_states.GraphStateConfiguration",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.graph_states.GraphStateConfiguration.html",
    "description": "Bases: BenchmarkConfigurationBase Graph States Benchmark configuration. benchmark ( Type [ Benchmark ] ) \u2013 shots ( int ) \u2013 max_gates_per_batch ( int | None ) \u2013 max_circuits_per_batch ( int | None ) \u2013 ...",
    "content": "Bases: BenchmarkConfigurationBase Graph States Benchmark configuration. benchmark ( Type [ Benchmark ] ) \u2013 shots ( int ) \u2013 max_gates_per_batch ( int | None ) \u2013 max_circuits_per_batch ( int | None ) \u2013 calset_id ( str | None ) \u2013 routing_method ( Literal [ 'basic' , 'lookahead' , 'stochastic' , 'sabre' , 'none' ] ) \u2013 physical_layout ( Literal [ 'fixed' , 'batching' ] ) \u2013 use_dd ( bool | None ) \u2013 dd_strategy ( DDStrategy | None ) \u2013 qubits ( Sequence [ int ] ) \u2013 tomography ( Literal [ 'state_tomography' , 'shadow_tomography' ] ) \u2013 num_bootstraps ( int ) \u2013 n_random_unitaries ( int ) \u2013 n_median_of_means ( int ) \u2013 GraphStateBenchmark Type[ Benchmark ] The physical qubit layout in which to benchmark graph state generation. Sequence[ int ] Whether to use state or shadow tomography.\n* Default is \u201cstate_tomography\u201d. Literal[\u201cstate_tomography\u201d, \u201cshadow_tomography\u201d] The amount of bootstrap samples to use with state tomography.\n* Default is 50. int The number of Haar random single-qubit unitaries to use for (local) shadow tomography.\n* Default is 100. int The number of mean samples over n_random_unitaries to generate a median of means estimator for shadow tomography.\n* NB: The total amount of execution calls will be a multiplicative factor of n_random_unitaries x n_median_of_means.\n* Default is 1 (no median of means). int Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. benchmark  qubits  tomography  num_bootstraps  n_random_unitaries  n_median_of_means  shots  max_gates_per_batch  max_circuits_per_batch  calset_id  routing_method  physical_layout  use_dd  dd_strategy  Methods Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.benchmarks.entanglement.graph_states.GraphStateBenchmark next iqm.benchmarks.logging_config By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.optimization",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.optimization.html",
    "description": "Q-score estimates the size of combinatorial optimization problems a given number of qubits can execute with meaningful results. Subpackages and modules qscore Qscore benchmark previous iqm.benchmarks....",
    "content": "Q-score estimates the size of combinatorial optimization problems a given number of qubits can execute with meaningful results. Subpackages and modules qscore Qscore benchmark previous iqm.benchmarks.logging_config next iqm.benchmarks.optimization.qscore By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.benchmark.BenchmarkConfigurationBase",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.benchmark.BenchmarkConfigurationBase.html",
    "description": "Bases: BaseModel Benchmark configuration base. benchmark ( Type [ BenchmarkBase ] ) \u2013 shots ( int ) \u2013 max_gates_per_batch ( int | None ) \u2013 max_circuits_per_batch ( int | None ) \u2013 calset_id ( str | Non...",
    "content": "Bases: BaseModel Benchmark configuration base. benchmark ( Type [ BenchmarkBase ] ) \u2013 shots ( int ) \u2013 max_gates_per_batch ( int | None ) \u2013 max_circuits_per_batch ( int | None ) \u2013 calset_id ( str | None ) \u2013 routing_method ( Literal [ 'basic' , 'lookahead' , 'stochastic' , 'sabre' , 'none' ] ) \u2013 physical_layout ( Literal [ 'fixed' , 'batching' ] ) \u2013 use_dd ( bool | None ) \u2013 dd_strategy ( DDStrategy | None ) \u2013 the benchmark configuration. Type[ BenchmarkBase ] the number of shots to use in circuit execution.\n* Default for all benchmarks is 2**8. int the maximum number of gates per circuit batch.\n* Default for all benchmarks is None. Optional[ int ] the maximum number of circuits per batch.\n* Default for all benchmarks is None. Optional[ int ] the calibration ID to use in circuit execution.\n* Default for all benchmarks is None (uses last available calibration ID). Optional[ str ] the Qiskit routing method to use in transpilation.\n* Default for all benchmarks is \u201csabre\u201d. Literal[\u201cbasic\u201d, \u201clookahead\u201d, \u201cstochastic\u201d, \u201csabre\u201d, \u201cnone\u201d] whether physical layout is constrained during transpilation to selected physical qubits.\n- \u201cfixed\u201d: physical layout is constrained during transpilation to the selected initial physical qubits.\n- \u201cbatching\u201d: physical layout is allowed to use any other physical qubits, and circuits are batched according to final measured qubits.\n* Default for all benchmarks is \u201cfixed\u201d. Literal[\u201cfixed\u201d, \u201cbatching\u201d] Boolean flag determining whether to enable dynamical decoupling during circuit execution.\n* Default: False bool Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. benchmark  shots  max_gates_per_batch  max_circuits_per_batch  calset_id  routing_method  physical_layout  use_dd  dd_strategy  Methods Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.benchmarks.benchmark.BenchmarkBase next iqm.benchmarks.benchmark_definition By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.logging_config",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.logging_config.html",
    "description": "Module to initialize logger. Should be used in every module to output information/warnings. previous iqm.benchmarks.entanglement.graph_states.GraphStateConfiguration next iqm.benchmarks.optimization B...",
    "content": "Module to initialize logger. Should be used in every module to output information/warnings. previous iqm.benchmarks.entanglement.graph_states.GraphStateConfiguration next iqm.benchmarks.optimization By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.optimization.qscore.is_successful",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.optimization.qscore.is_successful.html",
    "description": "Check whether a Q-score benchmark returned approximation ratio above beta*, therefore being successful. This condition checks that the mean approximation ratio is above the beta* = 0.2 threshold. appr...",
    "content": "Check whether a Q-score benchmark returned approximation ratio above beta*, therefore being successful. This condition checks that the mean approximation ratio is above the beta* = 0.2 threshold. approximation_ratio ( float ) \u2013 the mean approximation ratio of all problem graphs whether the Q-score benchmark was successful bool previous iqm.benchmarks.optimization.qscore.get_optimal_angles next iqm.benchmarks.optimization.qscore.plot_approximation_ratios By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.compressive_gst.gst_analysis.pandas_results_to_observations",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.compressive_gst.gst_analysis.pandas_results_to_observations.html",
    "description": "Converts high level GST results from a pandas Dataframe to a simple observation dictionary dataset ( Dataset ) \u2013 xarray.Dataset\nA dataset containing counts from the experiment and configurations qubit...",
    "content": "Converts high level GST results from a pandas Dataframe to a simple observation dictionary dataset ( Dataset ) \u2013 xarray.Dataset\nA dataset containing counts from the experiment and configurations qubit_layout \u2013 List[int]\nThe list of qubits for the current GST experiment df_g ( DataFrame ) \u2013 Pandas DataFrame\nThe dataframe with properly formated gate results df_o ( DataFrame ) \u2013 Pandas DataFrame\nThe dataframe with properly formated non-gate results like SPAM error measures or fit quality. identifier ( BenchmarkObservationIdentifier ) \u2013 BenchmarkObservationIdentifier\nAn identifier object for the current GST run List[BenchmarkObservation] List of observations converted from the pandas dataframes List of observations converted from the pandas dataframes observation_list previous iqm.benchmarks.compressive_gst.gst_analysis.mgst_analysis next iqm.benchmarks.compressive_gst.gst_analysis.result_str_to_floats By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.quantum_volume",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.quantum_volume.html",
    "description": "Quantum Volume reflects the deepest circuit a given number of qubits can execute with meaningful results. (CLOPS_v corresponding to QV circuits, CLOPS_h to square, parallel-gate layered, circuits) Sub...",
    "content": "Quantum Volume reflects the deepest circuit a given number of qubits can execute with meaningful results. (CLOPS_v corresponding to QV circuits, CLOPS_h to square, parallel-gate layered, circuits) Subpackages and modules clops CLOPS benchmark quantum_volume Quantum Volume benchmark previous iqm.benchmarks.optimization.qscore.QScoreConfiguration next iqm.benchmarks.quantum_volume.clops By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.ghz.generate_ghz_log_cruz",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.ghz.generate_ghz_log_cruz.html",
    "description": "Generates a GHZ state in log-depth according to https://arxiv.org/abs/1807.05572 :param num_qubits: the number of qubits of the GHZ state A quantum circuit generating a GHZ state on a given number of ...",
    "content": "Generates a GHZ state in log-depth according to https://arxiv.org/abs/1807.05572 :param num_qubits: the number of qubits of the GHZ state A quantum circuit generating a GHZ state on a given number of qubits. QuantumCircuit num_qubits ( int ) \u2013 previous iqm.benchmarks.entanglement.ghz.generate_ghz_linear next iqm.benchmarks.entanglement.ghz.generate_ghz_log_mooney By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.extract_fidelities",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.extract_fidelities.html",
    "description": "Returns couplings and CZ-fidelities from calibration data URL cal_url ( str ) \u2013 str\nThe url under which the calibration data for the backend can be found List[List[int]] A list of pairs, each of which...",
    "content": "Returns couplings and CZ-fidelities from calibration data URL cal_url ( str ) \u2013 str\nThe url under which the calibration data for the backend can be found List[List[int]] A list of pairs, each of which is a qubit coupling for which the calibration\ndata contains a fidelity. list_fids: List[float] A list of CZ fidelities from the calibration url, ordered in the same way as list_couplings topology: str Name of the chip topology layout, currently either \u201cstar\u201d or \u201ccrystal\u201d A list of pairs, each of which is a qubit coupling for which the calibration\ndata contains a fidelity. A list of CZ fidelities from the calibration url, ordered in the same way as list_couplings Name of the chip topology layout, currently either \u201cstar\u201d or \u201ccrystal\u201d list_couplings previous iqm.benchmarks.utils.count_native_gates next iqm.benchmarks.utils.generate_state_tomography_circuits By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.quantum_volume.quantum_volume.plot_hop_threshold",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.quantum_volume.quantum_volume.plot_hop_threshold.html",
    "description": "Generate the figure representing each HOP, the average and the threshold. qubits ( List [ int ] ) \u2013 the list of qubit labels. depth ( int ) \u2013 the depth of the QV circuit. qv_result ( List [ float ] ) ...",
    "content": "Generate the figure representing each HOP, the average and the threshold. qubits ( List [ int ] ) \u2013 the list of qubit labels. depth ( int ) \u2013 the depth of the QV circuit. qv_result ( List [ float ] ) \u2013 the list of HOP. qv_results_type ( str ) \u2013 whether results come from vanilla or DD execution. num_sigmas ( int ) \u2013 the number of sigmas to plot. backend_name ( str ) \u2013 the name of the backend. timestamp ( str ) \u2013 the execution timestamp. in_volumetric ( bool ) \u2013 whether the QV benchmark is being executed in the context of a volumetric benchmark.\nDefaults to False. plot_rem ( bool ) \u2013 whether the plot corresponds to REM corrected data. the name of the figure.\nFigure: the figure. str previous iqm.benchmarks.quantum_volume.quantum_volume.is_successful next iqm.benchmarks.quantum_volume.quantum_volume.qv_analysis By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.quantum_volume.quantum_volume.get_ideal_heavy_outputs",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.quantum_volume.quantum_volume.get_ideal_heavy_outputs.html",
    "description": "Calculate the heavy output bitrstrings of a list of quantum circuits. qc_list ( List [ QuantumCircuit ] ) \u2013 the list of quantum circuits. sorted_qc_list_indices ( Dict [ Tuple , List [ int ] ] ) \u2013 dic...",
    "content": "Calculate the heavy output bitrstrings of a list of quantum circuits. qc_list ( List [ QuantumCircuit ] ) \u2013 the list of quantum circuits. sorted_qc_list_indices ( Dict [ Tuple , List [ int ] ] ) \u2013 dictionary of indices (integers) corresponding to those in the original (untranspiled) list of circuits, with keys being final physical qubit measurements the list of heavy output dictionaries of each of the quantum circuits. List[Dict[ str , float ]] previous iqm.benchmarks.quantum_volume.quantum_volume.cumulative_std next iqm.benchmarks.quantum_volume.quantum_volume.get_rem_hops By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.quantum_volume.quantum_volume.QuantumVolumeBenchmark",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.quantum_volume.quantum_volume.QuantumVolumeBenchmark.html",
    "description": "Bases: Benchmark Quantum Volume reflects the deepest circuit a given number of qubits can execute with meaningful results. Attributes name  Methods add_all_circuits_to_dataset (dataset) Adds all gener...",
    "content": "Bases: Benchmark Quantum Volume reflects the deepest circuit a given number of qubits can execute with meaningful results. Attributes name  Methods add_all_circuits_to_dataset (dataset) Adds all generated circuits during execution to the dataset variable add_all_meta_to_dataset (dataset) Adds all configuration metadata and circuits to the dataset variable analysis_function (run) Analysis function for a Quantum Volume experiment execute (backend) Executes the benchmark. generate_circuit_list (num_qubits[,\u00a0depth,\u00a0...]) Generate a list of QV quantum circuits, with measurements at the end. generate_single_circuit (num_qubits[,\u00a0depth,\u00a0...]) Generate a single QV quantum circuit, with measurements at the end. get_rem_quasidistro (...) Computes readout-error-mitigated quasiprobabilities. submit_single_qv_job (backend,\u00a0qubits,\u00a0...) Submit a single set of QV jobs for execution in the specified IQMBackend: backend_arg ( IQMBackendBase | str ) \u2013 configuration ( QuantumVolumeConfiguration ) \u2013 Analysis function for a Quantum Volume experiment run ( RunResult ) \u2013 A Quantum Volume experiment run for which analysis result is created AnalysisResult corresponding to Quantum Volume BenchmarkAnalysisResult Adds all configuration metadata and circuits to the dataset variable dataset ( xr.Dataset ) \u2013 The xarray dataset Adds all generated circuits during execution to the dataset variable dataset ( xr.Dataset ) \u2013 The xarray dataset Returns: Generate a single QV quantum circuit, with measurements at the end. num_qubits ( int ) \u2013 number of qubits of the circuit depth ( Optional [ int ] ) \u2013 The depth of the QV circuit. Defaults to None, which makes it equal to the number of\nqubits. classical_permutation ( bool , optional ) \u2013 Whether permutations are classical, avoiding swapping layers.\n* Defaults to True. the QV quantum circuit. QuantumCircuit Generate a list of QV quantum circuits, with measurements at the end. num_qubits ( int ) \u2013 the number of qubits of the circuits. depth ( Optional [ int ] ) \u2013 The depth of the QV circuit. Defaults to None, which makes it equal to the number of qubits. classical_permutations ( bool , optional ) \u2013 Whether permutations are classical, avoiding swapping layers.\n* Defaults to True. the list of QV quantum circuits. List[QuantumCircuit] Computes readout-error-mitigated quasiprobabilities. sorted_transpiled_qc_list ( Dict [ Tuple , List [ QuantumCircuit ] ] ) \u2013 A dictionary of lists of quantum circuits, indexed by qubiy layouts. sorted_qc_list_indices ( Dict [ Tuple , List [ int ] ] ) \u2013 dictionary of indices (integers) corresponding to those in the original (untranspiled) list of circuits, with keys being final physical qubit measurements. execution_results ( List [ Dict [ str , int ] ] ) \u2013 counts from execution of all quantum circuits. mit_shots ( int ) \u2013 The number of measurement shots to estimate the readout calibration errors. A list of lists of quasiprobabilities. List [ List [ QuasiCollection ]] Organizes the results in a dictionary with the qubit layout, the submitted job objects, the type of QV results and submission time. backend ( IQMBackendBase ) \u2013 the IQM backend to submit the job. qubits ( List [ int ] ) \u2013 the qubits to identify the submitted job. sorted_transpiled_qc_list ( Dict [ Tuple [ int , ... ] | str , List [ QuantumCircuit ] ] ) \u2013 A dictionary of Lists of quantum circuits. Dict with qubit layout, submitted job objects, type (vanilla/DD) and submission time. Dict [ str , Any ] Executes the benchmark. backend ( IQMBackendBase ) \u2013 Dataset previous iqm.benchmarks.quantum_volume.quantum_volume.qv_analysis next iqm.benchmarks.quantum_volume.quantum_volume.QuantumVolumeConfiguration By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.circuit_containers.Circuits",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.circuit_containers.Circuits.html",
    "description": "Bases: object Container for all the BenchmarkCircuit that are generated in a single benchmark execution. benchmark_circuits ( List [ BenchmarkCircuit ] ) \u2013 List of BenchmarkCircuit contained. List[ iq...",
    "content": "Bases: object Container for all the BenchmarkCircuit that are generated in a single benchmark execution. benchmark_circuits ( List [ BenchmarkCircuit ] ) \u2013 List of BenchmarkCircuit contained. List[ iqm.benchmarks.circuit_containers.BenchmarkCircuit ] Attributes benchmark_circuits  Methods __eq__ (other) Return self==value. __getitem__ (key)  __repr__ () Return repr(self). __setitem__ (key,\u00a0value)  get_benchmark_circuits_by_name (name) Returned the BenchmarkCircuit by name. Returned the BenchmarkCircuit by name. name ( str ) \u2013 Name of the requested BenchmarkCircuit as a string The requested BenchmarkCircuit if it exists, None otherwise BenchmarkCircuit | None previous iqm.benchmarks.circuit_containers.CircuitGroup next iqm.benchmarks.compressive_gst By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.benchmark_definition.add_counts_to_dataset",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.benchmark_definition.add_counts_to_dataset.html",
    "description": "Adds the counts from a cortex job result to the given dataset.\nIf counts with the same identifier are already present in the old dataset, then both counts are added together. counts ( List [ Dict [ st...",
    "content": "Adds the counts from a cortex job result to the given dataset.\nIf counts with the same identifier are already present in the old dataset, then both counts are added together. counts ( List [ Dict [ str , int ] ] ) \u2013 A list of dictionaries with counts of bitstrings. identifier ( str ) \u2013 A string to identify the current data, for instance the qubit layout. dataset ( xr.Dataset ) \u2013 Dataset to add results to. xarray.Dataset A merged dataset where the new counts are added the input dataset A merged dataset where the new counts are added the input dataset dataset_merged previous iqm.benchmarks.benchmark_definition next iqm.benchmarks.benchmark_definition.default_analysis_function By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.html",
    "description": "GHZ verifies the generation of Greenberger-Horne-Zeilinger states\nGraph State estimates the amount of bipartite entanglement of native graph states Subpackages and modules ghz GHZ state benchmark grap...",
    "content": "GHZ verifies the generation of Greenberger-Horne-Zeilinger states\nGraph State estimates the amount of bipartite entanglement of native graph states Subpackages and modules ghz GHZ state benchmark graph_states Graph states benchmark previous iqm.benchmarks.compressive_gst.gst_analysis.run_mGST_wrapper next iqm.benchmarks.entanglement.ghz By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.generate_state_tomography_circuits",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.generate_state_tomography_circuits.html",
    "description": "Generate all quantum circuits required for a quantum state tomography experiment. qc ( QuantumCircuit ) \u2013 The quantum circuit. active_qubits ( Sequence [ int ] ) \u2013 The qubits to perform tomograhy on. ...",
    "content": "Generate all quantum circuits required for a quantum state tomography experiment. qc ( QuantumCircuit ) \u2013 The quantum circuit. active_qubits ( Sequence [ int ] ) \u2013 The qubits to perform tomograhy on. measure_other ( Optional [ Sequence [ int ] ] ) \u2013 Whether to measure other qubits in the qc QuantumCircuit.\n* Default is None. measure_other_name ( Optional [ str ] ) \u2013 Name of the classical register to assign measure_other. native ( bool ) \u2013 Whether circuits are prepared using IQM-native gates.\n* Default is True. A dictionary with keys being Pauli (measurement) strings and values the respective circuit. Pauli strings are ordered for qubit labels in increasing order, e.g., \u201cXY\u201d for active_qubits 4, 1 corresponds to \u201cX\u201d measurement on qubit 1 and \u201cY\u201d measurement on qubit 4. Pauli strings are ordered for qubit labels in increasing order, e.g., \u201cXY\u201d for active_qubits 4, 1 corresponds to \u201cX\u201d measurement on qubit 1 and \u201cY\u201d measurement on qubit 4. Dict[ str , QuantumCircuit] previous iqm.benchmarks.utils.extract_fidelities next iqm.benchmarks.utils.get_Pauli_expectation By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.interleaved_rb.interleaved_rb.InterleavedRandomizedBenchmarking",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.interleaved_rb.interleaved_rb.InterleavedRandomizedBenchmarking.html",
    "description": "Bases: Benchmark Interleaved RB estimates the average gate fidelity of a specific Clifford gate Attributes name  Methods add_all_circuits_to_dataset (dataset) Adds all generated circuits during execut...",
    "content": "Bases: Benchmark Interleaved RB estimates the average gate fidelity of a specific Clifford gate Attributes name  Methods add_all_circuits_to_dataset (dataset) Adds all generated circuits during execution to the dataset variable add_all_meta_to_dataset (dataset) Adds all configuration metadata and circuits to the dataset variable :param dataset: The xarray dataset :type dataset: xr.Dataset analysis_function (run) Analysis function for an Interleaved RB experiment execute (backend) Executes the benchmark backend_arg ( IQMBackendBase | str ) \u2013 configuration ( InterleavedRBConfiguration ) \u2013 Analysis function for an Interleaved RB experiment run ( RunResult ) \u2013 An interleaved RB experiment run for which analysis result is created AnalysisResult corresponding to Interleaved RB BenchmarkAnalysisResult Adds all configuration metadata and circuits to the dataset variable\n:param dataset: The xarray dataset\n:type dataset: xr.Dataset dataset ( Dataset ) \u2013 Adds all generated circuits during execution to the dataset variable dataset ( xr.Dataset ) \u2013 The xarray dataset Returns: Executes the benchmark backend ( IQMBackendBase ) \u2013 Dataset previous iqm.benchmarks.randomized_benchmarking.interleaved_rb.interleaved_rb.InterleavedRBConfiguration next iqm.benchmarks.randomized_benchmarking.mirror_rb By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.validate_irb_gate",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.validate_irb_gate.html",
    "description": "Validate that an input gate is Clifford and transpiled to IQM\u2019s native basis gate_id ( str ) \u2013 the gate identifier as a Qiskit circuit library operator backend_arg ( IQMBackendBase ) \u2013 the IQM backend...",
    "content": "Validate that an input gate is Clifford and transpiled to IQM\u2019s native basis gate_id ( str ) \u2013 the gate identifier as a Qiskit circuit library operator backend_arg ( IQMBackendBase ) \u2013 the IQM backend to verify transpilation gate_params ( Optional [ List [ float ] ] ) \u2013 the gate parameters Transpiled circuit IQMCircuit previous iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.survival_probabilities_parallel next iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common.validate_rb_qubits By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.eplg.eplg.eplg_analysis",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.eplg.eplg.eplg_analysis.html",
    "description": "EPLG analysis function run ( BenchmarkRunResult ) \u2013 The result of the benchmark run. AnalysisResult corresponding to DRB. BenchmarkAnalysisResult previous iqm.benchmarks.randomized_benchmarking.eplg.e...",
    "content": "EPLG analysis function run ( BenchmarkRunResult ) \u2013 The result of the benchmark run. AnalysisResult corresponding to DRB. BenchmarkAnalysisResult previous iqm.benchmarks.randomized_benchmarking.eplg.eplg next iqm.benchmarks.randomized_benchmarking.eplg.eplg.plot_layered_fidelities_graph By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.quantum_volume.clops.plot_times",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.quantum_volume.clops.plot_times.html",
    "description": "Generate a figure representing the different elapsed times in the CLOPS experiment. clops_data ( xr.Dataset ) \u2013 The dataset including elapsed time data from the CLOPS experiment observations ( Dict [ ...",
    "content": "Generate a figure representing the different elapsed times in the CLOPS experiment. clops_data ( xr.Dataset ) \u2013 The dataset including elapsed time data from the CLOPS experiment observations ( Dict [ int , Dict [ str , Dict [ str , float ] ] ] ) \u2013 The observations from the analysis of the CLOPS experiment. the name of the figure.\nFigure: the figure. str previous iqm.benchmarks.quantum_volume.clops.clops_analysis next iqm.benchmarks.quantum_volume.clops.retrieve_clops_elapsed_times By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.graph_states.GraphStateBenchmark",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.graph_states.GraphStateBenchmark.html",
    "description": "Bases: Benchmark The Graph States benchmark estimates the bipartite entangelement negativity of native graph states. Attributes name  Methods add_all_circuits_to_dataset (dataset) Adds all generated c...",
    "content": "Bases: Benchmark The Graph States benchmark estimates the bipartite entangelement negativity of native graph states. Attributes name  Methods add_all_circuits_to_dataset (dataset) Adds all generated circuits during execution to the dataset variable add_all_meta_to_dataset (dataset) Adds all configuration metadata and circuits to the dataset variable analysis_function (run) Analysis function for a Graph State benchmark experiment. execute (backend) Executes the benchmark. generate_all_circuit_info_for_graph_state_benchmark () Generates all circuits and associated information for the Graph State benchmark: backend_arg ( IQMBackendBase ) \u2013 configuration ( GraphStateConfiguration ) \u2013 Analysis function for a Graph State benchmark experiment. run ( BenchmarkRunResult ) \u2013 BenchmarkAnalysisResult Adds all configuration metadata and circuits to the dataset variable dataset ( xr.Dataset ) \u2013 The xarray dataset Adds all generated circuits during execution to the dataset variable dataset ( xr.Dataset ) \u2013 The xarray dataset Returns: Generates native graph states Identifies all pairs of qubits with disjoint neighbors Generates all projected nodes to cover all pairs of qubits with disjoint neighbors A dictionary containing all circuit information for the Graph State benchmark. Dict[ str , Any] Executes the benchmark. Dataset previous iqm.benchmarks.entanglement.graph_states.update_pauli_expectations next iqm.benchmarks.entanglement.graph_states.GraphStateConfiguration By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.timeit",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.timeit.html",
    "description": "Calculates the amount of time a function takes to execute. f \u2013 The function to add the timing attribute to. The decorated function execution with logger statement of elapsed time in execution. previou...",
    "content": "Calculates the amount of time a function takes to execute. f \u2013 The function to add the timing attribute to. The decorated function execution with logger statement of elapsed time in execution. previous iqm.benchmarks.utils.submit_execute next iqm.benchmarks.utils.xrvariable_to_counts By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils_plots.GraphPositions",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils_plots.GraphPositions.html",
    "description": "Bases: object A class to store and generate graph positions for different chip layouts. This class contains predefined node positions for various quantum chip topologies and\nprovides methods to genera...",
    "content": "Bases: object A class to store and generate graph positions for different chip layouts. This class contains predefined node positions for various quantum chip topologies and\nprovides methods to generate positions for different layout types. Mapping of node indices to (x,y) positions for Garnet chip. Dict[ int , Tuple[ int , int ]] Mapping of node indices to (x,y) positions for Deneb chip. Dict[ int , Tuple[ int , int ]] Mapping of chip names to their position dictionaries. Dict[ str , Dict[ int , Tuple[ int , int ]]] Attributes deneb_positions  garnet_positions  predefined_stations  Methods __eq__ (other) Return self==value. __repr__ () Return repr(self). create_positions (graph[,\u00a0topology]) Generate node positions for a given graph and topology. Generate node positions for a given graph and topology. graph ( PyGraph ) \u2013 The graph to generate positions for. topology ( Optional [ Literal [ \"star\" , \"crystal\" ] ] ) \u2013 The type of layout to generate. Must be either \u201cstar\u201d or \u201ccrystal\u201d. A dictionary mapping node indices to (x,y) coordinates. Dict[ int , Tuple[ float , float ]] previous iqm.benchmarks.utils_plots.rx_to_nx_graph next iqm.benchmarks.utils_shadows By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.html",
    "description": "Randomized Benchmarking reflects the fidelity of a gate or operation on a number of qubits Subpackages and modules clifford_rb Clifford RB reflects the fidelity of Clifford gates direct_rb Direct RB e...",
    "content": "Randomized Benchmarking reflects the fidelity of a gate or operation on a number of qubits Subpackages and modules clifford_rb Clifford RB reflects the fidelity of Clifford gates direct_rb Direct RB estimates the layer fidelity of canonical gates eplg Error Per Layered Gate (EPLG) estimates the layer fidelity of 2Q gate layers. interleaved_rb Interleaved RB reflects the fidelity of a given gate mirror_rb Mirror RB estimates the average layer fidelity of ensembles of gates multi_lmfit Lmfit for multiple datasets, generalized and extended version of the shown example in the lmfit documentation: https://lmfit.github.io/lmfit-py/examples/example_fit_multi_datasets.html#sphx-glr-examples-example-fit-multi-datasets-py randomized_benchmarking_common Common functions for Randomized Benchmarking-based techniques previous iqm.benchmarks.quantum_volume.quantum_volume.QuantumVolumeConfiguration next iqm.benchmarks.randomized_benchmarking.clifford_rb By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.multi_lmfit.get_param_names_from_func_signature",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.multi_lmfit.get_param_names_from_func_signature.html",
    "description": "Gets the function parameter names from its signature previous iqm.benchmarks.randomized_benchmarking.multi_lmfit.eval_func_single_dataset next iqm.benchmarks.randomized_benchmarking.multi_lmfit.multi_...",
    "content": "Gets the function parameter names from its signature previous iqm.benchmarks.randomized_benchmarking.multi_lmfit.eval_func_single_dataset next iqm.benchmarks.randomized_benchmarking.multi_lmfit.multi_dataset_residual By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.optimization.qscore.calculate_optimal_angles_for_QAOA_p1",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.optimization.qscore.calculate_optimal_angles_for_QAOA_p1.html",
    "description": "Calculates the optimal angles for single layer QAOA MaxCut ansatz. graph ( networkx graph ) \u2013 the MaxCut problem graph. optimal angles gamma and beta. List[ float ] previous iqm.benchmarks.optimizatio...",
    "content": "Calculates the optimal angles for single layer QAOA MaxCut ansatz. graph ( networkx graph ) \u2013 the MaxCut problem graph. optimal angles gamma and beta. List[ float ] previous iqm.benchmarks.optimization.qscore next iqm.benchmarks.optimization.qscore.compute_expectation_value By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.multi_lmfit.multi_dataset_residual",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.multi_lmfit.multi_dataset_residual.html",
    "description": "Calculate total residual for fits of func to several data sets. previous iqm.benchmarks.randomized_benchmarking.multi_lmfit.get_param_names_from_func_signature next iqm.benchmarks.randomized_benchmark...",
    "content": "Calculate total residual for fits of func to several data sets. previous iqm.benchmarks.randomized_benchmarking.multi_lmfit.get_param_names_from_func_signature next iqm.benchmarks.randomized_benchmarking.randomized_benchmarking_common By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.compressive_gst.gst_analysis.generate_non_gate_results",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.compressive_gst.gst_analysis.generate_non_gate_results.html",
    "description": "Creates error bars (if bootstrapping was used) and formats results for non-gate errors.\nThe resulting tables are also turned into figures, so that they can be saved automatically. dataset ( Dataset ) ...",
    "content": "Creates error bars (if bootstrapping was used) and formats results for non-gate errors.\nThe resulting tables are also turned into figures, so that they can be saved automatically. dataset ( Dataset ) \u2013 xr.Dataset\nA dataset containing counts from the experiment and configurations qubit_layout ( List [ int ] ) \u2013 List[int]\nThe list of qubits for the current GST experiment df_o ( DataFrame ) \u2013 Pandas DataFrame\nA dataframe containing the non-gate quality metrics (SPAM errors and fit quality) Pandas DataFrame The final formated results The final formated results df_o_final previous iqm.benchmarks.compressive_gst.gst_analysis.generate_gate_results next iqm.benchmarks.compressive_gst.gst_analysis.generate_unit_rank_gate_results By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.ghz.generate_ghz_linear",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.ghz.generate_ghz_linear.html",
    "description": "Generates a GHZ state by applying a Hadamard and a series of CX gates in a linear fashion.\nThe construction is symmetrized to halve the circuit depth.\n:param num_qubits: the number of qubits of the GH...",
    "content": "Generates a GHZ state by applying a Hadamard and a series of CX gates in a linear fashion.\nThe construction is symmetrized to halve the circuit depth.\n:param num_qubits: the number of qubits of the GHZ state A quantum circuit generating a GHZ state on a given number of qubits. QuantumCircuit num_qubits ( int ) \u2013 previous iqm.benchmarks.entanglement.ghz.fidelity_ghz_randomized_measurements next iqm.benchmarks.entanglement.ghz.generate_ghz_log_cruz By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.ghz.fidelity_ghz_randomized_measurements",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.ghz.fidelity_ghz_randomized_measurements.html",
    "description": "Estimates GHZ state fidelity through cross-correlations of RMs.\nImplementation of Eq. (34) in https://arxiv.org/abs/1812.02624 dataset ( xr.Dataset ) \u2013 qubit_layout \u2013 List[int]: The subset of system-q...",
    "content": "Estimates GHZ state fidelity through cross-correlations of RMs.\nImplementation of Eq. (34) in https://arxiv.org/abs/1812.02624 dataset ( xr.Dataset ) \u2013 qubit_layout \u2013 List[int]: The subset of system-qubits used in the protocol ideal_probabilities ( List [ Dict [ str , int ] ] ) \u2013 num_qubits ( int ) \u2013 Number of qubits circuits ( Circuits ) \u2013 Instance of Circuits containing transpiled circuits dict[str, Any] The fidelities uncertainties: dict[str, Any] The uncertainties for the fidelities The fidelities The uncertainties for the fidelities values previous iqm.benchmarks.entanglement.ghz.fidelity_ghz_coherences next iqm.benchmarks.entanglement.ghz.generate_ghz_linear By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.direct_rb.direct_rb.generate_drb_circuits",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.direct_rb.direct_rb.generate_drb_circuits.html",
    "description": "Stabilizer preparation - Layers of canonical randomly sampled gates - Stabilizer measurement qubits ( List [ int ] ) \u2013 the qubits of the backend. depth ( int ) \u2013 the depth (number of canonical layers)...",
    "content": "Stabilizer preparation - Layers of canonical randomly sampled gates - Stabilizer measurement qubits ( List [ int ] ) \u2013 the qubits of the backend. depth ( int ) \u2013 the depth (number of canonical layers) of the circuit. circ_samples ( int ) \u2013 the number of circuit samples to generate. backend_arg ( IQMBackendBase | str ) \u2013 the backend. density_2q_gates ( float ) \u2013 the expected density of 2Q gates. two_qubit_gate_ensemble ( Optional [ Dict [ str , float ] ] ) \u2013 A dictionary with keys being str specifying 2Q gates, and values being corresponding probabilities.\n* Default is None. clifford_sqg_probability ( float ) \u2013 Probability with which to uniformly sample Clifford 1Q gates.\n* Default is 1.0. sqg_gate_ensemble ( Optional [ Dict [ str , float ] ] ) \u2013 A dictionary with keys being str specifying 1Q gates, and values being corresponding probabilities.\n* Default is None. qiskit_optim_level ( int ) \u2013 Qiskit transpiler optimization level.\n* Default is 1. routing_method ( Literal [ \"basic\" , \"lookahead\" , \"stochastic\" , \"sabre\" , \"none\" ] ) \u2013 Qiskit transpiler routing method.\n* Default is \u201cbasic\u201d. a dictionary with keys \u201ctranspiled\u201d, \u201cuntranspiled\u201d and values a list of respective DRB circuits. Dict[ str , List[QuantumCircuit]] previous iqm.benchmarks.randomized_benchmarking.direct_rb.direct_rb.direct_rb_analysis next iqm.benchmarks.randomized_benchmarking.direct_rb.direct_rb.generate_fixed_depth_parallel_drb_circuits By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.remove_directed_duplicates_to_list",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.remove_directed_duplicates_to_list.html",
    "description": "Remove duplicate edges from a coupling map and returns as a list of edges (as a list of pairs of vertices). cp_map ( CouplingMap ) \u2013 A list of pairs of integers, representing a coupling map. the edges...",
    "content": "Remove duplicate edges from a coupling map and returns as a list of edges (as a list of pairs of vertices). cp_map ( CouplingMap ) \u2013 A list of pairs of integers, representing a coupling map. the edges of the coupling map. List[List[ int ]] previous iqm.benchmarks.utils.reduce_to_active_qubits next iqm.benchmarks.utils.retrieve_all_counts By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.count_native_gates",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.count_native_gates.html",
    "description": "Count the number of IQM native gates of each quantum circuit in a list. backend_arg ( str | IQMBackendBase ) \u2013 The backend, either specified as str or as IQMBackendBase. transpiled_qc_list ( List [ IQ...",
    "content": "Count the number of IQM native gates of each quantum circuit in a list. backend_arg ( str | IQMBackendBase ) \u2013 The backend, either specified as str or as IQMBackendBase. transpiled_qc_list ( List [ IQMCircuit ] ) \u2013 a list of quantum circuits transpiled to [\u2018r\u2019,\u2019cz\u2019,\u2019barrier\u2019,\u2019measure\u2019] gate set. Dictionary with outermost keys being native operations. values being Dict[str, float] with mean and standard deviation values of native operation counts. outermost keys being native operations. values being Dict[str, float] with mean and standard deviation values of native operation counts. Dict [ str , Dict [ str , float ]] previous iqm.benchmarks.utils.count_2q_layers next iqm.benchmarks.utils.extract_fidelities By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.optimization.qscore.get_optimal_angles",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.optimization.qscore.get_optimal_angles.html",
    "description": "provides the optimal angles for QAOA MaxCut ansatz given the number of layers num_layers ( int ) \u2013 number of layers of the QAOA MaxCut ansatz. optimal angles for QAOA MaxCut ansatz list [ float ] prev...",
    "content": "provides the optimal angles for QAOA MaxCut ansatz given the number of layers num_layers ( int ) \u2013 number of layers of the QAOA MaxCut ansatz. optimal angles for QAOA MaxCut ansatz list [ float ] previous iqm.benchmarks.optimization.qscore.cut_cost_function next iqm.benchmarks.optimization.qscore.is_successful By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.compressive_gst.gst_analysis.generate_unit_rank_gate_results",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.compressive_gst.gst_analysis.generate_unit_rank_gate_results.html",
    "description": "Produces all result tables for Kraus rank 1 estimates and turns them into figures. This includes parameters of the Hamiltonian generators in the Pauli basis for all gates,\nas well as the usual perform...",
    "content": "Produces all result tables for Kraus rank 1 estimates and turns them into figures. This includes parameters of the Hamiltonian generators in the Pauli basis for all gates,\nas well as the usual performance metrics (Fidelities and Diamond distances). If bootstrapping\ndata is available, error bars will also be generated. dataset ( Dataset ) \u2013 xarray.Dataset\nA dataset containing counts from the experiment and configurations qubit_layout ( List [ int ] ) \u2013 List[int]\nThe list of qubits for the current GST experiment df_g ( DataFrame ) \u2013 Pandas DataFrame\nThe dataframe with properly formated results X_opt ( ndarray ) \u2013 3D numpy array\nThe gate set after gauge optimization K_target ( ndarray ) \u2013 4D numpy array\nThe Kraus operators of all target gates, used to compute distance measures. Pandas DataFrame The dataframe with properly formated results of standard gate errors df_g_rotation Pandas DataFrame A dataframe containing Hamiltonian (rotation) parameters fig_g: Figure A table in Figure format of gate results (fidelities etc.) fig_rotation: Figure A table in Figure format of gate Hamiltonian parameters The dataframe with properly formated results of standard gate errors A dataframe containing Hamiltonian (rotation) parameters A table in Figure format of gate results (fidelities etc.) A table in Figure format of gate Hamiltonian parameters df_g_final previous iqm.benchmarks.compressive_gst.gst_analysis.generate_non_gate_results next iqm.benchmarks.compressive_gst.gst_analysis.mgst_analysis By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.interleaved_rb.interleaved_rb",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.interleaved_rb.interleaved_rb.html",
    "description": "Interleaved Clifford Randomized Benchmarking. Functions interleaved_rb_analysis (run) Analysis function for an Interleaved RB experiment Classes InterleavedRBConfiguration (*,\u00a0benchmark,\u00a0...) Interlea...",
    "content": "Interleaved Clifford Randomized Benchmarking. Functions interleaved_rb_analysis (run) Analysis function for an Interleaved RB experiment Classes InterleavedRBConfiguration (*,\u00a0benchmark,\u00a0...) Interleaved RB configuration. InterleavedRandomizedBenchmarking (...) Interleaved RB estimates the average gate fidelity of a specific Clifford gate Inheritance previous iqm.benchmarks.randomized_benchmarking.interleaved_rb next iqm.benchmarks.randomized_benchmarking.interleaved_rb.interleaved_rb.interleaved_rb_analysis By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.benchmark",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.benchmark.html",
    "description": "Generic Benchmark class Classes BenchmarkBase (backend,\u00a0configuration) The base implementation of all benchmarks, from which they inherit. BenchmarkConfigurationBase (*,\u00a0benchmark[,\u00a0...]) Benchmark co...",
    "content": "Generic Benchmark class Classes BenchmarkBase (backend,\u00a0configuration) The base implementation of all benchmarks, from which they inherit. BenchmarkConfigurationBase (*,\u00a0benchmark[,\u00a0...]) Benchmark configuration base. Inheritance previous iqm.benchmarks next iqm.benchmarks.benchmark.BenchmarkBase By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.compressive_gst.gst_analysis.dataset_counts_to_mgst_format",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.compressive_gst.gst_analysis.dataset_counts_to_mgst_format.html",
    "description": "into the format which is used in mGST dataset ( Dataset ) \u2013 xarray.Dataset\nA dataset containing counts from the experiment and configurations qubit_layout ( List [ int ] ) \u2013 List[int]\nThe list of qubi...",
    "content": "into the format which is used in mGST dataset ( Dataset ) \u2013 xarray.Dataset\nA dataset containing counts from the experiment and configurations qubit_layout ( List [ int ] ) \u2013 List[int]\nThe list of qubits for the current GST experiment y \u2013 2D array of measurement outcomes for sequences in J;\nEach column contains the outcome probabilities for a fixed sequence numpy array previous iqm.benchmarks.compressive_gst.gst_analysis.dataframe_to_figure next iqm.benchmarks.compressive_gst.gst_analysis.generate_basis_labels By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.quantum_volume.quantum_volume.is_successful",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.quantum_volume.quantum_volume.is_successful.html",
    "description": "Check whether a QV benchmark returned heavy output results over the threshold, therefore being successful. This condition checks that the average of HOP is above the 2/3 threshold within the number of...",
    "content": "Check whether a QV benchmark returned heavy output results over the threshold, therefore being successful. This condition checks that the average of HOP is above the 2/3 threshold within the number of sigmas given in\nthe configuration. heavy_output_probabilities ( List [ float ] ) \u2013 the HOP of all quantum circuits. num_sigmas ( int ) \u2013 the number of sigmas to check whether the QV benchmark was successful. bool previous iqm.benchmarks.quantum_volume.quantum_volume.heavy_projector next iqm.benchmarks.quantum_volume.quantum_volume.plot_hop_threshold By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils.get_tomography_matrix",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils.get_tomography_matrix.html",
    "description": "Reconstructs a density matrix from given Pauli expectations. pauli_expectations ( Dict [ str , float ] ) \u2013 A dictionary of Pauli expectations, with keys being Pauli strings. ValueError \u2013 If not all 4*...",
    "content": "Reconstructs a density matrix from given Pauli expectations. pauli_expectations ( Dict [ str , float ] ) \u2013 A dictionary of Pauli expectations, with keys being Pauli strings. ValueError \u2013 If not all 4**n Pauli expectations are specified. A tomographically reconstructed density matrix. np.ndarray previous iqm.benchmarks.utils.get_neighbors_of_edges next iqm.benchmarks.utils.marginal_distribution By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.utils_shadows.local_shadow_tomography",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.utils_shadows.local_shadow_tomography.html",
    "description": "Prepares the circuits to perform local Haar or Clifford shadow tomography. qc ( QuantumCircuit ) \u2013 The quantum circuit to which random unitaries are appended. Nu ( int ) \u2013 Number of local random unita...",
    "content": "Prepares the circuits to perform local Haar or Clifford shadow tomography. qc ( QuantumCircuit ) \u2013 The quantum circuit to which random unitaries are appended. Nu ( int ) \u2013 Number of local random unitaries used. active_qubits ( Sequence [ int ] ) \u2013 The Sequence of active qubits. measure_other ( Optional [ Sequence [ int ] ] ) \u2013 Whether to measure other qubits in the qc QuantumCircuit.\n* Default is None. measure_other_name ( Optional [ str ] ) \u2013 Name of the classical register to assign measure_other. clifford_or_haar ( Literal [ \"clifford\" , \"haar\" ] ) \u2013 Whether to use Clifford or Haar random 1Q gates.\n* Default is \u201cclifford\u201d. cliffords_1q ( Optional [ Dict [ str , QuantumCircuit ] ] ) \u2013 Dictionary of 1-qubit Cliffords in terms of IQM-native r and CZ gates.\n* Default is None. ValueError \u2013 If clifford_or_haar is not \u201cclifford\u201d or \u201chaar\u201d. ValueError \u2013 If cliffords_1q is None and clifford_or_haar is \u201cclifford\u201d. ndarray | Dict[str, List[str]]: Either: Unitary gate (numpy ndarray), composed of local unitaries for each random initialisation and qubit, if clifford_or_haar == \u2018haar\u2019. Dictionary of lists of Clifford labels corresponding to each RM, keys being str(qubit), if clifford_or_haar == \u2018clifford\u2019. List[QuantumCircuit]: List of tomography circuits. Unitary gate (numpy ndarray), composed of local unitaries for each random initialisation and qubit, if clifford_or_haar == \u2018haar\u2019. Dictionary of lists of Clifford labels corresponding to each RM, keys being str(qubit), if clifford_or_haar == \u2018clifford\u2019. List[QuantumCircuit]: List of tomography circuits. Tuple[np.ndarray | Dict[ str , List[ str ]], List[QuantumCircuit]] previous iqm.benchmarks.utils_shadows.get_negativity next License By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.quantum_volume.quantum_volume.get_rem_hops",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.quantum_volume.quantum_volume.get_rem_hops.html",
    "description": "Computes readout-error-mitigated heavy output probabilities. all_rem_quasidistro ( List [ List [ QuasiCollection ] ] ) \u2013 The list of lists of quasiprobability distributions. ideal_heavy_outputs ( List...",
    "content": "Computes readout-error-mitigated heavy output probabilities. all_rem_quasidistro ( List [ List [ QuasiCollection ] ] ) \u2013 The list of lists of quasiprobability distributions. ideal_heavy_outputs ( List [ Dict [ str , float ] ] ) \u2013 A list of the noiseless heavy output probability dictionaries. A list of readout-error-mitigated heavy output probabilities. List[ float ] previous iqm.benchmarks.quantum_volume.quantum_volume.get_ideal_heavy_outputs next iqm.benchmarks.quantum_volume.quantum_volume.heavy_projector By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.compressive_gst",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.compressive_gst.html",
    "description": "Compressive GST is a self-consistent characterization method which constructs the process matrices for a set of gates,\nas well as full parametrizations of an initial state and a POVM.\nLow rank compres...",
    "content": "Compressive GST is a self-consistent characterization method which constructs the process matrices for a set of gates,\nas well as full parametrizations of an initial state and a POVM.\nLow rank compression of the process matrix is used to reduce measurement and post-processing overhead. Subpackages and modules compressive_gst Compressive gate set tomography gst_analysis Data analysis code for compressive gate set tomography previous iqm.benchmarks.circuit_containers.Circuits next iqm.benchmarks.compressive_gst.compressive_gst By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.optimization.qscore.plot_approximation_ratios",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.optimization.qscore.plot_approximation_ratios.html",
    "description": "including standard deviation and the acceptance threshold. nodes ( list [ int ] ) \u2013 list nodes for the problem graph sizes. beta_ratio ( list [ float ] ) \u2013 Beta ratio calculated for each graph size. b...",
    "content": "including standard deviation and the acceptance threshold. nodes ( list [ int ] ) \u2013 list nodes for the problem graph sizes. beta_ratio ( list [ float ] ) \u2013 Beta ratio calculated for each graph size. beta_std ( list [ float ] ) \u2013 Standard deviation for beta ratio of each graph size. use_virtual_node ( Optional [ bool ] ) \u2013 whether to use virtual nodes or not. use_classically_optimized_angles ( Optional [ bool ] ) \u2013 whether to use classically optimized angles or not. num_instances ( int ) \u2013 the number of instances. backend_name ( str ) \u2013 the name of the backend. timestamp ( str ) \u2013 the timestamp of the execution of the experiment. the name of the figure.\nFigure: the figure. str previous iqm.benchmarks.optimization.qscore.is_successful next iqm.benchmarks.optimization.qscore.qscore_analysis By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.optimization.qscore.run_QAOA",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.optimization.qscore.run_QAOA.html",
    "description": "Solves the cut size of MaxCut for a graph using QAOA.\nThe result is average value sampled from the optimized ansatz. counts ( Dict [ str , int ] ) \u2013 key as bitstring, value as counts graph_physical ( ...",
    "content": "Solves the cut size of MaxCut for a graph using QAOA.\nThe result is average value sampled from the optimized ansatz. counts ( Dict [ str , int ] ) \u2013 key as bitstring, value as counts graph_physical ( Graph ) \u2013 the graph to be optimized qubit_node ( Dict [ int , int ] ) \u2013 the qubit to be optimized use_classical_angles ( bool ) \u2013 whether to use classical angles qaoa_layers ( int ) \u2013 the number of QAOA layers virtual_nodes ( List [ Tuple [ int , int ] ] ) \u2013 the presence of virtual nodes or not the expectation value of the maximum cut size. float previous iqm.benchmarks.optimization.qscore.qscore_analysis next iqm.benchmarks.optimization.qscore.QScoreBenchmark By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.entanglement.graph_states.update_pauli_expectations",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.entanglement.graph_states.update_pauli_expectations.html",
    "description": "Helper function that updates the input Pauli expectations dictionary of dictionaries (projections -> {pauli string: expectation}). pauli_expectations ( Dict [ str , Dict [ str , float ] ] ) \u2013 The Paul...",
    "content": "Helper function that updates the input Pauli expectations dictionary of dictionaries (projections -> {pauli string: expectation}). pauli_expectations ( Dict [ str , Dict [ str , float ] ] ) \u2013 The Pauli expectations dictionary of dictionaries to update.\n* Outermost keys are projected bitstrings; innermost are pauli strings and values are expectation values. projected_counts ( Dict [ str , Dict [ str , int ] ] ) \u2013 The corresponding projected counts dictionary of dictionaries. nonId_pauli_label ( str ) \u2013 The Pauli label to update expectations of, that should not contain identities.\n* Pauli expectations corresponding to I are inferred and updated from counts corresponding to strings containing Z instead. The updated Pauli expectations dictionary of dictionaries (projections -> {pauli string: expectation}). Dict[ str , Dict[ str , float ]] previous iqm.benchmarks.entanglement.graph_states.state_tomography_analysis next iqm.benchmarks.entanglement.graph_states.GraphStateBenchmark By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.clifford_rb",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.clifford_rb.html",
    "description": "Clifford RB reflects the fidelity of Clifford gates Subpackages and modules clifford_rb 'Standard' Clifford Randomized Benchmarking. previous iqm.benchmarks.randomized_benchmarking next iqm.benchmarks...",
    "content": "Clifford RB reflects the fidelity of Clifford gates Subpackages and modules clifford_rb 'Standard' Clifford Randomized Benchmarking. previous iqm.benchmarks.randomized_benchmarking next iqm.benchmarks.randomized_benchmarking.clifford_rb.clifford_rb By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.MirrorRandomizedBenchmarking",
    "url": "/iqm-benchmarks/api/iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.MirrorRandomizedBenchmarking.html",
    "description": "Bases: Benchmark Mirror RB estimates the fidelity of ensembles of n-qubit layers Attributes name  Methods add_all_meta_to_dataset (dataset) Adds all configuration metadata and circuits to the dataset ...",
    "content": "Bases: Benchmark Mirror RB estimates the fidelity of ensembles of n-qubit layers Attributes name  Methods add_all_meta_to_dataset (dataset) Adds all configuration metadata and circuits to the dataset variable analysis_function (run) Analysis function for a MRB experiment execute (backend) Executes the benchmark submit_single_mrb_job (backend_arg,\u00a0qubits,\u00a0...) Submit fixed-depth MRB jobs for execution in the specified IQMBackend backend_arg ( IQMBackendBase | str ) \u2013 configuration ( MirrorRBConfiguration ) \u2013 Analysis function for a MRB experiment run ( RunResult ) \u2013 A MRB experiment run for which analysis result is created AnalysisResult corresponding to MRB BenchmarkAnalysisResult Adds all configuration metadata and circuits to the dataset variable dataset ( xr.Dataset ) \u2013 The xarray dataset Submit fixed-depth MRB jobs for execution in the specified IQMBackend backend_arg ( IQMBackendBase ) \u2013 the IQM backend to submit the job qubits ( Sequence [ int ] ) \u2013 the qubits to identify the submitted job depth ( int ) \u2013 the depth (number of canonical layers) of the circuits to identify the submitted job sorted_transpiled_circuit_dicts ( Dict [ str , List [ QuantumCircuit ] ] ) \u2013 A dictionary containing all MRB circuits Dict with qubit layout, submitted job objects, type (vanilla/DD) and submission time Dict [ str , Any ] Executes the benchmark backend ( IQMBackendBase ) \u2013 Dataset previous iqm.benchmarks.randomized_benchmarking.mirror_rb.mirror_rb.MirrorRBConfiguration next iqm.benchmarks.randomized_benchmarking.multi_lmfit By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "How to make your own benchmark?",
    "url": "/iqm-benchmarks/development/how_to_make_your_own_benchmark.html",
    "description": "This notebook shows an example of how to use the benchmark defition to write a new benchmark class. Here we make a simple benchmark that creates two circuits, one that prepares all the qubits in the g...",
    "content": "This notebook shows an example of how to use the benchmark defition to write a new benchmark class. Here we make a simple benchmark that creates two circuits, one that prepares all the qubits in the ground state and another one that prepares them in the excited state. previous Development next 2-Qubit Clifford Group Decomposition By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Development",
    "url": "/iqm-benchmarks/development/development.html",
    "description": "This section provides examples and guidance on how to create benchmarks based on the IQM Benchmarks package. previous Benchmarking IQM Star next How to make your own benchmark? By IQM Benchmarks devel...",
    "content": "This section provides examples and guidance on how to create benchmarks based on the IQM Benchmarks package. previous Benchmarking IQM Star next How to make your own benchmark? By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "2-Qubit Clifford Group Decomposition",
    "url": "/iqm-benchmarks/development/generate_2qubit_cliffords.html",
    "description": "Generate the decomposition of the 2-qubit Clifford group according to: https://arxiv.org/abs/1402.4848 Verify the condition \\(\\displaystyle{\\sum_{k,\\,k^\\prime=1}^K}\\left|\\mathrm{tr}\\left(U_{k^\\prime}^...",
    "content": "Generate the decomposition of the 2-qubit Clifford group according to: https://arxiv.org/abs/1402.4848 Verify the condition \\(\\displaystyle{\\sum_{k,\\,k^\\prime=1}^K}\\left|\\mathrm{tr}\\left(U_{k^\\prime}^{\\dagger}U_k\\right)\\right|^4/K^2 = 2\\) (Eq. S2) Verify the condition \\(\\displaystyle{\\sum_{k,\\,k^\\prime=1}^K}\\left|\\mathrm{tr}\\left(U_{k^\\prime}^{\\dagger}U_k\\right)\\right|^4/K^2 = 2\\) (Eq. S2) WARNING : in total there are \\(n=11,520^2 = 132,710,400\\) values in the sum ! It suffices to compute the values in a triangular part of the matrix \\(U_{k^\\prime}^{\\dagger}U_k\\) \u2014 however there are still \\(n(n-1)/2\\) such terms ! previous How to make your own benchmark? next API Reference By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Devices",
    "url": "/iqm-benchmarks/devices/devices.html",
    "description": "This section provides examples and guidance on how to benchmark specific IQM devices. previous Q-Score next Benchmarking IQM Spark By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2...",
    "content": "This section provides examples and guidance on how to benchmark specific IQM devices. previous Q-Score next Benchmarking IQM Spark By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Benchmarking IQM Star",
    "url": "/iqm-benchmarks/devices/star.html",
    "description": "This notebook allows you to run some useful benchmarks for the Star system. We can access the Star backend and plot its connectivity graph to check that everything is working properly. We run the cell...",
    "content": "This notebook allows you to run some useful benchmarks for the Star system. We can access the Star backend and plot its connectivity graph to check that everything is working properly. We run the cell below to ignore those warnings that are not critical for the correct run of the benchmarks. The GHZ (Greenberger-Horne-Zeilinger) state is a maximally entangled quantum state that involves three or more qubits, \\(n\\) . It is an equal superposition of all qubits being in state 0 and all qubits being in state 1, i.e., \\(| GHZ \\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle^{\\otimes n}+|1\\rangle^{\\otimes n})\\) . The GHZ state fidelity acts as a witness for genuine multi-qubit entanglement if found to be above \\(0.5\\) . This means that the measurement results cannot be explained without entanglement involving all qubits, so it is a great way to evaluate the \u201cquantumness\u201d of the computer. The state \\(\\rho_{\\text{ideal}}= |GHZ\\rangle\\langle GHZ|\\) is a pure state, so in this case the fidelity can be computed as: where \\(\\rho_{\\text{measured}}\\) is the density matrix given by the actual results of the quantum computer. The ideal GHZ state density matrix entries can be written as \\(\\rho_{i,j}=\\langle i| \\rho_{\\text{ideal}} | j \\rangle\\) where \\(i,j\\) are the \\(n\\) basis states \\(\\{|00..0\\rangle, ..., |11..1\\rangle\\}\\) ; only the corner entries \\(\\rho_{0,0},\\rho_{0,n},\\rho_{n,0}\\) and \\(\\rho_{n,n} \\) are non-zero. This simplifies the process since we only need to measure these four components. In the fidelity formula, all other entries are effectively nullified by the zero entries in the ideal state matrix. To measure the coherences (off-diagonal entries) we use the method of multiple quantum coherences Mooney, 2021 . Quantum volume is a single-number metric that was introduced in Cross, 2019 . It evaluates the quality of a quantum processor via the largest random square circuit, i.e., with the same number of layers of parallel random 2-qubit unitaries as number of qubits, that it can run successfully. The success of a run is based on the heavy output probability, which corresponds to the probability of observing heavy outputs , i.e. the measurement outputs that occcur with a probability greater than the median of the distribution. The heavy output generation problem asks if the generated distribution of the random circuit we run contains heavy outputs at least 2/3 of the time (on average) with a high confidence level, typically higher than 97.5%. It can be shown that the heavy output probability for an ideal device is at around 0.85 asymptotically.\nThe quantum volume is then defined as where \\(n \\leq N\\) is a number of qubits and \\(d(n)\\) is the achievable depth , i.e. the largest depth such that we are confident the probability of observing a heavy output is greater than 2/3. We define a combination of qubits to test quantum volume on. If you want to modify the settings above, please refer to the documentation here . Warning: The following code cell may take few minutes to run since it will compute the benchmark on all the qubit layouts specified above. CLOPS is a metric that estimates the speed at which a quantum computer can execute Quantum Volume (QV) layers of a quantum circuit. That is, the circuits to calculate this benchmark have the same structure as the ones used for QV. Here we follow the definition introduced in ( Wack, 2021 ), but other versions of this benchmark exist. CLOPS is measured by means of a quantum variational-like protocol, where templates of parametrized QV circuits are assigned random parameters, executed, and outcomes are used as a seed to assign new parameters and repeat the process. The ratio of number of templates ( \\(M\\) ), parameter updates ( \\(K\\) ), measurement shots ( \\(S\\) ) and QV layers ( \\(\\log_2\\mathrm{QV}\\) ) with the time taken to run all, constitutes the CLOPS value: Notice that the total CLOPS time includes that of assignment of parameters, submission of circuits and retrieval of results. If you want to modify the settings above, please refer to the documentation here . The Q-score measures the maximum number of qubits that can be used\neffectively to solve the MaxCut combinatorial optimization problem with the Quantum Approximate\nOptimization Algorithm - Martiel,2021 The graphs chosen for the benchmark are random Erd\u0151s-R\u00e9nyi graphs with 50% edge-probability between nodes.\nThe obtained cost of the solution, i.e. the average number of cut edges, must be above a certain threshold. Specifically, one has to find the cost of a graph to be above \\(\\beta\\geq 0.2\\) on a scale where \\(\\beta = 0\\) corresponds to a random solution and \\(\\beta = 1\\) to an ideal solution. If you want to modify the settings above, please refer to the documentation here . Warning: The following code cell may take several minutes to run. previous Benchmarking IQM Spark next Development By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Benchmarking IQM Spark",
    "url": "/iqm-benchmarks/devices/spark.html",
    "description": "This notebook allows you to run some useful benchmarks for the Spark system. Before starting, make sure you have installed all the necessary packages: We can access the Spark backend and plot its conn...",
    "content": "This notebook allows you to run some useful benchmarks for the Spark system. Before starting, make sure you have installed all the necessary packages: We can access the Spark backend and plot its connectivity graph to check that everything is working properly. We run the cell below to ignore those warnings that are not critical for the correct run of the benchmarks. The GHZ (Greenberger-Horne-Zeilinger) state is a maximally entangled quantum state that involves three or more qubits, \\(n\\) . It is an equal superposition of all qubits being in state 0 and all qubits being in state 1, i.e., \\(| GHZ \\rangle = \\frac{1}{\\sqrt{2}}(|0\\rangle^{\\otimes n}+|1\\rangle^{\\otimes n})\\) . The GHZ state fidelity acts as a witness for genuine multi-qubit entanglement if found to be above \\(0.5\\) . This means that the measurement results cannot be explained without entanglement involving all qubits, so it is a great way to evaluate the \u201cquantumness\u201d of the computer. The state \\(\\rho_{\\text{ideal}}= |GHZ\\rangle\\langle GHZ|\\) is a pure state, so in this case the fidelity can be computed as: where \\(\\rho_{\\text{measured}}\\) is the density matrix given by the actual results of the quantum computer. The ideal GHZ state density matrix entries can be written as \\(\\rho_{i,j}=\\langle i| \\rho_{\\text{ideal}} | j \\rangle\\) where \\(i,j\\) are the \\(n\\) basis states \\(\\{|00..0\\rangle, ..., |11..1\\rangle\\}\\) ; only the corner entries \\(\\rho_{0,0},\\rho_{0,n},\\rho_{n,0}\\) and \\(\\rho_{n,n} \\) are non-zero. This simplifies the process since we only need to measure these four components. In the fidelity formula, all other entries are effectively nullified by the zero entries in the ideal state matrix. To measure the coherences (off-diagonal entries) we use the method of multiple quantum coherences Mooney, 2021 . If you want to modify the settings above, please refer to the documentation here . Before running the benchmark analysis, we can visualize the histogram of counts obtained from measuring a GHZ state on 5 qubits: Quantum volume is a single-number metric that was introduced in Cross, 2019 . It evaluates the quality of a quantum processor via the largest random square circuit, i.e., with the same number of layers of parallel random 2-qubit unitaries as number of qubits, that it can run successfully. The success of a run is based on the heavy output probability, which corresponds to the probability of observing heavy outputs , i.e. the measurement outputs that occcur with a probability greater than the median of the distribution. The heavy output generation problem asks if the generated distribution of the random circuit we run contains heavy outputs at least 2/3 of the time (on average) with a high confidence level, typically higher than 97.5%. It can be shown that the heavy output probability for an ideal device is at around 0.85 asymptotically.\nThe quantum volume is then defined as where \\(n \\leq N\\) is a number of qubits and \\(d(n)\\) is the achievable depth , i.e. the largest depth such that we are confident the probability of observing a heavy output is greater than 2/3. We define a combination of qubits to test quantum volume on. Due to the star topology, the combinations must contain at least qubit #2 (see topmost graph). If you want to modify the settings above, please refer to the documentation here . Warning: The following code cell may take few minutes to run since it will compute the benchmark on all the qubit layouts specified above. CLOPS is a metric that estimates the speed at which a quantum computer can execute Quantum Volume (QV) layers of a quantum circuit. That is, the circuits to calculate this benchmark have the same structure as the ones used for QV. Here we follow the definition introduced in ( Wack, 2021 ), but other versions of this benchmark exist. CLOPS is measured by means of a quantum variational-like protocol, where templates of parametrized QV circuits are assigned random parameters, executed, and outcomes are used as a seed to assign new parameters and repeat the process. The ratio of number of templates ( \\(M\\) ), parameter updates ( \\(K\\) ), measurement shots ( \\(S\\) ) and QV layers ( \\(\\log_2\\mathrm{QV}\\) ) with the time taken to run all, constitutes the CLOPS value: Notice that the total CLOPS time includes that of assignment of parameters, submission of circuits and retrieval of results. If you want to modify the settings above, please refer to the documentation here . The idea behind Clifford Randomized Benchmarking (CRB) is that under certain (simplified) types of noise, the average survival probability of an initial state \\(|0\\rangle\\) under random sequences of Clifford gates and a final sequence inverse will decay exponentially in the length of the sequences. This can be written as where \\(C_1, C_2, \\ldots, C_m\\) is the random sequences of Clifford gates, \\(C_\\text{inv}=(C_1C_2\\cdots{C}_m)^{-1}\\) , \\(0\\leq{p}\\leq{1}\\) and \\(0\\leq{A,B}\\leq1\\) are constants isolating the effects of state-preparation and measurement (SPAM) errors ( Magesan,2012 ). From such decay, one can in turn infer the average fidelity of the corresponding Clifford group. The main assumption we will make here is that the noise can be modeled as Markovian, time-stationary and gate-independent. The theory of CRB under these approximations, and the fact that the multi-qubit Clifford group is a unitary 2-design (i.e., uniformly averaging with two pairs of \\(C\\) , \\(C^{\\dagger}\\) Clifford operators gives the same result as using fully random unitaries), ensures that the average fidelity of our gate set is given by CRB is not generally intended to work for \\(n>2\\) , both because of the scaling of the size of the \\(n\\) -qubit Clifford group in \\(n\\) , and because such gates have to eventually be transpiled to a native basis of 1Q and 2Q gates! It is important to mention that the average Clifford fidelity is related to the average fidelity of IQM\u2019s native gate set for single-qubit gates as ( Barends, 2014 ) This is because all the single-qubit Clifford gates can be decomposed using on average 1.875 gates from IQM\u2019s native set. This formula shows that the value of \\(\\overline{F}_\\text{GATE}\\) will always be slightly higher than \\(\\overline{F}_\\text{CRB}\\) , so one must be careful when comparing with average fidelities reported in the specs of a QPU. If you want to modify the settings above, please refer to the documentation here . Warning: The following code cell may take few minutes to run since it will compute the average fidelities for all the qubits in the QPU (and we set parallel_execution=False ). Differently from the previous protocol, this benchmark aims at estimating the average fidelity of an individual quantum gate. This can be achieved interleaving random Clifford gates between the gate of interest. This method was introduced in Magesan, 2012 , and just as CRB, it is robust with respect to SPAM errors. The protocol runs two sets of sequences, one solely made up of random Clifford gates, as in CRB, and one made up of random Clifford sequences but interleaving the gate of interest among these (and compiling the corresponding sequence inverse). IRB then extracts the corresponding decay parameters (where we expect the decay rate for IRB to be smaller than the CRB one, because the sequence is longer), and the average fidelity of the gate we wish to characterize is then calculated with a simple formula using the two decay parameters. If you want to modify the settings above, please refer to the documentation here . NB: Clifford RB is executed by default when running Interleaved RB! Warning: The following code cells may take several minutes to run. The Q-score measures the maximum number of qubits that can be used\neffectively to solve the MaxCut combinatorial optimization problem with the Quantum Approximate\nOptimization Algorithm - Martiel,2021 The graphs chosen for the benchmark are random Erd\u0151s-R\u00e9nyi graphs with 50% edge-probability between nodes.\nThe obtained cost of the solution, i.e. the average number of cut edges, must be above a certain threshold. Specifically, one has to find the cost of a graph to be above \\(\\beta\\geq 0.2\\) on a scale where \\(\\beta = 0\\) corresponds to a random solution and \\(\\beta = 1\\) to an ideal solution. If you want to modify the settings above, please refer to the documentation here . Warning: The following code cell may take several minutes to run. Typical performance for IQM Spark is summarized in the table below and compared to the values obtained with your device. The typical single- and two-qubit gate fidelities reported below refer to the median over the 5 qubits and 4 couplings of the system, respectively. previous Devices next Benchmarking IQM Star By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Quantum Volume (QV)",
    "url": "/iqm-benchmarks/examples/example_quantum_volume.html",
    "description": "One can perform a separate run of the benchmark (also possible with a different configuration) List all the keys in the attributes of the dataset The data for specific experiments is indexed by 0,1,\u2026,...",
    "content": "One can perform a separate run of the benchmark (also possible with a different configuration) List all the keys in the attributes of the dataset The data for specific experiments is indexed by 0,1,\u2026, e.g., for the first experiment: The observation object contains the benchmark results Print a specific output Or print all the plots at once previous Compressive Gate Set Tomography (GST) next Circuit Layer Operations Per Second (CLOPS) By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Interleaved Randomized Benchmarking (IRB)",
    "url": "/iqm-benchmarks/examples/example_interleaved_rb.html",
    "description": "Set IQM Token if using Resonance. previous Clifford Randomized Benchmarking (CRB) next Error Per Layered Gate (EPLG) By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07....",
    "content": "Set IQM Token if using Resonance. previous Clifford Randomized Benchmarking (CRB) next Error Per Layered Gate (EPLG) By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Compressive Gate Set Tomography (GST)",
    "url": "/iqm-benchmarks/examples/example_gst.html",
    "description": "This notebook gives an introduction on how to run compressive gate set tomography, what the input parameters mean and how to display different observations and plots. This notebook and the compressive...",
    "content": "This notebook gives an introduction on how to run compressive gate set tomography, what the input parameters mean and how to display different observations and plots. This notebook and the compressive GST functionality requires the optional dependency \u201cmgst\u201d to be installed. For background, see the journal reference at https://journals.aps.org/prxquantum/abstract/10.1103/PRXQuantum.4.010325 The most important parameters are the following: qubits ( List[int] ): The qubits on the backend where the experiment is performed. gate_set ( Union[str, List[Type[QuantumCircuit]]] ): Either one of the currently predefined gate sets \"1QXYI\" , \"2QXYCZ\" , \"2QXYCZ_extended\" , \"3QXYCZ\" , or a list of quantum circuits. num_circuits ( int ): The number of circuits for the experiment. Recommended are at least 50 for single qubit GST, at least 300 for two-qubit GST and at least 2000 for 3-qubit GST. shots ( int ): The number of shots per circuit. rank ( int ): The Kraus rank of the reconstruction, i.e. the number of Kraus operators for each gate.\n$ \\( G(\\rho) = \\sum_{i = 1}^{\\text{rank}} K_i \\rho K_i^{\\dagger}\\) $\nSetting rank=1 will trigger a unitary gate fit, leading to a gate parametrization output in terms Hamiltonian parameters.\nThe maximum rank is given by the physical dimension squared. For fully rigorous performance computation of metrics such as the average gate fidelity or the diamond distance it is recommended to choose full rank.\nA low rank has the benefit of needing less circuits and less computing time, while still capturing the dominant error sources. bootstrap_samples ( int ): If bootstrapping error bars are to be generated, this variable sets the number of bootstrap runs. Recommended for trustworthy error bars are 50 samples. The default is 0, since computing bootstrap error bars is very time consuming. Be prepared that the first execution on a new system will take an extra 1-2 minutes to compile the lower level optimization code. To get a unitary model of the gate set from the same data, the rank parameter of the benchmark object can be set to 1.\nThe analysis will give a Hamiltonian parametrization of the gate set and produce different plots. For uncertaintites on the observations set bootstrap_samples \\(\\geq 10\\) . The high level results are stored in a list of Observations under restult.observations .\nTo access only those observations corresponding to a specific qubit layout, one can use the identifier attribute: In addition to the high level observations above, the full process matrices for each gate and the full parametrizations for initial state and measurement are stored. They can be accessed under result.dataset.attrs[f\"results_layout_{qubit_layout}\"] as follows. Two gate sets are saved, the raw gate set and the gauge-optimized gate set.\nIn most instances the gauge-optimized gate set should be used for further processing, since it gives the gate set in the reference frame in which the target gates are defined. The \"raw_gates\" and \"gauge_opt_gates\" keys in the outcome dictionary contain a 3D numpy array, where i.e. gate #1 is accessed with raw_results[\"gauge_opt_state\"][0] , and so on. The plots can be accessed in the notebook via result.plots, a dictionary containing all figure objects. These can then be diplayed as shown below, or saved to disc from the notebook.\nCurrently all gauge optimized gate superoperators are shown as matrix plots in their Pauli basis representation, while the state preparation and measurement outcomes are shown as matrix plots in standard basis.\nFor reference, a sinlge qubit superoperator for gate \\(G\\) in the Pauli-basis has entries \\(G_{ij}\\) defined via\n$ \\(\nG(\\rho) = \\frac{1}{2} \\sum_{i,j = 1}^4 G_{ij} P_i Tr(P_j \\rho),\n\\) \\(\nwhere \\) P_i, P_j$ are Pauli matrices. In addition to gate plots, selections of gate error measures and gate parameters are also stored in figure objects. Stored plot names can be displayed and individually plotted as follows. Rank 1 results (for example the gate Hamiltonians in the Pauli basis) Alternatively, all plots (of all layouts) can be displayed via result.plot_all() . In this example we define a gate set ourselves as a list of quantum circuits. The example gate set chosen here is the \u201cXYI\u201d gate set with the addition of \\(\\pi\\) -rotations around the X- and Y-axis.\nNote that we also increased the number of random GST sequences in the GST configuration from 50 to 100 to account for the larger gate set. previous Graph State Bipartite Entanglement next Quantum Volume (QV) By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Clifford Randomized Benchmarking (CRB)",
    "url": "/iqm-benchmarks/examples/example_clifford_rb.html",
    "description": "NB: Clifford RB is executed by default with Interleaved RB ! previous IQM Benchmarks: Summary Notebook next Interleaved Randomized Benchmarking (IRB) By IQM Benchmarks developers \u00a9 Copyright 2024, IQM...",
    "content": "NB: Clifford RB is executed by default with Interleaved RB ! previous IQM Benchmarks: Summary Notebook next Interleaved Randomized Benchmarking (IRB) By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Mirror Randomized Benchmarking (MRB)",
    "url": "/iqm-benchmarks/examples/example_mirror_rb.html",
    "description": "previous Error Per Layered Gate (EPLG) next Graph State Bipartite Entanglement By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07....",
    "content": "previous Error Per Layered Gate (EPLG) next Graph State Bipartite Entanglement By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "IQM Benchmarks: Summary Notebook",
    "url": "/iqm-benchmarks/examples/example_experiment_all.html",
    "description": "NB: Clifford RB is executed by default with Interleaved RB ! previous Examples next Clifford Randomized Benchmarking (CRB) By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-0...",
    "content": "NB: Clifford RB is executed by default with Interleaved RB ! previous Examples next Clifford Randomized Benchmarking (CRB) By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Greenberger\u2013Horne\u2013Zeilinger (GHZ) State Fidelity",
    "url": "/iqm-benchmarks/examples/example_ghz.html",
    "description": "The aim of this benchmark is to show whether a GHZ state with high enough fidelity can be prepared such that the state is genuinely multipartite entangled. One can show that a fidelity larger than 0.5...",
    "content": "The aim of this benchmark is to show whether a GHZ state with high enough fidelity can be prepared such that the state is genuinely multipartite entangled. One can show that a fidelity larger than 0.5 is a sufficient condition (see Leibfried, D. et al., Creation of a six-atom \u2018Schr\u00f6dinger cat\u2019 state. Nature 438, 639\u2013642 (2005)) The benchmark currently offers two methods to estimate the fidelity: Multiple quantum coherences (G. J. Mooney et al., Generation and verification of 27-qubit Greenberger-Horne-Zeilinger states in a superconducting quantum computer, J. Phys. Commun. 5, 095004 (2021)) Randomized measurements (Elben, A. et al., Statistical correlations between locally randomized measurements: A toolbox for probing entanglement in many-body quantum states, Phys. Rev. A 99, 052323 (2019)) Additionally, for a given set of \\(n\\) qubits, different circuits can be applied which lead to the same GHZ state. Currently there are the following implementations: \u201cnaive\u201d: The textbook ciruit of depth \\(n\\) , which starts from a Hadamrd gate on one qubit and entangles each additional qubit with a CNOT operation from the first. \u201clog_depth\u201d: A logarithmic depth circuit utilizing parallel CNOT applications. Either the method in Cruz et al. https://arxiv.org/abs/1807.05572 or the method in Mooney et al. https://arxiv.org/abs/2101.08946 is used, depending on which yields the lower depth or the lower number of 2-qubit gates. \u201ctree\u201d: An in-house logarithmic depth circuit utilizing calibration data of the CZ-fidelities and a tree-graph algorithm to find a circuit with minimal depth and high fidelity 2-qubit gates. Note that the first two methods will always give the same circuit for the same qubit layout (and the same coupling map), while the \u201ctree\u201d method relies on the latest calibration fidelities and can give different circuits on different days.\nThus for consistent comparisons one of the first two methods should be chosen, while for the best results, i.e. the largest possible GME entangled GHZ state, the tree-method is preferable. The important parameters are: custom_qubits_array : A list[list[int]] which includes all qubit layouts on which the benchmark is run. shots : The number of shots for the fidelity measurement fidelity_routine : Either \u201ccoherences\u201d or \u201crandomized_measurements\u201d rem : Boolean value that controls whether readout error mitigation is used mit_shots : Whenever rem=True, this parameter controls the total number of shots used to calibrate readout error mitgation num_RMs : The number of randomized measurement settings (only necessary when choosing fidelity_routine=randomized_measurements ) For thinking about which qubit layouts to use, the following visualization of the connectivity and CZ fidelities is helpful. Requirements: Access to the backend, in this example IQM Garnet. An access token environment variable needs to be set via os.environ[\"IQM_TOKEN\"] = <your_token> . Use of the plot: If the qubit_layouts argument is provided, the selected qubits are marked in orange. CZ errors are indicated with edge width, thinner is better , where the edge width is given by \\(w_{ij} = - \\mathrm{log}(\\mathcal{F}_{\\mathrm{CZ}}^{ij})\\) . Each edge is also labeled with the width value. Some graph layouts are predefined to match the layout as shown in IQM-Resonance. If the layout is not predefined, a graph in grid or star layout will be automatically generated, dependeing on the backend. Automatically generated graphs might need to be rerun a few times until a nice node layout is found. To see individual fidelitiy and uncertainty values of a given qubit layout, one can filter the result.observations -list by layout as shown below. The plot allows a comparison of all layout results with and without REM, where the data point description labels \u201cL0\u201d, \u201cL1\u201d, \u2026 enumerate the layouts in the order defined in the configuration. previous Circuit Layer Operations Per Second (CLOPS) next Q-Score By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Graph State Bipartite Entanglement",
    "url": "/iqm-benchmarks/examples/example_graphstate.html",
    "description": "Set IQM Token if using Resonance. The negativity is shown as a percentage of the ideal maximum value of 0.5 (which would be achieved on a noiseless backend). Plot the lowest and highest negativity res...",
    "content": "Set IQM Token if using Resonance. The negativity is shown as a percentage of the ideal maximum value of 0.5 (which would be achieved on a noiseless backend). Plot the lowest and highest negativity resconstructed density matrices Display max negativities in the backend graph All the qubit pair groups generated during execution previous Mirror Randomized Benchmarking (MRB) next Compressive Gate Set Tomography (GST) By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Error Per Layered Gate (EPLG)",
    "url": "/iqm-benchmarks/examples/example_eplg.html",
    "description": "In order to be able to use calibration fidelities as a proxy for selecting a linear chain, we need to specify the calibration URL of the station. If specifying qubit pairs manually (not necessarily fo...",
    "content": "In order to be able to use calibration fidelities as a proxy for selecting a linear chain, we need to specify the calibration URL of the station. If specifying qubit pairs manually (not necessarily forming a linear chain), this is not needed: you can simply pass the backend as a string name. Display all the attributes in the dataset previous Interleaved Randomized Benchmarking (IRB) next Mirror Randomized Benchmarking (MRB) By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Circuit Layer Operations Per Second (CLOPS)",
    "url": "/iqm-benchmarks/examples/example_clops.html",
    "description": "The plot generated by the CLOPS analysis is a bar plot that shows a breakdown of elapsed times in the experiment in units of seconds. The bars labeled as \u201cRemote\u201d refer to time spent in the remote com...",
    "content": "The plot generated by the CLOPS analysis is a bar plot that shows a breakdown of elapsed times in the experiment in units of seconds. The bars labeled as \u201cRemote\u201d refer to time spent in the remote components of the experiment, as reported by the backend. Remote (components) shows the values of the time spent in compilation, submission and execution of the jobs. Remote (total) shows the total time spent in the remote components of the experiment. NB: the difference between the Remote \u201ctotal\u201d and \u201ccomponents\u201d elapsed times may be due to other aspects like loading and storing jobs and IDs, etc. The \u201cWall-time\u201d bars show time spent in the experiment as experienced by the user. NB: The time spent in assigning parameters is not included in the CLOPS value, since this is done offline in your (the user\u2019s) hardware. Wall-time (CLOPS) encompasses the time related to the CLOPS value, i.e., comprising only of submitting jobs per template and retrieving the results, without time spent in transpilation or parameter assignment, which are both done offline. Wall-time (total) shows a breakdown of the total wall-time of the experiment, with the added offline times of transpilation of circuit templates and assignment of parameters. NB: The difference between the \u201cuser retrieve\u201d time and the Remote \u201ctotal\u201d time can be assigned as a latency time, and may vary significantly depending on external circumstances. This latency is the aggregated time between when a job is finished and when the results are received (which may be due to several external factors). previous Quantum Volume (QV) next Greenberger\u2013Horne\u2013Zeilinger (GHZ) State Fidelity By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Q-Score",
    "url": "/iqm-benchmarks/examples/example_qscore.html",
    "description": "previous Greenberger\u2013Horne\u2013Zeilinger (GHZ) State Fidelity next Devices By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07....",
    "content": "previous Greenberger\u2013Horne\u2013Zeilinger (GHZ) State Fidelity next Devices By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-benchmarks",
    "title": "Examples",
    "url": "/iqm-benchmarks/examples/examples.html",
    "description": "This section contains a collection of examples that demonstrate how to use the IQM Benchmarks package to perform various benchmarks. The first run all experiments in the package, and the rest are spec...",
    "content": "This section contains a collection of examples that demonstrate how to use the IQM Benchmarks package to perform various benchmarks. The first run all experiments in the package, and the rest are specific examples of different benchmarking protocols. previous IQM Benchmarks next IQM Benchmarks: Summary Notebook By IQM Benchmarks developers \u00a9 Copyright 2024, IQM. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "Cirq on IQM User Guide",
    "url": "/iqm-client/user_guide_cirq.html",
    "description": "This guide serves as an introduction to the main features of Cirq on IQM, the Cirq adapter for IQM Client.\nYou are encouraged to run the demonstrated code snippets and check the output yourself. Note ...",
    "content": "This guide serves as an introduction to the main features of Cirq on IQM, the Cirq adapter for IQM Client.\nYou are encouraged to run the demonstrated code snippets and check the output yourself. Note If you have previously installed the (now deprecated) cirq-iqm package in your Python environment,\nyou should first uninstall it with $ pip uninstall cirq-iqm . In this case, you should also include\nthe --force-reinstall option in the iqm-client installation command. The recommended way is to install the optional cirq feature of the iqm-client distribution package directly\nfrom the Python Package Index (PyPI): After installation, Cirq on IQM can be imported in your Python code as follows: Cirq on IQM provides descriptions of IQM\u2019s quantum architectures using the IQMDevice class, which is a\nsubclass of cirq.devices.Device and implements general functionality relevant to all IQM devices. The native\ngates and connectivity of the architecture are available in the IQMDeviceMetadata object returned by the IQMDevice.metadata property. It is possible to use the IQMDevice class directly, but\ncertain devices with predefined metadata are also available as subclasses of IQMDevice. As an example, let\nus import the class Adonis , which describes IQM\u2019s five-qubit architecture, and view some of its\nproperties contained in its metadata property: IQM devices use cirq.NamedQubit to represent their qubits. The names of the qubits consist of a prefix\nfollowed by a numeric index, so we have qubit names like QB1 , QB2 , etc. Note that we use 1-based\nindexing. You can get the list of the qubits in a particular device by accessing the qubits attribute of a\ncorresponding IQMDevice instance: There are two main ways of constructing cirq.Circuit instances for IQM devices: Create a Circuit instance using arbitrary qubit names and types. Create a Circuit from an OpenQASM 2.0 program. The qubit names are determined by the OpenQASM qreg names,\nappended with zero-based indices. Below we give an example of each method. Construct a circuit and use arbitrary qubits: This will result in the circuit You can read an OpenQASM 2.0 program from a file (or a string), e.g. and convert it into a cirq.Circuit object using circuit_from_qasm() . circuit_from_qasm() uses the OpenQASM 2.0 parser in cirq.contrib.qasm_import . After a circuit has been constructed, it can be decomposed and routed against a particular IQMDevice . The method IQMDevice.decompose_circuit() accepts a cirq.Circuit object as an argument and\nreturns the decomposed circuit containing only native operations for the corresponding device: The Hadamard and CNOT gates are not native to Adonis, so they were decomposed to X, Y and CZ gates which are. Routing means transforming a circuit such that it acts on the device qubits, and respects the\ndevice connectivity.\nThe method IQMDevice.route_circuit() accepts a cirq.Circuit object as an argument,\nand returns the circuit routed against the device, acting on the device qubits instead of the\narbitrary qubits we had originally. Along with the routed circuit route_circuit() returns the initial_mapping and final_mapping .\nThe initial_mapping is either the mapping from circuit to device qubits as provided by an cirq.AbstractInitialMapper or a mapping that is initialized from the device graph.\nThe final_mapping is the mapping from physical qubits before inserting SWAP gates to the physical\nqubits after the routing is complete As mentioned above, you may also provide the initial mapping from the logical qubits in the circuit to the physical qubits on the device yourself, by using the keyword argument initial_mapper .\nIt serves as the starting point of the routing: Under the hood, route_circuit() leverages the routing provided by cirq.RouteCQC .\nIt works on single- and two-qubit gates, and measurement operations of arbitrary size.\nIf you have gates involving more than two qubits you need to decompose them before routing.\nSince routing may add some SWAP gates to the circuit, you will need to decompose the circuit\nagain after the routing, unless SWAP is a native gate for the target device. To ensure that the transpiler is restricted to a specific subset of qubits, you can provide a list\nof qubits in the qubit_subset argument such that ancillary qubits will not be added during\nrouting. This is particularly useful when running Quantum Volume benchmarks. Devices that have the IQM Star architecture (e.g. IQM Deneb) contain\ncomputational resonators in addition to qubits, and use qubit-resonator gates instead of two-qubit\ngates. These include the MOVE gate which moves qubit states to and from the resonators.\nThere are two main supported workflows for the Star architecture: Construct your circuit as you would for a regular qubits-only device, decompose (and optimize)\nit to native gates, and then route it using IQMDevice.route_circuit() .\nThis will attempt to route all the (fictional) two-qubit gates in the circuit through the\nresonator(s) using the native gates, adding MOVE gates as necessary.\nUnder the hood, this uses the transpile_insert_moves() function of the iqm_client library. Construct your circuit directly using the device qubits, resonators, and qubit-resonator gates,\nrouting it manually. Advanced users can use transpile_insert_moves_into_circuit() to transpile circuits that\nhave some MOVE gates in them in addition to fictional qubit-qubit gates. Yet another important topic is circuit optimization. In addition to the optimizers available in Cirq you can also\nbenefit from Cirq on IQM\u2019s optimizers module which contains some optimization tools geared towards IQM devices.\nThe function optimizers.simplify_circuit() is a convenience method encapsulating a particular sequence of\noptimizations. Let us try it out on our decomposed and routed circuit above: Note The funtion simplify_circuit() is not associated with any IQM device, so its result may contain non-native\ngates for a particular device. In the example above we don\u2019t have them, however it is generally a good idea to run\ndecomposition once again after the simplification. Some IQM quantum computers support classically-controlled gates, that is, gates that are executed\nconditionally depending on the result of a measurement preceding them in the quantum circuit. This\nsupport currently has several limitations: Only the PhasedXPowGate , XPowGate and YPowGate gates can be classically controlled. The gates can only be conditioned on the measurement result of a single qubit, and the only control available is to\napply the gate if the result is 1, and apply an identity gate if the result is 0. The availability of the controlled gates depends on the instrumentation of the quantum computer. The classical control can be applied on an operation using with_classical_controls() : After an X gate is applied on Alice , the qubit is measured and the result is stored\nin the key A . If the result is 1 (which it should always be in this case),\nanother X gate is subsequently applied on Bob . If it is 0, an identity gate of corresponding\nduration is applied instead. The final measurement in the above circuit should always return 11 , even though Alice and Bob are never\nactually entangled. Note Because classically controlled gates can currently only take feedback from one classical bit you must condition\nthem on a measurement key that only measures a single qubit. The cirq.R operation can be used to reset qubits to the \\(|0\\rangle\\) state.\nIt is currently implemented as a (projective) measurement followed by a classically controlled X\ngate conditioned on the result, and is only available if the quantum computer supports\nclassically controlled gates. In the above example, the X gate prepares the qubit q1 in a \\(|1\\rangle\\) state,\nand the reset then collapses it back into the \\(|0\\rangle\\) state.\nExecuting the circuit should result in (mostly) zeros being measured. Note You can access IQM quantum computers via IQM Resonance or use one of the IQM quantum computers deployed at HPC centers and research institutions around the globe. Cirq contains various simulators which you can use to simulate the circuits constructed above.\nIn this subsection we demonstrate how to run them on an IQM quantum computer. Cirq on IQM provides IQMSampler , a subclass of cirq.work.Sampler , which is used\nto execute quantum circuits and decompose/route them for the architecture of the quantum computer.\nOnce you have access to an IQM server you can create an IQMSampler instance and use its run() method to send a circuit for execution and retrieve the results: Note that the code snippet above assumes that you have set the variable iqm_server_url to the URL\nof the IQM server. Additionally, you can pass IQM backend specific options to the IQMSampler class.\nThe below table summarises the currently available options: Name Type Example value Description calibration_set_id uuid.UUID \u201cf7d9642e-b0ca-4f2d-af2a-30195bd7a76d\u201d Indicates the calibration set to use. Defaults to None , which means the IQM server will use the\ncurrent default calibration set automatically. compiler_options CircuitCompilationOptions see below Contains various options that affect the compilation of the quantum circuit into an\ninstruction schedule. The CircuitCompilationOptions class contains the following attributes (in addition to some\nadvanced options described in the API documentation): Name Type Example value Description max_circuit_duration_over_t2 float | None 1.0 Set server-side circuit disqualification threshold. If any circuit in a job is estimated to take longer than the\nshortest T2 time of any qubit used in the circuit multiplied by this value, the server will reject the job.\nSetting this value to 0.0 will disable circuit duration check.\nThe default value None means the server default value will be used. heralding_mode HeraldingMode \u201czeros\u201d Heralding mode to use during execution. The default value is \u201cnone\u201d, \u201czeros\u201d enables\nall-zeros heralding where the circuit qubits are measured before the circuit begins, and the\nserver post-selects and returns only those shots where the heralding measurement yields zeros\nfor all the qubits. For example if you would like to use a particular calibration set, you can provide it as follows: The sampler will by default use an IQMDevice created based on architecture data obtained\nfrom the server, which is then available in the IQMSampler.device property. The architecture\ndata depends on the calibration set used by the sampler, so one should usually use different sampler\ninstances for different calibration sets. Alternatively, the device can be specified directly with\nthe device argument, but this is not recommended when running on a real quantum computer. When executing a circuit that uses something other than the device qubits, you need to route it first,\nas explained in the Routing section above. If you are using IQM Resonance, you have two options to authenticate: Set the IQM_TOKEN environment variable with the API token obtained from the Resonance dashboard. Pass the token parameter to IQMSampler . This will be forwarded to IQMClient . If the IQM server you are connecting to requires authentication, you may use IQM Client CLI to retrieve and automatically refresh access tokens,\nthen set the IQM_TOKENS_FILE environment variable, as instructed, to point to the tokens file.\nSee IQM Client CLI\u2019s documentation for details. Alternatively, you may authenticate yourself using the IQM_AUTH_SERVER , IQM_AUTH_USERNAME and IQM_AUTH_PASSWORD environment variables, or pass them as\narguments to IQMSampler , but this approach is less secure and\nconsidered deprecated. Multiple circuits can be submitted to the IQM quantum computer at once using the run_iqm_batch() method of IQMSampler .  This is often faster than\nexecuting the circuits individually. Circuits submitted in a batch are still executed sequentially. It is possible to inspect the final circuits that would be submitted for execution before actually submitting them,\nwhich can be useful for debugging purposes. This can be done using IQMSampler.create_run_request() , which returns\na RunRequest containing the circuits and other data. The method accepts the same\nparameters as IQMSampler.run() and IQMSampler.run_iqm_batch() , and creates the run request in the same\nway as those functions. It is also possible to print a run request when it is actually submitted by setting the environment variable IQM_CLIENT_DEBUG=1 . More examples are available in the Cirq on IQM examples directory of the IQM Client repository. previous Qiskit on IQM User Guide next License By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "Contributors",
    "url": "/iqm-client/authors.html",
    "description": "Olli Ahonen < olli @ meetiqm . com > Ville Bergholm < ville @ meetiqm . com > Maija Nevala < maija @ meetiqm . com > Hayk Sargsyan < hayk @ meetiqm . com > Maxim Smirnov < dc914337 @ gmail . com > Oll...",
    "content": "Olli Ahonen < olli @ meetiqm . com > Ville Bergholm < ville @ meetiqm . com > Maija Nevala < maija @ meetiqm . com > Hayk Sargsyan < hayk @ meetiqm . com > Maxim Smirnov < dc914337 @ gmail . com > Olli Tyrkk\u00f6 < otyrkko @ meetiqm . com > Rakhim Davletkaliyev < rakhim . davletkaliyev @ meetiqm . com > Matthias Beuerle < matthias . beuerle @ meetiqm . com > Janne Kotilahti < janne @ meetiqm . com > Vladimir Kukushkin < vladimir . kukushkin @ meetiqm . com > Ricardas Brazinskas < ricardas . brazinskas @ meetiqm . com > Leon Wubben < leon @ meetiqm . com > Adrian Auer < adrian . auer @ meetiqm . com > Stefan Seegerer < stefan . seegerer @ meetiqm . com > Vicente Pina Canelles < vicente . pina @ meetiqm . com > Jake Muff < jake . muff @ vtt . fi > Johan Guldmyr < johan @ meetiqm . com > Caspar Ockeloen-Korppi < caspar @ meetiqm . com > previous License next Changelog By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "API Reference",
    "url": "/iqm-client/API.html",
    "description": "iqm.cirq_iqm Cirq adapter for IQM's quantum computers. iqm.iqm_client Client-side library for connecting to and executing quantum circuits on IQM quantum computers. iqm.qiskit_iqm Qiskit adapter for I...",
    "content": "iqm.cirq_iqm Cirq adapter for IQM's quantum computers. iqm.iqm_client Client-side library for connecting to and executing quantum circuits on IQM quantum computers. iqm.qiskit_iqm Qiskit adapter for IQM's quantum computers. previous IQM Client next iqm.cirq_iqm By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "IQM Client CLI User Guide",
    "url": "/iqm-client/user_guide_cli.html",
    "description": "Command-line interface (CLI) for managing user authentication when using IQM quantum computers. For general usage instructions, run First, IQM Client CLI needs initialization, which produces a configu...",
    "content": "Command-line interface (CLI) for managing user authentication when using IQM quantum computers. For general usage instructions, run First, IQM Client CLI needs initialization, which produces a configuration file: IQM Client CLI will ask a few questions. You can also pass the values via command line to avoid having an interactive\nprompt. See iqmclient init --help for details. To log in, use This will ask you to enter your username and password. If you have a temporary password you will be asked to go to the\nauthentication server and enter a new password. URL of the authentication server will be provided. After a successful authentication, tokens will be saved into a tokens file (path specified in the configuration file),\nand a token manager daemon will start in the background. Token manager will periodically refresh the session and\nre-write the tokens file. To use the token manager in a foreground mode (not as daemon), run iqmclient auth login --no-daemon . This requires\nkeeping the shell session alive. However, you can start the process in the background by adding & after the\ncommand: iqmclient auth login --no-daemon & . This applies to Bash, zsh and similar shells, but may not be available\non all shells. To login and get tokens once, without starting a token manager at all, run iqmclient auth login --no-refresh . If the tokens file already exists, then running iqmclient auth login will first attempt to refresh the session\nwithout asking you for a username and password. If that fails (because existing tokens may already have expired), you\u2019ll\nbe asked to re-enter your credentials. See iqmclient auth login --help for more details. Adapters based on IQM Client, such as Cirq on IQM and Qiskit on IQM, can take advantage of the tokens file maintained by\nIQM Client CLI. This way you won\u2019t need to provide the authentication server URL, username, or password to the adapter\nlibrary itself. To achieve this, follow the instructions printed on the screen after running iqmclient auth login .\nNamely, set the IQM_TOKENS_FILE environment variable to point to your tokens file. On Linux: On Windows: Once set, this environment variable is read by the instance of IQM Client associated with the adapter. As a result,\nfrom the point of view of the adapter it looks like authentication is simply not required (i.e. no\nauthentication-related information has to be provided to the adapter). To see the current status of the token manager, use: If the tokens file exists, iqmclient auth status will report whether the corresponding token\nmanager is running. It will also print the time of the last successful refresh request, and\nhow much time is left until current tokens expire. See iqmclient auth status --help for more details. To log out, run This will send a logout request to the authentication server, kill the token manager daemon (if any), and delete the\ntokens file. You may want to stop the token manager, but maintain the session on the server and keep the tokens file intact.\nTo do so, run: See iqmclient auth logout --help for more details. By default, all IQM Client CLI commands read the configuration file from the default location ~/.config/iqm-client-cli/config.json . You can specify a different filepath by providing the --config-file value,\nfor example: previous Integration Guide next Qiskit on IQM User Guide By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "Qiskit on IQM User Guide",
    "url": "/iqm-client/user_guide_qiskit.html",
    "description": "This guide illustrates the main features of Qiskit on IQM, the Qiskit adapter for IQM Client.\nYou are encouraged to run the demonstrated code snippets and check the output yourself. Note IQM provides ...",
    "content": "This guide illustrates the main features of Qiskit on IQM, the Qiskit adapter for IQM Client.\nYou are encouraged to run the demonstrated code snippets and check the output yourself. Note IQM provides access to its quantum computers via IQM Resonance \u2013 IQM\u2019s quantum cloud service.\nPlease head over to our website to learn more. Here\u2019s a quick and easy way to run a small computation on an IQM quantum computer to check that\nthings are set up correctly, either\nthrough the IQM cloud service Resonance, or using an on-premises quantum computer. Login to IQM Resonance with your credentials. Upon your first visit to IQM Resonance, you can generate your unique, non-recoverable API token\ndirectly from the Dashboard page by selecting Generate token . It\u2019s important to copy the token\nimmediately from the window, as you won\u2019t be able to do so once the window is closed. If you lose\nyour token, you have the option to regenerate it at any time. However, be aware that regenerating\nyour API token will invalidate any previously generated token. Download one of the demo notebooks from IQM Academy or the resonance_example.py example file (Save Page As\u2026) Install Qiskit on IQM as instructed below. Add your API token to the example (either as the parameter token to the IQMProvider constructor, or by setting the environment variable IQM_TOKEN ) Run the Jupyter notebook (or run python resonance_example.py if you decided to go for the Python script). If you\u2019re connecting to a real quantum computer, the output should show almost half of the\nmeasurements resulting in \u201800000\u2019 and almost half in \u201811111\u2019 - if this is the case, things are\nset up correctly! You can find a video guide on how to set things up here .\nMore ready-to-run examples can also be found at IQM Academy . Download the bell_measure.py example file (Save Page As\u2026). Install Qiskit on IQM as instructed below. Install IQM Client CLI and log in as instructed in the documentation Set the environment variable as instructed by IQM Client CLI after logging in. Run $ python bell_measure.py --cortex_server_url https://demo.qc.iqm.fi/cocos - replace the example URL with the correct one. If you\u2019re connecting to a real quantum computer, the output should show almost half of the\nmeasurements resulting in \u201800\u2019 and almost half in \u201811\u2019 - if this is the case, things are set up\ncorrectly! Note If you have previously installed the (now deprecated) qiskit-iqm package in your Python environment,\nyou should first uninstall it with $ pip uninstall qiskit-iqm . In this case, you should also include\nthe --force-reinstall option in the iqm-client installation command. The recommended way is to install the optional qiskit feature of the iqm-client distribution package directly\nfrom the Python Package Index (PyPI): After installation, Qiskit on IQM can be imported in your Python code as follows: If you are using IQM Resonance, you have two options to authenticate: Set the IQM_TOKEN environment variable to the API token obtained from the Resonance dashboard. Pass the token parameter to IQMProvider . This will be forwarded to IQMClient . For an example, see the resonance_example.py file If the IQM server you are connecting to requires authentication, you may use IQM Client CLI to retrieve and automatically refresh access tokens,\nthen set the IQM_TOKENS_FILE environment variable, as instructed, to point to the tokens file.\nSee IQM Client CLI\u2019s documentation for details. You may also authenticate yourself using the IQM_AUTH_SERVER , IQM_AUTH_USERNAME and IQM_AUTH_PASSWORD environment variables, or pass them as\narguments to IQMProvider , however this approach is less secure and considered deprecated. In this section we demonstrate the practicalities of using Qiskit on IQM to execute\nquantum circuits on an IQM quantum computer. Let\u2019s consider the following quantum circuit which prepares and measures a GHZ state: To run this circuit on an IQM quantum computer you need to initialize an IQMProvider instance with the IQM server URL, use it to retrieve an IQMBackend instance representing\nthe quantum computer, and use Qiskit\u2019s transpile() function\nfollowed by IQMBackend.run() as usual. shots denotes the number of times the quantum\ncircuit(s) are sampled: Note As of qiskit >= 1.0 , Qiskit no longer supports execute() . Instead you should\nfirst transpile the circuit and then run it, as shown in the code above.\nSee the Transpilation section to learn how to transpile circuits in various ways. Note If you want to inspect the circuits that are sent to the device, use the circuit_callback keyword argument of IQMBackend.run() . See also Inspecting circuits before submitting them for execution for inspecting the actual run request sent for\nexecution. You can optionally provide IQMBackend specific options as additional keyword arguments to IQMBackend.run() , documented at IQMBackend.create_run_request() .\nFor example, you can enable heralding measurements using circuit_compilation_options as follows: The calibration data for an IQM quantum computer is stored in a calibration set . An IQMBackend instance\nalways corresponds to a specific calibration set, so that its transpilation target uses only those QPU components\n(qubits and computational resonators) and gates which are available in that calibration set. The server default\ncalibration set will be used by default, but you can also use a different calibration set by specifying the calibration_set_id parameter to IQMProvider.get_backend() or IQMBackend . If the server default\ncalibration set has changed after you have created the backend, the backend will still use the original default calibration\nset when submitting circuits for execution. When this happens you will get a warning.\nYou will need to create a new backend if you want to use the new default calibration set instead. The results of a job that was executed on the IQM quantum computer, represented as a Result instance, can be inspected using the usual Qiskit methods: The result comes with some metadata, such as the RunRequest that\nproduced it in result.request . The request contains e.g. the qubit mapping and the ID of the\ncalibration set that were used in the execution: Another piece of useful metadata are the timestamps of the various steps of processing the job. The\ntimestamps are stored in the dict result.timestamps . The job processing has three steps, compile where the circuits are converted to instruction schedules, submit where the instruction schedules are submitted for execution, and execution where the instruction schedules are executed and the measurement results are returned. The dict contains a timestamp for the start and end of each step.\nFor example, the timestamp of starting the circuit compilation is stored with key compile_start .\nIn the same way the other steps have their own timestamps with keys consisting of the step name and a _start or _end suffix. In addition to processing step timestamps, there are also timestamps for the job itself, job_start for when the job request was received by the server and job_end for when the job processing\nwas finished. If the processing of the job is terminated before it is complete, for example due to an error, the timestamps of\nprocessing steps that were not taken are not present in the dict. For example: The IQMBackend instance we created above provides all the standard backend functionality that one expects from a\nbackend in Qiskit. For this example, I am connected to an IQMBackend that features a 5-qubit chip with star-like\nconnectivity: Let\u2019s examine its basis gates and the coupling map through the backend instance Note that for IQMBackends the identity gate id is not actually a gate that is executed on the device and is simply omitted.\nAt IQM we identify qubits by their names, e.g. \u2018QB1\u2019, \u2018QB2\u2019, etc. as demonstrated above. In Qiskit, qubits are\nidentified by their indices in the quantum register, as you can see from the printed coupling map above. Most of the\ntime you do not need to deal with IQM-style qubit names when using Qiskit, however when you need, the methods IQMBackendBase.qubit_name_to_index() and IQMBackendBase.index_to_qubit_name() can become handy. Some IQM quantum computers support classically controlled gates, that is, gates that are executed\nconditionally depending on the result of a measurement preceding them in the quantum circuit. This\nsupport currently has several limitations: Only the x , y , rx , ry and r gates can be classically controlled. The gates can only be conditioned on one classical bit, and the only control available is to\napply the gate if the bit is 1, and apply an identity gate if the bit is 0. The availability of the controlled gates depends on the instrumentation of the quantum computer. The classical control can be applied on a circuit instruction using c_if() : The first measurement operation stores its result in the 1-bit classical register c . If the\nresult is 1, the X gate will be applied. If it is zero, an identity gate of corresponding\nduration is applied instead. Executing the above circuit should result in the counts being approximately 50/50 split\nbetween the \u201800 0\u2019 and \u201811 1\u2019 bins of the histogram (even though the state itself is never entangled). Note Because the gates can only take feedback from one classical bit you must place the measurement result\nin a 1-bit classical register, c in the above example. The qiskit.circuit.Reset operation can be used to reset qubits to the \\(|0\\rangle\\) state.\nIt is currently implemented as a (projective) measurement followed by a classically controlled X gate conditioned\non the result, and is only available if the quantum computer supports classically controlled gates. In the above example, the Hadamard gate prepares a uniform superposition of the \\(|0\\rangle\\) and \\(|1\\rangle\\) states, and the reset then collapses it back into the \\(|0\\rangle\\) state.\nExecuting the circuit should result in (mostly) zeros being measured. It is possible to inspect the final circuits that would be submitted for execution before actually submitting them,\nwhich can be useful for debugging purposes. This can be done using IQMBackend.create_run_request() , which returns\na RunRequest containing the circuits and other data. The method accepts the same\nparameters as IQMBackend.run() . It is also possible to print a run request when it is actually submitted by setting the environment variable IQM_CLIENT_DEBUG=1 . In this section we study how the circuit gets transpiled in more detail. You can use the default Qiskit transpiler on IQM quantum computers with both\nthe Crystal and the Star architectures.\nStarting from the GHZ circuit we created above: Under the hood the Qiskit transpiler uses the IQMDefaultSchedulingPlugin plugin that\nautomatically adapts the transpiled circuit to the IQMBackend. In particular, if optimization_level > 0 , the plugin will use the IQMOptimizeSingleQubitGates pass to optimize single-qubit gates, and for devices that have the IQM Star architecture, the plugin will use the IQMNaiveResonatorMoving pass to automatically insert MoveGate instructions\nas needed. Alternatively, you can use the transpile_to_IQM() function for more precise control over the\ntranspilation process as documented below. It is also possible to use one of our other pre-defined transpiler plugins as an argument to transpile() , for example transpile(circuit, backend=backend, scheduling_method=\"only_move_routing_keep\") .\nAdditionally, you can use any of our transpiler passes\nto define your own qiskit.transpiler.PassManager if you want to assemble custom\ntranspilation procedures manually. The IQM Star architecture includes computational resonators as additional QPU components,\nand uses qubit-resonator gates instead of two-qubit gates. These include MoveGate which moves qubit states to and from the resonators. The standard Qiskit transpiler does not know how to compile qubit-resonator gates.\nThis is why IQMBackend provides the Qiskit transpiler a simplified transpilation target in which\nthe resonators and MOVE gates have been abstracted away, and replaced with fictional two-qubit gates\nthat directly connect qubits that can be made to interact via a resonator. It then\nuses IQMDefaultSchedulingPlugin to re-introduce resonators and add MOVE gates between qubits and resonators as necessary at the scheduling stage. IQMDefaultSchedulingPlugin is executed automatically when you use the Qiskit transpiler.\nStarting from the GHZ circuit we created above: As an alternative to the native Qiskit transpiler integration, you can use the transpile_to_IQM() function.  It is meant for users who want at least one of the following: more fine grained control over the transpilation process without having to figure out which IQM\ntranspiler plugin to use, transpile Star architecture circuits that already contain qubit-resonator gates, or force the transpiler to use a strict subset of qubits on the device. For example, if you want to transpile the circuit with optimization_level=0 but also apply the\nsingle qubit gate optimization pass, you can do one of the following, equivalent things: Similarly, if you want to transpile a native Star architecture circuit that already contains MoveGate instances (that act on a qubit and a computational resonator), you can do the following: And if you want force the compiler to use a strict subset of qubits on the device, you can do the following: Note that if you do this, you do need to provide the IQMBackend.run() method a qubit\nmapping that matches the restriction: For the native integration of the custom IQM transpiler passes with the Qiskit transpiler, we\nhave implemented several scheduling plugins for the Qiskit transpiler. These plugins can be used as\nthe scheduling_method string argument for transpile() .\nThe mapping between these strings and the classes that implement the plugins is defined in the pyproject.toml file of this package.\nThe documentation of these plugins in found in the respective plugin classes. If you are unsure which plugin to use, you can use transpile_to_IQM() with the appropriate\narguments. This function determines which plugin to use based on the backend and the provided\narguments.  Note that the Qiskit transpiler automatically uses the IQMDefaultSchedulingPlugin when the backend is an IQMBackend. It is possible to submit multiple circuits to be executed, as a batch. In many cases this is more\ntime efficient than running the circuits one by one. Batch execution has some restrictions: all the\ncircuits must be executed for the same number of shots. For starters,\nlet\u2019s construct two circuits preparing and measuring different Bell states: Now, we can run them together in a batch: The batch execution functionality can be used to run a parameterized circuit for various concrete values of parameters: Note that it is important to transpile the parameterized circuit before binding the values to ensure a consistent qubit\nmeasurements across circuits in the batch. When multiple measurement instructions are present in a circuit, the measurements may be multiplexed, meaning the\nmeasurement pulses would be simultaneously executed on the quantum hardware, if possible. Multiplexing requires the\nmeasurement instructions to form a convex subgraph, i.e. not have other instructions between them acting on the same\nqubits. You don\u2019t have to do anything special to enable multiplexing, it is automatically attempted by the\ncircuit-to-pulse compiler on the server side. However, you can ensure multiplexing (whenever\npossible on the hardware level) by putting a barrier instruction before and after a group of\nmeasurements.  This prevents the transpiler from inserting any other instructions between the\nmeasurements.  There is no concept of multiplexed or simultaneous measurements in Qiskit, so the\ncircuit diagram will not indicate any multiplexing: In this section we show how to simulate the execution of quantum circuits on IQM quantum computers. Note Since the simulation happens locally, you do not need access to an actual quantum computer. The execution of circuits can be simulated locally, with a noise model to mimic the real hardware as\nmuch as possible.  To this end, Qiskit on IQM provides the class IQMFakeBackend that can\nbe instantiated with properties of a certain QPU, e.g. using functions such as IQMFakeAdonis() , IQMFakeApollo() and IQMFakeAphrodite() that represent specific IQM quantum architectures with pre-defined, representative noise models. Above, we use an IQMFakeAdonis() instance to run a noisy simulation of circuit on a simulated 5-qubit Adonis chip.\nThe noise model includes relaxation ( \\(T_1\\) ) and dephasing ( \\(T_2\\) ), gate infidelities and readout errors.\nIf you want to customize the noise model instead of using the default one provided by IQMFakeAdonis() , you can create\na copy of the IQMFakeBackend instance with an updated error profile: Circuits can be executed against a mock environment: an IQM server that has no real quantum computer hardware.\nResults from such executions are random bits. This may be useful when developing and testing software integrations. Qiskit on IQM contains IQMFacadeBackend , which allows to combine the mock remote execution with a local\nnoisy quantum circuit simulation. This way you can both validate your integration as well as get an idea of the expected circuit execution results. To run a circuit this way, use the \"facade_adonis\" backend retrieved from the provider. Note that the provider must be\ninitialized with the URL of a quantum computer with the equivalent architecture (i.e. names of qubits, their\nconnectivity, and the native gateset should match the 5-qubit Adonis architecture). Note When a classical register is added to the circuit, Qiskit fills it with classical bits of value 0 by default. If the\nregister is not used later, and the circuit is submitted to the IQM server, the results will not contain those\n0-filled bits. To make sure the facade backend returns results in the same format as a real IQM server, IQMFacadeBackend.run() checks for the presence of unused classical registers, and fails with an error if there\nare any. previous IQM Client CLI User Guide next Cirq on IQM User Guide By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "IQM client",
    "url": "/iqm-client/index.html",
    "description": "29.3.0 2025-07-07 Client-side library for connecting to an IQM quantum computer. Includes Qiskit and Cirq adapters for IQM\u2019s quantum computers. See user guides for Qiskit and Cirq for introductions on...",
    "content": "29.3.0 2025-07-07 Client-side library for connecting to an IQM quantum computer. Includes Qiskit and Cirq adapters for IQM\u2019s quantum computers. See user guides for Qiskit and Cirq for introductions on how to install and use the adapters. Also includes a CLI utility for managing user authentication when using IQM quantum computers. Index Module Index Search Page next IQM Client By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "IQM Client",
    "url": "/iqm-client/readme.html",
    "description": "Client-side Python library for connecting to an IQM quantum computer. Includes as an optional feature Qiskit and Cirq adapters for IQM\u2019s quantum computers, which allow you to: Transpile arbitrary quan...",
    "content": "Client-side Python library for connecting to an IQM quantum computer. Includes as an optional feature Qiskit and Cirq adapters for IQM\u2019s quantum computers, which allow you to: Transpile arbitrary quantum circuits for IQM quantum architectures Simulate execution on IQM quantum architectures with IQM-specific noise models\n(currently only the Qiskit adapter contains IQM noise models) Run quantum circuits on an IQM quantum computer Also includes a CLI utility for managing user\nauthentication when using IQM quantum computers. For executing code on an IQM quantum computer, you can use for example Qiskit on IQM or Cirq on IQM , which can be installed as optional\nfeatures of IQM Client from the Python Package Index (PyPI), e.g.: Note If you have previously installed the (now deprecated) qiskit-iqm or cirq-iqm packages in your\nPython environment, you should first uninstall them with $ pip uninstall qiskit-iqm cirq-iqm .\nIn this case, you should also include the --force-reinstall option in the iqm-client installation command. The CLI utility for managing user authentication can also\nbe installed as an optional feature: IQM Client by itself is not intended to be used directly by human users. If you want just the base IQM Client library,\nthough, you can install it with Note uv is highly recommended for practical Python environment and package management. Documentation for the latest version is available online .\nYou can build documentation for any older version locally by downloading the corresponding package from PyPI,\nand running the docs builder. For versions 20.12 and later this is done by running ./docbuild in the iqm-client root directory, and for earlier versions by running tox run -e docs . ./docbuild or tox run -e docs will build the documentation at ./build/sphinx/html .\nThese commands require installing the sphinx and sphinx-book-theme Python packages and graphviz . IQM Client is free software, released under the Apache License, version 2.0. Copyright 2021-2025 IQM Client developers. previous IQM client next API Reference By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "Integration Guide",
    "url": "/iqm-client/integration_guide.html",
    "description": "IQM client is designed to be the Python adapter to IQM\u2019s quantum computers for application-level\nquantum computing frameworks.  For example integrations maintained by IQM, please refer to the Qiskit a...",
    "content": "IQM client is designed to be the Python adapter to IQM\u2019s quantum computers for application-level\nquantum computing frameworks.  For example integrations maintained by IQM, please refer to the Qiskit and Cirq packages. IQM client offers the functionality to submit quantum circuits to an IQM quantum computer, query a\njob or a job status, and retrieve the quantum architecture of the quantum computer. The following sections illustrate how to integrate IQM quantum computers into your quantum computing\nframework. Initialising the IQM client is simple, and in case you perform authentication as described below,\nrequires only the URL of the IQM quantum computer. To submit a quantum circuit for execution, it has to be specified using the Circuit class.\nThe available native instructions are documented in the Instruction class. Then the circuit can be submitted, and its status and result can be queried with the job id. A dict containing arbitrary metadata can be attached to the circuit before submitting it for\nexecution. The attached metadata should consist only of values of JSON serializable datatypes.\nA utility function to_json_dict() can be used to convert supported datatypes,\ne.g. numpy.ndarray , to equivalent JSON serializable types. The progress of the job can be followed with IQMClient.get_run_status() . Once the job is ready,\nthe results can be read with IQMClient.get_run() . Both of these actions are combined in IQMClient.wait_for_results() which waits until the job is ready and then returns the result. In addition to the actual results, job result contains also metadata of the job execution.\nThe metadata includes the original request, ID of the calibration set used in the execution, and\na collection of timestamps describing the duration of the execution. The timestamps returned with job results are stored as an optional dict called timestamps in the metadata of RunResult of the job. Each timestamp is stored in the dict with a key describing the point in job processing where\nthe timestamp was stored. For example, the timestamp stored at the start of circuit compilation step is stored with\nkey compile_start . Other timestamps are stored in the same way, with keys containing the step name, compile , submit or execution , and either a _start or _end suffix. In addition, there are\nalso timestamps for starting and ending the job itself, job_start and job_end . If the job processing is\nterminated before it is complete the timestamps of steps not processed will not be present in the dict. The first timestamp stored is the job_start timestamp. It is stored when the server receives the job request. The job processing starts with compilation step where the circuits are converted to pulse schedules that can be\nsent for execution. Compilation step produces timestamps compile_start and compile_end . The pulse schedules are then submitted for execution. This step produces timestamps submit_start and submit_end . After submitting the pulse schedules the server waits for the execution results.\nThis step produces timestamps execution_start and execution_end . Finally, when job processing is complete, regardless whether the job was successful or not, the timestamp job_end is stored. IQM uses bearer token authentication to manage access to quantum computers.\nCurrently, there are three mutually exclusive ways of providing an authentication\ntoken to IQM client: The recommended way is to use IQM Client CLI to manage the authentication tokens and store them into a file. IQM client can then read\nthe token from the file and use it for authentication. The file path can be provided to\nIQM client in environment variable IQM_TOKENS_FILE .\nAlternatively, the tokens file path can be provided as argument tokens_file to IQMClient constructor. It is also possible to use plaintext token obtained from a server dashboard. These\ntokens may have longer lifespan than access tokens generated by IQM Client CLI, and thus\nIQM client won\u2019t attempt to refresh them. The generated token can be provided to IQM\nclient in environment variable IQM_TOKEN .\nAlternatively, the token can be provided as argument token to IQMClient constructor. The third way is to provide server URL, username and password for obtaining the\ntoken from an authentication server. IQM client will maintain a login session with\nthe authentication server and read and refresh the token as needed. The server URL,\nusername and password can be provided to IQM client in environment variables IQM_AUTH_SERVER , IQM_AUTH_USERNAME and IQM_AUTH_PASSWORD .\nAlternatively, the values can be provided as arguments auth_server_url , username and password to IQMClient constructor.\nNote, that all the values must be provided as either environment variables or\nas constructor arguments, not mixed. IQM does not provide an open source circuit transpilation library, so this will have to be supplied\nby the quantum computing framework or a third party library.  To obtain the necessary information\nfor circuit transpilation, IQMClient.get_dynamic_quantum_architecture() returns the names of the\nQPU components (qubits and computational resonators), and the native operations available\nin the given calibration set. This information should enable circuit transpilation for the\nIQM Crystal quantum architectures. The notable exception is the transpilation for the IQM Star quantum architectures, which have\ncomputational resonators in addition to qubits. Some specialized transpilation logic involving\nthe MOVE gates specific to these architectures is provided, in the form of the functions transpile_insert_moves() and transpile_remove_moves() .\nSee iqm.iqm_client.transpile for the details. A typical Star architecture use case would look something like this: We encourage to transpile circuits to use the physical IQM qubit names before submitting them to IQM\nquantum computers.  In case the quantum computing framework does not allow for this, providing a\nqubit mapping can do the translation from the framework qubit names to IQM qubit names.  Note, that\nqubit mapping is not supposed to be associated with individual circuits, but rather with the entire\njob request to IQM server.  Typically, you would have some local representation of the QPU and\ntranspile the circuits against that representation, then use qubit mapping along with the generated\ncircuits to map from the local representation to the IQM representation of qubit names.  We\ndiscourage exposing this feature to end users of the quantum computing framework. Before performing circuit execution, IQM server checks how long it would take to run each circuit.\nIf any circuit in a job would take too long to execute compared to the T2 time of the qubits,\nthe server will disqualify the job, not execute any circuits, and return a detailed error message.\nIn some special cases, it makes sense to adjust or disable this check using\nthe max_circuit_duration_over_t2 attribute of CircuitCompilationOptions ,\nand then passing the options to IQMClient.submit_circuits() . Set IQM_CLIENT_REQUESTS_TIMEOUT environment variable to override the network requests default\ntimeout value. The default value is 60 seconds and might not be sufficient when fetching run results\nof larger circuits via slow network connections. On Linux: On Windows: Once set, this environment variable will control network request timeouts for IQMClient methods abort_job , get_quantum_architecture , get_dynamic_quantum_architecture , get_run , and get_run_status . Set IQM_CLIENT_SECONDS_BETWEEN_CALLS to control the polling frequency when waiting for\ncompilation and run results with the IQMClient.wait_for_compilation() and IQMClient.wait_for_results() methods. The default value is set to 1 second. Set IQM_CLIENT_DEBUG=1 to print the run request when it is submitted for execution in IQMClient.submit_circuits() or IQMClient.submit_run_request() . To inspect the run request without sending\nit for execution, use IQMClient.create_run_request() . IQM provides a demo environment to test the integration against a mock quantum computer. If you\u2019d\nlike to request access to that environment, please contact IQM . previous iqm.qiskit_iqm.transpiler_plugins.OnlyRZOptimizationPlugin next IQM Client CLI User Guide By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.devices.adonis",
    "url": "/iqm-client/api/iqm.cirq_iqm.devices.adonis.html",
    "description": "IQM\u2019s Adonis quantum architecture. Classes Adonis () IQM's five-qubit transmon device. Inheritance previous iqm.cirq_iqm.devices next iqm.cirq_iqm.devices.adonis.Adonis By IQM client developers \u00a9 Copy...",
    "content": "IQM\u2019s Adonis quantum architecture. Classes Adonis () IQM's five-qubit transmon device. Inheritance previous iqm.cirq_iqm.devices next iqm.cirq_iqm.devices.adonis.Adonis By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.MoveGateFrameTrackingMode",
    "url": "/iqm-client/api/iqm.iqm_client.models.MoveGateFrameTrackingMode.html",
    "description": "Bases: str , Enum MOVE gate frame tracking mode for circuit compilation. This option is meant for advanced users. Attributes FULL Perform complete MOVE gate frame tracking. NO_DETUNING_CORRECTION Do n...",
    "content": "Bases: str , Enum MOVE gate frame tracking mode for circuit compilation. This option is meant for advanced users. Attributes FULL Perform complete MOVE gate frame tracking. NO_DETUNING_CORRECTION Do not add the phase detuning corrections to the pulse schedule for the MOVE gate. NONE Do not perform any MOVE gate frame tracking. Methods _generate_next_value_ (start,\u00a0count,\u00a0last_values) Generate the next value when not given. _new_member_ (**kwargs) Create and return a new object. _value_repr_ () Return repr(self). __format__ (format_spec) Return a formatted version of the string as described by format_spec. __new__ (value)  __repr__ () Return repr(self). __str__ () Return str(self). Perform complete MOVE gate frame tracking. Do not add the phase detuning corrections to the pulse schedule for the MOVE gate. The user is expected to do\nthese manually. Do not perform any MOVE gate frame tracking. The user is expected to do these manually. previous iqm.iqm_client.models.Metadata next iqm.iqm_client.models.MoveGateValidationMode By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.optimizers.DropRZBeforeMeasurement",
    "url": "/iqm-client/api/iqm.cirq_iqm.optimizers.DropRZBeforeMeasurement.html",
    "description": "Bases: PointOptimizer Drops z rotations that happen right before a z-basis measurement. These z rotations do not affect the result of the measurement, so we may ignore them. drop_final ( bool ) \u2013 iff ...",
    "content": "Bases: PointOptimizer Drops z rotations that happen right before a z-basis measurement. These z rotations do not affect the result of the measurement, so we may ignore them. drop_final ( bool ) \u2013 iff True, drop also any z rotation at the end of the circuit (since it\u2019s not\nfollowed by a measurement, it cannot affect them) Methods optimization_at (circuit,\u00a0index,\u00a0op) Describes how to change operations near the given location. Describes how to change operations near the given location. circuit ( Circuit ) \u2013 The circuit to improve. index ( int ) \u2013 The index of the moment with the operation to focus on. op ( Operation ) \u2013 The operation to focus improvements upon. A description of the optimization to perform, or else None if no\nchange should be made. PointOptimizationSummary | None previous iqm.cirq_iqm.optimizers.simplify_circuit next iqm.cirq_iqm.optimizers.MergeOneParameterGroupGates By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.validation.validate_instruction",
    "url": "/iqm-client/api/iqm.iqm_client.validation.validate_instruction.html",
    "description": "Validate an instruction against the dynamic quantum architecture. Checks that the instruction uses a valid implementation, and targets a valid locus. architecture ( DynamicQuantumArchitecture ) \u2013 Quan...",
    "content": "Validate an instruction against the dynamic quantum architecture. Checks that the instruction uses a valid implementation, and targets a valid locus. architecture ( DynamicQuantumArchitecture ) \u2013 Quantum architecture to check against. instruction ( Instruction ) \u2013 Instruction to check. qubit_mapping ( dict [ str , str ] | None ) \u2013 Mapping of logical qubit names to physical qubit names.\nCan be set to None if instruction already uses physical qubit names. CircuitValidationError \u2013 validation failed None previous iqm.iqm_client.validation.validate_circuit_moves next iqm.iqm_client.validation.validate_qubit_mapping By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.extended_qasm_parser.circuit_from_qasm",
    "url": "/iqm-client/api/iqm.cirq_iqm.extended_qasm_parser.circuit_from_qasm.html",
    "description": "Parses an OpenQASM 2.0 program to a Cirq circuit. qasm ( str ) \u2013 OpenQASM program parsed circuit Circuit previous iqm.cirq_iqm.extended_qasm_parser next iqm.cirq_iqm.iqm_gates By IQM client developers...",
    "content": "Parses an OpenQASM 2.0 program to a Cirq circuit. qasm ( str ) \u2013 OpenQASM program parsed circuit Circuit previous iqm.cirq_iqm.extended_qasm_parser next iqm.cirq_iqm.iqm_gates By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.optimizers.simplify_circuit",
    "url": "/iqm-client/api/iqm.cirq_iqm.optimizers.simplify_circuit.html",
    "description": "Simplifies and optimizes the given circuit. Currently it merges any neighboring gates belonging to the same one-parameter family merges all one-qubit rotations into phased X rotations followed by Z ro...",
    "content": "Simplifies and optimizes the given circuit. Currently it merges any neighboring gates belonging to the same one-parameter family merges all one-qubit rotations into phased X rotations followed by Z rotations pushes the Z rotations towards the end of the circuit as far as possible drops any empty Moments This sequence of optimization passes is repeated until the circuit hits a fixed point,\nor max_iterations is exceeded. Finally, it removes Z rotations that are immediately followed by a Z-basis measurement. circuit ( Circuit ) \u2013 circuit to simplify max_iterations ( int ) \u2013 maximum number of simplification rounds drop_final_rz ( bool ) \u2013 iff True, drop z rotations that have no successor operations simplified circuit Circuit previous iqm.cirq_iqm.optimizers next iqm.cirq_iqm.optimizers.DropRZBeforeMeasurement By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.util.to_json_dict",
    "url": "/iqm-client/api/iqm.iqm_client.util.to_json_dict.html",
    "description": "Convert a dict to JSON serializable dict obj ( dict [ str , Any ] ) \u2013 dict to convert dict containing converted data ValueError if the original dict contains unsupported datatypes \u2013 dict previous iqm....",
    "content": "Convert a dict to JSON serializable dict obj ( dict [ str , Any ] ) \u2013 dict to convert dict containing converted data ValueError if the original dict contains unsupported datatypes \u2013 dict previous iqm.iqm_client.util next iqm.iqm_client.util.IQMJSONEncoder By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.iqm_transpilation",
    "url": "/iqm-client/api/iqm.qiskit_iqm.iqm_transpilation.html",
    "description": "Transpilation tool to optimize the decomposition of single-qubit gates tailored to IQM hardware. Functions optimize_single_qubit_gates (circuit[,\u00a0...]) Optimize number of single-qubit gates in a trans...",
    "content": "Transpilation tool to optimize the decomposition of single-qubit gates tailored to IQM hardware. Functions optimize_single_qubit_gates (circuit[,\u00a0...]) Optimize number of single-qubit gates in a transpiled circuit exploiting the IQM specific gate set. Classes IQMOptimizeSingleQubitGates (*args,\u00a0**kwargs) Optimize the decomposition of single-qubit gates for the IQM gate set. IQMReplaceGateWithUnitaryPass (*args,\u00a0**kwargs) Transpiler pass that replaces all gates with given name in a circuit with a UnitaryGate. Inheritance previous iqm.qiskit_iqm.iqm_provider.IQMProvider next iqm.qiskit_iqm.iqm_transpilation.optimize_single_qubit_gates By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.errors.CircuitTranspilationError",
    "url": "/iqm-client/api/iqm.iqm_client.errors.CircuitTranspilationError.html",
    "description": "Circuit transpilation failed. previous iqm.iqm_client.errors.CircuitExecutionError next iqm.iqm_client.errors.CircuitValidationError By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Rel...",
    "content": "Circuit transpilation failed. previous iqm.iqm_client.errors.CircuitExecutionError next iqm.iqm_client.errors.CircuitValidationError By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.examples",
    "url": "/iqm-client/api/iqm.qiskit_iqm.examples.html",
    "description": "Example code. Subpackages and modules bell_measure This file is an example of using Qiskit on IQM to run a simple but non-trivial quantum circuit on an IQM quantum computer. resonance_example This fil...",
    "content": "Example code. Subpackages and modules bell_measure This file is an example of using Qiskit on IQM to run a simple but non-trivial quantum circuit on an IQM quantum computer. resonance_example This file is an example of using Qiskit on IQM to run a simple but non-trivial quantum circuit on Resonance, the IQM quantum cloud service. transpile_example This file is an example of using Qiskit on IQM to run a simple but non-trivial quantum circuit on an IQM quantum computer. previous iqm.qiskit_iqm next iqm.qiskit_iqm.examples.bell_measure By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.token_manager",
    "url": "/iqm-client/api/iqm.iqm_client.cli.token_manager.html",
    "description": "Token manager for authentication and authorization to IQM\u2019s quantum computers. Part of IQM Client CLI. Functions check_token_manager (tokens_file) Check whether a token manager related to the given to...",
    "content": "Token manager for authentication and authorization to IQM\u2019s quantum computers. Part of IQM Client CLI. Functions check_token_manager (tokens_file) Check whether a token manager related to the given tokens_file is running. daemonize_token_manager (cycle,\u00a0config[,\u00a0logfile]) Start a daemon process. read_tokens (path_to_tokens_file) Read current tokens from the tokens file. refresh_tokens (config,\u00a0current_tokens,\u00a0cycle) Request new tokens from auth server. start_token_manager (cycle,\u00a0config[,\u00a0single_run]) Refresh tokens periodically. write_tokens (path_to_tokens_file,\u00a0...[,\u00a0...]) Write new tokens into the tokens file. previous iqm.iqm_client.cli.models.TokensFile next iqm.iqm_client.cli.token_manager.check_token_manager By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.authentication.TokensFileReader",
    "url": "/iqm-client/api/iqm.iqm_client.authentication.TokensFileReader.html",
    "description": "Bases: TokenProviderInterface Reads token from a file Methods close () Closes authentication session. get_token () Returns a valid access token. tokens_file ( str ) \u2013 Returns a valid access token. Cli...",
    "content": "Bases: TokenProviderInterface Reads token from a file Methods close () Closes authentication session. get_token () Returns a valid access token. tokens_file ( str ) \u2013 Returns a valid access token. ClientAuthenticationError \u2013 acquiring the token failed str Closes authentication session. ClientAuthenticationError \u2013 closing the session failed None previous iqm.iqm_client.authentication.TokenProviderInterface next iqm.iqm_client.cli By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.iqm_transpilation.IQMOptimizeSingleQubitGates",
    "url": "/iqm-client/api/iqm.qiskit_iqm.iqm_transpilation.IQMOptimizeSingleQubitGates.html",
    "description": "Bases: TransformationPass Optimize the decomposition of single-qubit gates for the IQM gate set. This optimization pass expects the circuit to be correctly layouted and translated to the IQM architect...",
    "content": "Bases: TransformationPass Optimize the decomposition of single-qubit gates for the IQM gate set. This optimization pass expects the circuit to be correctly layouted and translated to the IQM architecture\nand raises an error otherwise.\nThe optimization logic follows the steps: Convert single-qubit gates to \\(U\\) gates and combine all neighboring \\(U\\) gates. Convert \\(U\\) gates according to \\(U(\\theta , \\phi , \\lambda) = ~ RZ(\\phi + \\lambda) R(\\theta, \\pi / 2  - \\lambda)\\) . Commute RZ gates to the end of the circuit using the fact that RZ and CZ gates commute, and \\(R(\\theta , \\phi) RZ(\\lambda) = RZ(\\lambda) R(\\theta, \\phi - \\lambda)\\) . Drop RZ gates immediately before measurements, and otherwise replace them according to \\(RZ(\\lambda) = R(\\pi, \\lambda / 2) R(- \\pi, 0)\\) . drop_final_rz \u2013 Drop terminal RZ gates even if there are no measurements following them (since they do not affect\nthe measurement results). Note that this will change the unitary propagator of the circuit.\nIt is recommended always to set this to true as the final RZ gates do no change the measurement outcomes of\nthe circuit. ignore_barriers ( bool ) \u2013 Removes the barriers from the circuit before optimization (default = False). Attributes Methods _validate_ops (dag)  run (dag) Run a pass on the DAGCircuit. Run a pass on the DAGCircuit. This is implemented by the pass developer. dag ( DAGCircuit ) \u2013 the dag on which the pass is run. NotImplementedError \u2013 when this is left unimplemented for a pass. DAGCircuit previous iqm.qiskit_iqm.iqm_transpilation.optimize_single_qubit_gates next iqm.qiskit_iqm.iqm_transpilation.IQMReplaceGateWithUnitaryPass By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.transpile.transpile_insert_moves",
    "url": "/iqm-client/api/iqm.iqm_client.transpile.transpile_insert_moves.html",
    "description": "Convert a simplified architecture circuit into an equivalent Star architecture circuit with\nresonators and MOVE gates, if needed. In the typical use case circuit has been transpiled to a simplified ar...",
    "content": "Convert a simplified architecture circuit into an equivalent Star architecture circuit with\nresonators and MOVE gates, if needed. In the typical use case circuit has been transpiled to a simplified architecture\nwhere the resonators have been abstracted away, and this function converts it into\nthe corresponding Star architecture circuit. It can also handle the case where circuit already contains MOVE gates and resonators,\nwhich are treated according to existing_moves , followed by the conversion\nof the two-qubit gates that are not supported by the Star architecture. The function does nothing if arch does not support MOVE gates. circuit ( Circuit ) \u2013 The circuit to convert. arch ( DynamicQuantumArchitecture ) \u2013 Real Star architecture of the target device. existing_moves ( ExistingMoveHandlingOptions ) \u2013 Specifies how to deal with existing MOVE instructions in circuit , if any. qubit_mapping ( dict [ str , str ] | None ) \u2013 Mapping of logical qubit names to physical qubit names.\nCan be set to None if circuit already uses physical qubit names. restore_states ( bool ) \u2013 Iff True, all qubit states held in resonators are returned to their qubits\nat the end of the circuit (i.e. all MOVE sandwiches are closed), even when there\nis no computational reason to do so. Equivalent Star architecture circuit with MOVEs and resonators added. Circuit previous iqm.iqm_client.transpile.simplify_architecture next iqm.iqm_client.transpile.transpile_remove_moves By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.authentication.TokenManager",
    "url": "/iqm-client/api/iqm.iqm_client.authentication.TokenManager.html",
    "description": "Bases: object TokenManager manages the access token required for user authentication. token ( str | None ) \u2013 Long-lived IQM token in plain text format tokens_file ( str | None ) \u2013 Path to a tokens fil...",
    "content": "Bases: object TokenManager manages the access token required for user authentication. token ( str | None ) \u2013 Long-lived IQM token in plain text format tokens_file ( str | None ) \u2013 Path to a tokens file used for authentication auth_server_url ( str | None ) \u2013 Base URL of the authentication server username ( str | None ) \u2013 Username to log in to authentication server password ( str | None ) \u2013 Password to log in to authentication server The parameters can also be read from the environment variables IQM_TOKEN, IQM_TOKENS_FILE,\nIQM_AUTH_SERVER, IQM_AUTH_USERNAME, IQM_AUTH_PASSWORD. Environment variables can not be\nmixed with initialisation arguments. All parameters must come from the same source. Methods close () Close the configured token provider. get_bearer_token ([retries]) Returns a valid bearer token, or None if no user authentication has been configured. time_left_seconds (token) Check how much time is left until the token expires. Check how much time is left until the token expires. Time left on token in seconds. token ( Any ) \u2013 int Returns a valid bearer token, or None if no user authentication has been configured. ClientAuthenticationError \u2013 getting the token failed retries ( int ) \u2013 str | None Close the configured token provider. True if closing was successful ClientAuthenticationError \u2013 closing failed bool previous iqm.iqm_client.authentication.TokenClient next iqm.iqm_client.authentication.TokenProviderInterface By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.models.TokensFile",
    "url": "/iqm-client/api/iqm.iqm_client.cli.models.TokensFile.html",
    "description": "Bases: BaseModel Model of tokens file, used for validating JSON. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. p...",
    "content": "Bases: BaseModel Model of tokens file, used for validating JSON. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. pid  timestamp  access_token  refresh_token  refresh_status  auth_server_url  Methods pid ( int | None ) \u2013 timestamp ( datetime ) \u2013 access_token ( str ) \u2013 refresh_token ( str ) \u2013 refresh_status ( str | None ) \u2013 auth_server_url ( AnyUrl ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.iqm_client.cli.models.ConfigFile next iqm.iqm_client.cli.token_manager By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.HeraldingMode",
    "url": "/iqm-client/api/iqm.iqm_client.models.HeraldingMode.html",
    "description": "Bases: str , Enum Heralding mode for circuit execution. Heralding is the practice of generating data about the state of qubits prior to execution of a circuit.\nThis can be achieved by measuring the qu...",
    "content": "Bases: str , Enum Heralding mode for circuit execution. Heralding is the practice of generating data about the state of qubits prior to execution of a circuit.\nThis can be achieved by measuring the qubits immediately before executing each shot for a circuit. Attributes NONE Do not do any heralding. ZEROS Perform a heralding measurement after qubit initialization, only retain shots with an all-zeros result. Methods _generate_next_value_ (start,\u00a0count,\u00a0last_values) Generate the next value when not given. _new_member_ (**kwargs) Create and return a new object. _value_repr_ () Return repr(self). __format__ (format_spec) Return a formatted version of the string as described by format_spec. __new__ (value)  __repr__ () Return repr(self). __str__ () Return str(self). Do not do any heralding. Perform a heralding measurement after qubit initialization, only retain shots with an all-zeros result. Note: in this mode, the number of shots returned after execution will be less or equal to the requested amount\ndue to the post-selection based on heralding data. previous iqm.iqm_client.models.GateInfo next iqm.iqm_client.models.Instruction By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.cli.ClickLoggingHandler",
    "url": "/iqm-client/api/iqm.iqm_client.cli.cli.ClickLoggingHandler.html",
    "description": "Bases: Handler Simple log handler using click\u2019s echo function. Attributes Methods emit (record) Do whatever it takes to actually log the specified logging record. Do whatever it takes to actually log ...",
    "content": "Bases: Handler Simple log handler using click\u2019s echo function. Attributes Methods emit (record) Do whatever it takes to actually log the specified logging record. Do whatever it takes to actually log the specified logging record. This version is intended to be implemented by subclasses and so\nraises a NotImplementedError. previous iqm.iqm_client.cli.cli.save_tokens_file next iqm.iqm_client.cli.cli.IQMClientCliCommand By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.iqm_gates.IQMMoveGate",
    "url": "/iqm-client/api/iqm.cirq_iqm.iqm_gates.IQMMoveGate.html",
    "description": "Bases: EigenGate The MOVE operation is a unitary population exchange operation between a qubit and a resonator.\nIts effect is only defined in the invariant subspace \\(S = \\text{span}\\{|00\\rangle, |01\\...",
    "content": "Bases: EigenGate The MOVE operation is a unitary population exchange operation between a qubit and a resonator.\nIts effect is only defined in the invariant subspace \\(S = \\text{span}\\{|00\\rangle, |01\\rangle, |10\\rangle\\}\\) ,\nwhere it swaps the populations of the states \\(|01\\rangle\\) and \\(|10\\rangle\\) .\nIts effect on the orthogonal subspace is undefined. MOVE has the following presentation in the subspace \\(S\\) : where \\(a\\) is an undefined complex phase that is canceled when the MOVE gate is applied a second time. To ensure that the state of the qubit and resonator has no overlap with \\(|11\\rangle\\) , it is\nrecommended that no single qubit gates are applied to the qubit in between a\npair of MOVE operations. Note: At this point the locus for the move gate must be defined in the order: [qubit, resonator] .\nAdditionally, the matrix representation of the gate set to be a SWAP gate, even though this is not what physically\nhappens. Attributes Methods __str__ () Return str(self). _circuit_diagram_info_ (args)  _eigen_components () Describes the eigendecomposition of the gate's matrix. _num_qubits_ () The number of qubits this gate acts on. _qid_shape_ () Returns a Tuple containing the number of quantum levels of each qid the gate acts on. num_qubits () The number of qubits this gate acts on. exponent ( float | Expr ) \u2013 global_shift ( float ) \u2013 The number of qubits this gate acts on. int previous iqm.cirq_iqm.iqm_gates next iqm.cirq_iqm.iqm_sampler By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingTrustExistingMovesPlugin",
    "url": "/iqm-client/api/iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingTrustExistingMovesPlugin.html",
    "description": "Bases: MoveGateRoutingPlugin Plugin class for single qubit gate optimization and MoveGate routing where existing moves are not checked. Methods previous iqm.qiskit_iqm.transpiler_plugins.MoveGateRouti...",
    "content": "Bases: MoveGateRoutingPlugin Plugin class for single qubit gate optimization and MoveGate routing where existing moves are not checked. Methods previous iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingRemoveExistingMovesPlugin next iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingWithExactRZPlugin By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.auth.login_request",
    "url": "/iqm-client/api/iqm.iqm_client.cli.auth.login_request.html",
    "description": "Sends login request to the authentication server. ClientAuthenticationError \u2013 obtaining the tokens failed Tokens dictionary url ( str ) \u2013 realm ( str ) \u2013 client_id ( str ) \u2013 username ( str ) \u2013 passwor...",
    "content": "Sends login request to the authentication server. ClientAuthenticationError \u2013 obtaining the tokens failed Tokens dictionary url ( str ) \u2013 realm ( str ) \u2013 client_id ( str ) \u2013 username ( str ) \u2013 password ( str ) \u2013 dict [ str , str ] previous iqm.iqm_client.cli.auth next iqm.iqm_client.cli.auth.logout_request By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.DynamicQuantumArchitecture",
    "url": "/iqm-client/api/iqm.iqm_client.models.DynamicQuantumArchitecture.html",
    "description": "Bases: BaseModel Dynamic quantum architecture as returned by server. The dynamic quantum architecture (DQA) describes gates/operations for which calibration data\nexists in the calibration set. Attribu...",
    "content": "Bases: BaseModel Dynamic quantum architecture as returned by server. The dynamic quantum architecture (DQA) describes gates/operations for which calibration data\nexists in the calibration set. Attributes components All locus components (qubits and computational resonators) sorted. model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. calibration_set_id id of the calibration set from which this DQA was generated qubits qubits that appear in at least one gate locus in the calibration set computational_resonators computational resonators that appear in at least one gate locus in the calibration set gates mapping of gate names to information about the gates Methods calibration_set_id ( UUID ) \u2013 qubits ( list [ str ] ) \u2013 computational_resonators ( list [ str ] ) \u2013 gates ( dict [ str , GateInfo ] ) \u2013 id of the calibration set from which this DQA was generated qubits that appear in at least one gate locus in the calibration set computational resonators that appear in at least one gate locus in the calibration set mapping of gate names to information about the gates All locus components (qubits and computational resonators) sorted. The components are first sorted alphabetically based on their non-numeric part, and then\ncomponents with the same non-numeric part are sorted numerically. An example of components\nsorted this way would be: (\u2018COMPR1\u2019, \u2018COMPR2\u2019, \u2018QB1\u2019, \u2018QB2\u2019, \u2018QB3\u2019, \u2018QB10\u2019, \u2018QB11\u2019, \u2018QB20\u2019). Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.iqm_client.models.DDStrategy next iqm.iqm_client.models.GateImplementationInfo By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.examples.bell_measure",
    "url": "/iqm-client/api/iqm.qiskit_iqm.examples.bell_measure.html",
    "description": "This file is an example of using Qiskit on IQM to run a simple but non-trivial quantum circuit on an IQM quantum\ncomputer. See the Qiskit on IQM user guide for instructions: https://docs.meetiqm.com/i...",
    "content": "This file is an example of using Qiskit on IQM to run a simple but non-trivial quantum circuit on an IQM quantum\ncomputer. See the Qiskit on IQM user guide for instructions: https://docs.meetiqm.com/iqm-client/user_guide_qiskit.html Functions bell_measure (server_url) Run a circuit that prepares and measures a Bell state. previous iqm.qiskit_iqm.examples next iqm.qiskit_iqm.examples.bell_measure.bell_measure By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.iqm_circuit",
    "url": "/iqm-client/api/iqm.qiskit_iqm.iqm_circuit.html",
    "description": "A simple extension of the QuantumCircuit class to allow the MOVE\ngate to be applied with a .move(qubit, resonator) shortcut. Classes IQMCircuit (*regs[,\u00a0name,\u00a0global_phase,\u00a0...]) Extends the QuantumCi...",
    "content": "A simple extension of the QuantumCircuit class to allow the MOVE\ngate to be applied with a .move(qubit, resonator) shortcut. Classes IQMCircuit (*regs[,\u00a0name,\u00a0global_phase,\u00a0...]) Extends the QuantumCircuit class, adding a shortcut for applying the MOVE gate. Inheritance previous iqm.qiskit_iqm.iqm_backend.IQMTarget next iqm.qiskit_iqm.iqm_circuit.IQMCircuit By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.token_manager.write_tokens",
    "url": "/iqm-client/api/iqm.iqm_client.cli.token_manager.write_tokens.html",
    "description": "Write new tokens into the tokens file. path_to_tokens_file ( str ) \u2013 path to the tokens file auth_server_url ( str ) \u2013 base URL of the auth server status ( bool ) \u2013 refresh status, True when successfu...",
    "content": "Write new tokens into the tokens file. path_to_tokens_file ( str ) \u2013 path to the tokens file auth_server_url ( str ) \u2013 base URL of the auth server status ( bool ) \u2013 refresh status, True when successful, False otherwise access_token ( str ) \u2013 new access token refresh_token ( str ) \u2013 new refresh token None previous iqm.iqm_client.cli.token_manager.start_token_manager next iqm.iqm_client.errors By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.transpiler_plugins.OnlyRZOptimizationIgnoreBarriersPlugin",
    "url": "/iqm-client/api/iqm.qiskit_iqm.transpiler_plugins.OnlyRZOptimizationIgnoreBarriersPlugin.html",
    "description": "Bases: OnlyRZOptimizationPlugin Plugin class for single qubit gate optimization without MOVE gate routing where barriers are ignored. Methods previous iqm.qiskit_iqm.transpiler_plugins.OnlyRZOptimizat...",
    "content": "Bases: OnlyRZOptimizationPlugin Plugin class for single qubit gate optimization without MOVE gate routing where barriers are ignored. Methods previous iqm.qiskit_iqm.transpiler_plugins.OnlyRZOptimizationExactPlugin next iqm.qiskit_iqm.transpiler_plugins.OnlyRZOptimizationPlugin By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.iqm_backend.IQMBackendBase",
    "url": "/iqm-client/api/iqm.qiskit_iqm.iqm_backend.IQMBackendBase.html",
    "description": "Bases: BackendV2 , ABC Abstract base class for various IQM-specific backends. architecture ( DynamicQuantumArchitecture ) \u2013 Description of the quantum architecture associated with the backend instance...",
    "content": "Bases: BackendV2 , ABC Abstract base class for various IQM-specific backends. architecture ( DynamicQuantumArchitecture ) \u2013 Description of the quantum architecture associated with the backend instance. Attributes physical_qubits Return the list of physical qubits in the backend. target A qiskit.transpiler.Target object for the backend. target_with_resonators Return the target with MOVE gates and resonators included. architecture Dynamic quantum architecture of the backend instance. name Name of the backend. description Optional human-readable description. online_date Date that the backend came online. backend_version Version of the backend being provided. Methods get_real_target () Return the real physical target of the backend without virtual CZ gates. get_scheduling_stage_plugin () Return the plugin that should be used for scheduling the circuits on this backend. has_resonators () True iff the backend QPU has computational resonators. index_to_qubit_name (index) Given a quantum register index, return the corresponding IQM-style qubit name. qubit_name_to_index (name) Given an IQM-style qubit name, return the corresponding index in the register. restrict_to_qubits (qubits[,\u00a0...]) Generated a restricted transpilation target from this backend that only contains the given qubits. Dynamic quantum architecture of the backend instance. A qiskit.transpiler.Target object for the backend. Target Return the target with MOVE gates and resonators included. Return the list of physical qubits in the backend. True iff the backend QPU has computational resonators. bool Return the real physical target of the backend without virtual CZ gates. Target Given an IQM-style qubit name, return the corresponding index in the register. name ( str ) \u2013 IQM-style qubit name (\u2018QB1\u2019, \u2018QB2\u2019, etc.) Index of the given qubit in the quantum register. ValueError \u2013 Qubit name cannot be found on the backend. int Given a quantum register index, return the corresponding IQM-style qubit name. index ( int ) \u2013 Qubit index in the quantum register. Corresponding IQM-style qubit name (\u2018QB1\u2019, \u2018QB2\u2019, etc.). ValueError \u2013 Qubit index cannot be found on the backend. str Return the plugin that should be used for scheduling the circuits on this backend. str Generated a restricted transpilation target from this backend that only contains the given qubits. qubits ( list [ int ] | list [ str ] ) \u2013 Qubits to restrict the target to. Can be either a list of qubit indices or qubit names. include_resonators ( bool ) \u2013 Whether to restrict self.target or self.target_with_resonators . include_fake_czs ( bool ) \u2013 Whether to include virtual CZs that are unsupported, but could be routed via MOVE. restricted target IQMTarget previous iqm.qiskit_iqm.iqm_backend next iqm.qiskit_iqm.iqm_backend.IQMTarget By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.transpile.Resolution",
    "url": "/iqm-client/api/iqm.iqm_client.transpile.Resolution.html",
    "description": "A (gate qubit, move qubit, resonator) triple that represents a resolution of a fictional\nqubit-qubit gate. alias of tuple [ str , str , str ] previous iqm.iqm_client.transpile next iqm.iqm_client.tran...",
    "content": "A (gate qubit, move qubit, resonator) triple that represents a resolution of a fictional\nqubit-qubit gate. alias of tuple [ str , str , str ] previous iqm.iqm_client.transpile next iqm.iqm_client.transpile.simplify_architecture By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.auth.token_is_valid",
    "url": "/iqm-client/api/iqm.iqm_client.cli.auth.token_is_valid.html",
    "description": "Check if token is not about to expire. True if token is still valid, False otherwise. refresh_token ( str ) \u2013 bool previous iqm.iqm_client.cli.auth.time_left_seconds next iqm.iqm_client.cli.auth.AuthR...",
    "content": "Check if token is not about to expire. True if token is still valid, False otherwise. refresh_token ( str ) \u2013 bool previous iqm.iqm_client.cli.auth.time_left_seconds next iqm.iqm_client.cli.auth.AuthRequest By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.iqm_job.IQMJob",
    "url": "/iqm-client/api/iqm.qiskit_iqm.iqm_job.IQMJob.html",
    "description": "Bases: JobV1 Implementation of Qiskit\u2019s job interface to handle circuit execution on an IQM server. backend ( IQMBackend ) \u2013 Backend instance initiating this job. job_id ( str ) \u2013 String representatio...",
    "content": "Bases: JobV1 Implementation of Qiskit\u2019s job interface to handle circuit execution on an IQM server. backend ( IQMBackend ) \u2013 Backend instance initiating this job. job_id ( str ) \u2013 String representation of the UUID generated by IQM server. kwargs \u2013 Arguments to be passed to the initializer of the parent class. Attributes Methods _format_iqm_results (iqm_result) Convert the measurement results for a batch of circuits into the Qiskit format. _format_measurement_results (...[,\u00a0...]) Convert the measurement results from a circuit into the Qiskit format. cancel () Attempt to cancel the job. error_message () Returns the error message if job has failed, otherwise returns None. queue_position ([refresh]) Return the position of the job in the server queue. result (*[,\u00a0timeout,\u00a0cancel_after_timeout]) Retrieve results within defined timeout. status () Return the status of the job, among the values of JobStatus . submit () Submit the job to the backend for execution. Submit the job to the backend for execution. Attempt to cancel the job. True if the job was cancelled successfully, False otherwise bool Retrieve results within defined timeout. timeout ( float ) \u2013 Time limit for client to get result, in seconds. cancel_after_timeout ( bool ) \u2013 Whether client will try to cancel the job if timeout exceeded. Result if retrieved successfully. APITimeoutError \u2013 Waiting for results exceeded timeout. JobAbortionError \u2013 Job failed to abort after timeout exceeded and cancellation requested. Result Return the status of the job, among the values of JobStatus . JobStatus Return the position of the job in the server queue. Note The position is not yet implemented and this function will always\nreturn None . The refresh argument is ignored. refresh ( bool ) \u2013 If True , re-query the server to get the latest value.\nOtherwise return the cached value. Position in the queue or None if position is unknown or not applicable. int | None Returns the error message if job has failed, otherwise returns None. str | None previous iqm.qiskit_iqm.iqm_job next iqm.qiskit_iqm.iqm_move_layout By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.optimizers.MergeOneParameterGroupGates",
    "url": "/iqm-client/api/iqm.cirq_iqm.optimizers.MergeOneParameterGroupGates.html",
    "description": "Bases: PointOptimizer Merges adjacent gates belonging to the same parametrized gate family. The merged gates have to act on the same sequence of qubits.\nThis optimizer only works with gate families th...",
    "content": "Bases: PointOptimizer Merges adjacent gates belonging to the same parametrized gate family. The merged gates have to act on the same sequence of qubits.\nThis optimizer only works with gate families that are known to be one-parameter groups. For now, all the families are assumed to be periodic with a period of 4. Attributes GATE_MERGING_TOLERANCE  ONE_PARAMETER_FAMILIES  PERIOD  Methods _normalize_par (par) Normalizes the given parameter value to (-period/2, period/2]. optimization_at (circuit,\u00a0index,\u00a0op) Describes how to change operations near the given location. post_clean_up ( Callable [ [ Sequence [ cirq.Operation ] ] , cirq.OP_TREE ] ) \u2013 Describes how to change operations near the given location. circuit ( Circuit ) \u2013 The circuit to improve. index ( int ) \u2013 The index of the moment with the operation to focus on. op ( Operation ) \u2013 The operation to focus improvements upon. A description of the optimization to perform, or else None if no\nchange should be made. PointOptimizationSummary | None previous iqm.cirq_iqm.optimizers.DropRZBeforeMeasurement next iqm.cirq_iqm.serialize By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.util.IQMJSONEncoder",
    "url": "/iqm-client/api/iqm.iqm_client.util.IQMJSONEncoder.html",
    "description": "Bases: JSONEncoder JSONEncoder that that adds support for some non-JSON datatypes Attributes Methods default (o) Implement this method in a subclass such that it returns a serializable object for o , ...",
    "content": "Bases: JSONEncoder JSONEncoder that that adds support for some non-JSON datatypes Attributes Methods default (o) Implement this method in a subclass such that it returns a serializable object for o , or calls the base implementation (to raise a TypeError ). Implement this method in a subclass such that it returns\na serializable object for o , or calls the base implementation\n(to raise a TypeError ). For example, to support arbitrary iterators, you could\nimplement default like this: o ( Any ) \u2013 previous iqm.iqm_client.util.to_json_dict next iqm.iqm_client.validation By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.auth.slash_join",
    "url": "/iqm-client/api/iqm.iqm_client.cli.auth.slash_join.html",
    "description": "Join two URL segments together, ensuring a single slash between them. a ( str ) \u2013 b ( str ) \u2013 str previous iqm.iqm_client.cli.auth.refresh_request next iqm.iqm_client.cli.auth.time_left_seconds By IQM...",
    "content": "Join two URL segments together, ensuring a single slash between them. a ( str ) \u2013 b ( str ) \u2013 str previous iqm.iqm_client.cli.auth.refresh_request next iqm.iqm_client.cli.auth.time_left_seconds By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.fake_backends.iqm_fake_backend.IQMFakeBackend",
    "url": "/iqm-client/api/iqm.qiskit_iqm.fake_backends.iqm_fake_backend.IQMFakeBackend.html",
    "description": "Bases: IQMBackendBase Simulated backend that mimics the behaviour of IQM quantum computers. Can be used to perform noisy gate-level simulations of quantum circuit execution on IQM hardware. A fake bac...",
    "content": "Bases: IQMBackendBase Simulated backend that mimics the behaviour of IQM quantum computers. Can be used to perform noisy gate-level simulations of quantum circuit execution on IQM hardware. A fake backend contains information about a specific IQM system, such as the static quantum architecture\n(number of qubits, connectivity), and a noise model based on system parameters such as relaxation ( \\(T_1\\) )\nand dephasing ( \\(T_2\\) ) times, gate infidelities, and readout errors. architecture ( StaticQuantumArchitecture ) \u2013 Static quantum architecture associated with the backend instance. error_profile ( IQMErrorProfile ) \u2013 Characteristics of a particular QPU specimen. name ( str ) \u2013 Attributes error_profile Error profile of this IQM fake backend instance. max_circuits The maximum number of circuits (or Pulse schedules) that can be run in a single job. architecture Dynamic quantum architecture of the backend instance. name Name of the backend. description Optional human-readable description. online_date Date that the backend came online. backend_version Version of the backend being provided. Methods _create_noise_model () Build a noise model from the attributes. _default_options () Return the default options _validate_architecture_and_error_profile (...) Verify that the parameters of the QPU error profile match the constraints of its quantum architecture. copy_with_error_profile (new_error_profile) Return another instance of IQMFakeBackend, which has the same quantum architecture but a different error profile. run (run_input,\u00a0**options) Run quantum circuits on the fake backend (by simulating them). validate_compatible_architecture (architecture) Compare a static quantum architecture to the static architecture of the fake backend. Error profile of this IQM fake backend instance. Return another instance of IQMFakeBackend, which has the same quantum architecture but a different error\nprofile. new_error_profile ( IQMErrorProfile ) \u2013 IQMFakeBackend The maximum number of circuits (or Pulse schedules) that can be\nrun in a single job. If there is no limit this will return None Run quantum circuits on the fake backend (by simulating them). This method will run the simulation with the noise model of the fake backend.\nValidity of the circuits is also checked. run_input ( QuantumCircuit | list [ QuantumCircuit ] ) \u2013 One or more quantum circuits to simulate on the backend. options \u2013 Any kwarg options to pass to the backend. The job object representing the run. ValueError \u2013 Empty list of circuits was provided. JobV1 Compare a static quantum architecture to the static architecture of the fake backend. architecture ( StaticQuantumArchitecture ) \u2013 static quantum architecture to compare to True iff the locus components and the component connectivity\nin the IQMFakeBackend SQA match architecture . bool previous iqm.qiskit_iqm.fake_backends.iqm_fake_backend.IQMErrorProfile next iqm.qiskit_iqm.iqm_backend By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.authentication.ExternalToken",
    "url": "/iqm-client/api/iqm.iqm_client.authentication.ExternalToken.html",
    "description": "Bases: TokenProviderInterface Holds an external token Methods close () Closes authentication session. get_token () Returns a valid access token. token ( str ) \u2013 Returns a valid access token. ClientAut...",
    "content": "Bases: TokenProviderInterface Holds an external token Methods close () Closes authentication session. get_token () Returns a valid access token. token ( str ) \u2013 Returns a valid access token. ClientAuthenticationError \u2013 acquiring the token failed str Closes authentication session. ClientAuthenticationError \u2013 closing the session failed None previous iqm.iqm_client.authentication next iqm.iqm_client.authentication.TokenClient By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.fake_backends.fake_garnet.IQMFakeGarnet",
    "url": "/iqm-client/api/iqm.qiskit_iqm.fake_backends.fake_garnet.IQMFakeGarnet.html",
    "description": "Return IQMFakeBackend instance representing IQM\u2019s Garnet architecture. IQMFakeBackend previous iqm.qiskit_iqm.fake_backends.fake_garnet next iqm.qiskit_iqm.fake_backends.iqm_fake_backend By IQM client...",
    "content": "Return IQMFakeBackend instance representing IQM\u2019s Garnet architecture. IQMFakeBackend previous iqm.qiskit_iqm.fake_backends.fake_garnet next iqm.qiskit_iqm.fake_backends.iqm_fake_backend By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.transpile",
    "url": "/iqm-client/api/iqm.iqm_client.transpile.html",
    "description": "Transpiling circuits to IQM devices involving computational resonators. In the IQM Star architecture, computational resonators are connected to multiple qubits.\nA MOVE gate can be used to move the sta...",
    "content": "Transpiling circuits to IQM devices involving computational resonators. In the IQM Star architecture, computational resonators are connected to multiple qubits.\nA MOVE gate can be used to move the state of a qubit to a connected, empty computational resonator,\nand back to the same qubit . Additionally, two-component gates like CZ can be applied\nbetween a qubit and a connected resonator, so that effectively the qubit can be made to interact\nwith other qubits connected to the resonator. However, the resonators cannot be measured,\nand no single-qubit gates can be applied on them. To enable third-party transpilers to work on the IQM Star architecture, we may abstract away the\nresonators and replace the real dynamic quantum architecture with a simplified architecture .\nSpecifically, this happens by removing the resonators from the architecture, and for\neach resonator r , and for each pair of supported native qubit-resonator (QR) gates (G(q1, r), MOVE(q2, r)) adding the fictional gate G(q1, q2) to the simplified architecture.\nThis works since the fictional gate can be implemented as the QR gate sequence This sequence is called a resolution of G(q1, q2) .\nCurrently  we assume all the QR gates (other than MOVE) are symmetric in the sense that holds. This has the effect of doubling the number of possible resolutions for G(q1, q2) since\nyou can reverse the roles of the qubits. Before a circuit transpiled to a simplified architecture can be executed it must be further\ntranspiled to the real Star architecture using transpile_insert_moves() , which will introduce\nthe resonators, add MOVE gates as necessary to move the states, and convert the fictional two-qubit\ngates into real native gates acting on qubit-resonator pairs. Likewise transpile_remove_moves() can be used to perform the opposite transformation,\nconverting a circuit valid for the real Star architecture into an equivalent circuit for the\ncorresponding simplified architecture, e.g. so that the circuit can be retranspiled or optimized\nusing third-party tools that do not support the MOVE gate. Given a DynamicQuantumArchitecture for a Star architecture, the corresponding simplified\nversion can be obtained using simplify_architecture() . Module Attributes Resolution A (gate qubit, move qubit, resonator) triple that represents a resolution of a fictional qubit-qubit gate. Functions simplify_architecture (arch,\u00a0*[,\u00a0...]) Converts the given IQM Star quantum architecture into the equivalent simplified quantum architecture. transpile_insert_moves (circuit,\u00a0arch,\u00a0*[,\u00a0...]) Convert a simplified architecture circuit into an equivalent Star architecture circuit with resonators and MOVE gates, if needed. transpile_remove_moves (circuit) Convert a Star architecture circuit involving resonators and MOVE gates into an equivalent simplified achitecture circuit without them. Classes ExistingMoveHandlingOptions (value[,\u00a0names,\u00a0...]) Options for how transpile_insert_moves() should handle existing MOVE instructions in the circuit. Inheritance previous iqm.iqm_client.models.Status next iqm.iqm_client.transpile.Resolution By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.errors.ClientAuthenticationError",
    "url": "/iqm-client/api/iqm.iqm_client.errors.ClientAuthenticationError.html",
    "description": "Something went wrong with user authentication. previous iqm.iqm_client.errors.CircuitValidationError next iqm.iqm_client.errors.ClientConfigurationError By IQM client developers \u00a9 Copyright 2021-2025,...",
    "content": "Something went wrong with user authentication. previous iqm.iqm_client.errors.CircuitValidationError next iqm.iqm_client.errors.ClientConfigurationError By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.api.APIConfig",
    "url": "/iqm-client/api/iqm.iqm_client.api.APIConfig.html",
    "description": "Bases: object Provides supported API endpoints for a given API variant. Methods _get_api_urls () Returns: Relative URLs for each supported API endpoints. is_supported (endpoint) param endpoint : API e...",
    "content": "Bases: object Provides supported API endpoints for a given API variant. Methods _get_api_urls () Returns: Relative URLs for each supported API endpoints. is_supported (endpoint) param endpoint : API endpoint. API endpoint. url (endpoint,\u00a0*args) param endpoint : API endpoint. API endpoint. station_control_url ( str ) \u2013 endpoint ( APIEndpoint ) \u2013 API endpoint. True if the endpoint is supported, False otherwise. bool endpoint ( APIEndpoint ) \u2013 API endpoint. args \u2013 Arguments to be passed to the URL. URL for the given endpoint. ValueError \u2013 If the endpoint is not supported. str previous iqm.iqm_client.api next iqm.iqm_client.api.APIEndpoint By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.errors.ClientConfigurationError",
    "url": "/iqm-client/api/iqm.iqm_client.errors.ClientConfigurationError.html",
    "description": "Wrong configuration provided. previous iqm.iqm_client.errors.ClientAuthenticationError next iqm.iqm_client.errors.EndpointRequestError By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, R...",
    "content": "Wrong configuration provided. previous iqm.iqm_client.errors.ClientAuthenticationError next iqm.iqm_client.errors.EndpointRequestError By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.NativeOperation",
    "url": "/iqm-client/api/iqm.iqm_client.models.NativeOperation.html",
    "description": "Bases: object Describes a native operation on the quantum computer. Attributes factorizable Iff True, any multi-component instance of this operation can be broken down to single-component instances, a...",
    "content": "Bases: object Describes a native operation on the quantum computer. Attributes factorizable Iff True, any multi-component instance of this operation can be broken down to single-component instances, and calibration data is specific to single-component loci. no_calibration_needed Iff true, the operation is always allowed on all QPU loci regardless of calibration state. renamed_to If nonempty, indicates that this operation name is deprecated, and IQM client will auto-rename it to the new name. symmetric True iff the effect of operation is symmetric in the locus components it acts on. name Name of the operation. arity Number of locus components (usually qubits) the operation acts on. args_required Maps names of required operation parameters to their allowed types. args_not_required Maps names of optional operation parameters to their allowed types. Methods __delattr__ (name) Implement delattr(self, name). __eq__ (other) Return self==value. __hash__ () Return hash(self). __repr__ () Return repr(self). __setattr__ (name,\u00a0value) Implement setattr(self, name, value). name ( str ) \u2013 arity ( int ) \u2013 args_required ( dict [ str , tuple [ type , ... ] ] ) \u2013 args_not_required ( dict [ str , tuple [ type , ... ] ] ) \u2013 symmetric ( bool ) \u2013 renamed_to ( str ) \u2013 factorizable ( bool ) \u2013 no_calibration_needed ( bool ) \u2013 Name of the operation. Number of locus components (usually qubits) the operation acts on.\nZero means the operation can be applied on any number of locus components. Maps names of required operation parameters to their allowed types. Maps names of optional operation parameters to their allowed types. True iff the effect of operation is symmetric in the locus components it acts on.\nOnly meaningful if arity != 1. If nonempty, indicates that this operation name is deprecated, and IQM client will\nauto-rename it to the new name. Iff True, any multi-component instance of this operation can be broken down to\nsingle-component instances, and calibration data is specific to single-component loci. Iff true, the operation is always allowed on all QPU loci regardless of calibration state.\nTypically a metaoperation like barrier. previous iqm.iqm_client.models.MoveGateValidationMode next iqm.iqm_client.models.QualityMetricSet By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.Locus",
    "url": "/iqm-client/api/iqm.iqm_client.models.Locus.html",
    "description": "Names of the QPU components (typically qubits) a quantum operation instance is acting on, e.g. (\u201cQB1\u201d, \u201cQB2\u201d) . alias of tuple [ Annotated [ str ], \u2026] previous iqm.iqm_client.models next iqm.iqm_clien...",
    "content": "Names of the QPU components (typically qubits) a quantum operation instance is acting on, e.g. (\u201cQB1\u201d, \u201cQB2\u201d) . alias of tuple [ Annotated [ str ], \u2026] previous iqm.iqm_client.models next iqm.iqm_client.models.CircuitBatch By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.GateInfo",
    "url": "/iqm-client/api/iqm.iqm_client.models.GateInfo.html",
    "description": "Bases: BaseModel Information about a quantum gate/operation. Attributes loci Returns all loci which are available for at least one of the implementations. model_config Configuration for the model, sho...",
    "content": "Bases: BaseModel Information about a quantum gate/operation. Attributes loci Returns all loci which are available for at least one of the implementations. model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. implementations mapping of available implementation names to information about the implementations default_implementation default implementation for the gate, used unless overridden by override_default_implementation or unless the user requests a specific implementation for a particular gate in the circuit using Instruction.implementation override_default_implementation mapping of loci to implementation names that override default_implementation for those loci Methods override_default_implementation_validator (value) Converts locus keys to tuples if they are encoded as strings. implementations ( dict [ str , GateImplementationInfo ] ) \u2013 default_implementation ( str ) \u2013 override_default_implementation ( dict [ tuple [ str , ... ] , str ] ) \u2013 mapping of available implementation names to information about the implementations default implementation for the gate, used unless overridden by override_default_implementation or unless the user requests a specific implementation for a particular gate in the circuit using Instruction.implementation mapping of loci to implementation names that override default_implementation for those loci Converts locus keys to tuples if they are encoded as strings. value ( Any ) \u2013 dict [ tuple [ str , \u2026], str ] Returns all loci which are available for at least one of the implementations. The loci are sorted first based on the first locus component, then the second, etc.\nThe sorting of individual locus components is first done alphabetically based on their\nnon-numeric part, and then components with the same non-numeric part are sorted numerically.\nAn example of loci sorted this way would be: (\u2018QB1\u2019, \u2018QB2\u2019),\n(\u2018QB2\u2019, \u2018COMPR1\u2019),\n(\u2018QB2\u2019, \u2018QB3\u2019),\n(\u2018QB3\u2019, \u2018COMPR1\u2019),\n(\u2018QB3\u2019, \u2018COMPR2\u2019),\n(\u2018QB3\u2019, \u2018QB1\u2019),\n(\u2018QB10\u2019, \u2018QB2\u2019), Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.iqm_client.models.GateImplementationInfo next iqm.iqm_client.models.HeraldingMode By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.validate_circuit",
    "url": "/iqm-client/api/iqm.iqm_client.models.validate_circuit.html",
    "description": "Validates a submitted quantum circuit using Pydantic tooling. circuit ( Circuit ) \u2013 a circuit that needs validation pydantic.error_wrappers.ValidationError \u2013 validation failed None previous iqm.iqm_cl...",
    "content": "Validates a submitted quantum circuit using Pydantic tooling. circuit ( Circuit ) \u2013 a circuit that needs validation pydantic.error_wrappers.ValidationError \u2013 validation failed None previous iqm.iqm_client.models.serialize_qubit_mapping next iqm.iqm_client.models.CalibrationSet By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.iqm_backend",
    "url": "/iqm-client/api/iqm.qiskit_iqm.iqm_backend.html",
    "description": "Qiskit backend for IQM quantum computers. Classes IQMBackendBase (architecture,\u00a0**kwargs) Abstract base class for various IQM-specific backends. IQMTarget (architecture,\u00a0component_to_idx,\u00a0...) Transpi...",
    "content": "Qiskit backend for IQM quantum computers. Classes IQMBackendBase (architecture,\u00a0**kwargs) Abstract base class for various IQM-specific backends. IQMTarget (architecture,\u00a0component_to_idx,\u00a0...) Transpilation target for an IQM architecture. Inheritance previous iqm.qiskit_iqm.fake_backends.iqm_fake_backend.IQMFakeBackend next iqm.qiskit_iqm.iqm_backend.IQMBackendBase By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.ClientLibrary",
    "url": "/iqm-client/api/iqm.iqm_client.models.ClientLibrary.html",
    "description": "Bases: BaseModel Represents a client library with its metadata. name ( str ) \u2013 display name of the client library. package_name ( str | None ) \u2013 name of the package as published in package repositorie...",
    "content": "Bases: BaseModel Represents a client library with its metadata. name ( str ) \u2013 display name of the client library. package_name ( str | None ) \u2013 name of the package as published in package repositories. repo_url ( str | None ) \u2013 URL to the source code repository. package_url ( str | None ) \u2013 URL to the package in the package repository. min ( str ) \u2013 minimum supported version. max ( str ) \u2013 maximum supported version. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name  package_name  repo_url  package_url  min  max  Methods Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.iqm_client.models.CircuitCompilationOptions next iqm.iqm_client.models.Counts By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.qiskit_to_iqm.deserialize_instructions",
    "url": "/iqm-client/api/iqm.qiskit_iqm.qiskit_to_iqm.deserialize_instructions.html",
    "description": "Helper function to turn a list of IQM Instructions into a Qiskit QuantumCircuit. instructions ( list [ Instruction ] ) \u2013 The gates in the circuit. qubit_name_to_index ( dict [ str , int ] ) \u2013 Mapping ...",
    "content": "Helper function to turn a list of IQM Instructions into a Qiskit QuantumCircuit. instructions ( list [ Instruction ] ) \u2013 The gates in the circuit. qubit_name_to_index ( dict [ str , int ] ) \u2013 Mapping from qubit names to their indices, as specified in a backend. layout ( Layout ) \u2013 Qiskit representation of a layout. ValueError \u2013 Thrown when a given instruction is not supported. Qiskit circuit represented by the given instructions. QuantumCircuit previous iqm.qiskit_iqm.qiskit_to_iqm next iqm.qiskit_iqm.qiskit_to_iqm.serialize_instructions By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.auth",
    "url": "/iqm-client/api/iqm.iqm_client.cli.auth.html",
    "description": "Authorization and session management for IQM Client CLI. Functions login_request (url,\u00a0realm,\u00a0client_id,\u00a0...) Sends login request to the authentication server. logout_request (url,\u00a0realm,\u00a0client_id,\u00a0....",
    "content": "Authorization and session management for IQM Client CLI. Functions login_request (url,\u00a0realm,\u00a0client_id,\u00a0...) Sends login request to the authentication server. logout_request (url,\u00a0realm,\u00a0client_id,\u00a0...) Sends logout request to the authentication server. refresh_request (url,\u00a0realm,\u00a0client_id,\u00a0...) Sends refresh request to the authentication server. slash_join (a,\u00a0b) Join two URL segments together, ensuring a single slash between them. time_left_seconds (token) Check how much time is left until the token expires. token_is_valid (refresh_token) Check if token is not about to expire. Classes AuthRequest (*,\u00a0client_id[,\u00a0grant_type,\u00a0...]) Request sent to authentication server for access token and refresh token, or for terminating the session. * Token request with grant type 'password' starts a new session in the authentication server. It uses fields client_id , grant_type , username and password . * Token request with grant type 'refresh_token' is used for maintaining an existing session. It uses field client_id , grant_type , refresh_token . * Logout request uses only fields client_id and refresh_token . GrantType (value[,\u00a0names,\u00a0module,\u00a0qualname,\u00a0...]) Type of token request. Exceptions ClientAccountSetupError User's account has not been fully set up yet. ClientAuthenticationError Something went wrong with user authentication. Inheritance previous iqm.iqm_client.cli next iqm.iqm_client.cli.auth.login_request By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.optimizers",
    "url": "/iqm-client/api/iqm.cirq_iqm.optimizers.html",
    "description": "Circuit optimization classes. Functions simplify_circuit (circuit,\u00a0*[,\u00a0...]) Simplifies and optimizes the given circuit. Classes DropRZBeforeMeasurement ([drop_final]) Drops z rotations that happen ri...",
    "content": "Circuit optimization classes. Functions simplify_circuit (circuit,\u00a0*[,\u00a0...]) Simplifies and optimizes the given circuit. Classes DropRZBeforeMeasurement ([drop_final]) Drops z rotations that happen right before a z-basis measurement. MergeOneParameterGroupGates (post_clean_up,\u00a0...) Merges adjacent gates belonging to the same parametrized gate family. Inheritance previous iqm.cirq_iqm.iqm_sampler.ResultMetadata next iqm.cirq_iqm.optimizers.simplify_circuit By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.validation.validate_circuit_moves",
    "url": "/iqm-client/api/iqm.iqm_client.validation.validate_circuit_moves.html",
    "description": "Raise an error if the MOVE gates in the circuit are not valid in the given architecture. architecture ( DynamicQuantumArchitecture ) \u2013 Quantum architecture to check against. circuit ( Circuit ) \u2013 Quan...",
    "content": "Raise an error if the MOVE gates in the circuit are not valid in the given architecture. architecture ( DynamicQuantumArchitecture ) \u2013 Quantum architecture to check against. circuit ( Circuit ) \u2013 Quantum circuit to validate. qubit_mapping ( dict [ str , str ] | None ) \u2013 Mapping of logical qubit names to physical qubit names.\nCan be set to None if the circuit already uses physical qubit names. validate_moves ( MoveGateValidationMode ) \u2013 Option for bypassing full or partial MOVE gate validation. must_close_sandwiches ( bool ) \u2013 Iff True, MOVE sandwiches cannot be left open when the circuit ends. CircuitValidationError \u2013 validation failed None previous iqm.iqm_client.validation.validate_circuit_instructions next iqm.iqm_client.validation.validate_instruction By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.GateImplementationInfo",
    "url": "/iqm-client/api/iqm.iqm_client.models.GateImplementationInfo.html",
    "description": "Bases: BaseModel Information about an implementation of a quantum gate/operation. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.conf...",
    "content": "Bases: BaseModel Information about an implementation of a quantum gate/operation. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. loci loci for which this gate implementation has been calibrated Methods loci ( tuple [ tuple [ str , ... ] , ... ] ) \u2013 loci for which this gate implementation has been calibrated Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.iqm_client.models.DynamicQuantumArchitecture next iqm.iqm_client.models.GateInfo By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.iqm_move_layout.generate_initial_layout",
    "url": "/iqm-client/api/iqm.qiskit_iqm.iqm_move_layout.generate_initial_layout.html",
    "description": "Generates an initial layout for the given circuit, when run against the given backend. backend ( IQMBackendBase ) \u2013 IQM backend to run against. circuit ( QuantumCircuit ) \u2013 Star architecture circuit f...",
    "content": "Generates an initial layout for the given circuit, when run against the given backend. backend ( IQMBackendBase ) \u2013 IQM backend to run against. circuit ( QuantumCircuit ) \u2013 Star architecture circuit for which a layout is to be generated. restrict_to_qubits ( list [ int ] | list [ str ] | None ) \u2013 Optional list of qubits to restrict the layout to. Layout that maps the logical qubits of circuit to the physical qubits of backend so that\nall the gates in circuit are available on those loci. Layout previous iqm.qiskit_iqm.iqm_move_layout next iqm.qiskit_iqm.iqm_move_layout.IQMMoveLayout By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.token_manager.start_token_manager",
    "url": "/iqm-client/api/iqm.iqm_client.cli.token_manager.start_token_manager.html",
    "description": "Refresh tokens periodically. For each refresh cycle new tokens are requested from auth server.\n- If refresh is successful next refresh is attempted in the next cycle.\n- If auth server does not respond...",
    "content": "Refresh tokens periodically. For each refresh cycle new tokens are requested from auth server.\n- If refresh is successful next refresh is attempted in the next cycle.\n- If auth server does not respond refresh is attempted repeatedly until it succeeds or the existing refresh token expires. If auth server responds but returns an error code or invalid tokens token manager is stopped. cycle ( int ) \u2013 refresh cycle in seconds config ( ConfigFile ) \u2013 IQM Client CLI configuration single_run ( bool ) \u2013 if True, refresh tokens only once and exit; otherwise repeat refreshing indefinitely None previous iqm.iqm_client.cli.token_manager.refresh_tokens next iqm.iqm_client.cli.token_manager.write_tokens By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.iqm_client",
    "url": "/iqm-client/api/iqm.iqm_client.iqm_client.html",
    "description": "Client for connecting to the IQM quantum computer server interface. Classes IQMClient (url,\u00a0*[,\u00a0client_signature,\u00a0token,\u00a0...]) Provides access to IQM quantum computers. Inheritance previous iqm.iqm_cl...",
    "content": "Client for connecting to the IQM quantum computer server interface. Classes IQMClient (url,\u00a0*[,\u00a0client_signature,\u00a0token,\u00a0...]) Provides access to IQM quantum computers. Inheritance previous iqm.iqm_client.errors.JobAbortionError next iqm.iqm_client.iqm_client.IQMClient By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingPlugin",
    "url": "/iqm-client/api/iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingPlugin.html",
    "description": "Bases: IQMSchedulingPlugin Plugin class for IQM single qubit gate optimization and MoveGate routing as a scheduling stage. Methods optimize_sqg ( bool ) \u2013 drop_final_rz ( bool ) \u2013 ignore_barriers ( bo...",
    "content": "Bases: IQMSchedulingPlugin Plugin class for IQM single qubit gate optimization and MoveGate routing as a scheduling stage. Methods optimize_sqg ( bool ) \u2013 drop_final_rz ( bool ) \u2013 ignore_barriers ( bool ) \u2013 existing_move_handling ( ExistingMoveHandlingOptions | None ) \u2013 previous iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingOnlyTrustExistingMovesPlugin next iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingRemoveExistingMovesPlugin By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.util",
    "url": "/iqm-client/api/iqm.iqm_client.util.html",
    "description": "Helpful utilities that can be used together with IQMClient. Functions to_json_dict (obj) Convert a dict to JSON serializable dict Classes IQMJSONEncoder (*[,\u00a0skipkeys,\u00a0ensure_ascii,\u00a0...]) JSONEncoder ...",
    "content": "Helpful utilities that can be used together with IQMClient. Functions to_json_dict (obj) Convert a dict to JSON serializable dict Classes IQMJSONEncoder (*[,\u00a0skipkeys,\u00a0ensure_ascii,\u00a0...]) JSONEncoder that that adds support for some non-JSON datatypes Inheritance previous iqm.iqm_client.transpile.ExistingMoveHandlingOptions next iqm.iqm_client.util.to_json_dict By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.examples.resonance_example.resonance_example",
    "url": "/iqm-client/api/iqm.qiskit_iqm.examples.resonance_example.resonance_example.html",
    "description": "Run a circuit via IQM Resonance. server_url ( str ) \u2013 URL of the IQM Resonance QC used for execution api_token ( str | None ) \u2013 IQM Resonance API token for authentication a mapping of bitstrings repre...",
    "content": "Run a circuit via IQM Resonance. server_url ( str ) \u2013 URL of the IQM Resonance QC used for execution api_token ( str | None ) \u2013 IQM Resonance API token for authentication a mapping of bitstrings representing qubit measurement results to counts for each result dict [ str , int ] previous iqm.qiskit_iqm.examples.resonance_example next iqm.qiskit_iqm.examples.transpile_example By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.transpiler.transpile_insert_moves_into_circuit",
    "url": "/iqm-client/api/iqm.cirq_iqm.transpiler.transpile_insert_moves_into_circuit.html",
    "description": "Transpile the circuit to insert MOVE gates where needed. cirq_circuit ( Circuit ) \u2013 Circuit to transpile. device ( IQMDevice ) \u2013 Device to transpile for. existing_moves ( ExistingMoveHandlingOptions )...",
    "content": "Transpile the circuit to insert MOVE gates where needed. cirq_circuit ( Circuit ) \u2013 Circuit to transpile. device ( IQMDevice ) \u2013 Device to transpile for. existing_moves ( ExistingMoveHandlingOptions ) \u2013 How to handle existing MOVE gates, obtained from the IQM client library. qubit_mapping ( dict [ str , str ] | None ) \u2013 Mapping from qubit names in the circuit to the device. Transpiled circuit. Circuit previous iqm.cirq_iqm.transpiler next iqm.iqm_client By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.MoveGateValidationMode",
    "url": "/iqm-client/api/iqm.iqm_client.models.MoveGateValidationMode.html",
    "description": "Bases: str , Enum MOVE gate validation mode for circuit compilation. This options is meant for advanced users. Attributes STRICT MOVE gates must only appear in sandwiches, with no gates acting on the ...",
    "content": "Bases: str , Enum MOVE gate validation mode for circuit compilation. This options is meant for advanced users. Attributes STRICT MOVE gates must only appear in sandwiches, with no gates acting on the MOVE qubit inside the sandwich. ALLOW_PRX Allow PRX gates on the MOVE qubit inside MOVE sandwiches during validation. NONE Do not perform any MOVE gate validation. Methods _generate_next_value_ (start,\u00a0count,\u00a0last_values) Generate the next value when not given. _new_member_ (**kwargs) Create and return a new object. _value_repr_ () Return repr(self). __format__ (format_spec) Return a formatted version of the string as described by format_spec. __new__ (value)  __repr__ () Return repr(self). __str__ () Return str(self). MOVE gates must only appear in sandwiches, with no gates acting on the\nMOVE qubit inside the sandwich. Perform standard MOVE gate validation Allow PRX gates on the MOVE qubit inside MOVE sandwiches during validation. Do not perform any MOVE gate validation. previous iqm.iqm_client.models.MoveGateFrameTrackingMode next iqm.iqm_client.models.NativeOperation By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.move_gate",
    "url": "/iqm-client/api/iqm.qiskit_iqm.move_gate.html",
    "description": "MOVE gate to be used on the IQM Star architecture. Module Attributes MOVE_GATE_UNITARY Unitary matrix for simulating the ideal MOVE gate. Classes MoveGate ([label]) The MOVE operation is a unitary pop...",
    "content": "MOVE gate to be used on the IQM Star architecture. Module Attributes MOVE_GATE_UNITARY Unitary matrix for simulating the ideal MOVE gate. Classes MoveGate ([label]) The MOVE operation is a unitary population exchange operation between a qubit and a resonator. Inheritance previous iqm.qiskit_iqm.iqm_transpilation.IQMReplaceGateWithUnitaryPass next iqm.qiskit_iqm.move_gate.MOVE_GATE_UNITARY By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.token_manager.read_tokens",
    "url": "/iqm-client/api/iqm.iqm_client.cli.token_manager.read_tokens.html",
    "description": "Read current tokens from the tokens file. path_to_tokens_file ( str ) \u2013 path to the tokens file dict containing the tokens dict previous iqm.iqm_client.cli.token_manager.daemonize_token_manager next i...",
    "content": "Read current tokens from the tokens file. path_to_tokens_file ( str ) \u2013 path to the tokens file dict containing the tokens dict previous iqm.iqm_client.cli.token_manager.daemonize_token_manager next iqm.iqm_client.cli.token_manager.refresh_tokens By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.STANDARD_DD_STRATEGY",
    "url": "/iqm-client/api/iqm.iqm_client.models.STANDARD_DD_STRATEGY.html",
    "description": "The default DD strategy uses the following gate sequences: Simple symmetric CPMG sequence for short idling times. Asymmetric (left-aligned) universal XY4 sequence for medium idling times. Asymmetric (...",
    "content": "The default DD strategy uses the following gate sequences: Simple symmetric CPMG sequence for short idling times. Asymmetric (left-aligned) universal XY4 sequence for medium idling times. Asymmetric (left-aligned) universal EDD sequence for longer idling times. previous iqm.iqm_client.models.PRXSequence next iqm.iqm_client.models.CircuitMeasurementResults By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingRemoveExistingMovesPlugin",
    "url": "/iqm-client/api/iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingRemoveExistingMovesPlugin.html",
    "description": "Bases: MoveGateRoutingPlugin Plugin class for single qubit gate optimization and MoveGate routing where existing moves are removed. Methods previous iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingPl...",
    "content": "Bases: MoveGateRoutingPlugin Plugin class for single qubit gate optimization and MoveGate routing where existing moves are removed. Methods previous iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingPlugin next iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingTrustExistingMovesPlugin By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.errors.CircuitValidationError",
    "url": "/iqm-client/api/iqm.iqm_client.errors.CircuitValidationError.html",
    "description": "Circuit validation failed. previous iqm.iqm_client.errors.CircuitTranspilationError next iqm.iqm_client.errors.ClientAuthenticationError By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy,...",
    "content": "Circuit validation failed. previous iqm.iqm_client.errors.CircuitTranspilationError next iqm.iqm_client.errors.ClientAuthenticationError By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.iqm_sampler.IQMResult",
    "url": "/iqm-client/api/iqm.cirq_iqm.iqm_sampler.IQMResult.html",
    "description": "Bases: ResultDict Stores the results of a quantum circuit execution on an IQM device. params ( cirq.ParamResolver | None ) \u2013 Parameter resolver used for this circuit, if any. measurements ( Mapping [ ...",
    "content": "Bases: ResultDict Stores the results of a quantum circuit execution on an IQM device. params ( cirq.ParamResolver | None ) \u2013 Parameter resolver used for this circuit, if any. measurements ( Mapping [ str , np.ndarray ] | None ) \u2013 Maps measurement keys to measurement results, which are 2-D arrays of dtype bool. shape == (repetitions, qubits) . records ( Mapping [ str , np.ndarray ] | None ) \u2013 Maps measurement keys to measurement results, which are 3D arrays of dtype bool. shape == (repetitions, instances, qubits) . metadata ( ResultMetadata ) \u2013 Metadata for the circuit execution results. Attributes Methods previous iqm.cirq_iqm.iqm_sampler next iqm.cirq_iqm.iqm_sampler.IQMSampler By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.iqm_transpilation.IQMReplaceGateWithUnitaryPass",
    "url": "/iqm-client/api/iqm.qiskit_iqm.iqm_transpilation.IQMReplaceGateWithUnitaryPass.html",
    "description": "Bases: TransformationPass Transpiler pass that replaces all gates with given name in a circuit with a UnitaryGate. gate \u2013 The name of the gate to replace. unitary \u2013 The unitary matrix to replace the g...",
    "content": "Bases: TransformationPass Transpiler pass that replaces all gates with given name in a circuit with a UnitaryGate. gate \u2013 The name of the gate to replace. unitary \u2013 The unitary matrix to replace the gate with. Attributes Methods run (dag) Run a pass on the DAGCircuit. Run a pass on the DAGCircuit. This is implemented by the pass developer. dag \u2013 the dag on which the pass is run. NotImplementedError \u2013 when this is left unimplemented for a pass. previous iqm.qiskit_iqm.iqm_transpilation.IQMOptimizeSingleQubitGates next iqm.qiskit_iqm.move_gate By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.fake_backends.fake_garnet",
    "url": "/iqm-client/api/iqm.qiskit_iqm.fake_backends.fake_garnet.html",
    "description": "Fake (i.e. simulated) backend for IQM\u2019s 20-qubit Garnet architecture Functions IQMFakeGarnet () Return IQMFakeBackend instance representing IQM's Garnet architecture. previous iqm.qiskit_iqm.fake_back...",
    "content": "Fake (i.e. simulated) backend for IQM\u2019s 20-qubit Garnet architecture Functions IQMFakeGarnet () Return IQMFakeBackend instance representing IQM's Garnet architecture. previous iqm.qiskit_iqm.fake_backends.fake_deneb.IQMFakeDeneb next iqm.qiskit_iqm.fake_backends.fake_garnet.IQMFakeGarnet By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.auth.time_left_seconds",
    "url": "/iqm-client/api/iqm.iqm_client.cli.auth.time_left_seconds.html",
    "description": "Check how much time is left until the token expires. Time left on token in seconds. token ( str ) \u2013 int previous iqm.iqm_client.cli.auth.slash_join next iqm.iqm_client.cli.auth.token_is_valid By IQM c...",
    "content": "Check how much time is left until the token expires. Time left on token in seconds. token ( str ) \u2013 int previous iqm.iqm_client.cli.auth.slash_join next iqm.iqm_client.cli.auth.token_is_valid By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.serialize.OperationNotSupportedError",
    "url": "/iqm-client/api/iqm.cirq_iqm.serialize.OperationNotSupportedError.html",
    "description": "Raised when a given operation is not supported by the IQM server. previous iqm.cirq_iqm.serialize.serialize_circuit next iqm.cirq_iqm.transpiler By IQM client developers \u00a9 Copyright 2021-2025, IQM Fin...",
    "content": "Raised when a given operation is not supported by the IQM server. previous iqm.cirq_iqm.serialize.serialize_circuit next iqm.cirq_iqm.transpiler By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.fake_backends",
    "url": "/iqm-client/api/iqm.qiskit_iqm.fake_backends.html",
    "description": "Fake backends for simulating IQM quantum computers. Subpackages and modules fake_adonis Fake backend for IQM's 5-qubit Adonis architecture. fake_aphrodite Fake (i.e. simulated) backend for IQM's 54-qu...",
    "content": "Fake backends for simulating IQM quantum computers. Subpackages and modules fake_adonis Fake backend for IQM's 5-qubit Adonis architecture. fake_aphrodite Fake (i.e. simulated) backend for IQM's 54-qubit Aphrodite architecture. fake_apollo Fake (i.e. simulated) backend for IQM's 20-qubit Apollo architecture. fake_deneb Fake backend for IQM's 6-qubit Deneb architecture. fake_garnet Fake (i.e. simulated) backend for IQM's 20-qubit Garnet architecture. iqm_fake_backend Error profile and fake backend base class for simulating IQM quantum computers. previous iqm.qiskit_iqm.examples.transpile_example.transpile_example next iqm.qiskit_iqm.fake_backends.fake_adonis By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.fake_backends.fake_adonis",
    "url": "/iqm-client/api/iqm.qiskit_iqm.fake_backends.fake_adonis.html",
    "description": "Fake backend for IQM\u2019s 5-qubit Adonis architecture. Functions IQMFakeAdonis () Return IQMFakeBackend instance representing IQM's Adonis architecture. previous iqm.qiskit_iqm.fake_backends next iqm.qis...",
    "content": "Fake backend for IQM\u2019s 5-qubit Adonis architecture. Functions IQMFakeAdonis () Return IQMFakeBackend instance representing IQM's Adonis architecture. previous iqm.qiskit_iqm.fake_backends next iqm.qiskit_iqm.fake_backends.fake_adonis.IQMFakeAdonis By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.PRXSequence",
    "url": "/iqm-client/api/iqm.iqm_client.models.PRXSequence.html",
    "description": "A sequence of PRX gates. A generic PRX gate is defined by rotation angle and phase angle, Theta and Phi,\nrespectively. alias of list [ tuple [ float , float ]] previous iqm.iqm_client.models.QubitMapp...",
    "content": "A sequence of PRX gates. A generic PRX gate is defined by rotation angle and phase angle, Theta and Phi,\nrespectively. alias of list [ tuple [ float , float ]] previous iqm.iqm_client.models.QubitMapping next iqm.iqm_client.models.STANDARD_DD_STRATEGY By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.QuantumArchitecture",
    "url": "/iqm-client/api/iqm.iqm_client.models.QuantumArchitecture.html",
    "description": "Bases: BaseModel Quantum architecture as returned by server. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. quant...",
    "content": "Bases: BaseModel Quantum architecture as returned by server. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. quantum_architecture Details about the quantum architecture. Methods quantum_architecture ( QuantumArchitectureSpecification ) \u2013 Details about the quantum architecture. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.iqm_client.models.QualityMetricSet next iqm.iqm_client.models.QuantumArchitectureSpecification By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.qiskit_to_iqm",
    "url": "/iqm-client/api/iqm.qiskit_iqm.qiskit_to_iqm.html",
    "description": "Conversion tools from Qiskit to IQM representation. Functions deserialize_instructions (instructions,\u00a0...) Helper function to turn a list of IQM Instructions into a Qiskit QuantumCircuit. serialize_in...",
    "content": "Conversion tools from Qiskit to IQM representation. Functions deserialize_instructions (instructions,\u00a0...) Helper function to turn a list of IQM Instructions into a Qiskit QuantumCircuit. serialize_instructions (circuit,\u00a0...[,\u00a0...]) Serialize a quantum circuit into the IQM data transfer format. Classes MeasurementKey (creg_name,\u00a0creg_len,\u00a0...) Unique key associated with a measurement instruction. Exceptions InstructionNotSupportedError Raised when a given instruction is not supported by the IQM server. Inheritance previous iqm.qiskit_iqm.move_gate.MoveGate next iqm.qiskit_iqm.qiskit_to_iqm.deserialize_instructions By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.CircuitMeasurementResultsBatch",
    "url": "/iqm-client/api/iqm.iqm_client.models.CircuitMeasurementResultsBatch.html",
    "description": "Type that represents measurement results for a batch of circuits. alias of list [ dict [ str , list [ list [ int ]]]] previous iqm.iqm_client.models.CircuitMeasurementResults next iqm.iqm_client.model...",
    "content": "Type that represents measurement results for a batch of circuits. alias of list [ dict [ str , list [ list [ int ]]]] previous iqm.iqm_client.models.CircuitMeasurementResults next iqm.iqm_client.models.serialize_qubit_mapping By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models",
    "url": "/iqm-client/api/iqm.iqm_client.models.html",
    "description": "This module contains the data models used by IQMClient. Module Attributes Locus Names of the QPU components (typically qubits) a quantum operation instance is acting on, e.g. (\"QB1\", \"QB2\") . CircuitB...",
    "content": "This module contains the data models used by IQMClient. Module Attributes Locus Names of the QPU components (typically qubits) a quantum operation instance is acting on, e.g. (\"QB1\", \"QB2\") . CircuitBatch Type that represents a list of quantum circuits to be executed together in a single batch. QubitMapping Type that represents a qubit mapping for a circuit, i.e. a list of single qubit mappings for all qubits in the circuit. PRXSequence A sequence of PRX gates. STANDARD_DD_STRATEGY The default DD strategy uses the following gate sequences: CircuitMeasurementResults Measurement results from a single circuit. CircuitMeasurementResultsBatch Type that represents measurement results for a batch of circuits. Functions serialize_qubit_mapping (qubit_mapping) Serializes a qubit mapping dict into the corresponding IQM data transfer format. validate_circuit (circuit) Validates a submitted quantum circuit using Pydantic tooling. Classes CalibrationSet (*,\u00a0calibration_set_id,\u00a0...) Metadata and observations of a calibration set. Circuit (*,\u00a0name,\u00a0instructions[,\u00a0metadata]) Quantum circuit to be executed. CircuitCompilationOptions ([...]) Various discrete options for quantum circuit compilation to pulse schedule. ClientLibrary (*,\u00a0name[,\u00a0package_name,\u00a0...]) Represents a client library with its metadata. Counts (*,\u00a0measurement_keys,\u00a0counts) Circuit measurement results in histogram representation. DDMode (value[,\u00a0names,\u00a0module,\u00a0qualname,\u00a0...]) Dynamical Decoupling (DD) mode for circuit execution. DDStrategy (*,\u00a0merge_contiguous_waits,\u00a0...) Describes a particular dynamical decoupling strategy. DynamicQuantumArchitecture (*,\u00a0...) Dynamic quantum architecture as returned by server. GateImplementationInfo (*,\u00a0loci) Information about an implementation of a quantum gate/operation. GateInfo (*,\u00a0implementations,\u00a0...) Information about a quantum gate/operation. HeraldingMode (value[,\u00a0names,\u00a0module,\u00a0...]) Heralding mode for circuit execution. Instruction (*,\u00a0name,\u00a0implementation,\u00a0qubits,\u00a0...) Native quantum operation instance with particular arguments and locus. JobParameters (*,\u00a0shots[,\u00a0...]) Job-specific parameters extracted from the original RunRequest. Metadata (*[,\u00a0calibration_set_id,\u00a0request,\u00a0...]) Metadata describing a circuit execution job. MoveGateFrameTrackingMode (value[,\u00a0names,\u00a0...]) MOVE gate frame tracking mode for circuit compilation. MoveGateValidationMode (value[,\u00a0names,\u00a0...]) MOVE gate validation mode for circuit compilation. NativeOperation (name,\u00a0arity,\u00a0args_required,\u00a0...) Describes a native operation on the quantum computer. QualityMetricSet (*,\u00a0calibration_set_id,\u00a0...) Quality metrics for a calibration set. QuantumArchitecture (*,\u00a0quantum_architecture) Quantum architecture as returned by server. QuantumArchitectureSpecification (*,\u00a0name,\u00a0...) Quantum architecture specification. RunCounts (*,\u00a0status[,\u00a0counts_batch]) Measurement results of a circuit execution job in histogram representation. RunRequest (*,\u00a0circuits[,\u00a0custom_settings,\u00a0...]) Request for an IQM quantum computer to run a job that executes a batch of quantum circuits. RunResult (*,\u00a0status[,\u00a0measurements,\u00a0...]) Results of the quantum circuit execution job. RunStatus (*,\u00a0status[,\u00a0message,\u00a0warnings]) Status of a circuit execution job. SingleQubitMapping (*,\u00a0logical_name,\u00a0...) Mapping of a logical qubit name to a physical qubit name. StaticQuantumArchitecture (*,\u00a0qubits,\u00a0...) Static quantum architecture of the server. Status (value[,\u00a0names,\u00a0module,\u00a0qualname,\u00a0...]) Status of a job. Inheritance previous iqm.iqm_client.iqm_client.IQMClient next iqm.iqm_client.models.Locus By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.transpiler",
    "url": "/iqm-client/api/iqm.cirq_iqm.transpiler.html",
    "description": "Helper functions for IQM specific transpilation needs. Functions transpile_insert_moves_into_circuit (...[,\u00a0...]) Transpile the circuit to insert MOVE gates where needed. previous iqm.cirq_iqm.seriali...",
    "content": "Helper functions for IQM specific transpilation needs. Functions transpile_insert_moves_into_circuit (...[,\u00a0...]) Transpile the circuit to insert MOVE gates where needed. previous iqm.cirq_iqm.serialize.OperationNotSupportedError next iqm.cirq_iqm.transpiler.transpile_insert_moves_into_circuit By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.extended_qasm_parser",
    "url": "/iqm-client/api/iqm.cirq_iqm.extended_qasm_parser.html",
    "description": "Imports OpenQASM 2.0 programs in a way that preserves gates native to the IQM architectures. Functions circuit_from_qasm (qasm) Parses an OpenQASM 2.0 program to a Cirq circuit. previous iqm.cirq_iqm....",
    "content": "Imports OpenQASM 2.0 programs in a way that preserves gates native to the IQM architectures. Functions circuit_from_qasm (qasm) Parses an OpenQASM 2.0 program to a Cirq circuit. previous iqm.cirq_iqm.devices.iqm_device_metadata.IQMDeviceMetadata next iqm.cirq_iqm.extended_qasm_parser.circuit_from_qasm By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.CircuitBatch",
    "url": "/iqm-client/api/iqm.iqm_client.models.CircuitBatch.html",
    "description": "Type that represents a list of quantum circuits to be executed together in a single batch. alias of list [ Circuit ] previous iqm.iqm_client.models.Locus next iqm.iqm_client.models.QubitMapping By IQM...",
    "content": "Type that represents a list of quantum circuits to be executed together in a single batch. alias of list [ Circuit ] previous iqm.iqm_client.models.Locus next iqm.iqm_client.models.QubitMapping By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.iqm_job",
    "url": "/iqm-client/api/iqm.qiskit_iqm.iqm_job.html",
    "description": "Circuit execution jobs. Classes IQMJob (backend,\u00a0job_id,\u00a0**kwargs) Implementation of Qiskit's job interface to handle circuit execution on an IQM server. Inheritance previous iqm.qiskit_iqm.iqm_circui...",
    "content": "Circuit execution jobs. Classes IQMJob (backend,\u00a0job_id,\u00a0**kwargs) Implementation of Qiskit's job interface to handle circuit execution on an IQM server. Inheritance previous iqm.qiskit_iqm.iqm_circuit_validation.validate_circuit next iqm.qiskit_iqm.iqm_job.IQMJob By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.devices.adonis.Adonis",
    "url": "/iqm-client/api/iqm.cirq_iqm.devices.adonis.Adonis.html",
    "description": "Bases: IQMDevice IQM\u2019s five-qubit transmon device. The qubits are connected thus: where the lines denote which qubit pairs can be subject to two-qubit gates. Adonis has native PhasedXPowGate, XPowGate...",
    "content": "Bases: IQMDevice IQM\u2019s five-qubit transmon device. The qubits are connected thus: where the lines denote which qubit pairs can be subject to two-qubit gates. Adonis has native PhasedXPowGate, XPowGate, and YPowGate gates. The two-qubit gate CZ is\nnative, as well. The qubits can be measured simultaneously or separately any number of times. Attributes Methods previous iqm.cirq_iqm.devices.adonis next iqm.cirq_iqm.devices.aphrodite By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.errors.EndpointRequestError",
    "url": "/iqm-client/api/iqm.iqm_client.errors.EndpointRequestError.html",
    "description": "Retrieving something from a server endpoint failed because we did not understand the response. previous iqm.iqm_client.errors.ClientConfigurationError next iqm.iqm_client.errors.JobAbortionError By IQ...",
    "content": "Retrieving something from a server endpoint failed because we did not understand the response. previous iqm.iqm_client.errors.ClientConfigurationError next iqm.iqm_client.errors.JobAbortionError By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.examples.bell_measure.bell_measure",
    "url": "/iqm-client/api/iqm.qiskit_iqm.examples.bell_measure.bell_measure.html",
    "description": "Run a circuit that prepares and measures a Bell state. server_url ( str ) \u2013 URL of the IQM server used for execution a mapping of bitstrings representing qubit measurement results to counts for each r...",
    "content": "Run a circuit that prepares and measures a Bell state. server_url ( str ) \u2013 URL of the IQM server used for execution a mapping of bitstrings representing qubit measurement results to counts for each result dict [ str , int ] previous iqm.qiskit_iqm.examples.bell_measure next iqm.qiskit_iqm.examples.resonance_example By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.iqm_gates",
    "url": "/iqm-client/api/iqm.cirq_iqm.iqm_gates.html",
    "description": "Implementations for IQM specific quantum gates Classes IQMMoveGate (*[,\u00a0exponent,\u00a0global_shift]) The MOVE operation is a unitary population exchange operation between a qubit and a resonator. Inherita...",
    "content": "Implementations for IQM specific quantum gates Classes IQMMoveGate (*[,\u00a0exponent,\u00a0global_shift]) The MOVE operation is a unitary population exchange operation between a qubit and a resonator. Inheritance previous iqm.cirq_iqm.extended_qasm_parser.circuit_from_qasm next iqm.cirq_iqm.iqm_gates.IQMMoveGate By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.iqm_provider.IQMProvider",
    "url": "/iqm-client/api/iqm.qiskit_iqm.iqm_provider.IQMProvider.html",
    "description": "Bases: object Provider for IQM backends. IQMProvider connects to a quantum computer through an IQM server.\nIf the server requires user authentication, you can provide it either using environment\nvaria...",
    "content": "Bases: object Provider for IQM backends. IQMProvider connects to a quantum computer through an IQM server.\nIf the server requires user authentication, you can provide it either using environment\nvariables, or as keyword arguments to IQMProvider. The user authentication kwargs are passed\nthrough to IQMClient as is, and are documented there. url ( str ) \u2013 URL of the IQM server (e.g. https://cocos.resonance.meetiqm.com/garnet ) Methods get_backend ([name,\u00a0calibration_set_id]) An IQMBackend instance associated with this provider. An IQMBackend instance associated with this provider. name ( str | None ) \u2013 optional name of a custom facade backend calibration_set_id ( UUID | None ) \u2013 ID of the calibration set used to create the transpilation target of the backend.\nIf None, the server default calibration set will be used. IQMBackend | IQMFacadeBackend previous iqm.qiskit_iqm.iqm_provider.IQMFacadeBackend next iqm.qiskit_iqm.iqm_transpilation By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.Circuit",
    "url": "/iqm-client/api/iqm.iqm_client.models.Circuit.html",
    "description": "Bases: BaseModel Quantum circuit to be executed. Consists of native quantum operations, each represented by an instance of the Instruction class. Attributes model_config Configuration for the model, s...",
    "content": "Bases: BaseModel Quantum circuit to be executed. Consists of native quantum operations, each represented by an instance of the Instruction class. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name name of the circuit instructions instructions comprising the circuit metadata arbitrary metadata associated with the circuit Methods all_qubits () Return the names of all qubits in the circuit. instructions_validator (value) Check the container of instructions and each instruction within name_validator (value) Check if the circuit name is a non-empty string name ( str ) \u2013 instructions ( list [ Instruction ] | tuple [ Instruction , ... ] ) \u2013 metadata ( dict [ str , Any ] | None ) \u2013 name of the circuit instructions comprising the circuit arbitrary metadata associated with the circuit Return the names of all qubits in the circuit. set [ str ] Check if the circuit name is a non-empty string Check the container of instructions and each instruction within Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.iqm_client.models.CalibrationSet next iqm.iqm_client.models.CircuitCompilationOptions By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.examples.transpile_example.transpile_example",
    "url": "/iqm-client/api/iqm.qiskit_iqm.examples.transpile_example.transpile_example.html",
    "description": "Run a GHZ circuit transpiled using the Qiskit transpile function. server_url ( str ) \u2013 URL of the IQM server used for execution transpiled circuit, a mapping of bitstrings representing qubit measureme...",
    "content": "Run a GHZ circuit transpiled using the Qiskit transpile function. server_url ( str ) \u2013 URL of the IQM server used for execution transpiled circuit, a mapping of bitstrings representing qubit measurement results to counts for each result tuple [ QuantumCircuit , dict [ str , int ]] previous iqm.qiskit_iqm.examples.transpile_example next iqm.qiskit_iqm.fake_backends By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.authentication.TokenClient",
    "url": "/iqm-client/api/iqm.iqm_client.authentication.TokenClient.html",
    "description": "Bases: TokenProviderInterface Requests new token from an authentication server Attributes PASSWORD_GRANT_TYPE  REFRESH_TOKEN_GRANT_TYPE  Methods _get_access_token_from_server (grant_type) Get new acce...",
    "content": "Bases: TokenProviderInterface Requests new token from an authentication server Attributes PASSWORD_GRANT_TYPE  REFRESH_TOKEN_GRANT_TYPE  Methods _get_access_token_from_server (grant_type) Get new access token from the server and update refresh token. close () Close authentication session get_token () Get new access token and refresh token from the server auth_server_url ( str ) \u2013 realm ( str ) \u2013 username ( str ) \u2013 password ( str ) \u2013 Get new access token and refresh token from the server str Close authentication session None previous iqm.iqm_client.authentication.ExternalToken next iqm.iqm_client.authentication.TokenManager By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingOnlyTrustExistingMovesPlugin",
    "url": "/iqm-client/api/iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingOnlyTrustExistingMovesPlugin.html",
    "description": "Bases: MoveGateRoutingPlugin Plugin class for MoveGate routing without single qubit gate optimization\nwhere existing moves are not checked. Methods previous iqm.qiskit_iqm.transpiler_plugins.MoveGateR...",
    "content": "Bases: MoveGateRoutingPlugin Plugin class for MoveGate routing without single qubit gate optimization\nwhere existing moves are not checked. Methods previous iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingOnlyRemoveExistingMovesPlugin next iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingPlugin By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.qiskit_to_iqm.InstructionNotSupportedError",
    "url": "/iqm-client/api/iqm.qiskit_iqm.qiskit_to_iqm.InstructionNotSupportedError.html",
    "description": "Raised when a given instruction is not supported by the IQM server. previous iqm.qiskit_iqm.qiskit_to_iqm.MeasurementKey next iqm.qiskit_iqm.transpiler_plugins By IQM client developers \u00a9 Copyright 202...",
    "content": "Raised when a given instruction is not supported by the IQM server. previous iqm.qiskit_iqm.qiskit_to_iqm.MeasurementKey next iqm.qiskit_iqm.transpiler_plugins By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.iqm_move_layout",
    "url": "/iqm-client/api/iqm.qiskit_iqm.iqm_move_layout.html",
    "description": "Generate an initial layout for a quantum circuit that is\nvalid on the quantum architecture specification of the given backend. Functions generate_initial_layout (backend,\u00a0circuit[,\u00a0...]) Generates an ...",
    "content": "Generate an initial layout for a quantum circuit that is\nvalid on the quantum architecture specification of the given backend. Functions generate_initial_layout (backend,\u00a0circuit[,\u00a0...]) Generates an initial layout for the given circuit, when run against the given backend. Classes IQMMoveLayout (*args,\u00a0**kwargs) Create a layout that is valid on the dynamic quantum architecture of the given IQM target. Inheritance previous iqm.qiskit_iqm.iqm_job.IQMJob next iqm.qiskit_iqm.iqm_move_layout.generate_initial_layout By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.transpiler_plugins.OnlyRZOptimizationPlugin",
    "url": "/iqm-client/api/iqm.qiskit_iqm.transpiler_plugins.OnlyRZOptimizationPlugin.html",
    "description": "Bases: IQMSchedulingPlugin Plugin class for single qubit gate optimization without MOVE gate routing. Methods previous iqm.qiskit_iqm.transpiler_plugins.OnlyRZOptimizationIgnoreBarriersPlugin next Int...",
    "content": "Bases: IQMSchedulingPlugin Plugin class for single qubit gate optimization without MOVE gate routing. Methods previous iqm.qiskit_iqm.transpiler_plugins.OnlyRZOptimizationIgnoreBarriersPlugin next Integration Guide By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.iqm_provider.IQMFacadeBackend",
    "url": "/iqm-client/api/iqm.qiskit_iqm.iqm_provider.IQMFacadeBackend.html",
    "description": "Bases: IQMBackend circuit to the IQM server, and if the execution was successful, performs a simulation with a respective IQM noise\nmodel locally, then returns the simulated results. client ( IQMClien...",
    "content": "Bases: IQMBackend circuit to the IQM server, and if the execution was successful, performs a simulation with a respective IQM noise\nmodel locally, then returns the simulated results. client ( IQMClient ) \u2013 client instance for communicating with an IQM server **kwargs \u2013 optional arguments to be passed to the parent Backend initializer Attributes architecture Dynamic quantum architecture of the backend instance. name Name of the backend. description Optional human-readable description. online_date Date that the backend came online. backend_version Version of the backend being provided. Methods _validate_no_empty_cregs (circuit) Returns True if given circuit has no empty (unused) classical registers, False otherwise. run (run_input,\u00a0**options) Run a quantum circuit or a list of quantum circuits on the IQM quantum computer represented by this backend. Run a quantum circuit or a list of quantum circuits on the IQM quantum computer represented by this backend. run_input ( QuantumCircuit | list [ QuantumCircuit ] ) \u2013 The circuits to run. options \u2013 Keyword arguments passed on to create_run_request() , and documented there. Job object from which the results can be obtained once the execution has finished. JobV1 previous iqm.qiskit_iqm.iqm_provider.IQMBackend next iqm.qiskit_iqm.iqm_provider.IQMProvider By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.RunResult",
    "url": "/iqm-client/api/iqm.iqm_client.models.RunResult.html",
    "description": "Bases: BaseModel Results of the quantum circuit execution job.\nIf the job succeeded, measurements contains the output of the batch of circuits,\nconsisting of the results of the measurement operations ...",
    "content": "Bases: BaseModel Results of the quantum circuit execution job.\nIf the job succeeded, measurements contains the output of the batch of circuits,\nconsisting of the results of the measurement operations in each circuit.\nIt is a list of dictionaries, where each dict maps each measurement key to a 2D array of measurement\nresults, represented as a nested list. RunResult.measurements[circuit_index][key][shot][qubit_index] is the result of measuring the qubit_index \u2019th qubit in measurement operation key in the shot shot in the circuit_index \u2019th circuit of the batch. measurements is present iff the status is 'ready' . message carries additional information for the 'failed' status.\nIf the status is 'pending compilation' or 'pending execution' , measurements and message are None . The results are non-negative integers representing the computational basis state (for qubits, 0 or 1)\nthat was the measurement outcome. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. status current status of the job, in {'pending_compilation', 'pending_execution', 'ready', 'failed', 'aborted'} measurements if the job has finished successfully, the measurement results for the circuit(s) message if the job failed, an error message metadata metadata about the job warnings list of warning messages Methods from_dict (inp) Parses the result from a dict. status ( Status ) \u2013 measurements ( list [ dict [ str , list [ list [ int ] ] ] ] | None ) \u2013 message ( str | None ) \u2013 metadata ( Metadata ) \u2013 warnings ( list [ str ] | None ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. current status of the job, in {'pending_compilation', 'pending_execution', 'ready', 'failed', 'aborted'} if the job has finished successfully, the measurement results for the circuit(s) if the job failed, an error message metadata about the job list of warning messages Parses the result from a dict. inp ( dict [ str , str | dict | list | None ] ) \u2013 value to parse, has to map to RunResult parsed job result RunResult previous iqm.iqm_client.models.RunRequest next iqm.iqm_client.models.RunStatus By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.CircuitCompilationOptions",
    "url": "/iqm-client/api/iqm.iqm_client.models.CircuitCompilationOptions.html",
    "description": "Bases: object Various discrete options for quantum circuit compilation to pulse schedule. Attributes active_reset_cycles Number of active reset operations inserted at the beginning of each circuit for...",
    "content": "Bases: object Various discrete options for quantum circuit compilation to pulse schedule. Attributes active_reset_cycles Number of active reset operations inserted at the beginning of each circuit for each active qubit. dd_mode Control whether dynamical decoupling should be enabled or disabled during the execution. dd_strategy A particular dynamical decoupling strategy to be used during the execution. heralding_mode Heralding mode to use during the execution. max_circuit_duration_over_t2 Server-side circuit disqualification threshold. move_gate_frame_tracking MOVE gate frame tracking mode for circuit compilation. move_gate_validation MOVE gate validation mode for circuit compilation. Methods __delattr__ (name) Implement delattr(self, name). __eq__ (other) Return self==value. __hash__ () Return hash(self). __post_init__ () Validate the options. __repr__ () Return repr(self). __setattr__ (name,\u00a0value) Implement setattr(self, name, value). max_circuit_duration_over_t2 ( float | None ) \u2013 heralding_mode ( HeraldingMode ) \u2013 move_gate_validation ( MoveGateValidationMode ) \u2013 move_gate_frame_tracking ( MoveGateFrameTrackingMode ) \u2013 active_reset_cycles ( int | None ) \u2013 dd_mode ( DDMode ) \u2013 dd_strategy ( DDStrategy | None ) \u2013 Server-side circuit disqualification threshold.\nThe job is rejected on the server if any circuit in it is estimated to take longer than\nthe shortest T2 time of any qubit used in the circuit, multiplied by this value.\nSetting this value to 0.0 turns off circuit duration checking. None tells the server to use its default value in the check. Heralding mode to use during the execution. MOVE gate validation mode for circuit compilation. This options is ignored on devices that do not support MOVE\nand for circuits that do not contain MOVE gates. MOVE gate frame tracking mode for circuit compilation. This options is ignored on devices that do not support\nMOVE and for circuits that do not contain MOVE gates. Number of active reset operations inserted at the beginning of each circuit for each active qubit. None means active reset is not used but instead reset is done by waiting (relaxation). Integer values smaller\nthan 1 result in neither active nor reset by wait being used, in which case any reset operations must be explicitly\nadded in the circuit. Control whether dynamical decoupling should be enabled or disabled during the execution. A particular dynamical decoupling strategy to be used during the execution. previous iqm.iqm_client.models.Circuit next iqm.iqm_client.models.ClientLibrary By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.errors.JobAbortionError",
    "url": "/iqm-client/api/iqm.iqm_client.errors.JobAbortionError.html",
    "description": "Job abortion failed. previous iqm.iqm_client.errors.EndpointRequestError next iqm.iqm_client.iqm_client By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on ...",
    "content": "Job abortion failed. previous iqm.iqm_client.errors.EndpointRequestError next iqm.iqm_client.iqm_client By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm",
    "url": "/iqm-client/api/iqm.cirq_iqm.html",
    "description": "Cirq adapter for IQM\u2019s quantum computers. Subpackages and modules devices Definitions for various IQM quantum devices for the Cirq framework. extended_qasm_parser Imports OpenQASM 2.0 programs in a wa...",
    "content": "Cirq adapter for IQM\u2019s quantum computers. Subpackages and modules devices Definitions for various IQM quantum devices for the Cirq framework. extended_qasm_parser Imports OpenQASM 2.0 programs in a way that preserves gates native to the IQM architectures. iqm_gates Implementations for IQM specific quantum gates iqm_sampler Circuit sampler that executes quantum circuits on an IQM quantum computer. optimizers Circuit optimization classes. serialize Helper functions for serializing and deserializing quantum circuits between Cirq and IQM circuit formats. transpiler Helper functions for IQM specific transpilation needs. previous API Reference next iqm.cirq_iqm.devices By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.devices.aphrodite",
    "url": "/iqm-client/api/iqm.cirq_iqm.devices.aphrodite.html",
    "description": "IQM\u2019s Aphrodite quantum architecture. Classes Aphrodite () IQM's 54-qubit transmon device. Inheritance previous iqm.cirq_iqm.devices.adonis.Adonis next iqm.cirq_iqm.devices.aphrodite.Aphrodite By IQM ...",
    "content": "IQM\u2019s Aphrodite quantum architecture. Classes Aphrodite () IQM's 54-qubit transmon device. Inheritance previous iqm.cirq_iqm.devices.adonis.Adonis next iqm.cirq_iqm.devices.aphrodite.Aphrodite By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.fake_backends.fake_deneb",
    "url": "/iqm-client/api/iqm.qiskit_iqm.fake_backends.fake_deneb.html",
    "description": "Fake backend for IQM\u2019s 6-qubit Deneb architecture. Functions IQMFakeDeneb () Return IQMFakeBackend instance representing IQM's Deneb architecture. previous iqm.qiskit_iqm.fake_backends.fake_apollo.IQM...",
    "content": "Fake backend for IQM\u2019s 6-qubit Deneb architecture. Functions IQMFakeDeneb () Return IQMFakeBackend instance representing IQM's Deneb architecture. previous iqm.qiskit_iqm.fake_backends.fake_apollo.IQMFakeApollo next iqm.qiskit_iqm.fake_backends.fake_deneb.IQMFakeDeneb By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.devices.iqm_device_metadata.IQMDeviceMetadata",
    "url": "/iqm-client/api/iqm.cirq_iqm.devices.iqm_device_metadata.IQMDeviceMetadata.html",
    "description": "Bases: DeviceMetadata Hardware metadata for IQM devices. qubits ( Iterable [ NamedQid ] ) \u2013 qubits on the device connectivity ( Iterable [ tuple [ NamedQid , ... ] ] ) \u2013 qubit connectivity graph of th...",
    "content": "Bases: DeviceMetadata Hardware metadata for IQM devices. qubits ( Iterable [ NamedQid ] ) \u2013 qubits on the device connectivity ( Iterable [ tuple [ NamedQid , ... ] ] ) \u2013 qubit connectivity graph of the device operations ( dict [ type [ cirq.Gate ] , list [ tuple [ cirq.NamedQid , ... ] ] ] | None ) \u2013 Supported quantum operations of the device, mapping op types to their possible loci. gateset ( cirq.Gateset | None ) \u2013 Native gateset of the device. If None, a default IQM device gateset will be used. resonators ( Iterable [ NamedQid ] ) \u2013 computational resonators of the device architecture ( DynamicQuantumArchitecture | None ) \u2013 architecture from which values of the other arguments were obtained Attributes QUBIT_NAME_PREFIX prefix for qubit names, to be followed by their numerical index RESONATOR_DIMENSION Dimension abstraction for the resonator Qids gateset Returns the cirq.Gateset of supported gates on this device. resonator_set Returns the set of resonators on the device. Methods __eq__ (other) Return self==value. __getstate__ () Helper for pickle. __hash__ () Return hash(self). __ne__ (other) Return self!=value. _value_equality_values_ ()  _value_equality_values_cls_ ()  from_architecture (architecture) Returns device metadata object created based on dynamic quantum architecture from_qubit_indices (qubit_count,\u00a0...[,\u00a0gateset]) Returns device metadata object created based on connectivity specified using qubit indices only. prefix for qubit names, to be followed by their numerical index Dimension abstraction for the resonator Qids Returns the set of resonators on the device. Frozenset of resonators on device. Returns device metadata object created based on dynamic quantum architecture architecture ( DynamicQuantumArchitecture ) \u2013 IQMDeviceMetadata Returns device metadata object created based on connectivity specified using qubit indices only. qubit_count ( int ) \u2013 connectivity_indices ( Iterable [ set [ int ] ] ) \u2013 gateset ( tuple [ type [ Gate ] ] | None ) \u2013 IQMDeviceMetadata Returns the cirq.Gateset of supported gates on this device. previous iqm.cirq_iqm.devices.iqm_device_metadata next iqm.cirq_iqm.extended_qasm_parser By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.iqm_transpilation.optimize_single_qubit_gates",
    "url": "/iqm-client/api/iqm.qiskit_iqm.iqm_transpilation.optimize_single_qubit_gates.html",
    "description": "Optimize number of single-qubit gates in a transpiled circuit exploiting the IQM specific gate set. circuit ( QuantumCircuit ) \u2013 quantum circuit to optimize drop_final_rz ( bool ) \u2013 Drop terminal RZ g...",
    "content": "Optimize number of single-qubit gates in a transpiled circuit exploiting the IQM specific gate set. circuit ( QuantumCircuit ) \u2013 quantum circuit to optimize drop_final_rz ( bool ) \u2013 Drop terminal RZ gates even if there are no measurements following them (since they do not affect\nthe measurement results). Note that this will change the unitary propagator of the circuit.\nIt is recommended always to set this to true as the final RZ gates do no change the measurement outcomes of\nthe circuit. ignore_barriers ( bool ) \u2013 Removes barriers from the circuit if they exist (default = False) before optimization. optimized circuit QuantumCircuit previous iqm.qiskit_iqm.iqm_transpilation next iqm.qiskit_iqm.iqm_transpilation.IQMOptimizeSingleQubitGates By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.fake_backends.fake_aphrodite.IQMFakeAphrodite",
    "url": "/iqm-client/api/iqm.qiskit_iqm.fake_backends.fake_aphrodite.IQMFakeAphrodite.html",
    "description": "Return IQMFakeBackend instance representing IQM\u2019s Aphrodite architecture. IQMFakeBackend previous iqm.qiskit_iqm.fake_backends.fake_aphrodite next iqm.qiskit_iqm.fake_backends.fake_apollo By IQM clien...",
    "content": "Return IQMFakeBackend instance representing IQM\u2019s Aphrodite architecture. IQMFakeBackend previous iqm.qiskit_iqm.fake_backends.fake_aphrodite next iqm.qiskit_iqm.fake_backends.fake_apollo By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.devices.iqm_device_metadata",
    "url": "/iqm-client/api/iqm.cirq_iqm.devices.iqm_device_metadata.html",
    "description": "DeviceMetadata subtype for IQM devices. Classes IQMDeviceMetadata (qubits,\u00a0connectivity,\u00a0*[,\u00a0...]) Hardware metadata for IQM devices. Inheritance previous iqm.cirq_iqm.devices.iqm_device.IQMDevice nex...",
    "content": "DeviceMetadata subtype for IQM devices. Classes IQMDeviceMetadata (qubits,\u00a0connectivity,\u00a0*[,\u00a0...]) Hardware metadata for IQM devices. Inheritance previous iqm.cirq_iqm.devices.iqm_device.IQMDevice next iqm.cirq_iqm.devices.iqm_device_metadata.IQMDeviceMetadata By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.iqm_move_layout.IQMMoveLayout",
    "url": "/iqm-client/api/iqm.qiskit_iqm.iqm_move_layout.IQMMoveLayout.html",
    "description": "Bases: TrivialLayout Create a layout that is valid on the dynamic quantum architecture of the\ngiven IQM target. The architecture defines which gate loci are available. This class\ntries to map the virt...",
    "content": "Bases: TrivialLayout Create a layout that is valid on the dynamic quantum architecture of the\ngiven IQM target. The architecture defines which gate loci are available. This class\ntries to map the virtual/logical components of the circuit to the physical QPU components\nof the architecture, such that the gates in the circuit can be applied on those components. This class is required because Qiskit\u2019s basic layout algorithm assumes all connections between\ntwo qubits have the same two-qubit gates available, which isn\u2019t true in general. Note This version of the layout generator only works reliably with a single resonator,\nand can only handle pure Star architecture circuits.\nIt also assumes that a valid layout exists for the circuit that does not require SWAPs, which\nisn\u2019t true in general. Attributes Methods _calculate_requirements (dag) Determine the requirements for each used logical qubit in the circuit. _determine_restrictions (dqa) Determine which gates are restricted to specific qubits or resonators. _is_restricted_gate (gate,\u00a0index,\u00a0components,\u00a0dqa) Check if the gate is restricted to a specific qubit or resonator. get_initial_layout () Returns the initial layout generated by the algorithm. run (dag) Creates a valid layout for the given quantum circuit. Creates a valid layout for the given quantum circuit. dag ( DAGCircuit ) \u2013 Circuit DAG to find layout for. TranspilerError \u2013 A valid layout could not be found. Returns the initial layout generated by the algorithm. The initial layout. Layout previous iqm.qiskit_iqm.iqm_move_layout.generate_initial_layout next iqm.qiskit_iqm.iqm_naive_move_pass By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.QuantumArchitectureSpecification",
    "url": "/iqm-client/api/iqm.iqm_client.models.QuantumArchitectureSpecification.html",
    "description": "Bases: BaseModel Quantum architecture specification. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name Name of ...",
    "content": "Bases: BaseModel Quantum architecture specification. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name Name of the quantum architecture. operations Operations supported by this quantum architecture, mapped to the allowed loci. qubits List of qubits of this quantum architecture. qubit_connectivity Qubit connectivity of this quantum architecture. Methods compare_operations (ops1,\u00a0ops2) Compares the given operation sets. has_equivalent_operations (other) Compares the given operation sets defined by the quantum architecture against another architecture specification. name ( str ) \u2013 operations ( dict [ str , list [ list [ str ] ] ] ) \u2013 qubits ( list [ str ] ) \u2013 qubit_connectivity ( list [ list [ str ] ] ) \u2013 Name of the quantum architecture. List of qubits of this quantum architecture. Qubit connectivity of this quantum architecture. Operations supported by this quantum architecture, mapped to the allowed loci. Compares the given operation sets defined by the quantum architecture against\nanother architecture specification. True if the operation and the loci are equivalent. other ( QuantumArchitectureSpecification ) \u2013 bool Compares the given operation sets. True if the operation and the loci are equivalent. ops1 ( dict [ str , list [ list [ str ] ] ] ) \u2013 ops2 ( dict [ str , list [ list [ str ] ] ] ) \u2013 bool Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.iqm_client.models.QuantumArchitecture next iqm.iqm_client.models.RunCounts By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.iqm_sampler.IQMSampler",
    "url": "/iqm-client/api/iqm.cirq_iqm.iqm_sampler.IQMSampler.html",
    "description": "Bases: Sampler Circuit sampler for executing quantum circuits on IQM quantum computers. IQMSampler connects to a quantum computer through an IQM server.\nIf the server requires user authentication, you...",
    "content": "Bases: Sampler Circuit sampler for executing quantum circuits on IQM quantum computers. IQMSampler connects to a quantum computer through an IQM server.\nIf the server requires user authentication, you can provide it either using environment\nvariables, or as keyword arguments to IQMSampler. The user authentication kwargs are passed\nthrough to IQMClient as is, and are documented there. url ( str ) \u2013 URL of the IQM server. Has to start with http or https. device ( IQMDevice | None ) \u2013 Device to execute the circuits on. If None , the device will be created based\non the calibration-specific dynamic quantum architecture obtained from IQMClient . calibration_set_id ( UUID | None ) \u2013 ID of the calibration set to use. If None , use the default one. run_sweep_timeout ( int | None ) \u2013 Timeout for polling sweep results, in seconds. If None , use the client default value. compiler_options ( CircuitCompilationOptions | None ) \u2013 The compilation options to use for the circuits, as defined by IQM Client. Attributes device Returns the device used by the sampler. Methods _resolve_parameters (program,\u00a0params)  _send_circuits (circuits[,\u00a0repetitions]) Sends a batch of circuits to be executed and retrieves the results. close_client () Close IQMClient's session with the user authentication server. create_run_request (programs,\u00a0*[,\u00a0params,\u00a0...]) Creates a run request without submitting it for execution. run_iqm_batch (programs[,\u00a0repetitions]) Sends a batch of circuits to be executed. run_sweep (program,\u00a0params[,\u00a0repetitions]) Samples from the given Circuit. run_sweep_async (program,\u00a0params[,\u00a0repetitions]) Asynchronously samples from the given Circuit. Returns the device used by the sampler. Close IQMClient\u2019s session with the user authentication server. Discard the client. Samples from the given Circuit. This allows for sweeping over different parameter values,\nunlike the run method.  The params argument will provide a\nmapping from sympy.Symbol`s used within the circuit to a set of\nvalues.  Unlike the `run method, which specifies a single\nmapping from symbol to value, this method allows a \u201csweep\u201d of\nvalues.  This allows a user to specify execution of a family of\nrelated circuits efficiently. program ( Circuit ) \u2013 The circuit to sample from. params ( ParamResolver | Mapping [ str | Expr , complex | number | Expr ] | None | Sweep | _Sweepable ) \u2013 Parameters to run with the program. repetitions ( int ) \u2013 The number of times to sample. Result list for this run; one for each possible parameter resolver. list [ IQMResult ] Sends a batch of circuits to be executed. Running circuits in a batch is more efficient and hence completes quicker than running the circuits\nindividually. Circuits run in a batch must all measure the same qubits. programs ( list [ Circuit ] ) \u2013 quantum circuits to execute repetitions ( int ) \u2013 number of times the circuits are sampled results of the execution ValueError \u2013 circuits are not valid for execution CircuitExecutionError \u2013 something went wrong on the server APITimeoutError \u2013 server did not return the results in the allocated time RuntimeError \u2013 IQM client session has been closed list [ IQMResult ] Creates a run request without submitting it for execution. This takes the same parameters as run() and run_iqm_batch() , and can be used to check the\nrun request that would be sent when calling those functions. programs ( Circuit | list [ Circuit ] ) \u2013 quantum circuit(s) that would be executed when submitting the run request params ( ParamResolver | Mapping [ str | Expr , complex | number | Expr ] | None | Sweep | _Sweepable ) \u2013 same as params for run() , used only if programs is not a list repetitions ( int ) \u2013 number of times the circuits are sampled the created run request RunRequest Asynchronously samples from the given Circuit. By default, this method invokes run_sweep synchronously and simply\nexposes its result is an awaitable. Child classes that are capable of\ntrue asynchronous sampling should override it to use other strategies. program ( cirq.AbstractCircuit ) \u2013 The circuit to sample from. params ( cirq.Sweepable ) \u2013 Parameters to run with the program. repetitions ( int ) \u2013 The number of times to sample. Result list for this run; one for each possible parameter resolver. Sequence [cirq.Result] previous iqm.cirq_iqm.iqm_sampler.IQMResult next iqm.cirq_iqm.iqm_sampler.ResultMetadata By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.auth.ClientAuthenticationError",
    "url": "/iqm-client/api/iqm.iqm_client.cli.auth.ClientAuthenticationError.html",
    "description": "Something went wrong with user authentication. previous iqm.iqm_client.cli.auth.ClientAccountSetupError next iqm.iqm_client.cli.cli By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Rele...",
    "content": "Something went wrong with user authentication. previous iqm.iqm_client.cli.auth.ClientAccountSetupError next iqm.iqm_client.cli.cli By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.devices.apollo.Apollo",
    "url": "/iqm-client/api/iqm.cirq_iqm.devices.apollo.Apollo.html",
    "description": "Bases: IQMDevice IQM\u2019s twenty-qubit transmon device. The qubits are connected thus: where the lines denote which qubit pairs can be subject to two-qubit gates. Apollo has native PhasedXPowGate, XPowGa...",
    "content": "Bases: IQMDevice IQM\u2019s twenty-qubit transmon device. The qubits are connected thus: where the lines denote which qubit pairs can be subject to two-qubit gates. Apollo has native PhasedXPowGate, XPowGate, and YPowGate gates. The two-qubit gate CZ is\nnative, as well. The qubits can be measured simultaneously or separately any number of times. Attributes Methods previous iqm.cirq_iqm.devices.apollo next iqm.cirq_iqm.devices.iqm_device By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.examples.resonance_example",
    "url": "/iqm-client/api/iqm.qiskit_iqm.examples.resonance_example.html",
    "description": "This file is an example of using Qiskit on IQM to run a simple but non-trivial quantum circuit on\nResonance, the IQM quantum cloud service.\nSee the Qiskit on IQM user guide for instructions: https://d...",
    "content": "This file is an example of using Qiskit on IQM to run a simple but non-trivial quantum circuit on\nResonance, the IQM quantum cloud service.\nSee the Qiskit on IQM user guide for instructions: https://docs.meetiqm.com/iqm-client/user_guide_qiskit.html Functions resonance_example (server_url,\u00a0api_token) Run a circuit via IQM Resonance. previous iqm.qiskit_iqm.examples.bell_measure.bell_measure next iqm.qiskit_iqm.examples.resonance_example.resonance_example By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.auth.refresh_request",
    "url": "/iqm-client/api/iqm.iqm_client.cli.auth.refresh_request.html",
    "description": "Sends refresh request to the authentication server. Timeout \u2013 no response from auth server within the timeout period ConnectionError \u2013 connecting the auth server failed on all retries ClientAuthentica...",
    "content": "Sends refresh request to the authentication server. Timeout \u2013 no response from auth server within the timeout period ConnectionError \u2013 connecting the auth server failed on all retries ClientAuthenticationError \u2013 updating the tokens failed Tokens dictionary, or None if refresh_token is expired. url ( str ) \u2013 realm ( str ) \u2013 client_id ( str ) \u2013 refresh_token ( str ) \u2013 dict [ str , str ] | None previous iqm.iqm_client.cli.auth.logout_request next iqm.iqm_client.cli.auth.slash_join By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.fake_backends.fake_adonis.IQMFakeAdonis",
    "url": "/iqm-client/api/iqm.qiskit_iqm.fake_backends.fake_adonis.IQMFakeAdonis.html",
    "description": "Return IQMFakeBackend instance representing IQM\u2019s Adonis architecture. IQMFakeBackend previous iqm.qiskit_iqm.fake_backends.fake_adonis next iqm.qiskit_iqm.fake_backends.fake_aphrodite By IQM client d...",
    "content": "Return IQMFakeBackend instance representing IQM\u2019s Adonis architecture. IQMFakeBackend previous iqm.qiskit_iqm.fake_backends.fake_adonis next iqm.qiskit_iqm.fake_backends.fake_aphrodite By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.errors",
    "url": "/iqm-client/api/iqm.iqm_client.errors.html",
    "description": "This module contains error classes required by IQMClient. Exceptions APITimeoutError Executing a job on the server took too long. CircuitExecutionError Something went wrong on the server. CircuitTrans...",
    "content": "This module contains error classes required by IQMClient. Exceptions APITimeoutError Executing a job on the server took too long. CircuitExecutionError Something went wrong on the server. CircuitTranspilationError Circuit transpilation failed. CircuitValidationError Circuit validation failed. ClientAuthenticationError Something went wrong with user authentication. ClientConfigurationError Wrong configuration provided. EndpointRequestError Retrieving something from a server endpoint failed because we did not understand the response. JobAbortionError Job abortion failed. previous iqm.iqm_client.cli.token_manager.write_tokens next iqm.iqm_client.errors.APITimeoutError By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingOnlyPlugin",
    "url": "/iqm-client/api/iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingOnlyPlugin.html",
    "description": "Bases: MoveGateRoutingPlugin Plugin class for MoveGate routing without single qubit gate optimization as a scheduling stage. Methods previous iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingOnlyKeepE...",
    "content": "Bases: MoveGateRoutingPlugin Plugin class for MoveGate routing without single qubit gate optimization as a scheduling stage. Methods previous iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingOnlyKeepExistingMovesPlugin next iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingOnlyRemoveExistingMovesPlugin By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.token_manager.refresh_tokens",
    "url": "/iqm-client/api/iqm.iqm_client.cli.token_manager.refresh_tokens.html",
    "description": "Request new tokens from auth server. config ( ConfigFile ) \u2013 IQM Client CLI configuration current_tokens ( dict ) \u2013 dict containing the current tokens from the tokens file cycle ( int ) \u2013 refresh cycl...",
    "content": "Request new tokens from auth server. config ( ConfigFile ) \u2013 IQM Client CLI configuration current_tokens ( dict ) \u2013 dict containing the current tokens from the tokens file cycle ( int ) \u2013 refresh cycle length in seconds Tuple[Optional[dict], bool, int] = (tokens, status, sleep_time)\ntokens: dict containing new tokens or current tokens if auth server could not be connected or None if auth server refused to provide new tokens. status: bool, True if tokens were refreshed successfully, False otherwise\nsleep_time: time to sleep before next refresh attempt Tuple[Optional[dict], bool, int] = (tokens, status, sleep_time)\ntokens: dict containing new tokens or current tokens if auth server could not be connected or None if auth server refused to provide new tokens. status: bool, True if tokens were refreshed successfully, False otherwise\nsleep_time: time to sleep before next refresh attempt tuple [ dict | None, bool , int ] previous iqm.iqm_client.cli.token_manager.read_tokens next iqm.iqm_client.cli.token_manager.start_token_manager By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingWithExactRZPlugin",
    "url": "/iqm-client/api/iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingWithExactRZPlugin.html",
    "description": "Bases: MoveGateRoutingPlugin Plugin class for single qubit gate optimization and MoveGate routing where\ntrailing RZ gates are kept in the circuit. Methods previous iqm.qiskit_iqm.transpiler_plugins.Mo...",
    "content": "Bases: MoveGateRoutingPlugin Plugin class for single qubit gate optimization and MoveGate routing where\ntrailing RZ gates are kept in the circuit. Methods previous iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingTrustExistingMovesPlugin next iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingWithRZOptimizationIgnoreBarriersPlugin By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.iqm_circuit_validation",
    "url": "/iqm-client/api/iqm.qiskit_iqm.iqm_circuit_validation.html",
    "description": "Helper functions for circuit validation. Functions validate_circuit (circuit,\u00a0backend[,\u00a0...]) Validate a circuit against the backend. previous iqm.qiskit_iqm.iqm_circuit.IQMCircuit next iqm.qiskit_iqm...",
    "content": "Helper functions for circuit validation. Functions validate_circuit (circuit,\u00a0backend[,\u00a0...]) Validate a circuit against the backend. previous iqm.qiskit_iqm.iqm_circuit.IQMCircuit next iqm.qiskit_iqm.iqm_circuit_validation.validate_circuit By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.fake_backends.iqm_fake_backend.IQMErrorProfile",
    "url": "/iqm-client/api/iqm.qiskit_iqm.fake_backends.iqm_fake_backend.IQMErrorProfile.html",
    "description": "Bases: object Characteristics of an IQM QPU specimen, used for constructing an error model. All the attributes of this class refer to the components of the QPU using their physical names.\nThere are tw...",
    "content": "Bases: object Characteristics of an IQM QPU specimen, used for constructing an error model. All the attributes of this class refer to the components of the QPU using their physical names.\nThere are two types of QPU components, qubits and computational resonators. t1s ( dict [ str , float ] ) \u2013 maps components to their \\(T_1\\) times (in ns) t2s ( dict [ str , float ] ) \u2013 maps components to their \\(T_2\\) times (in ns) single_qubit_gate_depolarizing_error_parameters ( dict [ str , dict [ str , float ] ] ) \u2013 Depolarizing error parameters for single-qubit gates.\nMaps single-qubit gate names to a mapping of qubits (on which the gate acts) to a depolarizing error.\nThe error, used in a one-qubit depolarizing channel, concatenated with a thermal relaxation channel,\nleads to average gate fidelities that would be determined by benchmarking. two_qubit_gate_depolarizing_error_parameters ( dict [ str , dict [ tuple [ str , str ] , float ] ] ) \u2013 Depolarizing error parameters for two-qubit gates.\nMaps two-qubit gate names to a mapping of pairs of qubits (on which the gate acts) to a depolarizing error.\nThe error, used in a two-qubit depolarizing channel, concatenated with thermal relaxation channels for the\nqubits, leads to average gate fidelities that would be determined by benchmarking. single_qubit_gate_durations ( dict [ str , float ] ) \u2013 Gate duration (in ns) for each single-qubit gate two_qubit_gate_durations ( dict [ str , float ] ) \u2013 Gate duration (in ns) for each two-qubit gate. readout_errors ( dict [ str , dict [ str , float ] ] ) \u2013 Maps physical qubit names to dicts that describe their single-qubit readout errors.\nFor each qubit, the inner dict maps the state labels \u201c0\u201d and \u201c1\u201d to the probability \\(P(\\neg x|x)\\) of observing the state \\(\\ket{\\neg x}\\) given the true state is \\(\\ket{x}\\) . name ( str | None ) \u2013 Identifier of the QPU specimen. Example Attributes name  t1s  t2s  single_qubit_gate_depolarizing_error_parameters  two_qubit_gate_depolarizing_error_parameters  single_qubit_gate_durations  two_qubit_gate_durations  readout_errors  Methods __eq__ (other) Return self==value. __repr__ () Return repr(self). thermal_relaxation (component,\u00a0duration) One-qubit relaxation error channel. One-qubit relaxation error channel. component ( str ) \u2013 duration ( float ) \u2013 QuantumError previous iqm.qiskit_iqm.fake_backends.iqm_fake_backend next iqm.qiskit_iqm.fake_backends.iqm_fake_backend.IQMFakeBackend By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.CircuitMeasurementResults",
    "url": "/iqm-client/api/iqm.iqm_client.models.CircuitMeasurementResults.html",
    "description": "Measurement results from a single circuit. For each measurement operation in the circuit,\nmaps the measurement key to the corresponding results. The outer list elements correspond to shots,\nand the in...",
    "content": "Measurement results from a single circuit. For each measurement operation in the circuit,\nmaps the measurement key to the corresponding results. The outer list elements correspond to shots,\nand the inner list elements to the qubits measured in the measurement operation. alias of dict [ str , list [ list [ int ]]] previous iqm.iqm_client.models.STANDARD_DD_STRATEGY next iqm.iqm_client.models.CircuitMeasurementResultsBatch By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.transpiler_plugins",
    "url": "/iqm-client/api/iqm.qiskit_iqm.transpiler_plugins.html",
    "description": "Collection of Qiskit transpiler plugins for native use of specialized transpiler passes by our devices. Classes IQMDefaultSchedulingPlugin () Plugin class for IQM single qubit gate optimization and Mo...",
    "content": "Collection of Qiskit transpiler plugins for native use of specialized transpiler passes by our devices. Classes IQMDefaultSchedulingPlugin () Plugin class for IQM single qubit gate optimization and MoveGate routing as a scheduling stage. IQMSchedulingPlugin (move_gate_routing,\u00a0...) Basic plugin for scheduling stage of IQM devices. MoveGateRoutingKeepExistingMovesPlugin () Plugin class for single qubit gate optimization and MoveGate routing where existing moves are kept. MoveGateRoutingOnlyKeepExistingMovesPlugin () Plugin class for MoveGate routing without single qubit gate optimization where existing moves are kept. MoveGateRoutingOnlyPlugin () Plugin class for MoveGate routing without single qubit gate optimization as a scheduling stage. MoveGateRoutingOnlyRemoveExistingMovesPlugin () Plugin class for MoveGate routing without single qubit gate optimization where existing moves are removed. MoveGateRoutingOnlyTrustExistingMovesPlugin () Plugin class for MoveGate routing without single qubit gate optimization where existing moves are not checked. MoveGateRoutingPlugin ([optimize_sqg,\u00a0...]) Plugin class for IQM single qubit gate optimization and MoveGate routing as a scheduling stage. MoveGateRoutingRemoveExistingMovesPlugin () Plugin class for single qubit gate optimization and MoveGate routing where existing moves are removed. MoveGateRoutingTrustExistingMovesPlugin () Plugin class for single qubit gate optimization and MoveGate routing where existing moves are not checked. MoveGateRoutingWithExactRZPlugin () Plugin class for single qubit gate optimization and MoveGate routing where trailing RZ gates are kept in the circuit. MoveGateRoutingWithRZOptimizationIgnoreBarriersPlugin () Plugin class for single qubit gate optimization and MoveGate routing where barriers are ignored during optimization. OnlyRZOptimizationExactIgnoreBarriersPlugin () Plugin class for single qubit gate optimization without MOVE gate routing and the final RZ gates are not dropped. OnlyRZOptimizationExactPlugin () Plugin class for single qubit gate optimization without MOVE gate routing and the final RZ gates are not dropped. OnlyRZOptimizationIgnoreBarriersPlugin () Plugin class for single qubit gate optimization without MOVE gate routing where barriers are ignored. OnlyRZOptimizationPlugin ([drop_final_rz,\u00a0...]) Plugin class for single qubit gate optimization without MOVE gate routing. Inheritance previous iqm.qiskit_iqm.qiskit_to_iqm.InstructionNotSupportedError next iqm.qiskit_iqm.transpiler_plugins.IQMDefaultSchedulingPlugin By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.serialize.map_operation",
    "url": "/iqm-client/api/iqm.cirq_iqm.serialize.map_operation.html",
    "description": "Map a Cirq Operation to the IQM data transfer format. Assumes the circuit has been transpiled so that it only contains operations natively supported by the\ngiven IQM quantum architecture. operation ( ...",
    "content": "Map a Cirq Operation to the IQM data transfer format. Assumes the circuit has been transpiled so that it only contains operations natively supported by the\ngiven IQM quantum architecture. operation ( Operation ) \u2013 a Cirq Operation the converted operation Instruction OperationNotSupportedError When the circuit contains an unsupported operation. \u2013 previous iqm.cirq_iqm.serialize.instruction_to_operation next iqm.cirq_iqm.serialize.serialize_circuit By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.devices",
    "url": "/iqm-client/api/iqm.cirq_iqm.devices.html",
    "description": "Definitions for various IQM quantum devices for the Cirq framework. Subpackages and modules adonis IQM's Adonis quantum architecture. aphrodite IQM's Aphrodite quantum architecture. apollo IQM's Apoll...",
    "content": "Definitions for various IQM quantum devices for the Cirq framework. Subpackages and modules adonis IQM's Adonis quantum architecture. aphrodite IQM's Aphrodite quantum architecture. apollo IQM's Apollo quantum architecture. iqm_device Describes IQM quantum architectures in the Cirq framework. iqm_device_metadata DeviceMetadata subtype for IQM devices. previous iqm.cirq_iqm next iqm.cirq_iqm.devices.adonis By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.devices.aphrodite.Aphrodite",
    "url": "/iqm-client/api/iqm.cirq_iqm.devices.aphrodite.Aphrodite.html",
    "description": "Bases: IQMDevice IQM\u2019s 54-qubit transmon device. The qubits are connected thus: where the lines denote which qubit pairs can be subject to two-qubit gates. Aphrodite has native PhasedXPowGate, XPowGat...",
    "content": "Bases: IQMDevice IQM\u2019s 54-qubit transmon device. The qubits are connected thus: where the lines denote which qubit pairs can be subject to two-qubit gates. Aphrodite has native PhasedXPowGate, XPowGate, and YPowGate gates. The two-qubit gate CZ is\nnative, as well. The qubits can be measured simultaneously or separately any number of times. Attributes Methods previous iqm.cirq_iqm.devices.aphrodite next iqm.cirq_iqm.devices.apollo By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.serialize",
    "url": "/iqm-client/api/iqm.cirq_iqm.serialize.html",
    "description": "Helper functions for serializing and deserializing quantum circuits between Cirq and IQM circuit formats. Functions deserialize_circuit (circuit) Deserializes a quantum circuit from the IQM data trans...",
    "content": "Helper functions for serializing and deserializing quantum circuits between Cirq and IQM circuit formats. Functions deserialize_circuit (circuit) Deserializes a quantum circuit from the IQM data transfer format to a Cirq Circuit. instruction_to_operation (instr) Convert an IQM instruction to a Cirq Operation. map_operation (operation) Map a Cirq Operation to the IQM data transfer format. serialize_circuit (circuit) Serializes a quantum circuit into the IQM data transfer format. Exceptions OperationNotSupportedError Raised when a given operation is not supported by the IQM server. previous iqm.cirq_iqm.optimizers.MergeOneParameterGroupGates next iqm.cirq_iqm.serialize.deserialize_circuit By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.JobParameters",
    "url": "/iqm-client/api/iqm.iqm_client.models.JobParameters.html",
    "description": "Bases: BaseModel Job-specific parameters extracted from the original RunRequest. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.confi...",
    "content": "Bases: BaseModel Job-specific parameters extracted from the original RunRequest. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. shots  max_circuit_duration_over_t2  heralding_mode  move_validation_mode  move_gate_frame_tracking_mode  dd_mode  dd_strategy  Methods shots ( int ) \u2013 max_circuit_duration_over_t2 ( float | None ) \u2013 heralding_mode ( HeraldingMode ) \u2013 move_validation_mode ( MoveGateValidationMode ) \u2013 move_gate_frame_tracking_mode ( MoveGateFrameTrackingMode ) \u2013 dd_mode ( DDMode ) \u2013 dd_strategy ( DDStrategy | None ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.iqm_client.models.Instruction next iqm.iqm_client.models.Metadata By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.CalibrationSet",
    "url": "/iqm-client/api/iqm.iqm_client.models.CalibrationSet.html",
    "description": "Bases: BaseModel Metadata and observations of a calibration set. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. c...",
    "content": "Bases: BaseModel Metadata and observations of a calibration set. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. calibration_set_id ID of the calibration set. calibration_set_dut_label Chip Label of the calibration set. calibration_set_is_invalid Whether the calibration set is invalid. calibration_set_created_timestamp Timestamp when the calibration set was created. calibration_set_end_timestamp Timestamp when the calibration set was finalized. observations Calibration data. Methods calibration_set_id ( UUID ) \u2013 calibration_set_dut_label ( str ) \u2013 calibration_set_is_invalid ( bool ) \u2013 calibration_set_created_timestamp ( str ) \u2013 calibration_set_end_timestamp ( str ) \u2013 observations ( dict [ str , Any ] ) \u2013 ID of the calibration set. Chip Label of the calibration set. Whether the calibration set is invalid. Timestamp when the calibration set was created. Timestamp when the calibration set was finalized. Calibration data. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.iqm_client.models.validate_circuit next iqm.iqm_client.models.Circuit By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingKeepExistingMovesPlugin",
    "url": "/iqm-client/api/iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingKeepExistingMovesPlugin.html",
    "description": "Bases: MoveGateRoutingPlugin Plugin class for single qubit gate optimization and MoveGate routing where existing moves are kept. Methods previous iqm.qiskit_iqm.transpiler_plugins.IQMSchedulingPlugin ...",
    "content": "Bases: MoveGateRoutingPlugin Plugin class for single qubit gate optimization and MoveGate routing where existing moves are kept. Methods previous iqm.qiskit_iqm.transpiler_plugins.IQMSchedulingPlugin next iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingOnlyKeepExistingMovesPlugin By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.Instruction",
    "url": "/iqm-client/api/iqm.iqm_client.models.Instruction.html",
    "description": "Bases: BaseModel Native quantum operation instance with particular arguments and locus. This class represents a native quantum operation\nacting on qubits , with the arguments args .\nThe operation is d...",
    "content": "Bases: BaseModel Native quantum operation instance with particular arguments and locus. This class represents a native quantum operation\nacting on qubits , with the arguments args .\nThe operation is determined by name . We currently support the following native operations: name # of qubits args description measure >= 1 key: str , feedback_key: str Measurement in the Z basis. prx 1 angle_t: float , phase_t: float Phased x-rotation gate. cc_prx 1 angle_t: float , phase_t: float , feedback_qubit: str , feedback_key: str Classically controlled PRX gate. reset >= 1 Reset the qubit(s) to \\(|0\\rangle\\) . cz 2 Controlled-Z gate. move 2 Move a qubit state between a qubit and a\ncomputational resonator, as long as\nat least one of the components is\nin the \\(|0\\rangle\\) state. barrier >= 1 Execution barrier. delay >= 1 duration: float Force a delay between circuit operations. For each Instruction you may also optionally specify implementation ,\nwhich contains the name of an implementation of the operation to use.\nSupport for multiple implementations is currently experimental and in normal use the\nfield should be omitted, this selects the default implementation for the operation for that locus. Measurement in the computational (Z) basis. The measurement results are the output of the circuit.\nTakes two string arguments: key , denoting the measurement key the returned results are labeled with,\nand feedback_key , which is only needed if the measurement result is used for classical control\nwithin the circuit.\nAll the measurement keys and feedback keys used in a circuit must be unique (but the two groups of\nkeys are independent namespaces).\nEach qubit may be measured multiple times, i.e. mid-circuit measurements are allowed. Phased x-rotation gate, i.e. an x-rotation conjugated by a z-rotation.\nTakes two arguments, the rotation angle angle_t and the phase angle phase_t ,\nboth measured in units of full turns ( \\(2\\pi\\) radians).\nThe gate is represented in the standard computational basis by the matrix where \\(\\theta\\) = angle_t , \\(\\phi\\) = phase_t ,\nand \\(X\\) and \\(Y\\) are Pauli matrices. Classically controlled PRX gate. Takes four arguments. angle_t and phase_t are exactly as in PRX. feedback_key is a string that identifies the measure instruction whose result controls\nthe gate (the one that shares the feedback key). feedback_qubit is the name of the physical qubit within the measure instruction that produces the feedback.\nIf the measurement result is 1, the PRX gate is applied. If it is 0, an identity gate of similar time\nduration gate is applied instead.\nThe measurement instruction must precede the classically controlled gate instruction in the quantum circuit. Resets the qubit(s) non-unitarily to the \\(|0\\rangle\\) state. Note Currently inherits its calibration from cc_prx and is only available when cc_prx is. Controlled-Z gate. Represented in the standard computational basis by the matrix It is symmetric wrt. the qubits it\u2019s acting on, and takes no arguments. The MOVE operation is a unitary population exchange operation between a qubit and a resonator.\nIts effect is only defined in the invariant subspace \\(S = \\text{span}\\{|00\\rangle, |01\\rangle, |10\\rangle\\}\\) ,\nwhere it swaps the populations of the states \\(|01\\rangle\\) and \\(|10\\rangle\\) .\nIts effect on the orthogonal subspace is undefined. MOVE has the following presentation in the subspace \\(S\\) : where \\(a\\) is an undefined complex phase that is canceled when the MOVE gate is applied a second time. To ensure that the state of the qubit and resonator has no overlap with \\(|11\\rangle\\) , it is\nrecommended that no single qubit gates are applied to the qubit in between a\npair of MOVE operations. Note MOVE is only available in quantum computers with the IQM Star architecture. Affects the physical execution order of the instructions elsewhere in the\ncircuit that act on qubits spanned by the barrier.\nIt ensures that any such instructions that succeed the barrier are only executed after\nall such instructions that precede the barrier have been completed.\nHence it can be used to guarantee a specific causal order for the other instructions.\nIt takes no arguments, and has no other effect. Note One-qubit barriers will not have any effect on circuit\u2019s compilation and execution. Higher layers\nthat sit on top of IQM Client can make actual use of one-qubit barriers (e.g. during circuit optimization),\ntherefore having them is allowed. Forces a delay between the preceding and following circuit operations.\nIt can be applied to any number of qubits. Takes one argument, duration , which is the minimum\nduration of the delay in seconds. It will be rounded up to the nearest possible duration the\nhardware can handle. Note We can only guarantee that the delay is at least of the requested duration, due to both\nhardware and practical constraints, but could be much more depending on the other operations\nin the circuit. To see why, consider e.g. the circuit In this case the actual delay between the two CZ gates will be 100 ns rounded up to\nhardware granularity, even though only 1 ns was requested for alice . Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name name of the quantum operation implementation name of the implementation, for experimental use only qubits names of the locus components (typically qubits) the operation acts on args arguments for the operation Methods args_validator (value,\u00a0info) Check argument names and types for a given instruction implementation_validator (value) Check if the implementation of the instruction is set to a non-empty string. name_validator (value) Check if the name of instruction is set to one of the supported quantum operations. qubits_validator (value,\u00a0info) Check if the instruction has the correct number of qubits for its operation. name of the implementation, for experimental use only names of the locus components (typically qubits) the operation acts on arguments for the operation name of the quantum operation Check if the name of instruction is set to one of the supported quantum operations. Check if the implementation of the instruction is set to a non-empty string. Check if the instruction has the correct number of qubits for its operation. info ( ValidationInfo ) \u2013 Check argument names and types for a given instruction info ( ValidationInfo ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. name ( str ) \u2013 implementation ( str | None ) \u2013 qubits ( tuple [ str , ... ] ) \u2013 args ( dict [ str , Any ] ) \u2013 previous iqm.iqm_client.models.HeraldingMode next iqm.iqm_client.models.JobParameters By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.fake_backends.fake_apollo.IQMFakeApollo",
    "url": "/iqm-client/api/iqm.qiskit_iqm.fake_backends.fake_apollo.IQMFakeApollo.html",
    "description": "Return IQMFakeBackend instance representing IQM\u2019s Apollo architecture. IQMFakeBackend previous iqm.qiskit_iqm.fake_backends.fake_apollo next iqm.qiskit_iqm.fake_backends.fake_deneb By IQM client devel...",
    "content": "Return IQMFakeBackend instance representing IQM\u2019s Apollo architecture. IQMFakeBackend previous iqm.qiskit_iqm.fake_backends.fake_apollo next iqm.qiskit_iqm.fake_backends.fake_deneb By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.move_gate.MoveGate",
    "url": "/iqm-client/api/iqm.qiskit_iqm.move_gate.MoveGate.html",
    "description": "Bases: Gate The MOVE operation is a unitary population exchange operation between a qubit and a resonator.\nIts effect is only defined in the invariant subspace \\(S = \\text{span}\\{|00\\rangle, |01\\rangl...",
    "content": "Bases: Gate The MOVE operation is a unitary population exchange operation between a qubit and a resonator.\nIts effect is only defined in the invariant subspace \\(S = \\text{span}\\{|00\\rangle, |01\\rangle, |10\\rangle\\}\\) ,\nwhere it swaps the populations of the states \\(|01\\rangle\\) and \\(|10\\rangle\\) .\nIts effect on the orthogonal subspace is undefined. MOVE has the following presentation in the subspace \\(S\\) : where \\(a\\) is an undefined complex phase that is canceled when the MOVE gate is applied a second time. To ensure that the state of the qubit and resonator has no overlap with \\(|11\\rangle\\) , it is\nrecommended that no single qubit gates are applied to the qubit in between a\npair of MOVE operations. Note The MOVE gate must always be be applied on the qubit and the resonator in the\norder [qubit, resonator] , regardless of which component is currently holding the state. Attributes Methods _define () This function is purposefully not defined so that that the Qiskit transpiler cannot accidentally decompose the MOVE gate into a sequence of other gates, instead it will throw an error. previous iqm.qiskit_iqm.move_gate.MOVE_GATE_UNITARY next iqm.qiskit_iqm.qiskit_to_iqm By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.devices.iqm_device",
    "url": "/iqm-client/api/iqm.cirq_iqm.devices.iqm_device.html",
    "description": "Describes IQM quantum architectures in the Cirq framework. The description includes the qubit connectivity, the native gate set, and the gate decompositions\nto use with the architecture. Classes IQMDe...",
    "content": "Describes IQM quantum architectures in the Cirq framework. The description includes the qubit connectivity, the native gate set, and the gate decompositions\nto use with the architecture. Classes IQMDevice (metadata) ABC for the properties of a specific IQM quantum architecture. Inheritance previous iqm.cirq_iqm.devices.apollo.Apollo next iqm.cirq_iqm.devices.iqm_device.IQMDevice By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.errors.CircuitExecutionError",
    "url": "/iqm-client/api/iqm.iqm_client.errors.CircuitExecutionError.html",
    "description": "Something went wrong on the server. previous iqm.iqm_client.errors.APITimeoutError next iqm.iqm_client.errors.CircuitTranspilationError By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, ...",
    "content": "Something went wrong on the server. previous iqm.iqm_client.errors.APITimeoutError next iqm.iqm_client.errors.CircuitTranspilationError By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.qiskit_to_iqm.serialize_instructions",
    "url": "/iqm-client/api/iqm.qiskit_iqm.qiskit_to_iqm.serialize_instructions.html",
    "description": "Serialize a quantum circuit into the IQM data transfer format. This is IQM\u2019s internal helper for IQMBackend.serialize_circuit() that gives slightly more control.\nSee IQMBackend.serialize_circuit() for...",
    "content": "Serialize a quantum circuit into the IQM data transfer format. This is IQM\u2019s internal helper for IQMBackend.serialize_circuit() that gives slightly more control.\nSee IQMBackend.serialize_circuit() for details. circuit ( QuantumCircuit ) \u2013 quantum circuit to serialize qubit_index_to_name ( dict [ int , str ] ) \u2013 Mapping from qubit indices to the corresponding qubit names. allowed_nonnative_gates ( Collection [ str ] ) \u2013 Names of gates that are converted as-is without validation.\nBy default, any gate that can\u2019t be converted will raise an error.\nIf such gates are present in the circuit, the caller must edit the result to be valid and executable.\nNotably, since IQM transfer format requires named parameters and qiskit parameters don\u2019t have names, the i th parameter of an unrecognized instruction is given the name \"p<i>\" . list of instructions representing the circuit ValueError \u2013 circuit contains an unsupported instruction or is not transpiled in general list [ Instruction ] previous iqm.qiskit_iqm.qiskit_to_iqm.deserialize_instructions next iqm.qiskit_iqm.qiskit_to_iqm.MeasurementKey By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.serialize.instruction_to_operation",
    "url": "/iqm-client/api/iqm.cirq_iqm.serialize.instruction_to_operation.html",
    "description": "Convert an IQM instruction to a Cirq Operation. instr ( Instruction ) \u2013 the IQM instruction the converted operation Operation OperationNotSupportedError When the circuit contains an unsupported operat...",
    "content": "Convert an IQM instruction to a Cirq Operation. instr ( Instruction ) \u2013 the IQM instruction the converted operation Operation OperationNotSupportedError When the circuit contains an unsupported operation. \u2013 previous iqm.cirq_iqm.serialize.deserialize_circuit next iqm.cirq_iqm.serialize.map_operation By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.cli.ResolvedPath",
    "url": "/iqm-client/api/iqm.iqm_client.cli.cli.ResolvedPath.html",
    "description": "Bases: Path A click parameter type for a resolved path.\nNormal click.Path(resolve_path=True) fails under Windows running python <= 3.9.\nSee pallets/click#2466 Attributes name the descriptive name of t...",
    "content": "Bases: Path A click parameter type for a resolved path.\nNormal click.Path(resolve_path=True) fails under Windows running python <= 3.9.\nSee pallets/click#2466 Attributes name the descriptive name of this type Methods convert (value,\u00a0param,\u00a0ctx) Convert the value to the correct type. Convert the value to the correct type. This is not called if\nthe value is None (the missing value). This must accept string values from the command line, as well as\nvalues that are already the correct type. It may also convert\nother compatible types. The param and ctx arguments may be None in certain\nsituations, such as when converting prompt input. If the value cannot be converted, call fail() with a\ndescriptive message. value ( Any ) \u2013 The value to convert. param ( Parameter | None ) \u2013 The parameter that is using this type to convert\nits value. May be None . ctx ( Context | None ) \u2013 The current context that arrived at this value. May\nbe None . Any previous iqm.iqm_client.cli.cli.IQMClientCliCommand next iqm.iqm_client.cli.models By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.RunStatus",
    "url": "/iqm-client/api/iqm.iqm_client.models.RunStatus.html",
    "description": "Bases: BaseModel Status of a circuit execution job. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. status current...",
    "content": "Bases: BaseModel Status of a circuit execution job. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. status current status of the job, in {'pending_compilation', 'pending_execution', 'ready', 'failed', 'aborted'} message if the job failed, an error message warnings list of warning messages Methods status ( Status ) \u2013 message ( str | None ) \u2013 warnings ( list [ str ] | None ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. current status of the job, in {'pending_compilation', 'pending_execution', 'ready', 'failed', 'aborted'} if the job failed, an error message list of warning messages previous iqm.iqm_client.models.RunResult next iqm.iqm_client.models.SingleQubitMapping By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.errors.APITimeoutError",
    "url": "/iqm-client/api/iqm.iqm_client.errors.APITimeoutError.html",
    "description": "Executing a job on the server took too long. previous iqm.iqm_client.errors next iqm.iqm_client.errors.CircuitExecutionError By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29....",
    "content": "Executing a job on the server took too long. previous iqm.iqm_client.errors next iqm.iqm_client.errors.CircuitExecutionError By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.validation.validate_qubit_mapping",
    "url": "/iqm-client/api/iqm.iqm_client.validation.validate_qubit_mapping.html",
    "description": "Validate the given qubit mapping. architecture ( DynamicQuantumArchitecture ) \u2013 Quantum architecture to check against. circuits ( list [ Circuit ] ) \u2013 Circuits to be checked. qubit_mapping ( dict [ st...",
    "content": "Validate the given qubit mapping. architecture ( DynamicQuantumArchitecture ) \u2013 Quantum architecture to check against. circuits ( list [ Circuit ] ) \u2013 Circuits to be checked. qubit_mapping ( dict [ str , str ] | None ) \u2013 Mapping of logical qubit names to physical qubit names.\nCan be set to None if all circuits already use physical qubit names.\nNote that the qubit_mapping is used for all circuits . CircuitValidationError \u2013 There was something wrong with circuits . None previous iqm.iqm_client.validation.validate_instruction next iqm.qiskit_iqm By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.iqm_sampler.ResultMetadata",
    "url": "/iqm-client/api/iqm.cirq_iqm.iqm_sampler.ResultMetadata.html",
    "description": "Bases: object Metadata for an IQM execution result. job_id ( UUID ) \u2013 calibration_set_id ( UUID | None ) \u2013 request ( RunRequest ) \u2013 ID of the computational job. uuid.UUID Calibration set used for this...",
    "content": "Bases: object Metadata for an IQM execution result. job_id ( UUID ) \u2013 calibration_set_id ( UUID | None ) \u2013 request ( RunRequest ) \u2013 ID of the computational job. uuid.UUID Calibration set used for this IQMResult . uuid.UUID | None Request made to run the job. iqm.iqm_client.models.RunRequest Attributes job_id  calibration_set_id  request  Methods __eq__ (other) Return self==value. __repr__ () Return repr(self). previous iqm.cirq_iqm.iqm_sampler.IQMSampler next iqm.cirq_iqm.optimizers By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.iqm_naive_move_pass.IQMNaiveResonatorMoving",
    "url": "/iqm-client/api/iqm.qiskit_iqm.iqm_naive_move_pass.IQMNaiveResonatorMoving.html",
    "description": "Bases: TransformationPass Naive transpilation pass for resonator moving. The logic of this pass is deferred to iqm-client.transpile_insert_moves .\nThis pass is a wrapper that converts the circuit into...",
    "content": "Bases: TransformationPass Naive transpilation pass for resonator moving. The logic of this pass is deferred to iqm-client.transpile_insert_moves .\nThis pass is a wrapper that converts the circuit into the IQMClient Circuit format,\nruns the transpile_insert_moves function, and then converts the result back to a Qiskit circuit. target \u2013 Transpilation target. existing_moves_handling \u2013 How to handle existing MOVE gates in the circuit. Attributes Methods run (dag) Run the pass on a circuit. Run the pass on a circuit. dag ( DAGCircuit ) \u2013 DAG to map. Mapped dag . TranspilerError \u2013 The layout is not compatible with the DAG, or if the input gate set is incorrect. DAGCircuit previous iqm.qiskit_iqm.iqm_naive_move_pass.transpile_to_IQM next iqm.qiskit_iqm.iqm_provider By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.qiskit_to_iqm.MeasurementKey",
    "url": "/iqm-client/api/iqm.qiskit_iqm.qiskit_to_iqm.MeasurementKey.html",
    "description": "Bases: object Unique key associated with a measurement instruction. Qiskit stores the results of quantum measurements in classical registers consisting of bits.\nThe circuit execution results are prese...",
    "content": "Bases: object Unique key associated with a measurement instruction. Qiskit stores the results of quantum measurements in classical registers consisting of bits.\nThe circuit execution results are presented as bitstrings of a certain structure so that the classical\nregister and the index within that register for each bit is implied from its position in the bitstring. For example, if you have two classical registers in the circuit with lengths 3 and 2, then the\nmeasurement results will look like \u201801 101\u2019 if the classical register of length 3 was added to\nthe circuit first, and \u2018101 01\u2019 otherwise. If a bit in a classical register is not used in any\nmeasurement operation it will still show up in the results with the default value of \u20180\u2019. To be able to handle measurement results in a Qiskit-friendly way, we need to keep around some\ninformation about how the circuit was constructed. This can, for example, be achieved by keeping\naround the original Qiskit quantum circuit and using it when constructing the results in IQMJob . This should be done so that the circuit is saved on the server side and not in IQMJob , since otherwise users will not be able to retrieve results from a detached Python\nenvironment solely based on the job id. Another option is to use measurement key strings to\nstore the required info. Qiskit does not use measurement keys, so we are free to use them\ninternally in the communication with the IQM server, and can encode the necessary information in\nthem. This class encapsulates the necessary info, and provides methods to transform between this\nrepresentation and the measurement key string representation. creg_name ( str ) \u2013 name of the classical register creg_len ( int ) \u2013 number of bits in the classical register creg_idx ( int ) \u2013 Index of the classical register in the circuit. Determines the order in which this register was added\nto the circuit relative to the others. clbit_idx ( int ) \u2013 index of the classical bit within the classical register Attributes creg_name  creg_len  creg_idx  clbit_idx  Methods __delattr__ (name) Implement delattr(self, name). __eq__ (other) Return self==value. __hash__ () Return hash(self). __repr__ () Return repr(self). __setattr__ (name,\u00a0value) Implement setattr(self, name, value). __str__ () Return str(self). from_clbit (clbit,\u00a0circuit) Create a MeasurementKey for a classical bit in a quantum circuit. from_string (string) Create a MeasurementKey from its string representation. Create a MeasurementKey from its string representation. string ( str ) \u2013 MeasurementKey Create a MeasurementKey for a classical bit in a quantum circuit. clbit ( Clbit ) \u2013 circuit ( QuantumCircuit ) \u2013 MeasurementKey previous iqm.qiskit_iqm.qiskit_to_iqm.serialize_instructions next iqm.qiskit_iqm.qiskit_to_iqm.InstructionNotSupportedError By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.api",
    "url": "/iqm-client/api/iqm.iqm_client.api.html",
    "description": "This module contains definitions of IQM Server API endpoints. Classes APIConfig (station_control_url) Provides supported API endpoints for a given API variant. APIEndpoint (value[,\u00a0names,\u00a0module,\u00a0...]...",
    "content": "This module contains definitions of IQM Server API endpoints. Classes APIConfig (station_control_url) Provides supported API endpoints for a given API variant. APIEndpoint (value[,\u00a0names,\u00a0module,\u00a0...]) Supported API endpoints. Inheritance previous iqm.iqm_client next iqm.iqm_client.api.APIConfig By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.validation",
    "url": "/iqm-client/api/iqm.iqm_client.validation.html",
    "description": "Validation related helper functions for IQMClient. Functions validate_circuit_instructions (architecture,\u00a0...) Validate the given circuits against the given quantum architecture. validate_circuit_move...",
    "content": "Validation related helper functions for IQMClient. Functions validate_circuit_instructions (architecture,\u00a0...) Validate the given circuits against the given quantum architecture. validate_circuit_moves (architecture,\u00a0circuit) Raise an error if the MOVE gates in the circuit are not valid in the given architecture. validate_instruction (architecture,\u00a0instruction) Validate an instruction against the dynamic quantum architecture. validate_qubit_mapping (architecture,\u00a0circuits) Validate the given qubit mapping. previous iqm.iqm_client.util.IQMJSONEncoder next iqm.iqm_client.validation.validate_circuit_instructions By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.DDMode",
    "url": "/iqm-client/api/iqm.iqm_client.models.DDMode.html",
    "description": "Bases: str , Enum Dynamical Decoupling (DD) mode for circuit execution. Attributes DISABLED Do not apply dynamical decoupling. ENABLED Apply dynamical decoupling. Methods _generate_next_value_ (start,...",
    "content": "Bases: str , Enum Dynamical Decoupling (DD) mode for circuit execution. Attributes DISABLED Do not apply dynamical decoupling. ENABLED Apply dynamical decoupling. Methods _generate_next_value_ (start,\u00a0count,\u00a0last_values) Generate the next value when not given. _new_member_ (**kwargs) Create and return a new object. _value_repr_ () Return repr(self). __format__ (format_spec) Return a formatted version of the string as described by format_spec. __new__ (value)  __repr__ () Return repr(self). __str__ () Return str(self). Do not apply dynamical decoupling. Apply dynamical decoupling. previous iqm.iqm_client.models.Counts next iqm.iqm_client.models.DDStrategy By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.transpiler_plugins.OnlyRZOptimizationExactIgnoreBarriersPlugin",
    "url": "/iqm-client/api/iqm.qiskit_iqm.transpiler_plugins.OnlyRZOptimizationExactIgnoreBarriersPlugin.html",
    "description": "Bases: OnlyRZOptimizationPlugin Plugin class for single qubit gate optimization without MOVE gate routing and\nthe final RZ gates are not dropped. Methods previous iqm.qiskit_iqm.transpiler_plugins.Mov...",
    "content": "Bases: OnlyRZOptimizationPlugin Plugin class for single qubit gate optimization without MOVE gate routing and\nthe final RZ gates are not dropped. Methods previous iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingWithRZOptimizationIgnoreBarriersPlugin next iqm.qiskit_iqm.transpiler_plugins.OnlyRZOptimizationExactPlugin By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.fake_backends.fake_deneb.IQMFakeDeneb",
    "url": "/iqm-client/api/iqm.qiskit_iqm.fake_backends.fake_deneb.IQMFakeDeneb.html",
    "description": "Return IQMFakeBackend instance representing IQM\u2019s Deneb architecture. IQMFakeBackend previous iqm.qiskit_iqm.fake_backends.fake_deneb next iqm.qiskit_iqm.fake_backends.fake_garnet By IQM client develo...",
    "content": "Return IQMFakeBackend instance representing IQM\u2019s Deneb architecture. IQMFakeBackend previous iqm.qiskit_iqm.fake_backends.fake_deneb next iqm.qiskit_iqm.fake_backends.fake_garnet By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.iqm_circuit_validation.validate_circuit",
    "url": "/iqm-client/api/iqm.qiskit_iqm.iqm_circuit_validation.validate_circuit.html",
    "description": "Validate a circuit against the backend. circuit ( QuantumCircuit ) \u2013 backend ( IQMBackendBase ) \u2013 validate_moves ( MoveGateValidationMode | None ) \u2013 qubit_mapping ( dict [ int , str ] | None ) \u2013 previ...",
    "content": "Validate a circuit against the backend. circuit ( QuantumCircuit ) \u2013 backend ( IQMBackendBase ) \u2013 validate_moves ( MoveGateValidationMode | None ) \u2013 qubit_mapping ( dict [ int , str ] | None ) \u2013 previous iqm.qiskit_iqm.iqm_circuit_validation next iqm.qiskit_iqm.iqm_job By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingOnlyRemoveExistingMovesPlugin",
    "url": "/iqm-client/api/iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingOnlyRemoveExistingMovesPlugin.html",
    "description": "Bases: MoveGateRoutingPlugin Plugin class for MoveGate routing without single qubit gate optimization\nwhere existing moves are removed. Methods previous iqm.qiskit_iqm.transpiler_plugins.MoveGateRouti...",
    "content": "Bases: MoveGateRoutingPlugin Plugin class for MoveGate routing without single qubit gate optimization\nwhere existing moves are removed. Methods previous iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingOnlyPlugin next iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingOnlyTrustExistingMovesPlugin By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.transpile.simplify_architecture",
    "url": "/iqm-client/api/iqm.iqm_client.transpile.simplify_architecture.html",
    "description": "Converts the given IQM Star quantum architecture into the equivalent simplified quantum architecture. See iqm.iqm_client.transpile for the details. Adds fictional gates, abstracts away their gate impl...",
    "content": "Converts the given IQM Star quantum architecture into the equivalent simplified quantum architecture. See iqm.iqm_client.transpile for the details. Adds fictional gates, abstracts away their gate implementations.\nReturns arch itself if it does not contain computational resonators (in which case nothing will change). arch ( DynamicQuantumArchitecture ) \u2013 quantum architecture to convert remove_resonators ( bool ) \u2013 iff False, return the union of the simplified and real architectures equivalent quantum architecture with fictional gates DynamicQuantumArchitecture previous iqm.iqm_client.transpile.Resolution next iqm.iqm_client.transpile.transpile_insert_moves By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client",
    "url": "/iqm-client/api/iqm.iqm_client.html",
    "description": "Client-side library for connecting to and executing quantum circuits on IQM quantum computers. Subpackages and modules api This module contains definitions of IQM Server API endpoints. authentication ...",
    "content": "Client-side library for connecting to and executing quantum circuits on IQM quantum computers. Subpackages and modules api This module contains definitions of IQM Server API endpoints. authentication This module contains user authentication related classes and functions required by IQMClient. cli Command-line interface (CLI) for managing user authentication when using IQM quantum computers. errors This module contains error classes required by IQMClient. iqm_client Client for connecting to the IQM quantum computer server interface. models This module contains the data models used by IQMClient. transpile Transpiling circuits to IQM devices involving computational resonators. util Helpful utilities that can be used together with IQMClient. validation Validation related helper functions for IQMClient. previous iqm.cirq_iqm.transpiler.transpile_insert_moves_into_circuit next iqm.iqm_client.api By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.auth.GrantType",
    "url": "/iqm-client/api/iqm.iqm_client.cli.auth.GrantType.html",
    "description": "Bases: str , Enum Type of token request. Attributes PASSWORD  REFRESH  Methods _generate_next_value_ (start,\u00a0count,\u00a0last_values) Generate the next value when not given. _new_member_ (**kwargs) Create ...",
    "content": "Bases: str , Enum Type of token request. Attributes PASSWORD  REFRESH  Methods _generate_next_value_ (start,\u00a0count,\u00a0last_values) Generate the next value when not given. _new_member_ (**kwargs) Create and return a new object. _value_repr_ () Return repr(self). __format__ (format_spec) Return a formatted version of the string as described by format_spec. __new__ (value)  __repr__ () Return repr(self). __str__ () Return str(self). previous iqm.iqm_client.cli.auth.AuthRequest next iqm.iqm_client.cli.auth.ClientAccountSetupError By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.examples.transpile_example",
    "url": "/iqm-client/api/iqm.qiskit_iqm.examples.transpile_example.html",
    "description": "This file is an example of using Qiskit on IQM to run a simple but non-trivial quantum circuit on an IQM quantum\ncomputer. See the Qiskit on IQM user guide for instructions: https://docs.meetiqm.com/i...",
    "content": "This file is an example of using Qiskit on IQM to run a simple but non-trivial quantum circuit on an IQM quantum\ncomputer. See the Qiskit on IQM user guide for instructions: https://docs.meetiqm.com/iqm-client/user_guide_qiskit.html Functions transpile_example (server_url) Run a GHZ circuit transpiled using the Qiskit transpile function. previous iqm.qiskit_iqm.examples.resonance_example.resonance_example next iqm.qiskit_iqm.examples.transpile_example.transpile_example By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.authentication.TokenProviderInterface",
    "url": "/iqm-client/api/iqm.iqm_client.authentication.TokenProviderInterface.html",
    "description": "Bases: ABC Interface to token provider Methods close () Closes authentication session. get_token () Returns a valid access token. Returns a valid access token. ClientAuthenticationError \u2013 acquiring th...",
    "content": "Bases: ABC Interface to token provider Methods close () Closes authentication session. get_token () Returns a valid access token. Returns a valid access token. ClientAuthenticationError \u2013 acquiring the token failed str Closes authentication session. ClientAuthenticationError \u2013 closing the session failed None previous iqm.iqm_client.authentication.TokenManager next iqm.iqm_client.authentication.TokensFileReader By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.authentication",
    "url": "/iqm-client/api/iqm.iqm_client.authentication.html",
    "description": "This module contains user authentication related classes and functions required by IQMClient. Classes ExternalToken (token) Holds an external token TokenClient (auth_server_url,\u00a0realm,\u00a0...) Requests n...",
    "content": "This module contains user authentication related classes and functions required by IQMClient. Classes ExternalToken (token) Holds an external token TokenClient (auth_server_url,\u00a0realm,\u00a0...) Requests new token from an authentication server TokenManager ([token,\u00a0tokens_file,\u00a0...]) TokenManager manages the access token required for user authentication. TokenProviderInterface () Interface to token provider TokensFileReader (tokens_file) Reads token from a file Inheritance previous iqm.iqm_client.api.APIEndpoint next iqm.iqm_client.authentication.ExternalToken By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.transpiler_plugins.OnlyRZOptimizationExactPlugin",
    "url": "/iqm-client/api/iqm.qiskit_iqm.transpiler_plugins.OnlyRZOptimizationExactPlugin.html",
    "description": "Bases: OnlyRZOptimizationPlugin Plugin class for single qubit gate optimization without MOVE gate routing and\nthe final RZ gates are not dropped. Methods previous iqm.qiskit_iqm.transpiler_plugins.Onl...",
    "content": "Bases: OnlyRZOptimizationPlugin Plugin class for single qubit gate optimization without MOVE gate routing and\nthe final RZ gates are not dropped. Methods previous iqm.qiskit_iqm.transpiler_plugins.OnlyRZOptimizationExactIgnoreBarriersPlugin next iqm.qiskit_iqm.transpiler_plugins.OnlyRZOptimizationIgnoreBarriersPlugin By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.auth.logout_request",
    "url": "/iqm-client/api/iqm.iqm_client.cli.auth.logout_request.html",
    "description": "Sends logout request to the authentication server. ClientAuthenticationError \u2013 updating the tokens failed True if logout was successful url ( str ) \u2013 realm ( str ) \u2013 client_id ( str ) \u2013 refresh_token ...",
    "content": "Sends logout request to the authentication server. ClientAuthenticationError \u2013 updating the tokens failed True if logout was successful url ( str ) \u2013 realm ( str ) \u2013 client_id ( str ) \u2013 refresh_token ( str ) \u2013 bool previous iqm.iqm_client.cli.auth.login_request next iqm.iqm_client.cli.auth.refresh_request By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.iqm_provider.IQMBackend",
    "url": "/iqm-client/api/iqm.qiskit_iqm.iqm_provider.IQMBackend.html",
    "description": "Bases: IQMBackendBase Backend for executing quantum circuits on IQM quantum computers. client ( IQMClient ) \u2013 client instance for communicating with an IQM server calibration_set_id ( str | UUID | Non...",
    "content": "Bases: IQMBackendBase Backend for executing quantum circuits on IQM quantum computers. client ( IQMClient ) \u2013 client instance for communicating with an IQM server calibration_set_id ( str | UUID | None ) \u2013 ID of the calibration set the backend will use. None means the IQM server will be queried for the current default\ncalibration set. kwargs \u2013 optional arguments to be passed to the parent Backend initializer Attributes max_circuits Maximum number of circuits that should be run in a single batch. architecture Dynamic quantum architecture of the backend instance. name Name of the backend. description Optional human-readable description. online_date Date that the backend came online. backend_version Version of the backend being provided. Methods _default_options () Qiskit method for defining the default options for running the backend. close_client () Close IQMClient's session with the authentication server. create_run_request (run_input[,\u00a0shots,\u00a0...]) Creates a run request without submitting it for execution. retrieve_job (job_id) Create and return an IQMJob instance associated with this backend with given job id. run (run_input,\u00a0**options) Run a quantum circuit or a list of quantum circuits on the IQM quantum computer represented by this backend. serialize_circuit (circuit[,\u00a0qubit_mapping]) Serialize a quantum circuit into the IQM data transfer format. Maximum number of circuits that should be run in a single batch. Currently there is no hard limit on the number of circuits that can be executed in a single batch/job.\nHowever, some libraries like Qiskit Experiments use this property to split multi-circuit computational\ntasks into multiple baches/jobs. The default value is None , meaning there is no limit. You can set it to a specific integer\nvalue to force these libraries to run at most that many circuits in a single batch. Run a quantum circuit or a list of quantum circuits on the IQM quantum computer represented by this backend. run_input ( QuantumCircuit | list [ QuantumCircuit ] ) \u2013 The circuits to run. options \u2013 Keyword arguments passed on to create_run_request() , and documented there. Job object from which the results can be obtained once the execution has finished. IQMJob Creates a run request without submitting it for execution. This can be used to check what would be submitted for execution by an equivalent call to run() . run_input ( QuantumCircuit | list [ QuantumCircuit ] ) \u2013 Same as in run() . shots ( int ) \u2013 Number of repetitions of each circuit, for sampling. circuit_compilation_options ( CircuitCompilationOptions | None ) \u2013 Compilation options for the circuits, passed on to IQMClient .\nIf None , the defaults of the CircuitCompilationOptions class are used. circuit_callback ( Callable [ [ list [ QuantumCircuit ] ] , Any ] | None ) \u2013 Callback function that, if provided, will be called for the circuits before sending\nthem to the device.  This may be useful in situations when you do not have explicit\ncontrol over transpilation, but need some information on how it was done. This can\nhappen, for example, when you use pre-implemented algorithms and experiments in\nQiskit, where the implementation of the said algorithm or experiment takes care of\ndelivering correctly transpiled circuits to the backend. This callback method gives\nyou a chance to look into those transpiled circuits, and extract any info you need.\nAs a side effect, you can also use this callback to modify the transpiled circuits\nin-place, just before execution; however, we do not recommend to use it for this\npurpose. qubit_mapping ( dict [ int , str ] | None ) \u2013 Mapping from qubit indices in the circuit to qubit names on the device. If None , IQMBackendBase.index_to_qubit_name will be used. The created run request object RunRequest Create and return an IQMJob instance associated with this backend with given job id. job_id ( str ) \u2013 ID of the job to retrieve. corresponding job IQMJob Close IQMClient\u2019s session with the authentication server. None Serialize a quantum circuit into the IQM data transfer format. Serializing is not strictly bound to the native gateset, i.e. some gates that are not explicitly mentioned in\nthe native gateset of the backend can still be serialized. For example, the native single qubit gate for IQM\nbackend is the \u2018r\u2019 gate, however \u2018x\u2019, \u2018rx\u2019, \u2018y\u2019 and \u2018ry\u2019 gates can also be serialized since they are just\nparticular cases of the \u2018r\u2019 gate. If the circuit was transpiled against a backend using Qiskit\u2019s transpiler\nmachinery, these gates are not supposed to be present. However, when constructing circuits manually and\nsubmitting directly to the backend, it is sometimes more explicit and understandable to use these concrete\ngates rather than \u2018r\u2019. Serializing them explicitly makes it possible for the backend to accept such circuits. Qiskit uses one measurement instruction per qubit (i.e. there is no measurement grouping concept). While\nserializing we do not group any measurements together but rather associate a unique measurement key with each\nmeasurement instruction, so that the results can later be reconstructed correctly (see MeasurementKey documentation for more details). circuit ( QuantumCircuit ) \u2013 quantum circuit to serialize qubit_mapping ( dict [ int , str ] | None ) \u2013 Mapping from qubit indices in the circuit to qubit names on the device. If not provided, IQMBackendBase.index_to_qubit_name will be used. data transfer object representing the circuit ValueError \u2013 circuit contains an unsupported instruction or is not transpiled in general Circuit previous iqm.qiskit_iqm.iqm_provider next iqm.qiskit_iqm.iqm_provider.IQMFacadeBackend By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.RunRequest",
    "url": "/iqm-client/api/iqm.iqm_client.models.RunRequest.html",
    "description": "Bases: BaseModel Request for an IQM quantum computer to run a job that executes a batch of quantum circuits. Note: all circuits in a batch must measure the same qubits otherwise batch execution fails....",
    "content": "Bases: BaseModel Request for an IQM quantum computer to run a job that executes a batch of quantum circuits. Note: all circuits in a batch must measure the same qubits otherwise batch execution fails. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. circuits batch of quantum circuit(s) to execute custom_settings Custom settings to override default IQM hardware settings and calibration data. calibration_set_id ID of the calibration set to use, or None to use the latest calibration set qubit_mapping mapping of logical qubit names to physical qubit names, or None if using physical qubit names shots how many times to execute each circuit in the batch, must be greater than zero max_circuit_duration_over_t2 Circuits are disqualified on the server if they are longer than this ratio of the T2 time of the qubits. heralding_mode which heralding mode to use during the execution of circuits in this request. move_validation_mode Which method of MOVE gate validation to use for circuit compilation. move_gate_frame_tracking_mode Which method of MOVE gate frame tracking to use for circuit compilation. active_reset_cycles Number of active reset operations inserted at the beginning of each circuit for each active qubit. dd_mode Control whether dynamical decoupling should be enabled or disabled during the execution. dd_strategy A particular dynamical decoupling strategy to be used during the execution. Methods circuits ( list [ Circuit ] ) \u2013 custom_settings ( dict [ str , Any ] | None ) \u2013 calibration_set_id ( UUID | None ) \u2013 qubit_mapping ( list [ SingleQubitMapping ] | None ) \u2013 shots ( int ) \u2013 max_circuit_duration_over_t2 ( float | None ) \u2013 heralding_mode ( HeraldingMode ) \u2013 move_validation_mode ( MoveGateValidationMode ) \u2013 move_gate_frame_tracking_mode ( MoveGateFrameTrackingMode ) \u2013 active_reset_cycles ( int | None ) \u2013 dd_mode ( DDMode ) \u2013 dd_strategy ( DDStrategy | None ) \u2013 batch of quantum circuit(s) to execute Custom settings to override default IQM hardware settings and calibration data.\nNote: This field should be always None in normal use. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. ID of the calibration set to use, or None to use the latest calibration set mapping of logical qubit names to physical qubit names, or None if using physical qubit names how many times to execute each circuit in the batch, must be greater than zero Circuits are disqualified on the server if they are longer than this ratio\nof the T2 time of the qubits.\nIf set to 0.0, no circuits are disqualified. If set to None the server default value is used. which heralding mode to use during the execution of circuits in this request. Which method of MOVE gate validation to use for circuit compilation. Which method of MOVE gate frame tracking to use for circuit compilation. Number of active reset operations inserted at the beginning of each circuit for each active qubit. None means active reset is not used but instead reset is done by waiting (relaxation). Integer values smaller\nthan 1 result in neither active nor reset by wait being used, in which case any reset operations must be explicitly\nadded in the circuit. Control whether dynamical decoupling should be enabled or disabled during the execution. A particular dynamical decoupling strategy to be used during the execution. previous iqm.iqm_client.models.RunCounts next iqm.iqm_client.models.RunResult By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.devices.iqm_device.IQMDevice",
    "url": "/iqm-client/api/iqm.cirq_iqm.devices.iqm_device.IQMDevice.html",
    "description": "Bases: Device ABC for the properties of a specific IQM quantum architecture. Adds extra functionality on top of the basic cirq.Device class for decomposing gates,\noptimizing circuits and mapping qubit...",
    "content": "Bases: Device ABC for the properties of a specific IQM quantum architecture. Adds extra functionality on top of the basic cirq.Device class for decomposing gates,\noptimizing circuits and mapping qubits. metadata ( IQMDeviceMetadata ) \u2013 device metadata which contains the qubits, their connectivity, and the native gateset Attributes metadata Returns metadata for the device. Methods __eq__ (other) Return self==value. check_qubit_connectivity (operation) Raises a ValueError if operation acts on qubits that are not connected. decompose_circuit (circuit) Decomposes the given circuit to the native gate set of the device. decompose_operation (operation) Decompose a single quantum operation into the native operation set. get_qubit (index) The device qubit corresponding to the given numeric index. get_qubit_index (qubit) The numeric index of the given qubit on the device. has_valid_operation_targets (op) Predicate, True iff the given operation is native and its targets are valid. is_native_operation (op) Predicate, True iff the given operation is considered native for the architecture. operation_decomposer (op) Decomposes operations into the native operation set. route_circuit (circuit,\u00a0*[,\u00a0initial_mapper,\u00a0...]) Routes the given circuit to the device connectivity and qubit names. validate_circuit (circuit) Raises an exception if a circuit is not valid. validate_move (operation) Validates whether the IQMMoveGate is between qubit and resonator registers. validate_moves (circuit) Validates whether the IQMMoveGates are correctly applied in the circuit. validate_operation (operation) Raises an exception if an operation is not valid. Returns metadata for the device. The numeric index of the given qubit on the device. qubit ( NamedQubit ) \u2013 int The device qubit corresponding to the given numeric index. index ( int ) \u2013 Qid Raises a ValueError if operation acts on qubits that are not connected. operation ( Operation ) \u2013 None Predicate, True iff the given operation is considered native for the architecture. op ( Operation ) \u2013 bool Predicate, True iff the given operation is native and its targets are valid. op ( Operation ) \u2013 bool Decomposes operations into the native operation set. All the decompositions below keep track of global phase (required for decomposing controlled gates). op ( Operation ) \u2013 operation to decompose decomposition, or None to pass op to the Cirq native decomposition machinery instead list [ Operation ] | None Decompose a single quantum operation into the native operation set. operation ( cirq.Operation ) \u2013 cirq.OP_TREE Routes the given circuit to the device connectivity and qubit names. The routed circuit uses the device qubits, and may have additional SWAP gates inserted to perform the qubit\nrouting. The transformer cirq.RouterCQC is used for routing.\nNote that only gates of one or two qubits, and measurement operations of arbitrary size are supported. Adds the attribute iqm_calibration_set_id to the routed circuit, with value taken from self.metadata.architecture.calibration_set_id if available, otherwise None. circuit ( Circuit ) \u2013 Circuit to route. initial_mapper ( AbstractInitialMapper | None ) \u2013 Initial mapping from circuit qubits to device qubits, to serve as\nthe starting point of the routing. None means it will be generated automatically. qubit_subset ( Sequence [ Qid ] | None ) \u2013 Restrict the routing to this subset of the device qubits. If None ,\nuse the entire device. routed circuit, initial mapping before inserting SWAP gates (see cirq.RouterCQC.route_circuit() ),\nfinal mapping from physical qubits to physical qubits (see cirq.RouterCQC.route_circuit() ) ValueError \u2013 routing is impossible tuple [ Circuit , dict [ Qid , Qid ], dict [ Qid , Qid ]] Decomposes the given circuit to the native gate set of the device. Adds the attribute iqm_calibration_set_id to the decomposed circuit, with value taken from self.metadata.architecture.calibration_set_id if available, otherwise None. circuit ( Circuit ) \u2013 circuit to decompose decomposed circuit Circuit Raises an exception if a circuit is not valid. circuit ( AbstractCircuit ) \u2013 The circuit to validate. ValueError \u2013 The circuit isn\u2019t valid for this device. None Raises an exception if an operation is not valid. operation ( Operation ) \u2013 The operation to validate. ValueError \u2013 The operation isn\u2019t valid for this device. None Validates whether the IQMMoveGate is between qubit and resonator registers. operation ( cirq.Operation ) \u2013 Operation to check ValueError \u2013 In case the the first argument of the IQMMoveGate is not a qubit,\n    or if the second argument is not a resonator on this device. None when the IQMMoveGate is used correctly. None Validates whether the IQMMoveGates are correctly applied in the circuit. circuit ( cirq.AbstractCircuit ) \u2013 The circuit to validate. ValueError \u2013 If the IQMMoveGate is applied incorrectly. None if the IQMMoveGates are applied correctly. None previous iqm.cirq_iqm.devices.iqm_device next iqm.cirq_iqm.devices.iqm_device_metadata By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.serialize.serialize_circuit",
    "url": "/iqm-client/api/iqm.cirq_iqm.serialize.serialize_circuit.html",
    "description": "Serializes a quantum circuit into the IQM data transfer format. circuit ( Circuit ) \u2013 quantum circuit to serialize data transfer object representing the circuit Circuit previous iqm.cirq_iqm.serialize...",
    "content": "Serializes a quantum circuit into the IQM data transfer format. circuit ( Circuit ) \u2013 quantum circuit to serialize data transfer object representing the circuit Circuit previous iqm.cirq_iqm.serialize.map_operation next iqm.cirq_iqm.serialize.OperationNotSupportedError By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.DDStrategy",
    "url": "/iqm-client/api/iqm.iqm_client.models.DDStrategy.html",
    "description": "Bases: BaseModel Describes a particular dynamical decoupling strategy. The current standard DD stategy can be found in STANDARD_DD_STRATEGY ,\nbut users can use this class to provide their own dynamica...",
    "content": "Bases: BaseModel Describes a particular dynamical decoupling strategy. The current standard DD stategy can be found in STANDARD_DD_STRATEGY ,\nbut users can use this class to provide their own dynamical decoupling strategies. See Ezzell et al., Phys. Rev. Appl. 20, 064027 (2022) for information on DD sequences. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. merge_contiguous_waits Merge contiguous Wait instructions into one if they are separated only by Block instructions. target_qubits Qubits on which dynamical decoupling should be applied. skip_leading_wait Skip processing leading Wait instructions. skip_trailing_wait Skip processing trailing Wait instructions. gate_sequences Available decoupling gate sequences to chose from in this strategy. Methods merge_contiguous_waits ( bool ) \u2013 target_qubits ( frozenset [ str ] | None ) \u2013 skip_leading_wait ( bool ) \u2013 skip_trailing_wait ( bool ) \u2013 gate_sequences ( list [ tuple [ int , str | list [ tuple [ float , float ] ] , str ] ] ) \u2013 Merge contiguous Wait instructions into one if they are separated only by Block instructions. Qubits on which dynamical decoupling should be applied. If None , all qubits are targeted. Skip processing leading Wait instructions. Skip processing trailing Wait instructions. Available decoupling gate sequences to chose from in this strategy. Each sequence is defined by a tuple of (ratio, gate pattern, align) : ratio: Minimal duration for the sequence (in PRX gate durations) as integer. gate pattern: Gate pattern can be defined in two ways. It can be a string containing \u201cX\u201d and \u201cY\u201d characters,\nencoding a PRX gate sequence. For example, \u201cYXYX\u201d corresponds to the\nXY4 sequence, \u201cXYXYYXYX\u201d to the EDD sequence, etc. If more flexibility is needed, a gate pattern can be\ndefined as a sequence of PRX gate argument tuples (that contain a rotation angle and a phase angle). For\nexample, sequence \u201cYX\u201d could be written as [(math.pi, math.pi / 2), (math.pi, 0)] . align: Controls the alignment of the sequence within the time window it is inserted in. Supported values: \u201casap\u201d: Corresponds to a ASAP-aligned sequence with no waiting time before the first pulse. \u201ccenter\u201d: Corresponds to a symmetric sequence. \u201calap\u201d: Corresponds to a ALAP-aligned sequence. The Dynamical Decoupling algorithm uses the best fitting gate sequence by first sorting them\nby ratio in descending order. Then the longest fitting pattern is determined by comparing ratio with the duration of the time window divided by the PRX gate duration. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.iqm_client.models.DDMode next iqm.iqm_client.models.DynamicQuantumArchitecture By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.transpiler_plugins.IQMDefaultSchedulingPlugin",
    "url": "/iqm-client/api/iqm.qiskit_iqm.transpiler_plugins.IQMDefaultSchedulingPlugin.html",
    "description": "Bases: IQMSchedulingPlugin Plugin class for IQM single qubit gate optimization and MoveGate routing as a scheduling stage. Methods pass_manager (pass_manager_config[,\u00a0...]) Build scheduling stage Pass...",
    "content": "Bases: IQMSchedulingPlugin Plugin class for IQM single qubit gate optimization and MoveGate routing as a scheduling stage. Methods pass_manager (pass_manager_config[,\u00a0...]) Build scheduling stage PassManager Build scheduling stage PassManager pass_manager_config ( PassManagerConfig ) \u2013 optimization_level ( int | None ) \u2013 PassManager previous iqm.qiskit_iqm.transpiler_plugins next iqm.qiskit_iqm.transpiler_plugins.IQMSchedulingPlugin By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.fake_backends.fake_aphrodite",
    "url": "/iqm-client/api/iqm.qiskit_iqm.fake_backends.fake_aphrodite.html",
    "description": "Fake (i.e. simulated) backend for IQM\u2019s 54-qubit Aphrodite architecture Functions IQMFakeAphrodite () Return IQMFakeBackend instance representing IQM's Aphrodite architecture. previous iqm.qiskit_iqm....",
    "content": "Fake (i.e. simulated) backend for IQM\u2019s 54-qubit Aphrodite architecture Functions IQMFakeAphrodite () Return IQMFakeBackend instance representing IQM's Aphrodite architecture. previous iqm.qiskit_iqm.fake_backends.fake_adonis.IQMFakeAdonis next iqm.qiskit_iqm.fake_backends.fake_aphrodite.IQMFakeAphrodite By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.iqm_circuit.IQMCircuit",
    "url": "/iqm-client/api/iqm.qiskit_iqm.iqm_circuit.IQMCircuit.html",
    "description": "Bases: QuantumCircuit Extends the QuantumCircuit class, adding a shortcut for applying the MOVE gate. Attributes name A human-readable name for the circuit. qregs A list of the QuantumRegister s in th...",
    "content": "Bases: QuantumCircuit Extends the QuantumCircuit class, adding a shortcut for applying the MOVE gate. Attributes name A human-readable name for the circuit. qregs A list of the QuantumRegister s in this circuit. cregs A list of the ClassicalRegister s in this circuit. duration The total duration of the circuit, set by a scheduling transpiler pass. unit The unit that duration is specified in. Methods move (qubit,\u00a0resonator) Applies the MOVE gate to the circuit. regs ( Register | int | Sequence [ Bit ] ) \u2013 name ( str | None ) \u2013 global_phase ( ParameterValueType ) \u2013 metadata ( dict | None ) \u2013 inputs ( Iterable [ expr.Var ] ) \u2013 captures ( Iterable [ expr.Var ] ) \u2013 declarations ( Mapping [ expr.Var , expr.Expr ] | Iterable [ Tuple [ expr.Var , expr.Expr ] ] ) \u2013 Applies the MOVE gate to the circuit. Note: at this point the circuit layout is only guaranteed to work if the order\nof the qubit and the resonator is correct (qubit first, resonator second). qubit ( int ) \u2013 the logical index of the qubit resonator ( int ) \u2013 the logical index of the resonator previous iqm.qiskit_iqm.iqm_circuit next iqm.qiskit_iqm.iqm_circuit_validation By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingOnlyKeepExistingMovesPlugin",
    "url": "/iqm-client/api/iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingOnlyKeepExistingMovesPlugin.html",
    "description": "Bases: MoveGateRoutingPlugin Plugin class for MoveGate routing without single qubit gate optimization\nwhere existing moves are kept. Methods previous iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingK...",
    "content": "Bases: MoveGateRoutingPlugin Plugin class for MoveGate routing without single qubit gate optimization\nwhere existing moves are kept. Methods previous iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingKeepExistingMovesPlugin next iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingOnlyPlugin By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.serialize_qubit_mapping",
    "url": "/iqm-client/api/iqm.iqm_client.models.serialize_qubit_mapping.html",
    "description": "Serializes a qubit mapping dict into the corresponding IQM data transfer format. qubit_mapping ( dict [ str , str ] ) \u2013 mapping from logical to physical qubit names data transfer object representing t...",
    "content": "Serializes a qubit mapping dict into the corresponding IQM data transfer format. qubit_mapping ( dict [ str , str ] ) \u2013 mapping from logical to physical qubit names data transfer object representing the mapping list [ SingleQubitMapping ] previous iqm.iqm_client.models.CircuitMeasurementResultsBatch next iqm.iqm_client.models.validate_circuit By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.QubitMapping",
    "url": "/iqm-client/api/iqm.iqm_client.models.QubitMapping.html",
    "description": "Type that represents a qubit mapping for a circuit, i.e. a list of single qubit mappings\nfor all qubits in the circuit. alias of list [ SingleQubitMapping ] previous iqm.iqm_client.models.CircuitBatch...",
    "content": "Type that represents a qubit mapping for a circuit, i.e. a list of single qubit mappings\nfor all qubits in the circuit. alias of list [ SingleQubitMapping ] previous iqm.iqm_client.models.CircuitBatch next iqm.iqm_client.models.PRXSequence By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.auth.ClientAccountSetupError",
    "url": "/iqm-client/api/iqm.iqm_client.cli.auth.ClientAccountSetupError.html",
    "description": "User\u2019s account has not been fully set up yet. previous iqm.iqm_client.cli.auth.GrantType next iqm.iqm_client.cli.auth.ClientAuthenticationError By IQM client developers \u00a9 Copyright 2021-2025, IQM Finl...",
    "content": "User\u2019s account has not been fully set up yet. previous iqm.iqm_client.cli.auth.GrantType next iqm.iqm_client.cli.auth.ClientAuthenticationError By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.auth.AuthRequest",
    "url": "/iqm-client/api/iqm.iqm_client.cli.auth.AuthRequest.html",
    "description": "Bases: BaseModel Request sent to authentication server for access token and refresh token, or for terminating the session.\n* Token request with grant type 'password' starts a new session in the authen...",
    "content": "Bases: BaseModel Request sent to authentication server for access token and refresh token, or for terminating the session.\n* Token request with grant type 'password' starts a new session in the authentication server. It uses fields client_id , grant_type , username and password . Token request with grant type 'refresh_token' is used for maintaining an existing session.\nIt uses field client_id , grant_type , refresh_token . Logout request uses only fields client_id and refresh_token . Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. client_id name of the client for all request types grant_type type of token request, in {'password', 'refresh_token'} username username for grant type 'password' password password for grant type 'password' refresh_token refresh token for grant type 'refresh_token' and logout request Methods client_id ( str ) \u2013 grant_type ( GrantType | None ) \u2013 username ( str | None ) \u2013 password ( str | None ) \u2013 refresh_token ( str | None ) \u2013 name of the client for all request types type of token request, in {'password', 'refresh_token'} username for grant type 'password' password for grant type 'password' refresh token for grant type 'refresh_token' and logout request Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.iqm_client.cli.auth.token_is_valid next iqm.iqm_client.cli.auth.GrantType By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.serialize.deserialize_circuit",
    "url": "/iqm-client/api/iqm.cirq_iqm.serialize.deserialize_circuit.html",
    "description": "Deserializes a quantum circuit from the IQM data transfer format to a Cirq Circuit. circuit ( Circuit ) \u2013 data transfer object representing the circuit quantum circuit Circuit previous iqm.cirq_iqm.se...",
    "content": "Deserializes a quantum circuit from the IQM data transfer format to a Cirq Circuit. circuit ( Circuit ) \u2013 data transfer object representing the circuit quantum circuit Circuit previous iqm.cirq_iqm.serialize next iqm.cirq_iqm.serialize.instruction_to_operation By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.token_manager.check_token_manager",
    "url": "/iqm-client/api/iqm.iqm_client.cli.token_manager.check_token_manager.html",
    "description": "Check whether a token manager related to the given tokens_file is running. tokens_file ( str ) \u2013 Path to a tokens JSON file. PID of the process if process is running, None otherwise. Optional[ int ] p...",
    "content": "Check whether a token manager related to the given tokens_file is running. tokens_file ( str ) \u2013 Path to a tokens JSON file. PID of the process if process is running, None otherwise. Optional[ int ] previous iqm.iqm_client.cli.token_manager next iqm.iqm_client.cli.token_manager.daemonize_token_manager By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.transpile.transpile_remove_moves",
    "url": "/iqm-client/api/iqm.iqm_client.transpile.transpile_remove_moves.html",
    "description": "Convert a Star architecture circuit involving resonators and MOVE gates into an equivalent\nsimplified achitecture circuit without them. The method assumes that in circuit a MOVE gate is always used to...",
    "content": "Convert a Star architecture circuit involving resonators and MOVE gates into an equivalent\nsimplified achitecture circuit without them. The method assumes that in circuit a MOVE gate is always used to move a qubit state into a\nresonator before any other gates act on the resonator. If this is not the case, this function\nwill not work as intended. circuit ( Circuit ) \u2013 Star architecture circuit from which resonators and MOVE gates should be removed. Equivalent simplified architecture circuit without resonators and MOVEs. Circuit previous iqm.iqm_client.transpile.transpile_insert_moves next iqm.iqm_client.transpile.ExistingMoveHandlingOptions By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.iqm_backend.IQMTarget",
    "url": "/iqm-client/api/iqm.qiskit_iqm.iqm_backend.IQMTarget.html",
    "description": "Bases: Target Transpilation target for an IQM architecture. Contains the mapping of physical qubit name on the device to qubit index in the Target. architecture ( DynamicQuantumArchitecture ) \u2013 Quantu...",
    "content": "Bases: Target Transpilation target for an IQM architecture. Contains the mapping of physical qubit name on the device to qubit index in the Target. architecture ( DynamicQuantumArchitecture ) \u2013 Quantum architecture that defines the target. component_to_idx ( dict [ str , int ] ) \u2013 Mapping from QPU component names to integer indices used by Qiskit to refer to them. include_resonators ( bool ) \u2013 Whether to include MOVE gates in the target. include_fake_czs ( bool ) \u2013 Whether to include virtual CZs that are not natively supported, but could be routed via MOVE. Attributes physical_qubits Return the ordered list of physical qubits in the backend. Methods _add_connections_from_DQA () Initializes the Target, making it represent the dynamic quantum architecture iqm_dqa . restrict_to_qubits (qubits) Generated a restricted transpilation target from this Target that only contains the given qubits. Return the ordered list of physical qubits in the backend. Generated a restricted transpilation target from this Target that only contains the given qubits. qubits ( list [ int ] | list [ str ] ) \u2013 Qubits to restrict the target to. Can be either a list of qubit indices or qubit names. restricted target IQMTarget previous iqm.qiskit_iqm.iqm_backend.IQMBackendBase next iqm.qiskit_iqm.iqm_circuit By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.Metadata",
    "url": "/iqm-client/api/iqm.iqm_client.models.Metadata.html",
    "description": "Bases: BaseModel Metadata describing a circuit execution job. Attributes circuits Return the circuits in the job. dd_mode Return the dynamical decoupling mode requested with the job. dd_strategy Retur...",
    "content": "Bases: BaseModel Metadata describing a circuit execution job. Attributes circuits Return the circuits in the job. dd_mode Return the dynamical decoupling mode requested with the job. dd_strategy Return the dynamical decoupling strategy used with the job. heralding_mode Return the heralding mode requested with the job. model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. shots Return the number of shots in the job. calibration_set_id ID of the calibration set used request optional copy of the original RunRequest sent to the server parameters job-specific parameters extracted from the original request circuits_batch circuits batch submitted for execution cocos_version CoCoS version used to execute the job timestamps Timestamps of execution progress Methods calibration_set_id ( UUID | None ) \u2013 request ( RunRequest | None ) \u2013 parameters ( JobParameters | None ) \u2013 circuits_batch ( list [ Circuit ] | None ) \u2013 cocos_version ( str | None ) \u2013 timestamps ( dict [ str , str ] | None ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. ID of the calibration set used optional copy of the original RunRequest sent to the server job-specific parameters extracted from the original request circuits batch submitted for execution CoCoS version used to execute the job Timestamps of execution progress Return the number of shots in the job. Return the circuits in the job. Return the heralding mode requested with the job. Return the dynamical decoupling mode requested with the job. Return the dynamical decoupling strategy used with the job. previous iqm.iqm_client.models.JobParameters next iqm.iqm_client.models.MoveGateFrameTrackingMode By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.fake_backends.iqm_fake_backend",
    "url": "/iqm-client/api/iqm.qiskit_iqm.fake_backends.iqm_fake_backend.html",
    "description": "Error profile and fake backend base class for simulating IQM quantum computers. Classes IQMErrorProfile (t1s,\u00a0t2s,\u00a0...[,\u00a0name]) Characteristics of an IQM QPU specimen, used for constructing an error m...",
    "content": "Error profile and fake backend base class for simulating IQM quantum computers. Classes IQMErrorProfile (t1s,\u00a0t2s,\u00a0...[,\u00a0name]) Characteristics of an IQM QPU specimen, used for constructing an error model. IQMFakeBackend (architecture,\u00a0error_profile) Simulated backend that mimics the behaviour of IQM quantum computers. Inheritance previous iqm.qiskit_iqm.fake_backends.fake_garnet.IQMFakeGarnet next iqm.qiskit_iqm.fake_backends.iqm_fake_backend.IQMErrorProfile By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.Counts",
    "url": "/iqm-client/api/iqm.iqm_client.models.Counts.html",
    "description": "Bases: BaseModel Circuit measurement results in histogram representation. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.Confi...",
    "content": "Bases: BaseModel Circuit measurement results in histogram representation. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. measurement_keys Measurement keys in the order they are concatenated to form the state bitstrings in counts . counts mapping from computational basis states, represented as bitstrings, to the number of times they were observed when executing the circuit Methods measurement_keys ( list [ str ] ) \u2013 counts ( dict [ str , int ] ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. Measurement keys in the order they are concatenated to form the state bitstrings in counts . For example, if measurement_keys is ['mk_1', 'mk2'] and 'mk_1' measures QB1 and 'mk_2' measures QB3 and QB5 , then counts could contains keys such as '010' representing\nshots where QB1`, ``QB3 and QB5 were observed to be in the state \\(|010\nangle\\) . mapping from computational basis states, represented as bitstrings, to the number of times they were observed\nwhen executing the circuit previous iqm.iqm_client.models.ClientLibrary next iqm.iqm_client.models.DDMode By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.Status",
    "url": "/iqm-client/api/iqm.iqm_client.models.Status.html",
    "description": "Bases: str , Enum Status of a job. Attributes RECEIVED Job has been received but nothing has been done about it. VALIDATION_STARTED Job is being validated. PROCESSING  VALIDATION_ENDED Job has passed ...",
    "content": "Bases: str , Enum Status of a job. Attributes RECEIVED Job has been received but nothing has been done about it. VALIDATION_STARTED Job is being validated. PROCESSING  VALIDATION_ENDED Job has passed initial checks and will proceed to compilation. FETCH_CALIBRATION_STARTED The calibration is being fetched for the job. FETCH_CALIBRATION_ENDED Job has been fetched for the job. COMPILATION_STARTED The job is being compiled. COMPILATION_ENDED Job has been compiled to a low-level representation. SAVE_SWEEP_METADATA_STARTED Metadata about the sweep is being saved to the database. SAVE_SWEEP_METADATA_ENDED Metadata has been successfully saved. PENDING_EXECUTION Job has been compiled and is queued for execution. EXECUTION_STARTED The job has begun execution on hardware. EXECUTION_ENDED The job has completed execution on hardware. POST_PROCESSING_PENDING The job has finished executing and is pending post-processing. POST_PROCESSING_STARTED The job results is being post-processed. POST_PROCESSING_ENDED The job has been successfully post processed. READY Job has been executed and results are available. FAILED Execution or compilation failed. ABORTED User cancelled the execution. PENDING_DELETION Job is set to be deleted. DELETION_FAILED Job was supposed to be deleted but deletion failed. DELETED Job deleted from the database. UNKNOWN Job is in a state not recognized by this version of the client. Methods _generate_next_value_ (start,\u00a0count,\u00a0last_values) Generate the next value when not given. _missing_ (value) This is a backwards compatibility fix for resonance integration. terminal_statuses () Statuses from which the execution can't continue. _new_member_ (**kwargs) Create and return a new object. _value_repr_ () Return repr(self). __format__ (format_spec) Return a formatted version of the string as described by format_spec. __new__ (value)  __repr__ () Return repr(self). __str__ () Return str(self). Job has been received but nothing has been done about it. Job is being validated. Job has passed initial checks and will proceed to compilation. The calibration is being fetched for the job. Job has been fetched for the job. The job is being compiled. Job has been compiled to a low-level representation. Metadata about the sweep is being saved to the database. Metadata has been successfully saved. Job has been compiled and is queued for execution. The job has begun execution on hardware. The job has completed execution on hardware. The job has finished executing and is pending post-processing. The job results is being post-processed. The job has been successfully post processed. Job has been executed and results are available. Execution or compilation failed. User cancelled the execution. Job is set to be deleted. Job was supposed to be deleted but deletion failed. Job deleted from the database. Job is in a state not recognized by this version of the client. Statuses from which the execution can\u2019t continue. set [ Status ] previous iqm.iqm_client.models.StaticQuantumArchitecture next iqm.iqm_client.transpile By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingWithRZOptimizationIgnoreBarriersPlugin",
    "url": "/iqm-client/api/iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingWithRZOptimizationIgnoreBarriersPlugin.html",
    "description": "Bases: MoveGateRoutingPlugin Plugin class for single qubit gate optimization and MoveGate routing where barriers are ignored during\noptimization. Methods previous iqm.qiskit_iqm.transpiler_plugins.Mov...",
    "content": "Bases: MoveGateRoutingPlugin Plugin class for single qubit gate optimization and MoveGate routing where barriers are ignored during\noptimization. Methods previous iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingWithExactRZPlugin next iqm.qiskit_iqm.transpiler_plugins.OnlyRZOptimizationExactIgnoreBarriersPlugin By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.cli.IQMClientCliCommand",
    "url": "/iqm-client/api/iqm.iqm_client.cli.cli.IQMClientCliCommand.html",
    "description": "Bases: Group A custom click command group class to wrap global constants. Attributes default_config_path  default_tokens_path  commands The registered subcommands by their exported names. name the nam...",
    "content": "Bases: Group A custom click command group class to wrap global constants. Attributes default_config_path  default_tokens_path  commands The registered subcommands by their exported names. name the name the command thinks it has. context_settings an optional dictionary with defaults passed to the context. callback the callback to execute when the command fires. params the list of parameters for this command in the order they should show up in the help page and execute. Methods name ( str | None ) \u2013 commands ( cabc.MutableMapping [ str , Command ] | cabc.Sequence [ Command ] | None ) \u2013 invoke_without_command ( bool ) \u2013 no_args_is_help ( bool | None ) \u2013 subcommand_metavar ( str | None ) \u2013 chain ( bool ) \u2013 result_callback ( t.Callable [ ... , t.Any ] | None ) \u2013 kwargs ( t.Any ) \u2013 previous iqm.iqm_client.cli.cli.ClickLoggingHandler next iqm.iqm_client.cli.cli.ResolvedPath By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.cli",
    "url": "/iqm-client/api/iqm.iqm_client.cli.cli.html",
    "description": "Command line interface for managing user authentication when using IQM quantum computers. Functions save_tokens_file (path,\u00a0tokens,\u00a0auth_server_url) Saves tokens as JSON file at given path. Classes Cl...",
    "content": "Command line interface for managing user authentication when using IQM quantum computers. Functions save_tokens_file (path,\u00a0tokens,\u00a0auth_server_url) Saves tokens as JSON file at given path. Classes ClickLoggingHandler () Simple log handler using click's echo function. IQMClientCliCommand ([name,\u00a0commands,\u00a0...]) A custom click command group class to wrap global constants. ResolvedPath (*args,\u00a0**kwargs) A click parameter type for a resolved path. Inheritance previous iqm.iqm_client.cli.auth.ClientAuthenticationError next iqm.iqm_client.cli.cli.save_tokens_file By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.SingleQubitMapping",
    "url": "/iqm-client/api/iqm.iqm_client.models.SingleQubitMapping.html",
    "description": "Bases: BaseModel Mapping of a logical qubit name to a physical qubit name. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.Conf...",
    "content": "Bases: BaseModel Mapping of a logical qubit name to a physical qubit name. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. logical_name logical qubit name physical_name physical qubit name Methods logical_name ( str ) \u2013 physical_name ( str ) \u2013 logical qubit name physical qubit name Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.iqm_client.models.RunStatus next iqm.iqm_client.models.StaticQuantumArchitecture By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.RunCounts",
    "url": "/iqm-client/api/iqm.iqm_client.models.RunCounts.html",
    "description": "Bases: BaseModel Measurement results of a circuit execution job in histogram representation. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][py...",
    "content": "Bases: BaseModel Measurement results of a circuit execution job in histogram representation. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. status current status of the job, in {'pending compilation', 'pending execution', 'ready', 'failed', 'aborted'} counts_batch measurement results in histogram representation for each circuit in the batch Methods status ( Status ) \u2013 counts_batch ( list [ Counts ] | None ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. current status of the job, in {'pending compilation', 'pending execution', 'ready', 'failed', 'aborted'} measurement results in histogram representation for each circuit in the batch previous iqm.iqm_client.models.QuantumArchitectureSpecification next iqm.iqm_client.models.RunRequest By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.iqm_naive_move_pass",
    "url": "/iqm-client/api/iqm.qiskit_iqm.iqm_naive_move_pass.html",
    "description": "Naive transpilation for the IQM Star architecture. Functions transpile_to_IQM (circuit,\u00a0backend[,\u00a0target,\u00a0...]) Customized transpilation to IQM backends. Classes IQMNaiveResonatorMoving (*args,\u00a0**kwar...",
    "content": "Naive transpilation for the IQM Star architecture. Functions transpile_to_IQM (circuit,\u00a0backend[,\u00a0target,\u00a0...]) Customized transpilation to IQM backends. Classes IQMNaiveResonatorMoving (*args,\u00a0**kwargs) Naive transpilation pass for resonator moving. Inheritance previous iqm.qiskit_iqm.iqm_move_layout.IQMMoveLayout next iqm.qiskit_iqm.iqm_naive_move_pass.transpile_to_IQM By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.iqm_naive_move_pass.transpile_to_IQM",
    "url": "/iqm-client/api/iqm.qiskit_iqm.iqm_naive_move_pass.transpile_to_IQM.html",
    "description": "Customized transpilation to IQM backends. Works with both the Crystal and Star architectures. circuit ( QuantumCircuit ) \u2013 The circuit to be transpiled without MOVE gates. backend ( IQMBackendBase ) \u2013...",
    "content": "Customized transpilation to IQM backends. Works with both the Crystal and Star architectures. circuit ( QuantumCircuit ) \u2013 The circuit to be transpiled without MOVE gates. backend ( IQMBackendBase ) \u2013 The target backend to compile to. Does not require a resonator. target ( IQMTarget | None ) \u2013 An alternative target to compile to than the backend, using this option requires intimate knowledge\nof the transpiler and thus it is not recommended to use. initial_layout ( Layout | dict | list | None ) \u2013 The initial layout to use for the transpilation, same as transpile() . perform_move_routing ( bool ) \u2013 Whether to perform MOVE gate routing. optimize_single_qubits ( bool ) \u2013 Whether to optimize single qubit gates away. ignore_barriers ( bool ) \u2013 Whether to ignore barriers when optimizing single qubit gates away. remove_final_rzs ( bool ) \u2013 Whether to remove the final z rotations. It is recommended always to set this to true as\nthe final RZ gates do no change the measurement outcomes of the circuit. existing_moves_handling ( ExistingMoveHandlingOptions | None ) \u2013 How to handle existing MOVE gates in the circuit, required if the circuit contains\nMOVE gates. restrict_to_qubits ( list [ int ] | list [ str ] | None ) \u2013 Restrict the transpilation to only use these specific physical qubits. Note that you will\nhave to pass this information to the backend.run method as well as a dictionary. qiskit_transpiler_kwargs \u2013 Arguments to be passed to the Qiskit transpiler. Transpiled circuit ready for running on the backend. QuantumCircuit previous iqm.qiskit_iqm.iqm_naive_move_pass next iqm.qiskit_iqm.iqm_naive_move_pass.IQMNaiveResonatorMoving By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.transpiler_plugins.IQMSchedulingPlugin",
    "url": "/iqm-client/api/iqm.qiskit_iqm.transpiler_plugins.IQMSchedulingPlugin.html",
    "description": "Bases: PassManagerStagePlugin Basic plugin for scheduling stage of IQM devices. move_gate_routing ( bool ) \u2013 whether to include MoveGate routing in the scheduling stage. optimize_sqg ( bool ) \u2013 Whethe...",
    "content": "Bases: PassManagerStagePlugin Basic plugin for scheduling stage of IQM devices. move_gate_routing ( bool ) \u2013 whether to include MoveGate routing in the scheduling stage. optimize_sqg ( bool ) \u2013 Whether to include single qubit gate optimization in the scheduling stage. drop_final_rz ( bool ) \u2013 Whether to drop trailing RZ gates in the circuit during single qubit gate optimization. ignore_barriers ( bool ) \u2013 Whether to ignore barriers during single qubit gate optimization. existing_move_handling ( ExistingMoveHandlingOptions | None ) \u2013 How to handle existing MoveGates in the circuit during MoveGate routing. ValueError \u2013 When incompatible options are set. Methods pass_manager (pass_manager_config[,\u00a0...]) Build scheduling stage PassManager Build scheduling stage PassManager pass_manager_config ( PassManagerConfig ) \u2013 optimization_level ( int | None ) \u2013 PassManager previous iqm.qiskit_iqm.transpiler_plugins.IQMDefaultSchedulingPlugin next iqm.qiskit_iqm.transpiler_plugins.MoveGateRoutingKeepExistingMovesPlugin By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm",
    "url": "/iqm-client/api/iqm.qiskit_iqm.html",
    "description": "Qiskit adapter for IQM\u2019s quantum computers. Subpackages and modules examples Example code. fake_backends Fake backends for simulating IQM quantum computers. iqm_backend Qiskit backend for IQM quantum ...",
    "content": "Qiskit adapter for IQM\u2019s quantum computers. Subpackages and modules examples Example code. fake_backends Fake backends for simulating IQM quantum computers. iqm_backend Qiskit backend for IQM quantum computers. iqm_circuit A simple extension of the QuantumCircuit class to allow the MOVE gate to be applied with a .move(qubit, resonator) shortcut. iqm_circuit_validation Helper functions for circuit validation. iqm_job Circuit execution jobs. iqm_move_layout Generate an initial layout for a quantum circuit that is valid on the quantum architecture specification of the given backend. iqm_naive_move_pass Naive transpilation for the IQM Star architecture. iqm_provider Qiskit backend provider for IQM backends. iqm_transpilation Transpilation tool to optimize the decomposition of single-qubit gates tailored to IQM hardware. move_gate MOVE gate to be used on the IQM Star architecture. qiskit_to_iqm Conversion tools from Qiskit to IQM representation. transpiler_plugins Collection of Qiskit transpiler plugins for native use of specialized transpiler passes by our devices. previous iqm.iqm_client.validation.validate_qubit_mapping next iqm.qiskit_iqm.examples By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.QualityMetricSet",
    "url": "/iqm-client/api/iqm.iqm_client.models.QualityMetricSet.html",
    "description": "Bases: BaseModel Quality metrics for a calibration set. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. calibratio...",
    "content": "Bases: BaseModel Quality metrics for a calibration set. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. calibration_set_id ID of the calibration set. calibration_set_dut_label Chip Label of the calibration set. calibration_set_number_of_observations Number of observations in the calibration set. calibration_set_created_timestamp Timestamp when the calibration set was created. calibration_set_end_timestamp Timestamp when the calibration set was finalized. calibration_set_is_invalid Whether the calibration set is invalid. quality_metric_set_id ID of the quality metric set. quality_metric_set_dut_label Chip label of the quality metric set. quality_metric_set_created_timestamp Timestamp when the quality metric set was created. quality_metric_set_end_timestamp Timestamp when the quality metric set was finalized. quality_metric_set_is_invalid Whether the quality metric set is invalid. metrics Quality metrics. Methods calibration_set_id ( UUID | None ) \u2013 calibration_set_dut_label ( str ) \u2013 calibration_set_number_of_observations ( int ) \u2013 calibration_set_created_timestamp ( str ) \u2013 calibration_set_end_timestamp ( str ) \u2013 calibration_set_is_invalid ( bool ) \u2013 quality_metric_set_id ( UUID | None ) \u2013 quality_metric_set_dut_label ( str | None ) \u2013 quality_metric_set_created_timestamp ( str | None ) \u2013 quality_metric_set_end_timestamp ( str | None ) \u2013 quality_metric_set_is_invalid ( bool ) \u2013 metrics ( dict [ str , dict [ str , Any ] ] | None ) \u2013 ID of the calibration set. Chip Label of the calibration set. Number of observations in the calibration set. Timestamp when the calibration set was created. Timestamp when the calibration set was finalized. Whether the calibration set is invalid. ID of the quality metric set. Chip label of the quality metric set. Timestamp when the quality metric set was created. Timestamp when the quality metric set was finalized. Whether the quality metric set is invalid. Quality metrics. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.iqm_client.models.NativeOperation next iqm.iqm_client.models.QuantumArchitecture By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.models.StaticQuantumArchitecture",
    "url": "/iqm-client/api/iqm.iqm_client.models.StaticQuantumArchitecture.html",
    "description": "Bases: BaseModel Static quantum architecture of the server. The static quantum architecture (SQA) provides information about the QPU,\nincluding the names of its computational components and the connec...",
    "content": "Bases: BaseModel Static quantum architecture of the server. The static quantum architecture (SQA) provides information about the QPU,\nincluding the names of its computational components and the connections between them. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. qubits Names of the physical qubits on the QPU, sorted. computational_resonators Names of the physical computational resonators on the QPU, sorted. connectivity Groups of components (qubits and computational resonators) that are connected by a coupler on the QPU, sorted. Methods qubits ( list [ str ] ) \u2013 computational_resonators ( list [ str ] ) \u2013 connectivity ( list [ tuple [ str , ... ] ] ) \u2013 Names of the physical qubits on the QPU, sorted. Names of the physical computational resonators on the QPU, sorted. Groups of components (qubits and computational resonators) that are connected by a coupler on the QPU, sorted. Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.iqm_client.models.SingleQubitMapping next iqm.iqm_client.models.Status By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli",
    "url": "/iqm-client/api/iqm.iqm_client.cli.html",
    "description": "Command-line interface (CLI) for managing user authentication when using IQM quantum computers. Subpackages and modules auth Authorization and session management for IQM Client CLI. cli Command line i...",
    "content": "Command-line interface (CLI) for managing user authentication when using IQM quantum computers. Subpackages and modules auth Authorization and session management for IQM Client CLI. cli Command line interface for managing user authentication when using IQM quantum computers. models Pydantic models for IQM Client CLI files. token_manager Token manager for authentication and authorization to IQM's quantum computers. previous iqm.iqm_client.authentication.TokensFileReader next iqm.iqm_client.cli.auth By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.api.APIEndpoint",
    "url": "/iqm-client/api/iqm.iqm_client.api.APIEndpoint.html",
    "description": "Bases: Enum Supported API endpoints. Attributes GET_JOB_RESULT  GET_JOB_REQUEST_PARAMETERS  GET_JOB_CALIBRATION_SET_ID  GET_JOB_CIRCUITS_BATCH  GET_JOB_ERROR_LOG  SUBMIT_JOB  GET_JOB_COUNTS  GET_JOB_S...",
    "content": "Bases: Enum Supported API endpoints. Attributes GET_JOB_RESULT  GET_JOB_REQUEST_PARAMETERS  GET_JOB_CALIBRATION_SET_ID  GET_JOB_CIRCUITS_BATCH  GET_JOB_ERROR_LOG  SUBMIT_JOB  GET_JOB_COUNTS  GET_JOB_STATUS  GET_JOB_TIMELINE  ABORT_JOB  Methods previous iqm.iqm_client.api.APIConfig next iqm.iqm_client.authentication By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.cli.save_tokens_file",
    "url": "/iqm-client/api/iqm.iqm_client.cli.cli.save_tokens_file.html",
    "description": "Saves tokens as JSON file at given path. path ( str ) \u2013 path to the file to write tokens ( dict [ str , str ] ) \u2013 authorization access and refresh tokens auth_server_url ( str ) \u2013 base url of the auth...",
    "content": "Saves tokens as JSON file at given path. path ( str ) \u2013 path to the file to write tokens ( dict [ str , str ] ) \u2013 authorization access and refresh tokens auth_server_url ( str ) \u2013 base url of the authorization server OSError \u2013 if writing to file fails None previous iqm.iqm_client.cli.cli next iqm.iqm_client.cli.cli.ClickLoggingHandler By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.fake_backends.fake_apollo",
    "url": "/iqm-client/api/iqm.qiskit_iqm.fake_backends.fake_apollo.html",
    "description": "Fake (i.e. simulated) backend for IQM\u2019s 20-qubit Apollo architecture Functions IQMFakeApollo () Return IQMFakeBackend instance representing IQM's Apollo architecture. previous iqm.qiskit_iqm.fake_back...",
    "content": "Fake (i.e. simulated) backend for IQM\u2019s 20-qubit Apollo architecture Functions IQMFakeApollo () Return IQMFakeBackend instance representing IQM's Apollo architecture. previous iqm.qiskit_iqm.fake_backends.fake_aphrodite.IQMFakeAphrodite next iqm.qiskit_iqm.fake_backends.fake_apollo.IQMFakeApollo By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.iqm_provider",
    "url": "/iqm-client/api/iqm.qiskit_iqm.iqm_provider.html",
    "description": "Qiskit backend provider for IQM backends. Classes IQMBackend (client,\u00a0*[,\u00a0calibration_set_id]) Backend for executing quantum circuits on IQM quantum computers. IQMFacadeBackend (client,\u00a0**kwargs) Faca...",
    "content": "Qiskit backend provider for IQM backends. Classes IQMBackend (client,\u00a0*[,\u00a0calibration_set_id]) Backend for executing quantum circuits on IQM quantum computers. IQMFacadeBackend (client,\u00a0**kwargs) Facade backend for mimicking the execution of quantum circuits on IQM quantum computers. Allows to submit a IQMProvider (url,\u00a0**user_auth_args) Provider for IQM backends. Inheritance previous iqm.qiskit_iqm.iqm_naive_move_pass.IQMNaiveResonatorMoving next iqm.qiskit_iqm.iqm_provider.IQMBackend By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.validation.validate_circuit_instructions",
    "url": "/iqm-client/api/iqm.iqm_client.validation.validate_circuit_instructions.html",
    "description": "Validate the given circuits against the given quantum architecture. architecture ( DynamicQuantumArchitecture ) \u2013 Quantum architecture to check against. circuits ( list [ Circuit ] ) \u2013 Circuits to be ...",
    "content": "Validate the given circuits against the given quantum architecture. architecture ( DynamicQuantumArchitecture ) \u2013 Quantum architecture to check against. circuits ( list [ Circuit ] ) \u2013 Circuits to be checked. qubit_mapping ( dict [ str , str ] | None ) \u2013 Mapping of logical qubit names to physical qubit names.\nCan be set to None if all circuits already use physical qubit names.\nNote that the qubit_mapping is used for all circuits . validate_moves ( MoveGateValidationMode ) \u2013 Determines how MOVE gate validation works. must_close_sandwiches ( bool ) \u2013 Iff True, MOVE sandwiches cannot be left open when the circuit ends. CircuitValidationError \u2013 validation failed None previous iqm.iqm_client.validation next iqm.iqm_client.validation.validate_circuit_moves By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.iqm_sampler",
    "url": "/iqm-client/api/iqm.cirq_iqm.iqm_sampler.html",
    "description": "Circuit sampler that executes quantum circuits on an IQM quantum computer. Classes IQMResult (*[,\u00a0params,\u00a0measurements,\u00a0records]) Stores the results of a quantum circuit execution on an IQM device. IQ...",
    "content": "Circuit sampler that executes quantum circuits on an IQM quantum computer. Classes IQMResult (*[,\u00a0params,\u00a0measurements,\u00a0records]) Stores the results of a quantum circuit execution on an IQM device. IQMSampler (url,\u00a0*[,\u00a0device,\u00a0...]) Circuit sampler for executing quantum circuits on IQM quantum computers. ResultMetadata (job_id,\u00a0calibration_set_id,\u00a0...) Metadata for an IQM execution result. Inheritance previous iqm.cirq_iqm.iqm_gates.IQMMoveGate next iqm.cirq_iqm.iqm_sampler.IQMResult By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.transpile.ExistingMoveHandlingOptions",
    "url": "/iqm-client/api/iqm.iqm_client.transpile.ExistingMoveHandlingOptions.html",
    "description": "Bases: str , Enum Options for how transpile_insert_moves() should handle existing MOVE instructions\nin the circuit. Attributes KEEP Strict mode. TRUST Lenient mode. REMOVE Removes existing MOVE instru...",
    "content": "Bases: str , Enum Options for how transpile_insert_moves() should handle existing MOVE instructions\nin the circuit. Attributes KEEP Strict mode. TRUST Lenient mode. REMOVE Removes existing MOVE instructions from the circuit using transpile_remove_moves() , and then does the same as TRUST. Methods _generate_next_value_ (start,\u00a0count,\u00a0last_values) Generate the next value when not given. _new_member_ (**kwargs) Create and return a new object. _value_repr_ () Return repr(self). __format__ (format_spec) Return a formatted version of the string as described by format_spec. __new__ (value)  __repr__ () Return repr(self). __str__ () Return str(self). Strict mode. The circuit, including existing MOVE instructions in it, is validated first.\nThen, any fictional two-qubit gates in the circuit are implemented with qubit-resonator gates. Lenient mode. Same as KEEP, but does not validate the circuit first.\nWill attempt to fix any apparent user errors in the circuit by adding extra MOVE gates. Removes existing MOVE instructions from the circuit using transpile_remove_moves() , and\nthen does the same as TRUST. This may produce a more optimized end result. previous iqm.iqm_client.transpile.transpile_remove_moves next iqm.iqm_client.util By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.models",
    "url": "/iqm-client/api/iqm.iqm_client.cli.models.html",
    "description": "Pydantic models for IQM Client CLI files. Classes ConfigFile (*,\u00a0auth_server_url,\u00a0realm,\u00a0client_id) Model of configuration file, used for validating JSON. TokensFile (*[,\u00a0pid,\u00a0refresh_status]) Model o...",
    "content": "Pydantic models for IQM Client CLI files. Classes ConfigFile (*,\u00a0auth_server_url,\u00a0realm,\u00a0client_id) Model of configuration file, used for validating JSON. TokensFile (*[,\u00a0pid,\u00a0refresh_status]) Model of tokens file, used for validating JSON. Inheritance previous iqm.iqm_client.cli.cli.ResolvedPath next iqm.iqm_client.cli.models.ConfigFile By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.token_manager.daemonize_token_manager",
    "url": "/iqm-client/api/iqm.iqm_client.cli.token_manager.daemonize_token_manager.html",
    "description": "Start a daemon process. cycle ( int ) \u2013 refresh cycle in seconds config ( ConfigFile ) \u2013 IQM Client CLI configuration logfile ( str | None ) \u2013 path to file for writing errors None previous iqm.iqm_cli...",
    "content": "Start a daemon process. cycle ( int ) \u2013 refresh cycle in seconds config ( ConfigFile ) \u2013 IQM Client CLI configuration logfile ( str | None ) \u2013 path to file for writing errors None previous iqm.iqm_client.cli.token_manager.check_token_manager next iqm.iqm_client.cli.token_manager.read_tokens By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.qiskit_iqm.move_gate.MOVE_GATE_UNITARY",
    "url": "/iqm-client/api/iqm.qiskit_iqm.move_gate.MOVE_GATE_UNITARY.html",
    "description": "Unitary matrix for simulating the ideal MOVE gate. This matrix is not a realistic description of MOVE, since it applies a zero phase on the moved\nstate, and acts as identity in the \\(|11\nangle\\) subsp...",
    "content": "Unitary matrix for simulating the ideal MOVE gate. This matrix is not a realistic description of MOVE, since it applies a zero phase on the moved\nstate, and acts as identity in the \\(|11\nangle\\) subspace, thus being equal to the SWAP gate. previous iqm.qiskit_iqm.move_gate next iqm.qiskit_iqm.move_gate.MoveGate By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.cirq_iqm.devices.apollo",
    "url": "/iqm-client/api/iqm.cirq_iqm.devices.apollo.html",
    "description": "IQM\u2019s Apollo quantum architecture. Classes Apollo () IQM's twenty-qubit transmon device. Inheritance previous iqm.cirq_iqm.devices.aphrodite.Aphrodite next iqm.cirq_iqm.devices.apollo.Apollo By IQM cl...",
    "content": "IQM\u2019s Apollo quantum architecture. Classes Apollo () IQM's twenty-qubit transmon device. Inheritance previous iqm.cirq_iqm.devices.aphrodite.Aphrodite next iqm.cirq_iqm.devices.apollo.Apollo By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.cli.models.ConfigFile",
    "url": "/iqm-client/api/iqm.iqm_client.cli.models.ConfigFile.html",
    "description": "Bases: BaseModel Model of configuration file, used for validating JSON. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigD...",
    "content": "Bases: BaseModel Model of configuration file, used for validating JSON. Attributes model_config Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. auth_server_url  realm  client_id  username  tokens_file  Methods auth_server_url ( AnyUrl ) \u2013 realm ( str ) \u2013 client_id ( str ) \u2013 username ( str | None ) \u2013 tokens_file ( Path ) \u2013 Configuration for the model, should be a dictionary conforming to [ ConfigDict ][pydantic.config.ConfigDict]. previous iqm.iqm_client.cli.models next iqm.iqm_client.cli.models.TokensFile By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  },
  {
    "package": "iqm-client",
    "title": "iqm.iqm_client.iqm_client.IQMClient",
    "url": "/iqm-client/api/iqm.iqm_client.iqm_client.IQMClient.html",
    "description": "Bases: object Provides access to IQM quantum computers. url ( str ) \u2013 Endpoint for accessing the server. Has to start with http or https. client_signature ( str | None ) \u2013 String that IQMClient adds t...",
    "content": "Bases: object Provides access to IQM quantum computers. url ( str ) \u2013 Endpoint for accessing the server. Has to start with http or https. client_signature ( str | None ) \u2013 String that IQMClient adds to User-Agent header of requests\nit sends to the server. The signature is appended to IQMClient\u2019s own version\ninformation and is intended to carry additional version information,\nfor example the version information of the caller. token ( str | None ) \u2013 Long-lived authentication token in plain text format. Used by IQM Resonance.\nIf token is given no other user authentication parameters should be given. tokens_file ( str | None ) \u2013 Path to a tokens file used for authentication.\nIf tokens_file is given no other user authentication parameters should be given. auth_server_url ( str | None ) \u2013 Base URL of the authentication server.\nIf auth_server_url is given also username and password must be given. username ( str | None ) \u2013 Username to log in to authentication server. password ( str | None ) \u2013 Password to log in to authentication server. Alternatively, the user authentication related keyword arguments can also be given in\nenvironment variables IQM_TOKEN , IQM_TOKENS_FILE , IQM_AUTH_SERVER , IQM_AUTH_USERNAME and IQM_AUTH_PASSWORD . All parameters must be given either\nas keyword arguments or as environment variables. Same combination restrictions apply\nfor values given as environment variables as for keyword arguments. Methods __del__ ()  _check_authentication_errors (result) Raise ClientAuthenticationError with appropriate message if the authentication failed for some reason. _check_not_found_error (response) Raise HTTPError with appropriate message if response.status_code == 404 . _check_versions () Check the client version against compatible client versions reported by server. _default_headers () Default headers for HTTP requests to the IQM server. _deserialize_response (response,\u00a0model_class) Deserialize a HTTP endpoint response. _get_dut_label ()  _get_request (api_endpoint[,\u00a0endpoint_args,\u00a0...]) Make an HTTP GET request to an IQM server endpoint. abort_job (job_id,\u00a0*[,\u00a0timeout_secs]) Abort a job that was submitted for execution. close_auth_session () Terminate session with authentication server if there is one. create_run_request (circuits,\u00a0*[,\u00a0...]) Create a run request for executing circuits without sending it to the server. get_about () Return information about the IQM client. get_calibration_set ([calibration_set_id]) Retrieve the given calibration set from the server. get_dynamic_quantum_architecture ([...]) Retrieve the dynamic quantum architecture (DQA) for the given calibration set from the server. get_feedback_groups () Retrieve groups of qubits that can receive real-time feedback signals from each other. get_health () Return the status of the station control service. get_quality_metric_set ([calibration_set_id]) Retrieve the latest quality metric set for the given calibration set from the server. get_run (job_id,\u00a0*[,\u00a0timeout_secs]) Query the status and results of a submitted job. get_run_counts (job_id,\u00a0*[,\u00a0timeout_secs]) Query the counts of an executed job. get_run_status (job_id,\u00a0*[,\u00a0timeout_secs]) Query the status of a submitted job. get_static_quantum_architecture () Retrieve the static quantum architecture (SQA) from the server. get_supported_client_libraries ([timeout_secs]) Retrieve information about supported client libraries from the server. submit_circuits (circuits,\u00a0*[,\u00a0...]) Submit a batch of quantum circuits for execution on a quantum computer. submit_run_request (run_request) Submit a run request for execution on a quantum computer. wait_for_compilation (job_id[,\u00a0timeout_secs]) Poll results until a job is either compiled, pending execution, ready, failed, aborted, or timed out. wait_for_results (job_id[,\u00a0timeout_secs]) Poll results until a job is either ready, failed, aborted, or timed out. Return information about the IQM client. dict Return the status of the station control service. dict Submit a batch of quantum circuits for execution on a quantum computer. circuits ( list [ Circuit ] ) \u2013 Circuits to be executed. qubit_mapping ( dict [ str , str ] | None ) \u2013 Mapping of logical qubit names to physical qubit names.\nCan be set to None if all circuits already use physical qubit names.\nNote that the qubit_mapping is used for all circuits . custom_settings ( dict [ str , Any ] | None ) \u2013 Custom settings to override default settings and calibration data.\nNote: This field should always be None in normal use. calibration_set_id ( UUID | None ) \u2013 ID of the calibration set to use, or None to use the current default calibration. shots ( int ) \u2013 Number of times circuits are executed. Must be greater than zero. options ( CircuitCompilationOptions | None ) \u2013 Various discrete options for compiling quantum circuits to instruction schedules. ID for the created job. This ID is needed to query the job status and the execution results. UUID Create a run request for executing circuits without sending it to the server. This is called in submit_circuits() and does not need to be called separately in normal usage. Can be used to inspect the run request that would be submitted by submit_circuits() , without actually\nsubmitting it for execution. circuits ( list [ Circuit ] ) \u2013 Circuits to be executed. qubit_mapping ( dict [ str , str ] | None ) \u2013 Mapping of logical qubit names to physical qubit names.\nCan be set to None if all circuits already use physical qubit names.\nNote that the qubit_mapping is used for all circuits . custom_settings ( dict [ str , Any ] | None ) \u2013 Custom settings to override default settings and calibration data.\nNote: This field should always be None in normal use. calibration_set_id ( UUID | None ) \u2013 ID of the calibration set to use, or None to use the current default calibration. shots ( int ) \u2013 Number of times circuits are executed. Must be greater than zero. options ( CircuitCompilationOptions | None ) \u2013 Various discrete options for compiling quantum circuits to instruction schedules. RunRequest that would be submitted by equivalent call to submit_circuits() . RunRequest Submit a run request for execution on a quantum computer. This is called in submit_circuits() and does not need to be called separately in normal usage. run_request ( RunRequest ) \u2013 Run request to be submitted for execution. ID for the created job. This ID is needed to query the job status and the execution results. UUID Query the status and results of a submitted job. job_id ( UUID ) \u2013 ID of the job to query. timeout_secs ( float ) \u2013 Network request timeout (seconds). Result of the job (can be pending). CircuitExecutionError \u2013 IQM server specific exceptions HTTPException \u2013 HTTP exceptions RunResult Query the status of a submitted job. job_id ( UUID ) \u2013 ID of the job to query. timeout_secs ( float ) \u2013 Network request timeout (seconds). Job status. CircuitExecutionError \u2013 IQM server specific exceptions HTTPException \u2013 HTTP exceptions RunStatus Poll results until a job is either compiled, pending execution, ready, failed, aborted, or timed out. job_id ( UUID ) \u2013 ID of the job to wait for. timeout_secs ( float ) \u2013 How long to wait for a response before raising an APITimeoutError (seconds). Job result. APITimeoutError \u2013 time exceeded the set timeout RunResult Poll results until a job is either ready, failed, aborted, or timed out. Note that jobs handling on the server side is async and if we try to request the results\nright after submitting the job (which is usually the case)\nwe will find the job is still pending at least for the first query. job_id ( UUID ) \u2013 ID of the job to wait for. timeout_secs ( float ) \u2013 How long to wait for a response before raising an APITimeoutError (seconds). Job result. APITimeoutError \u2013 time exceeded the set timeout RunResult Abort a job that was submitted for execution. job_id ( UUID ) \u2013 ID of the job to be aborted. timeout_secs ( float ) \u2013 Network request timeout (seconds). JobAbortionError \u2013 aborting the job failed None Retrieve the static quantum architecture (SQA) from the server. Caches the result and returns it on later invocations. Static quantum architecture of the server. EndpointRequestError \u2013 did not understand the endpoint response ClientAuthenticationError \u2013 no valid authentication provided HTTPException \u2013 HTTP exceptions StaticQuantumArchitecture Retrieve the latest quality metric set for the given calibration set from the server. calibration_set_id ( UUID | None ) \u2013 ID of the calibration set for which the quality metrics are returned.\nIf None , the current default calibration set is used. Requested quality metric set. EndpointRequestError \u2013 did not understand the endpoint response ClientAuthenticationError \u2013 no valid authentication provided HTTPException \u2013 HTTP exceptions QualityMetricSet Retrieve the given calibration set from the server. calibration_set_id ( UUID | None ) \u2013 ID of the calibration set to retrieve.\nIf None , the current default calibration set is retrieved. Requested calibration set. EndpointRequestError \u2013 did not understand the endpoint response ClientAuthenticationError \u2013 no valid authentication provided HTTPException \u2013 HTTP exceptions CalibrationSet Retrieve the dynamic quantum architecture (DQA) for the given calibration set from the server. Caches the result and returns the same result on later invocations, unless calibration_set_id is None .\nIf calibration_set_id is None , always retrieves the result from the server because the default\ncalibration set may have changed. calibration_set_id ( UUID | None ) \u2013 ID of the calibration set for which the DQA is retrieved.\nIf None , use current default calibration set on the server. Dynamic quantum architecture corresponding to the given calibration set. EndpointRequestError \u2013 did not understand the endpoint response ClientAuthenticationError \u2013 no valid authentication provided HTTPException \u2013 HTTP exceptions DynamicQuantumArchitecture Retrieve groups of qubits that can receive real-time feedback signals from each other. Real-time feedback enables conditional gates such as cc_prx .\nSome hardware configurations support routing real-time feedback only between certain qubits. Feedback groups. Within a group, any qubit can receive real-time feedback from any other qubit in the same group. A qubit can belong to multiple groups.\nIf there is only one group, there are no restrictions regarding feedback routing. the same group. A qubit can belong to multiple groups.\nIf there is only one group, there are no restrictions regarding feedback routing. EndpointRequestError \u2013 did not understand the endpoint response ClientAuthenticationError \u2013 no valid authentication provided HTTPException \u2013 HTTP exceptions tuple [ frozenset [ str ], \u2026] Query the counts of an executed job. job_id ( UUID ) \u2013 ID of the job to query. timeout_secs ( float ) \u2013 Network request timeout (seconds). Measurement results of the job in histogram representation. EndpointRequestError \u2013 did not understand the endpoint response ClientAuthenticationError \u2013 no valid authentication provided HTTPException \u2013 HTTP exceptions RunCounts Retrieve information about supported client libraries from the server. timeout_secs ( float ) \u2013 Network request timeout (seconds). Mapping from library identifiers to their metadata. EndpointRequestError \u2013 did not understand the endpoint response ClientAuthenticationError \u2013 no valid authentication provided HTTPException \u2013 HTTP exceptions dict [ str , ClientLibrary ] | None Terminate session with authentication server if there is one. True iff session was successfully closed. ClientAuthenticationError \u2013 logout failed ClientAuthenticationError \u2013 asked to close externally managed authentication session bool previous iqm.iqm_client.iqm_client next iqm.iqm_client.models By IQM client developers \u00a9 Copyright 2021-2025, IQM Finland Oy, Release 29.3.0. Last updated on 2025-07-07."
  }
]